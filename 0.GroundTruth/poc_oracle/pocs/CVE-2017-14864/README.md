# Exiv2 Invalid Memory Address Dereference Vulnerability (CVE-2017-14864)

## POC URL
This vulnerability was reported in Red Hat Bugzilla: [Bug 1494467](https://bugzilla.redhat.com/show_bug.cgi?id=1494467)

## Compilation Environment
- OS: Linux x86_64
- Exiv2 Version: 0.26 (64-bit build)
- AddressSanitizer (ASAN) enabled

## Run Command
```
./exiv2 02-Invalid-mem-def
```

## Expected Output
```
=================================================================
==27020==ERROR: AddressSanitizer: SEGV on unknown address 0x62a100000405 (pc 0x7f827e6cc4af bp 0x7ffdbe4d55b0 sp 0x7ffdbe4d55a0 T0)
    #0 0x7f827e6cc4ae in Exiv2::getULong(unsigned char const*, Exiv2::ByteOrder) /root/fuzzing/exiv2-trunk/src/types.cpp:246
    #1 0x7f827e6cc6cb in Exiv2::getURational(unsigned char const*, Exiv2::ByteOrder) /root/fuzzing/exiv2-trunk/src/types.cpp:257
    #2 0x7f827e57323c in std::pair<unsigned int, unsigned int> Exiv2::getValue<std::pair<unsigned int, unsigned int> >(unsigned char const*, Exiv2::ByteOrder) (/usr/local/exiv2_ASAN/lib/libexiv2.so.26+0x31523c)
    ... [stack trace continues] ...
SUMMARY: AddressSanitizer: SEGV /root/fuzzing/exiv2-trunk/src/types.cpp:246 Exiv2::getULong(unsigned char const*, Exiv2::ByteOrder)
==27020==ABORTING
```

This output demonstrates an invalid memory address dereference in Exiv2's `getULong` function, which leads to a segmentation fault. The vulnerability was fixed in Exiv2 version 0.27.0 and later.