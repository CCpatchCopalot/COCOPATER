diff --git a/examples/Makefile.am b/examples/Makefile.am
index 8c6540fd981..66655742120 100644
--- a/examples/Makefile.am
+++ b/examples/Makefile.am
@@ -35,9 +35,9 @@ EXAMPLE_PROG = h5_write h5_read h5_extend_write h5_chunk_read h5_compound \
            h5_crtgrpd h5_subset h5_cmprss h5_rdwt h5_crtgrpar h5_extend \
            h5_crtatt h5_crtgrp h5_crtdat \
            h5_group h5_select h5_attribute h5_mount h5_reference h5_drivers \
-           h5_ref2reg h5_extlink h5_elink_unix2win h5_shared_mesg h5_vds h5_vds-exc \
-           h5_vds-exclim h5_vds-eiger h5_vds-simpleIO h5_vds-percival \
-           h5_vds-percival-unlim h5_vds-percival-unlim-maxmin
+           h5_ref2reg h5_extlink h5_elink_unix2win h5_shared_mesg h5_debug_trace \
+           h5_vds h5_vds-exc h5_vds-exclim h5_vds-eiger h5_vds-simpleIO \
+           h5_vds-percival h5_vds-percival-unlim h5_vds-percival-unlim-maxmin
 TEST_SCRIPT=testh5cc.sh 
 TEST_EXAMPLES_SCRIPT=$(INSTALL_SCRIPT_FILES)
 
@@ -48,9 +48,9 @@ INSTALL_FILES = h5_write.c h5_read.c h5_extend_write.c h5_chunk_read.c   \
           h5_extend.c h5_crtatt.c h5_crtgrp.c h5_crtdat.c \
           h5_compound.c h5_group.c h5_select.c h5_attribute.c h5_mount.c \
           h5_reference.c h5_drivers.c h5_extlink.c h5_elink_unix2win.c   \
-          h5_ref2reg.c h5_shared_mesg.c ph5example.c h5_vds.c h5_vds-exc.c \
-          h5_vds-exclim.c h5_vds-eiger.c h5_vds-simpleIO.c h5_vds-percival.c \
-          h5_vds-percival-unlim.c h5_vds-percival-unlim-maxmin.c
+          h5_ref2reg.c h5_shared_mesg.c h5_debug_trace.c ph5example.c \
+          h5_vds.c h5_vds-exc.c h5_vds-exclim.c h5_vds-eiger.c h5_vds-simpleIO.c \
+          h5_vds-percival.c h5_vds-percival-unlim.c h5_vds-percival-unlim-maxmin.c
 
 
 
diff --git a/examples/h5_debug_trace.c b/examples/h5_debug_trace.c
new file mode 100644
index 00000000000..3d89ba46074
--- /dev/null
+++ b/examples/h5_debug_trace.c
@@ -0,0 +1,144 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the files COPYING and Copyright.html.  COPYING can be found at the root   *
+ * of the source code distribution tree; Copyright.html can be found at the  *
+ * root level of an installed copy of the electronic HDF5 document set and   *
+ * is linked from the top-level documents page.  It can also be found at     *
+ * http://hdfgroup.org/HDF5/doc/Copyright.html.  If you do not have          *
+ * access to either file, you may request a copy from help@hdfgroup.org.     *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+ 
+/* This example demonstrates debug trace output.
+ *
+ * Debug/trace/performance output is not tested as a regular part of our
+ * testing so this program gives a quick check that it's all working.
+ *
+ * Preconditions:
+ *
+ * You need to set an environment variable named HDF5_DEBUG to have a value
+ * of "+all trace ttimes".  In the bash shell, you'd use:
+ *
+ *      export HDF5_DEBUG="+all trace ttimes"
+ *
+ * When you are done with this test program, you can set the variable back
+ * to "-all" to suppress trace output.
+ *
+ * Usage:
+ *
+ * Compile and run the test program, then inspect the output.  You should see
+ * trace information for each HDF5 function call that increase over time.
+ * Each time stamp is in seconds and designated with an '@' sign.  The
+ * elapsed time for the function call is given in seconds in the [dt= ]
+ * part.
+ *
+ * You will also get summary output for the shuffle filter performance and
+ * data type conversion performance.  These will include the elapsed time
+ * (always) and the system and user times (if available on your system).  On
+ * fast machines, these numbers may be 0.0.  Adjust the loop variables in
+ * the program as needed to generate reasonable output.
+ */
+ 
+#include <stdio.h>
+#include <stdlib.h>
+ 
+#include "hdf5.h"
+ 
+#define BUF_SIZE   1048576
+#define N_LOOPS    64
+ 
+#define TESTFILE "h5_debug_trace_out.h5"
+ 
+int
+main(int argc, char **argv)
+{
+    int i, j;
+    int *data;
+    
+    hid_t   fid;
+    hid_t   pid;
+    hid_t   did;
+    hid_t   sid;
+    
+    hsize_t dims[1] = { BUF_SIZE };
+    hsize_t chunk_sizes[1] = { 1024 };
+    
+    herr_t err;
+    
+    /*************************************************************************/
+
+    /* Warn the user about trace deluge to come */
+
+    printf("Testing debug/trace/performance data generation\n");
+    printf("\n");
+    printf("This test should generate a large amount of trace data\n");
+    printf("\n");
+    printf("*** BEGIN TRACE OUTPUT ***\n");
+    printf("\n");
+    fflush(stdout);
+
+    /* This will emit H5Tconvert() performance information */
+    
+    for(i = 0; i < N_LOOPS; i++) {
+        
+        /* The buffer has to be large enough to hold the conversion output */
+        data = (int *)malloc(BUF_SIZE * sizeof(double));
+        
+        for(j = 0; j < BUF_SIZE; j++) {
+            data[j] = j;
+        }
+        
+        err = H5Tconvert(H5T_NATIVE_INT, H5T_NATIVE_DOUBLE, BUF_SIZE, data,
+            NULL, H5P_DEFAULT);
+        
+        if(err < 0) {
+            fprintf(stderr, "ERROR: Conversion failed\n");
+            free(data);
+            return err;
+        }
+        
+        free(data);
+        
+    }
+    
+    
+    /* This will emit H5Z performance information */
+    
+    data = (int *)malloc(BUF_SIZE * sizeof(int));
+    
+    for(i = 0; i < BUF_SIZE; i++) {
+        data[i] = i;
+    }
+    
+    fid = H5Fcreate(TESTFILE, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
+    
+    pid = H5Pcreate(H5P_DATASET_CREATE);
+    err = H5Pset_chunk(pid, 1, chunk_sizes);
+    err = H5Pset_shuffle(pid);
+    
+    sid = H5Screate_simple(1, dims, dims);
+    did = H5Dcreate(fid, "somedata", H5T_NATIVE_INT, sid, H5P_DEFAULT, pid, H5P_DEFAULT);
+    err = H5Dwrite(did, H5T_NATIVE_INT, sid, sid, H5P_DEFAULT, data);
+    
+    H5Sclose(sid);
+    H5Dclose(did);
+    H5Pclose(pid);
+    H5Fclose(fid);
+    
+    free(data);
+    
+    /* Finished */
+    fflush(stdout);
+    printf("\n");
+    printf("*** END TRACE OUTPUT ***\n");
+    printf("\n");
+
+    remove(TESTFILE);
+    
+    return 0;
+}
+
diff --git a/examples/run-c-ex.sh.in b/examples/run-c-ex.sh.in
index 4d5d5943b5f..f5509925dad 100644
--- a/examples/run-c-ex.sh.in
+++ b/examples/run-c-ex.sh.in
@@ -122,6 +122,11 @@ then
         rm h5_extlink &&\
         RunTest h5_elink_unix2win &&\
         rm h5_elink_unix2win &&\
+        OLD_DEBUG_STRING=$HDF5_DEBUG &&\
+        export HDF5_DEBUG="+all +trace +ttimes" &&\
+        RunTest h5_debug_trace &&\
+        HDF5_DEBUG=$OLD_DEBUG_STRING &&\
+        rm h5_debug_trace &&\
         RunTest h5_shared_mesg &&\
         rm h5_shared_mesg &&\
         RunTest h5_vds-eiger &&\
diff --git a/src/H5Eprivate.h b/src/H5Eprivate.h
index 57e74855f7e..d75c43d4f70 100644
--- a/src/H5Eprivate.h
+++ b/src/H5Eprivate.h
@@ -184,7 +184,7 @@ H5_DLL herr_t H5E_init(void);
 H5_DLL herr_t H5E_push_stack(H5E_t *estack, const char *file, const char *func,
     unsigned line, hid_t cls_id, hid_t maj_id, hid_t min_id, const char *desc);
 H5_DLL herr_t H5E_printf_stack(H5E_t *estack, const char *file, const char *func,
-    unsigned line, hid_t cls_id, hid_t maj_id, hid_t min_id, const char *fmt, ...)H5_ATTR_FORMAT(printf, 8, 9);
+    unsigned line, hid_t cls_id, hid_t maj_id, hid_t min_id, const char *fmt, ...) H5_ATTR_FORMAT(printf, 8, 9);
 H5_DLL herr_t H5E_clear_stack(H5E_t *estack);
 H5_DLL herr_t H5E_dump_api_stack(hbool_t is_api);
 
diff --git a/src/H5FDlog.c b/src/H5FDlog.c
index 7c2297a6966..b7b24213c3d 100644
--- a/src/H5FDlog.c
+++ b/src/H5FDlog.c
@@ -479,11 +479,8 @@ H5FD_log_open(const char *name, unsigned flags, hid_t fapl_id, haddr_t maxaddr)
 #ifdef H5_HAVE_WIN32_API
     struct _BY_HANDLE_FILE_INFORMATION fileinfo;
 #endif
-#ifdef H5_HAVE_GETTIMEOFDAY
-    struct timeval timeval_start;
-    struct timeval open_timeval_diff;
-    struct timeval stat_timeval_diff;
-#endif /* H5_HAVE_GETTIMEOFDAY */
+    H5_timer_t      open_timer;         /* Timer for open() call */
+    H5_timer_t      stat_timer;         /* Timer for stat() call */
     h5_stat_t       sb;
     H5FD_t          *ret_value = NULL;  /* Return value */
 
@@ -515,54 +512,36 @@ H5FD_log_open(const char *name, unsigned flags, hid_t fapl_id, haddr_t maxaddr)
     if(NULL == (fa = (const H5FD_log_fapl_t *)H5P_peek_driver_info(plist)))
         HGOTO_ERROR(H5E_PLIST, H5E_BADVALUE, NULL, "bad VFL driver info")
 
-#ifdef H5_HAVE_GETTIMEOFDAY
-    if(fa->flags & H5FD_LOG_TIME_OPEN)
-        HDgettimeofday(&timeval_start, NULL);
-#endif /* H5_HAVE_GETTIMEOFDAY */
+    /* Start timer for open() call */
+    if(fa->flags & H5FD_LOG_TIME_OPEN) {
+        H5_timer_init(&open_timer);
+        H5_timer_start(&open_timer);
+    } /* end if */
+
     /* Open the file */
     if((fd = HDopen(name, o_flags, H5_POSIX_CREATE_MODE_RW)) < 0) {
         int myerrno = errno;
 
         HGOTO_ERROR(H5E_FILE, H5E_CANTOPENFILE, NULL, "unable to open file: name = '%s', errno = %d, error message = '%s', flags = %x, o_flags = %x", name, myerrno, HDstrerror(myerrno), flags, (unsigned)o_flags);
     } /* end if */
-#ifdef H5_HAVE_GETTIMEOFDAY
-    if(fa->flags & H5FD_LOG_TIME_OPEN) {
-        struct timeval timeval_stop;
 
-        HDgettimeofday(&timeval_stop, NULL);
+    /* Stop timer for open() call */
+    if(fa->flags & H5FD_LOG_TIME_OPEN)
+        H5_timer_stop(&open_timer);
 
-         /* Calculate the elapsed gettimeofday time */
-         open_timeval_diff.tv_usec = timeval_stop.tv_usec - timeval_start.tv_usec;
-         open_timeval_diff.tv_sec = timeval_stop.tv_sec - timeval_start.tv_sec;
-         if(open_timeval_diff.tv_usec < 0) {
-             open_timeval_diff.tv_usec += 1000000;
-             open_timeval_diff.tv_sec--;
-         } /* end if */
+    /* Start timer for stat() call */
+    if(fa->flags & H5FD_LOG_TIME_STAT) {
+        H5_timer_init(&stat_timer);
+        H5_timer_start(&stat_timer);
     } /* end if */
-#endif /* H5_HAVE_GETTIMEOFDAY */
 
-#ifdef H5_HAVE_GETTIMEOFDAY
-    if(fa->flags & H5FD_LOG_TIME_STAT)
-        HDgettimeofday(&timeval_start, NULL);
-#endif /* H5_HAVE_GETTIMEOFDAY */
     /* Get the file stats */
     if(HDfstat(fd, &sb) < 0)
         HSYS_GOTO_ERROR(H5E_FILE, H5E_BADFILE, NULL, "unable to fstat file")
-#ifdef H5_HAVE_GETTIMEOFDAY
-    if(fa->flags & H5FD_LOG_TIME_STAT) {
-        struct timeval timeval_stop;
 
-        HDgettimeofday(&timeval_stop, NULL);
-
-         /* Calculate the elapsed gettimeofday time */
-         stat_timeval_diff.tv_usec = timeval_stop.tv_usec - timeval_start.tv_usec;
-         stat_timeval_diff.tv_sec = timeval_stop.tv_sec - timeval_start.tv_sec;
-         if(stat_timeval_diff.tv_usec < 0) {
-             stat_timeval_diff.tv_usec += 1000000;
-             stat_timeval_diff.tv_sec--;
-         } /* end if */
-    } /* end if */
-#endif /* H5_HAVE_GETTIMEOFDAY */
+    /* Stop timer for stat() call */
+    if(fa->flags & H5FD_LOG_TIME_STAT)
+        H5_timer_stop(&stat_timer);
 
     /* Create the new file struct */
     if(NULL == (file = H5FL_CALLOC(H5FD_log_t)))
@@ -623,13 +602,19 @@ H5FD_log_open(const char *name, unsigned flags, hid_t fapl_id, haddr_t maxaddr)
         else
             file->logfp = stderr;
 
-#ifdef H5_HAVE_GETTIMEOFDAY
-        if(file->fa.flags & H5FD_LOG_TIME_OPEN)
-            HDfprintf(file->logfp, "Open took: (%f s)\n", (double)open_timeval_diff.tv_sec + ((double)open_timeval_diff.tv_usec / (double)1000000.0f));
-        if(file->fa.flags & H5FD_LOG_TIME_STAT)
-            HDfprintf(file->logfp, "Stat took: (%f s)\n", (double)stat_timeval_diff.tv_sec + ((double)stat_timeval_diff.tv_usec / (double)1000000.0f));
-#endif /* H5_HAVE_GETTIMEOFDAY */
+        /* Log the timer values */
+        if(file->fa.flags & H5FD_LOG_TIME_OPEN) {
+            H5_timevals_t   open_times;         /* Elapsed time for open() call */
 
+            H5_timer_get_times(open_timer, &open_times);
+            HDfprintf(file->logfp, "Open took: (%f s)\n", open_times.elapsed);
+        } /* end if */
+        if(file->fa.flags & H5FD_LOG_TIME_STAT) {
+            H5_timevals_t   stat_times;         /* Elapsed time for stat() call */
+
+            H5_timer_get_times(stat_timer, &stat_times);
+            HDfprintf(file->logfp, "Stat took: (%f s)\n", stat_times.elapsed);
+        } /* end if */
     } /* end if */
 
     /* Check for non-default FAPL */
@@ -676,27 +661,27 @@ static herr_t
 H5FD_log_close(H5FD_t *_file)
 {
     H5FD_log_t	*file = (H5FD_log_t *)_file;
-#ifdef H5_HAVE_GETTIMEOFDAY
-    struct timeval timeval_start, timeval_stop;
-#endif /* H5_HAVE_GETTIMEOFDAY */
-    herr_t ret_value = SUCCEED;                 /* Return value */
+    H5_timer_t      close_timer;        /* Timer for close() call */
+    herr_t ret_value = SUCCEED;         /* Return value */
 
     FUNC_ENTER_NOAPI_NOINIT
 
     /* Sanity check */
     HDassert(file);
 
-#ifdef H5_HAVE_GETTIMEOFDAY
-    if(file->fa.flags&H5FD_LOG_TIME_CLOSE)
-        HDgettimeofday(&timeval_start, NULL);
-#endif /* H5_HAVE_GETTIMEOFDAY */
+    /* Start timer for close() call */
+    if(file->fa.flags & H5FD_LOG_TIME_CLOSE) {
+        H5_timer_init(&close_timer);
+        H5_timer_start(&close_timer);
+    } /* end if */
+
     /* Close the underlying file */
     if(HDclose(file->fd) < 0)
         HSYS_GOTO_ERROR(H5E_IO, H5E_CANTCLOSEFILE, FAIL, "unable to close file")
-#ifdef H5_HAVE_GETTIMEOFDAY
+
+    /* Stop timer for close() call */
     if(file->fa.flags&H5FD_LOG_TIME_CLOSE)
-        HDgettimeofday(&timeval_stop, NULL);
-#endif /* H5_HAVE_GETTIMEOFDAY */
+        H5_timer_stop(&close_timer);
 
     /* Dump I/O information */
     if(file->fa.flags != 0) {
@@ -704,20 +689,12 @@ H5FD_log_close(H5FD_t *_file)
         haddr_t last_addr;
         unsigned char last_val;
 
-#ifdef H5_HAVE_GETTIMEOFDAY
         if(file->fa.flags & H5FD_LOG_TIME_CLOSE) {
-            struct timeval timeval_diff;
-
-             /* Calculate the elapsed gettimeofday time */
-             timeval_diff.tv_usec = timeval_stop.tv_usec - timeval_start.tv_usec;
-             timeval_diff.tv_sec = timeval_stop.tv_sec - timeval_start.tv_sec;
-             if(timeval_diff.tv_usec < 0) {
-                 timeval_diff.tv_usec += 1000000;
-                 timeval_diff.tv_sec--;
-             } /* end if */
-            HDfprintf(file->logfp, "Close took: (%f s)\n", (double)timeval_diff.tv_sec + ((double)timeval_diff.tv_usec / (double)1000000.0f));
+            H5_timevals_t   close_times;        /* Elapsed time for close() call */
+
+            H5_timer_get_times(close_timer, &close_times);
+            HDfprintf(file->logfp, "Close took: (%f s)\n", close_times.elapsed);
         } /* end if */
-#endif /* H5_HAVE_GETTIMEOFDAY */
 
         /* Dump the total number of seek/read/write operations */
         if(file->fa.flags & H5FD_LOG_NUM_READ)
@@ -1160,10 +1137,11 @@ H5FD_log_read(H5FD_t *_file, H5FD_mem_t type, hid_t H5_ATTR_UNUSED dxpl_id, hadd
     H5FD_log_t          *file = (H5FD_log_t *)_file;
     size_t              orig_size = size; /* Save the original size for later */
     haddr_t             orig_addr = addr;
-#ifdef H5_HAVE_GETTIMEOFDAY
-    struct timeval      timeval_start, timeval_stop;
-#endif /* H5_HAVE_GETTIMEOFDAY */
-    herr_t              ret_value = SUCCEED;       /* Return value */
+    H5_timer_t          read_timer;             /* Timer for read operation */
+    H5_timer_t          seek_timer;             /* Timer for seek operation */
+    H5_timevals_t       read_times;             /* Elapsed time for read operation */
+    H5_timevals_t       seek_times;             /* Elapsed time for seek operation */
+    herr_t              ret_value = SUCCEED;    /* Return value */
 
     FUNC_ENTER_NOAPI_NOINIT
 
@@ -1191,58 +1169,55 @@ H5FD_log_read(H5FD_t *_file, H5FD_mem_t type, hid_t H5_ATTR_UNUSED dxpl_id, hadd
 
     /* Seek to the correct location */
     if(addr != file->pos || OP_READ != file->op) {
-#ifdef H5_HAVE_GETTIMEOFDAY
-        if(file->fa.flags & H5FD_LOG_TIME_SEEK)
-            HDgettimeofday(&timeval_start, NULL);
-#endif /* H5_HAVE_GETTIMEOFDAY */
+        /* Start timer for seek() call */
+        if(file->fa.flags & H5FD_LOG_TIME_SEEK) {
+            H5_timer_init(&seek_timer);
+            H5_timer_start(&seek_timer);
+        } /* end if */
+
         if(HDlseek(file->fd, (HDoff_t)addr, SEEK_SET) < 0)
             HSYS_GOTO_ERROR(H5E_IO, H5E_SEEKERROR, FAIL, "unable to seek to proper position")
-#ifdef H5_HAVE_GETTIMEOFDAY
+
+        /* Stop timer for seek() call */
         if(file->fa.flags & H5FD_LOG_TIME_SEEK)
-            HDgettimeofday(&timeval_stop, NULL);
-#endif /* H5_HAVE_GETTIMEOFDAY */
+            H5_timer_stop(&seek_timer);
 
-        /* Log information about the seek */
+        /* Add to the number of seeks, when tracking that */
         if(file->fa.flags & H5FD_LOG_NUM_SEEK)
             file->total_seek_ops++;
+
+        /* Add to the total seek time, when tracking that */
+        if(file->fa.flags & H5FD_LOG_TIME_SEEK) {
+            H5_timer_get_times(seek_timer, &seek_times);
+            file->total_seek_time += seek_times.elapsed;
+        } /* end if */
+
+        /* Emit log string if we're tracking individual seek events. */
         if(file->fa.flags & H5FD_LOG_LOC_SEEK) {
             HDfprintf(file->logfp, "Seek: From %10a To %10a", file->pos, addr);
-#ifdef H5_HAVE_GETTIMEOFDAY
-            if(file->fa.flags & H5FD_LOG_TIME_SEEK) {
-                struct timeval timeval_diff;
-                double time_diff;
-
-                /* Calculate the elapsed gettimeofday time */
-                timeval_diff.tv_usec = timeval_stop.tv_usec - timeval_start.tv_usec;
-                timeval_diff.tv_sec = timeval_stop.tv_sec - timeval_start.tv_sec;
-                if(timeval_diff.tv_usec < 0) {
-                    timeval_diff.tv_usec += 1000000;
-                    timeval_diff.tv_sec--;
-                } /* end if */
-                time_diff = (double)timeval_diff.tv_sec + ((double)timeval_diff.tv_usec / (double)1000000.0f);
-                HDfprintf(file->logfp, " (%fs @ %.6lu.%.6llu)\n", time_diff, (unsigned long long)timeval_start.tv_sec, (unsigned long long)timeval_start.tv_usec);
 
-                /* Add to total seek time */
-                file->total_seek_time += time_diff;
-            } /* end if */
-            else
-                HDfprintf(file->logfp, "\n");
-#else /* H5_HAVE_GETTIMEOFDAY */
-            HDfprintf(file->logfp, "\n");
-#endif /* H5_HAVE_GETTIMEOFDAY */
+            /* Add the seek time, if we're tracking that.
+             * Note that the seek time is NOT emitted for when just H5FD_LOG_TIME_SEEK
+             * is set.
+             */
+            if(file->fa.flags & H5FD_LOG_TIME_SEEK)
+                HDfprintf(file->logfp, " (%fs @ %f)\n", seek_times.elapsed, seek_timer.initial.elapsed);
+             else
+                 HDfprintf(file->logfp, "\n");
         } /* end if */
     } /* end if */
 
+    /* Start timer for read operation */
+    if(file->fa.flags & H5FD_LOG_TIME_READ) {
+        H5_timer_init(&read_timer);
+        H5_timer_start(&read_timer);
+    } /* end if */
+
     /*
      * Read data, being careful of interrupted system calls, partial results,
      * and the end of the file.
      */
-#ifdef H5_HAVE_GETTIMEOFDAY
-    if(file->fa.flags & H5FD_LOG_TIME_READ)
-        HDgettimeofday(&timeval_start, NULL);
-#endif /* H5_HAVE_GETTIMEOFDAY */
     while(size > 0) {
-
         h5_posix_io_t       bytes_in        = 0;    /* # of bytes to read       */
         h5_posix_io_ret_t   bytes_read      = -1;   /* # of bytes actually read */ 
 
@@ -1283,14 +1258,22 @@ H5FD_log_read(H5FD_t *_file, H5FD_mem_t type, hid_t H5_ATTR_UNUSED dxpl_id, hadd
         buf = (char *)buf + bytes_read;
 
     } /* end while */
-#ifdef H5_HAVE_GETTIMEOFDAY
+
+    /* Stop timer for read operation */
     if(file->fa.flags & H5FD_LOG_TIME_READ)
-        HDgettimeofday(&timeval_stop, NULL);
-#endif /* H5_HAVE_GETTIMEOFDAY */
+        H5_timer_stop(&read_timer);
 
-    /* Log information about the read */
+    /* Add to the number of reads, when tracking that */
     if(file->fa.flags & H5FD_LOG_NUM_READ)
         file->total_read_ops++;
+
+    /* Add to the total read time, when tracking that */
+    if(file->fa.flags & H5FD_LOG_TIME_READ) {
+        H5_timer_get_times(read_timer, &read_times);
+        file->total_read_time += read_times.elapsed;
+    } /* end if */
+
+    /* Log information about the read */
     if(file->fa.flags & H5FD_LOG_LOC_READ) {
         HDfprintf(file->logfp, "%10a-%10a (%10Zu bytes) (%s) Read", orig_addr, (orig_addr + orig_size) - 1, orig_size, flavors[type]);
 
@@ -1300,30 +1283,14 @@ H5FD_log_read(H5FD_t *_file, H5FD_mem_t type, hid_t H5_ATTR_UNUSED dxpl_id, hadd
             HDassert(type == H5FD_MEM_DEFAULT || type == (H5FD_mem_t)file->flavor[(orig_addr + orig_size) - 1] || (H5FD_mem_t)file->flavor[(orig_addr + orig_size) - 1] == H5FD_MEM_DEFAULT);
         } /* end if */
 
-
-#ifdef H5_HAVE_GETTIMEOFDAY
-        if(file->fa.flags & H5FD_LOG_TIME_READ) {
-            struct timeval timeval_diff;
-            double time_diff;
-
-            /* Calculate the elapsed gettimeofday time */
-            timeval_diff.tv_usec = timeval_stop.tv_usec - timeval_start.tv_usec;
-            timeval_diff.tv_sec = timeval_stop.tv_sec - timeval_start.tv_sec;
-            if(timeval_diff.tv_usec < 0) {
-                timeval_diff.tv_usec += 1000000;
-                timeval_diff.tv_sec--;
-            } /* end if */
-            time_diff = (double)timeval_diff.tv_sec + ((double)timeval_diff.tv_usec / (double)1000000.0f);
-            HDfprintf(file->logfp, " (%fs @ %.6lu.%.6llu)\n", time_diff, (unsigned long long)timeval_start.tv_sec, (unsigned long long)timeval_start.tv_usec);
-
-            /* Add to total read time */
-            file->total_read_time += time_diff;
-        } /* end if */
+        /* Add the read time, if we're tracking that.
+         * Note that the read time is NOT emitted for when just H5FD_LOG_TIME_READ
+         * is set.
+         */
+        if(file->fa.flags & H5FD_LOG_TIME_READ)
+            HDfprintf(file->logfp, " (%fs @ %f)\n", read_times.elapsed, read_timer.initial.elapsed);
         else
             HDfprintf(file->logfp, "\n");
-#else /* H5_HAVE_GETTIMEOFDAY */
-        HDfprintf(file->logfp, "\n");
-#endif /* H5_HAVE_GETTIMEOFDAY */
     } /* end if */
 
     /* Update current position */
@@ -1362,10 +1329,11 @@ H5FD_log_write(H5FD_t *_file, H5FD_mem_t type, hid_t H5_ATTR_UNUSED dxpl_id, had
     H5FD_log_t          *file = (H5FD_log_t *)_file;
     size_t              orig_size = size; /* Save the original size for later */
     haddr_t             orig_addr = addr;
-#ifdef H5_HAVE_GETTIMEOFDAY
-    struct timeval      timeval_start, timeval_stop;
-#endif /* H5_HAVE_GETTIMEOFDAY */
-    herr_t              ret_value = SUCCEED;       /* Return value */
+    H5_timer_t          write_timer;            /* Timer for write operation */
+    H5_timer_t          seek_timer;             /* Timer for seek operation */
+    H5_timevals_t       write_times;            /* Elapsed time for write operation */
+    H5_timevals_t       seek_times;             /* Elapsed time for seek operation */
+    herr_t              ret_value = SUCCEED;    /* Return value */
 
     FUNC_ENTER_NOAPI_NOINIT
 
@@ -1398,58 +1366,55 @@ H5FD_log_write(H5FD_t *_file, H5FD_mem_t type, hid_t H5_ATTR_UNUSED dxpl_id, had
 
     /* Seek to the correct location */
     if(addr != file->pos || OP_WRITE != file->op) {
-#ifdef H5_HAVE_GETTIMEOFDAY
-        if(file->fa.flags & H5FD_LOG_TIME_SEEK)
-            HDgettimeofday(&timeval_start, NULL);
-#endif /* H5_HAVE_GETTIMEOFDAY */
+        /* Start timer for seek() call */
+        if(file->fa.flags & H5FD_LOG_TIME_SEEK) {
+            H5_timer_init(&seek_timer);
+            H5_timer_start(&seek_timer);
+        } /* end if */
+
         if(HDlseek(file->fd, (HDoff_t)addr, SEEK_SET) < 0)
             HSYS_GOTO_ERROR(H5E_IO, H5E_SEEKERROR, FAIL, "unable to seek to proper position")
-#ifdef H5_HAVE_GETTIMEOFDAY
+
+        /* Stop timer for seek() call */
         if(file->fa.flags & H5FD_LOG_TIME_SEEK)
-            HDgettimeofday(&timeval_stop, NULL);
-#endif /* H5_HAVE_GETTIMEOFDAY */
+            H5_timer_stop(&seek_timer);
 
-        /* Log information about the seek */
+        /* Add to the number of seeks, when tracking that */
         if(file->fa.flags & H5FD_LOG_NUM_SEEK)
             file->total_seek_ops++;
+
+        /* Add to the total seek time, when tracking that */
+        if(file->fa.flags & H5FD_LOG_TIME_SEEK) {
+            H5_timer_get_times(seek_timer, &seek_times);
+            file->total_seek_time += seek_times.elapsed;
+        } /* end if */
+
+        /* Emit log string if we're tracking individual seek events. */
         if(file->fa.flags & H5FD_LOG_LOC_SEEK) {
             HDfprintf(file->logfp, "Seek: From %10a To %10a", file->pos, addr);
-#ifdef H5_HAVE_GETTIMEOFDAY
-            if(file->fa.flags & H5FD_LOG_TIME_SEEK) {
-                struct timeval timeval_diff;
-                double time_diff;
-
-                /* Calculate the elapsed gettimeofday time */
-                timeval_diff.tv_usec = timeval_stop.tv_usec - timeval_start.tv_usec;
-                timeval_diff.tv_sec = timeval_stop.tv_sec - timeval_start.tv_sec;
-                if(timeval_diff.tv_usec < 0) {
-                    timeval_diff.tv_usec += 1000000;
-                    timeval_diff.tv_sec--;
-                } /* end if */
-                time_diff = (double)timeval_diff.tv_sec + ((double)timeval_diff.tv_usec / (double)1000000.0f);
-                HDfprintf(file->logfp, " (%fs @ %.6lu.%.6llu)\n", time_diff, (unsigned long long)timeval_start.tv_sec, (unsigned long long)timeval_start.tv_usec);
 
-                /* Add to total seek time */
-                file->total_seek_time += time_diff;
-            } /* end if */
-            else
-                HDfprintf(file->logfp, "\n");
-#else /* H5_HAVE_GETTIMEOFDAY */
-            HDfprintf(file->logfp, "\n");
-#endif /* H5_HAVE_GETTIMEOFDAY */
+            /* Add the seek time, if we're tracking that.
+             * Note that the seek time is NOT emitted for when just H5FD_LOG_TIME_SEEK
+             * is set.
+             */
+            if(file->fa.flags & H5FD_LOG_TIME_SEEK)
+                HDfprintf(file->logfp, " (%fs @ %f)\n", seek_times.elapsed, seek_timer.initial.elapsed);
+             else
+                 HDfprintf(file->logfp, "\n");
         } /* end if */
     } /* end if */
 
+    /* Start timer for write operation */
+    if(file->fa.flags&H5FD_LOG_TIME_WRITE) {
+        H5_timer_init(&write_timer);
+        H5_timer_start(&write_timer);
+    } /* end if */
+
     /*
      * Write the data, being careful of interrupted system calls and partial
      * results
      */
-#ifdef H5_HAVE_GETTIMEOFDAY
-    if(file->fa.flags&H5FD_LOG_TIME_WRITE)
-        HDgettimeofday(&timeval_start, NULL);
-#endif /* H5_HAVE_GETTIMEOFDAY */
     while(size > 0) {
-
         h5_posix_io_t       bytes_in        = 0;    /* # of bytes to write  */
         h5_posix_io_ret_t   bytes_wrote     = -1;   /* # of bytes written   */ 
 
@@ -1483,14 +1448,22 @@ H5FD_log_write(H5FD_t *_file, H5FD_mem_t type, hid_t H5_ATTR_UNUSED dxpl_id, had
         addr += (haddr_t)bytes_wrote;
         buf = (const char *)buf + bytes_wrote;
     } /* end while */
-#ifdef H5_HAVE_GETTIMEOFDAY
+
+    /* Stop timer for write operation */
     if(file->fa.flags & H5FD_LOG_TIME_WRITE)
-        HDgettimeofday(&timeval_stop, NULL);
-#endif /* H5_HAVE_GETTIMEOFDAY */
+        H5_timer_stop(&write_timer);
 
-    /* Log information about the write */
+    /* Add to the number of writes, when tracking that */
     if(file->fa.flags & H5FD_LOG_NUM_WRITE)
         file->total_write_ops++;
+
+    /* Add to the total write time, when tracking that */
+    if(file->fa.flags & H5FD_LOG_TIME_WRITE) {
+        H5_timer_get_times(write_timer, &write_times);
+        file->total_write_time += write_times.elapsed;
+    } /* end if */
+
+    /* Log information about the write */
     if(file->fa.flags & H5FD_LOG_LOC_WRITE) {
         HDfprintf(file->logfp, "%10a-%10a (%10Zu bytes) (%s) Written", orig_addr, (orig_addr + orig_size) - 1, orig_size, flavors[type]);
 
@@ -1502,29 +1475,14 @@ H5FD_log_write(H5FD_t *_file, H5FD_mem_t type, hid_t H5_ATTR_UNUSED dxpl_id, had
             } /* end if */
         } /* end if */
 
-#ifdef H5_HAVE_GETTIMEOFDAY
-        if(file->fa.flags & H5FD_LOG_TIME_WRITE) {
-            struct timeval timeval_diff;
-            double time_diff;
-
-            /* Calculate the elapsed gettimeofday time */
-            timeval_diff.tv_usec = timeval_stop.tv_usec - timeval_start.tv_usec;
-            timeval_diff.tv_sec = timeval_stop.tv_sec - timeval_start.tv_sec;
-            if(timeval_diff.tv_usec < 0) {
-                timeval_diff.tv_usec += 1000000;
-                timeval_diff.tv_sec--;
-            } /* end if */
-            time_diff = (double)timeval_diff.tv_sec + ((double)timeval_diff.tv_usec / (double)1000000.0f);
-            HDfprintf(file->logfp, " (%fs @ %.6lu.%.6llu)\n", time_diff, (unsigned long long)timeval_start.tv_sec, (unsigned long long)timeval_start.tv_usec);
-
-            /* Add to total write time */
-            file->total_write_time += time_diff;
-        } /* end if */
-        else
-            HDfprintf(file->logfp, "\n");
-#else /* H5_HAVE_GETTIMEOFDAY */
-        HDfprintf(file->logfp, "\n");
-#endif /* H5_HAVE_GETTIMEOFDAY */
+        /* Add the write time, if we're tracking that.
+         * Note that the write time is NOT emitted for when just H5FD_LOG_TIME_WRITE
+         * is set.
+         */
+        if(file->fa.flags & H5FD_LOG_TIME_WRITE)
+            HDfprintf(file->logfp, " (%fs @ %f)\n", write_times.elapsed, write_timer.initial.elapsed);
+         else
+             HDfprintf(file->logfp, "\n");
     } /* end if */
 
     /* Update current position and eof */
@@ -1569,23 +1527,22 @@ H5FD_log_truncate(H5FD_t *_file, hid_t H5_ATTR_UNUSED dxpl_id, hbool_t H5_ATTR_U
 
     /* Extend the file to make sure it's large enough */
     if(!H5F_addr_eq(file->eoa, file->eof)) {
-#ifdef H5_HAVE_GETTIMEOFDAY
-        struct timeval timeval_start, timeval_stop;
-#endif /* H5_HAVE_GETTIMEOFDAY */
+        H5_timer_t      trunc_timer;        /* Timer for truncate operation */
+        H5_timevals_t   trunc_times;        /* Elapsed time for truncate operation */
+
+        /* Start timer for truncate operation */
+        if(file->fa.flags & H5FD_LOG_TIME_TRUNCATE) {
+            H5_timer_init(&trunc_timer);
+            H5_timer_start(&trunc_timer);
+        } /* end if */
+
 #ifdef H5_HAVE_WIN32_API
+{
         LARGE_INTEGER   li;         /* 64-bit (union) integer for SetFilePointer() call */
         DWORD           dwPtrLow;   /* Low-order pointer bits from SetFilePointer()
                                      * Only used as an error code here.
                                      */
-        DWORD           dwError;    /* DWORD error code from GetLastError() */
-        BOOL            bError;     /* Boolean error flag */
-#endif /* H5_HAVE_WIN32_API */
 
-#ifdef H5_HAVE_GETTIMEOFDAY
-        if(file->fa.flags & H5FD_LOG_TIME_TRUNCATE)
-            HDgettimeofday(&timeval_start, NULL);
-#endif /* H5_HAVE_GETTIMEOFDAY */
-#ifdef H5_HAVE_WIN32_API
         /* Windows uses this odd QuadPart union for 32/64-bit portability */
         li.QuadPart = (__int64)file->eoa;
 
@@ -1596,51 +1553,48 @@ H5FD_log_truncate(H5FD_t *_file, hid_t H5_ATTR_UNUSED dxpl_id, hbool_t H5_ATTR_U
          */
         dwPtrLow = SetFilePointer(file->hFile, li.LowPart, &li.HighPart, FILE_BEGIN);
         if(INVALID_SET_FILE_POINTER == dwPtrLow) {
+            DWORD           dwError;    /* DWORD error code from GetLastError() */
+
             dwError = GetLastError();
             if(dwError != NO_ERROR )
                 HGOTO_ERROR(H5E_FILE, H5E_FILEOPEN, FAIL, "unable to set file pointer")
-        }
+        } /* end if */
 
-        bError = SetEndOfFile(file->hFile);
-        if(0 == bError)
+        if(0 == SetEndOfFile(file->hFile))
             HGOTO_ERROR(H5E_IO, H5E_SEEKERROR, FAIL, "unable to extend file properly")
+}
 #else /* H5_HAVE_WIN32_API */
+        /* Truncate/extend the file */
         if(-1 == HDftruncate(file->fd, (HDoff_t)file->eoa))
             HSYS_GOTO_ERROR(H5E_IO, H5E_SEEKERROR, FAIL, "unable to extend file properly")
 #endif /* H5_HAVE_WIN32_API */
-#ifdef H5_HAVE_GETTIMEOFDAY
+
+        /* Stop timer for truncate operation */
         if(file->fa.flags & H5FD_LOG_TIME_TRUNCATE)
-            HDgettimeofday(&timeval_stop, NULL);
-#endif /* H5_HAVE_GETTIMEOFDAY */
+            H5_timer_stop(&trunc_timer);
 
-        /* Log information about the truncate */
+        /* Add to the number of truncates, when tracking that */
         if(file->fa.flags & H5FD_LOG_NUM_TRUNCATE)
             file->total_truncate_ops++;
+
+        /* Add to the total truncate time, when tracking that */
+        if(file->fa.flags & H5FD_LOG_TIME_TRUNCATE) {
+            H5_timer_get_times(trunc_timer, &trunc_times);
+            file->total_truncate_time += trunc_times.elapsed;
+        } /* end if */
+
+        /* Emit log string if we're tracking individual truncate events. */
         if(file->fa.flags & H5FD_LOG_TRUNCATE) {
             HDfprintf(file->logfp, "Truncate: To %10a", file->eoa);
-#ifdef H5_HAVE_GETTIMEOFDAY
-            if(file->fa.flags & H5FD_LOG_TIME_TRUNCATE) {
-                struct timeval timeval_diff;
-                double time_diff;
-
-                /* Calculate the elapsed gettimeofday time */
-                timeval_diff.tv_usec = timeval_stop.tv_usec - timeval_start.tv_usec;
-                timeval_diff.tv_sec = timeval_stop.tv_sec - timeval_start.tv_sec;
-                if(timeval_diff.tv_usec < 0) {
-                    timeval_diff.tv_usec += 1000000;
-                    timeval_diff.tv_sec--;
-                } /* end if */
-                time_diff = (double)timeval_diff.tv_sec + ((double)timeval_diff.tv_usec / (double)1000000.0f);
-                HDfprintf(file->logfp, " (%fs @ %.6lu.%.6llu)\n", time_diff, (unsigned long long)timeval_start.tv_sec, (unsigned long long)timeval_start.tv_usec);
 
-                /* Add to total truncate time */
-                file->total_truncate_time += time_diff;
-            } /* end if */
-            else
-                HDfprintf(file->logfp, "\n");
-#else /* H5_HAVE_GETTIMEOFDAY */
-            HDfprintf(file->logfp, "\n");
-#endif /* H5_HAVE_GETTIMEOFDAY */
+            /* Add the truncate time, if we're tracking that.
+             * Note that the truncate time is NOT emitted for when just H5FD_LOG_TIME_TRUNCATE
+             * is set.
+             */
+            if(file->fa.flags & H5FD_LOG_TIME_TRUNCATE)
+                HDfprintf(file->logfp, " (%fs @ %f)\n", trunc_times.elapsed, trunc_timer.initial.elapsed);
+             else
+                 HDfprintf(file->logfp, "\n");
         } /* end if */
 
         /* Update the eof value */
diff --git a/src/H5T.c b/src/H5T.c
index a525cd56580..4f0c700f6d7 100644
--- a/src/H5T.c
+++ b/src/H5T.c
@@ -4806,34 +4806,47 @@ H5T_compiler_conv(H5T_t *src, H5T_t *dst)
  */
 herr_t
 H5T_convert(H5T_path_t *tpath, hid_t src_id, hid_t dst_id, size_t nelmts,
-        size_t buf_stride, size_t bkg_stride, void *buf, void *bkg,
-            hid_t dset_xfer_plist)
+    size_t buf_stride, size_t bkg_stride, void *buf, void *bkg,
+    hid_t dset_xfer_plist)
 {
 #ifdef H5T_DEBUG
-    H5_timer_t        timer;
+    H5_timer_t  timer;                  /* Timer for conversion */
 #endif
-    herr_t      ret_value=SUCCEED;       /* Return value */
+    herr_t      ret_value = SUCCEED;    /* Return value */
 
     FUNC_ENTER_NOAPI(FAIL)
 
 #ifdef H5T_DEBUG
-    if (H5DEBUG(T)) H5_timer_begin(&timer);
+    if(H5DEBUG(T)) {
+        /* Initialize and start timer */
+        H5_timer_init(&timer);
+        H5_timer_start(&timer);
+    } /* end if */
 #endif
+
+    /* Call the appropriate conversion callback */
     tpath->cdata.command = H5T_CONV_CONV;
-    if ((tpath->func)(src_id, dst_id, &(tpath->cdata), nelmts, buf_stride,
-                      bkg_stride, buf, bkg, dset_xfer_plist)<0)
+    if((tpath->func)(src_id, dst_id, &(tpath->cdata), nelmts, buf_stride,
+                      bkg_stride, buf, bkg, dset_xfer_plist) < 0)
         HGOTO_ERROR(H5E_ATTR, H5E_CANTENCODE, FAIL, "data type conversion failed");
+
 #ifdef H5T_DEBUG
-    if (H5DEBUG(T)) {
-        H5_timer_end(&(tpath->stats.timer), &timer);
+    if(H5DEBUG(T)) {
+        /* Stop timer */
+        H5_timer_stop(&timer);
+
+        /* Record elapsed timer info */
+        H5_timer_get_times(timer, &tpath->stats.times);
+
+        /* Increment # of calls and # of elements converted */
         tpath->stats.ncalls++;
         tpath->stats.nelmts += nelmts;
-    }
+    } /* end if */
 #endif
 
 done:
     FUNC_LEAVE_NOAPI(ret_value)
-}
+} /* end H5T_convert() */
 
 
 /*-------------------------------------------------------------------------
diff --git a/src/H5Tdbg.c b/src/H5Tdbg.c
index f4345437cb0..e20113e4351 100644
--- a/src/H5Tdbg.c
+++ b/src/H5Tdbg.c
@@ -102,15 +102,13 @@
 herr_t
 H5T__print_stats(H5T_path_t H5_ATTR_UNUSED * path, int H5_ATTR_UNUSED * nprint/*in,out*/)
 {
-#ifdef H5T_DEBUG
-    hsize_t	nbytes;
-    char	bandwidth[32];
-#endif
-
     FUNC_ENTER_PACKAGE_NOERR
 
 #ifdef H5T_DEBUG
     if(H5DEBUG(T) && path->stats.ncalls > 0) {
+        hsize_t	nbytes;
+        char	bandwidth[32];
+
 	if(nprint && 0 == (*nprint)++) {
 	    HDfprintf(H5DEBUG(T), "H5T: type conversion statistics:\n");
 	    HDfprintf(H5DEBUG(T), "   %-16s %10s %10s %8s %8s %8s %10s\n",
@@ -119,7 +117,8 @@ H5T__print_stats(H5T_path_t H5_ATTR_UNUSED * path, int H5_ATTR_UNUSED * nprint/*
 	    HDfprintf(H5DEBUG(T), "   %-16s %10s %10s %8s %8s %8s %10s\n",
 		       "----------", "-----", "-----", "----",
 		       "------", "-------", "---------");
-	}
+	} /* end if */
+
         if(path->src && path->dst)
             nbytes = MAX(H5T_get_size(path->src), H5T_get_size(path->dst));
         else if(path->src)
@@ -128,18 +127,20 @@ H5T__print_stats(H5T_path_t H5_ATTR_UNUSED * path, int H5_ATTR_UNUSED * nprint/*
             nbytes = H5T_get_size(path->dst);
         else
             nbytes = 0;
+
 	nbytes *= path->stats.nelmts;
-	H5_bandwidth(bandwidth, (double)nbytes, path->stats.timer.etime);
-	HDfprintf(H5DEBUG(T), "   %-16s %10Hd %10d %8.2f %8.2f %8.2f %10s\n",
+        H5_bandwidth(bandwidth, (double)nbytes, path->stats.times.elapsed);
+        HDfprintf(H5DEBUG(T), "   %-16s %10Hd %10d %8T %8T %8T %10s\n",
 		   path->name,
 		   path->stats.nelmts,
 		   path->stats.ncalls,
-		   path->stats.timer.utime,
-		   path->stats.timer.stime,
-		   path->stats.timer.etime,
+                   path->stats.times.user,
+                   path->stats.times.system,
+                   path->stats.times.elapsed,
 		   bandwidth);
-    }
+    } /* end if */
 #endif
+
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5T__print_stats() */
 
diff --git a/src/H5Tpkg.h b/src/H5Tpkg.h
index d075127eed6..fe54ce1a650 100644
--- a/src/H5Tpkg.h
+++ b/src/H5Tpkg.h
@@ -146,7 +146,7 @@
 struct H5T_stats_t {
     unsigned	ncalls;			/*num calls to conversion function   */
     hsize_t	nelmts;			/*total data points converted	     */
-    H5_timer_t	timer;			/*total time for conversion	     */
+    H5_timevals_t times;		/*total time for conversion	     */
 };
 
 /* The datatype conversion database */
diff --git a/src/H5Z.c b/src/H5Z.c
index ef34d7c5eba..04624a6b633 100644
--- a/src/H5Z.c
+++ b/src/H5Z.c
@@ -34,10 +34,10 @@
 #ifdef H5Z_DEBUG
 typedef struct H5Z_stats_t {
     struct {
-	hsize_t	total;		/*total number of bytes processed	*/
-	hsize_t	errors;		/*bytes of total attributable to errors	*/
-	H5_timer_t timer;	/*execution time including errors	*/
-    } stats[2];			/*0=output, 1=input			*/
+	hsize_t	total;		/* total number of bytes processed */
+	hsize_t	errors;		/* bytes of total attributable to errors */
+        H5_timevals_t times;    /* execution time including errors */
+    } stats[2];			/* 0 = output, 1 = input */
 } H5Z_stats_t;
 #endif /* H5Z_DEBUG */
 
@@ -136,9 +136,9 @@ H5Z_term_package(void)
 
     if(H5_PKG_INIT_VAR) {
 #ifdef H5Z_DEBUG
-        char comment[16], bandwidth[32];
-        int dir, nprint = 0;
-        size_t i;
+        char	comment[16], bandwidth[32];
+        int	dir, nprint = 0;
+        size_t	i;
 
 	if(H5DEBUG(Z)) {
 	    for(i = 0; i < H5Z_table_used_g; i++) {
@@ -169,27 +169,27 @@ H5Z_term_package(void)
 		     * units of `B/s', `kB/s', `MB/s', `GB/s', or `TB/s' or
 		     * the word `Inf' if the elapsed time is zero.
 		     */
-		    H5_bandwidth(bandwidth,
-				 (double)(H5Z_stat_table_g[i].stats[dir].total),
-				 H5Z_stat_table_g[i].stats[dir].timer.etime);
+                    H5_bandwidth(bandwidth, (double)(H5Z_stat_table_g[i].stats[dir].total),
+                            H5Z_stat_table_g[i].stats[dir].times.elapsed);
 
 		    /* Print the statistics */
-		    HDfprintf(H5DEBUG(Z),
-			       "   %s%-15s %10Hd %10Hd %8.2f %8.2f %8.2f "
-			       "%10s\n", dir?"<":">", comment,
-			       H5Z_stat_table_g[i].stats[dir].total,
-			       H5Z_stat_table_g[i].stats[dir].errors,
-			       H5Z_stat_table_g[i].stats[dir].timer.utime,
-			       H5Z_stat_table_g[i].stats[dir].timer.stime,
-			       H5Z_stat_table_g[i].stats[dir].timer.etime,
-			       bandwidth);
+                    HDfprintf(H5DEBUG(Z), "   %s%-15s %10Hd %10Hd %8T %8T %8T %10s\n",
+                            (dir ? "<" : ">"), comment,
+                            H5Z_stat_table_g[i].stats[dir].total,
+                            H5Z_stat_table_g[i].stats[dir].errors,
+                            H5Z_stat_table_g[i].stats[dir].times.user,
+                            H5Z_stat_table_g[i].stats[dir].times.system,
+                            H5Z_stat_table_g[i].stats[dir].times.elapsed,
+                            bandwidth);
 		} /* end for */
 	    } /* end for */
 	} /* end if */
 #endif /* H5Z_DEBUG */
+
 	/* Free the table of filters */
         if(H5Z_table_g) {
             H5Z_table_g = (H5Z_class2_t *)H5MM_xfree(H5Z_table_g);
+
 #ifdef H5Z_DEBUG
             H5Z_stat_table_g = (H5Z_stats_t *)H5MM_xfree(H5Z_stat_table_g);
 #endif /* H5Z_DEBUG */
@@ -1281,26 +1281,26 @@ H5Z_find(H5Z_filter_t id)
  * Programmer:	Robb Matzke
  *              Tuesday, August  4, 1998
  *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 herr_t
 H5Z_pipeline(const H5O_pline_t *pline, unsigned flags,
- 	     unsigned *filter_mask/*in,out*/, H5Z_EDC_t edc_read,
-             H5Z_cb_t cb_struct, size_t *nbytes/*in,out*/,
-             size_t *buf_size/*in,out*/, void **buf/*in,out*/)
+    unsigned *filter_mask/*in,out*/, H5Z_EDC_t edc_read, H5Z_cb_t cb_struct,
+    size_t *nbytes/*in,out*/, size_t *buf_size/*in,out*/, void **buf/*in,out*/)
 {
-    size_t	i, idx, new_nbytes;
-    int fclass_idx;             /* Index of filter class in global table */
-    H5Z_class2_t	*fclass=NULL;   /* Filter class pointer */
+    size_t          idx;
+    size_t          new_nbytes;
+    int             fclass_idx;     /* Index of filter class in global table */
+    H5Z_class2_t   *fclass = NULL;  /* Filter class pointer */
 #ifdef H5Z_DEBUG
-    H5Z_stats_t	*fstats=NULL;   /* Filter stats pointer */
-    H5_timer_t	timer;
+    H5Z_stats_t	   *fstats = NULL;   /* Filter stats pointer */
+    H5_timer_t      timer;           /* Timer for filter operations */
+    H5_timevals_t   times;           /* Elapsed time for each operation */
 #endif
-    unsigned	failed = 0;
-    unsigned	tmp_flags;
-    herr_t      ret_value=SUCCEED;       /* Return value */
+    unsigned        failed = 0;
+    unsigned        tmp_flags;
+    size_t          i;
+    herr_t          ret_value = SUCCEED;    /* Return value */
 
     FUNC_ENTER_NOAPI(FAIL)
 
@@ -1311,14 +1311,17 @@ H5Z_pipeline(const H5O_pline_t *pline, unsigned flags,
     HDassert(buf && *buf);
     HDassert(!pline || pline->nused<H5Z_MAX_NFILTERS);
 
-    if (pline && (flags & H5Z_FLAG_REVERSE)) { /* Read */
-	for (i=pline->nused; i>0; --i) {
-	    idx = i-1;
+#ifdef H5Z_DEBUG
+    H5_timer_init(&timer);
+#endif
 
-	    if (*filter_mask & ((unsigned)1<<idx)) {
+    if(pline && (flags & H5Z_FLAG_REVERSE)) { /* Read */
+	for(i = pline->nused; i > 0; --i) {
+	    idx = i - 1;
+	    if(*filter_mask & ((unsigned)1 << idx)) {
 		failed |= (unsigned)1 << idx;
-		continue;/*filter excluded*/
-	    }
+		continue;       /* filter excluded */
+	    } /* end if */
 
             /* If the filter isn't registered and the application doesn't 
              * indicate no plugin through HDF5_PRELOAD_PLUG (using the symbol "::"), 
@@ -1326,20 +1329,20 @@ H5Z_pipeline(const H5O_pline_t *pline, unsigned flags,
              */
 	    if((fclass_idx = H5Z_find_idx(pline->filter[idx].id)) < 0) {
                 hbool_t issue_error = FALSE;
-				const H5Z_class2_t    *filter_info;
+                const H5Z_class2_t    *filter_info;
 
-				/* Try loading the filter */
-				if(NULL != (filter_info = (const H5Z_class2_t *)H5PL_load(H5PL_TYPE_FILTER, (int)(pline->filter[idx].id)))) {
-					/* Register the filter we loaded */
-					if(H5Z_register(filter_info) < 0)
-						HGOTO_ERROR(H5E_PLINE, H5E_CANTINIT, FAIL, "unable to register filter")
+                /* Try loading the filter */
+                if(NULL != (filter_info = (const H5Z_class2_t *)H5PL_load(H5PL_TYPE_FILTER, (int)(pline->filter[idx].id)))) {
+                    /* Register the filter we loaded */
+                    if(H5Z_register(filter_info) < 0)
+                        HGOTO_ERROR(H5E_PLINE, H5E_CANTINIT, FAIL, "unable to register filter")
 
-					/* Search in the table of registered filters again to find the dynamic filter just loaded and registered */
-					if((fclass_idx = H5Z_find_idx(pline->filter[idx].id)) < 0)
-						issue_error = TRUE;
-				} /* end if */
-				else
-					issue_error = TRUE;
+                    /* Search in the table of registered filters again to find the dynamic filter just loaded and registered */
+                    if((fclass_idx = H5Z_find_idx(pline->filter[idx].id)) < 0)
+                        issue_error = TRUE;
+                } /* end if */
+                else
+                    issue_error = TRUE;
 
                 /* Check for error */
                 if(issue_error) {
@@ -1352,76 +1355,96 @@ H5Z_pipeline(const H5O_pline_t *pline, unsigned flags,
                 } /* end if */
             } /* end if */
 
-            fclass=&H5Z_table_g[fclass_idx];
+            fclass = &H5Z_table_g[fclass_idx];
+
 #ifdef H5Z_DEBUG
-            fstats=&H5Z_stat_table_g[fclass_idx];
-	    H5_timer_begin(&timer);
+            fstats = &H5Z_stat_table_g[fclass_idx];
+            H5_timer_start(&timer);
 #endif
+
             tmp_flags=flags|(pline->filter[idx].flags);
             tmp_flags|=(edc_read== H5Z_DISABLE_EDC) ? H5Z_FLAG_SKIP_EDC : 0;
-	    new_nbytes = (fclass->filter)(tmp_flags, pline->filter[idx].cd_nelmts,
-                                        pline->filter[idx].cd_values, *nbytes, buf_size, buf);
+            new_nbytes = (fclass->filter)(tmp_flags,
+                    pline->filter[idx].cd_nelmts, pline->filter[idx].cd_values,
+                    *nbytes, buf_size, buf);
 
 #ifdef H5Z_DEBUG
-	    H5_timer_end(&(fstats->stats[1].timer), &timer);
+            H5_timer_stop(&timer);
+            H5_timer_get_times(timer, &times);
+            fstats->stats[1].times.elapsed += times.elapsed;
+            fstats->stats[1].times.system  += times.system;
+            fstats->stats[1].times.user    += times.user;
+
 	    fstats->stats[1].total += MAX(*nbytes, new_nbytes);
-	    if (0==new_nbytes) fstats->stats[1].errors += *nbytes;
+            if(0 == new_nbytes)
+                fstats->stats[1].errors += *nbytes;
 #endif
 
             if(0==new_nbytes) {
-                if((cb_struct.func && (H5Z_CB_FAIL==cb_struct.func(pline->filter[idx].id, *buf, *buf_size, cb_struct.op_data)))
-                    || !cb_struct.func)
-		      HGOTO_ERROR(H5E_PLINE, H5E_READERROR, FAIL, "filter returned failure during read")
+                if((cb_struct.func 
+                        && (H5Z_CB_FAIL == cb_struct.func(pline->filter[idx].id, *buf, *buf_size, cb_struct.op_data)))
+                        || !cb_struct.func)
+                    HGOTO_ERROR(H5E_PLINE, H5E_READERROR, FAIL, "filter returned failure during read")
 
                 *nbytes = *buf_size;
                 failed |= (unsigned)1 << idx;
                 H5E_clear_stack(NULL);
-            } else {
+            } /* end if */
+            else
                 *nbytes = new_nbytes;
-            }
-	}
+	} /* end for */
     } else if (pline) { /* Write */
-	for (idx=0; idx<pline->nused; idx++) {
-	    if (*filter_mask & ((unsigned)1<<idx)) {
+	for(idx = 0; idx < pline->nused; idx++) {
+	    if(*filter_mask & ((unsigned)1 << idx)) {
 		failed |= (unsigned)1 << idx;
-		continue; /*filter excluded*/
-	    }
-	    if ((fclass_idx=H5Z_find_idx(pline->filter[idx].id))<0) {
+		continue;       /* filter excluded */
+	    } /* end if */
+	    if((fclass_idx = H5Z_find_idx(pline->filter[idx].id)) < 0) {
                 /* Check if filter is optional -- If it isn't, then error */
-		if ((pline->filter[idx].flags & H5Z_FLAG_OPTIONAL) == 0)
+		if((pline->filter[idx].flags & H5Z_FLAG_OPTIONAL) == 0)
 		    HGOTO_ERROR(H5E_PLINE, H5E_WRITEERROR, FAIL, "required filter is not registered")
-
 		failed |= (unsigned)1 << idx;
                 H5E_clear_stack(NULL);
-		continue; /*filter excluded*/
-	    }
-            fclass=&H5Z_table_g[fclass_idx];
+		continue;       /* filter excluded */
+	    } /* end if */
+
+            fclass = &H5Z_table_g[fclass_idx];
+
 #ifdef H5Z_DEBUG
-            fstats=&H5Z_stat_table_g[fclass_idx];
-	    H5_timer_begin(&timer);
+            fstats = &H5Z_stat_table_g[fclass_idx];
+            H5_timer_start(&timer);
 #endif
-	    new_nbytes = (fclass->filter)(flags|(pline->filter[idx].flags), pline->filter[idx].cd_nelmts,
-					pline->filter[idx].cd_values, *nbytes, buf_size, buf);
+
+            new_nbytes = (fclass->filter)(flags|(pline->filter[idx].flags),
+                    pline->filter[idx].cd_nelmts, pline->filter[idx].cd_values,
+                    *nbytes, buf_size, buf);
+
 #ifdef H5Z_DEBUG
-	    H5_timer_end(&(fstats->stats[0].timer), &timer);
+            H5_timer_stop(&timer);
+            H5_timer_get_times(timer, &times);
+            fstats->stats[0].times.elapsed += times.elapsed;
+            fstats->stats[0].times.system  += times.system;
+            fstats->stats[0].times.user    += times.user;
+
 	    fstats->stats[0].total += MAX(*nbytes, new_nbytes);
-	    if (0==new_nbytes) fstats->stats[0].errors += *nbytes;
+            if(0 == new_nbytes)
+                fstats->stats[0].errors += *nbytes;
 #endif
-            if(0==new_nbytes) {
-                if (0==(pline->filter[idx].flags & H5Z_FLAG_OPTIONAL)) {
+
+            if(0 == new_nbytes) {
+                if(0 == (pline->filter[idx].flags & H5Z_FLAG_OPTIONAL)) {
                     if((cb_struct.func && (H5Z_CB_FAIL==cb_struct.func(pline->filter[idx].id, *buf, *nbytes, cb_struct.op_data)))
                             || !cb_struct.func)
                         HGOTO_ERROR(H5E_PLINE, H5E_WRITEERROR, FAIL, "filter returned failure")
 
                     *nbytes = *buf_size;
-                }
-
+                } /* end if */
                 failed |= (unsigned)1 << idx;
                 H5E_clear_stack(NULL);
-            } else {
+            } /* end if */
+            else
                 *nbytes = new_nbytes;
-            }
-	}
+	} /* end for */
     }
 
     *filter_mask = failed;
diff --git a/src/H5private.h b/src/H5private.h
index ca4ebcf318b..557eeba923b 100644
--- a/src/H5private.h
+++ b/src/H5private.h
@@ -573,21 +573,37 @@
 #define LOCK_UN     0x08
 #endif /* H5_HAVE_FLOCK */
 
-/*
- * Data types and functions for timing certain parts of the library.
+/* Typedefs and functions for timing certain parts of the library. */
+
+/* A set of elapsed/user/system times emitted as a time point by the
+ * platform-independent timers.
  */
 typedef struct {
-    double  utime;    /*user time      */
-    double  stime;    /*system time      */
-    double  etime;    /*elapsed wall-clock time  */
+    double user;      /* User time in seconds */
+    double system;    /* System time in seconds */
+    double elapsed;   /* Elapsed (wall clock) time in seconds */
+} H5_timevals_t;
+
+/* Timer structure for platform-independent timers */
+typedef struct {
+    H5_timevals_t   initial;            /* Current interval start time */
+    H5_timevals_t   final_interval;     /* Last interval elapsed time */
+    H5_timevals_t   total;              /* Total elapsed time for all intervals */
+    hbool_t         is_running;         /* Whether timer is running */
 } H5_timer_t;
 
-H5_DLL void H5_timer_reset (H5_timer_t *timer);
-H5_DLL void H5_timer_begin (H5_timer_t *timer);
-H5_DLL void H5_timer_end (H5_timer_t *sum/*in,out*/,
-         H5_timer_t *timer/*in,out*/);
+/* Returns library bandwidth as a pretty string */
 H5_DLL void H5_bandwidth(char *buf/*out*/, double nbytes, double nseconds);
+
+/* Timer functionality */
 H5_DLL time_t H5_now(void);
+H5_DLL uint64_t H5_now_usec(void);
+H5_DLL herr_t H5_timer_init(H5_timer_t *timer /*in,out*/);
+H5_DLL herr_t H5_timer_start(H5_timer_t *timer /*in,out*/);
+H5_DLL herr_t H5_timer_stop(H5_timer_t *timer /*in,out*/);
+H5_DLL herr_t H5_timer_get_times(H5_timer_t timer, H5_timevals_t *times /*in,out*/);
+H5_DLL herr_t H5_timer_get_total_times(H5_timer_t timer, H5_timevals_t *times /*in,out*/);
+H5_DLL char *H5_timer_get_time_string(double seconds);
 
 /* Depth of object copy */
 typedef enum {
@@ -703,6 +719,9 @@ typedef struct {
 #ifndef HDclock
     #define HDclock()    clock()
 #endif /* HDclock */
+#ifndef HDclock_gettime
+    #define HDclock_gettime(CID, TS)    clock_gettime(CID, TS)
+#endif /* HDclock_gettime */
 #ifndef HDclose
     #define HDclose(F)    close(F)
 #endif /* HDclose */
diff --git a/src/H5system.c b/src/H5system.c
index a1cdf19df62..cff2d7156e2 100644
--- a/src/H5system.c
+++ b/src/H5system.c
@@ -13,11 +13,11 @@
 
 /*-------------------------------------------------------------------------
  *
- * Created:    H5system.c
- *      Aug 21 2006
- *      Quincey Koziol <koziol@hdfgroup.org>
+ * Created:		H5system.c
+ *			Aug 21 2006
+ *			Quincey Koziol <koziol@hdfgroup.org>
  *
- * Purpose:    System call wrapper implementations.
+ * Purpose:             System call wrapper implementations.
  *
  *-------------------------------------------------------------------------
  */
@@ -30,10 +30,10 @@
 /***********/
 /* Headers */
 /***********/
-#include "H5private.h"        /* Generic Functions            */
-#include "H5Eprivate.h"        /* Error handling              */
-#include "H5Fprivate.h"        /* File access                */
-#include "H5MMprivate.h"    /* Memory management            */
+#include "H5private.h"      /* Generic Functions        */
+#include "H5Eprivate.h"     /* Error handling           */
+#include "H5Fprivate.h"     /* File access              */
+#include "H5MMprivate.h"    /* Memory management        */
 
 
 /****************/
@@ -372,7 +372,7 @@ HDfprintf(FILE *stream, const char *fmt, ...)
                             if(fwidth)
                                 len += HDsnprintf(format_templ + len, (sizeof(format_templ) - (size_t)(len + 1)),  "%d", fwidth);
                             HDstrncat(format_templ, "s", (sizeof(format_templ) - (size_t)(len + 1)));
-                            fprintf(stream, format_templ, "UNDEF");
+                            n = fprintf(stream, format_templ, "UNDEF");
                         }
                     }
                     break;
@@ -402,11 +402,25 @@ HDfprintf(FILE *stream, const char *fmt, ...)
                         htri_t tri_var = va_arg(ap, htri_t);
 
                         if(tri_var > 0)
-                            fprintf(stream, "TRUE");
+                            n = fprintf(stream, "TRUE");
                         else if(!tri_var)
-                            fprintf(stream, "FALSE");
+                            n = fprintf(stream, "FALSE");
                         else
-                            fprintf(stream, "FAIL(%d)", (int)tri_var);
+                            n = fprintf(stream, "FAIL(%d)", (int)tri_var);
+                    }
+                    break;
+
+                case 'T':       /* Elapsed time, in seconds */
+                    {
+                        double seconds = va_arg(ap, double);
+                        char *time_string = H5_timer_get_time_string(seconds);
+
+                        if(time_string) {
+                            n = fprintf(stream, format_templ, time_string);
+                            HDfree(time_string);
+                        } /* end if */
+                        else
+                            n = fprintf(stream, format_templ, "(error)");
                     }
                     break;
 
@@ -822,11 +836,88 @@ Wsetenv(const char *name, const char *value, int overwrite)
 #pragma comment(lib, "advapi32.lib")
 #endif
 
+
+/*-------------------------------------------------------------------------
+ * Function:    H5_get_win32_times
+ *
+ * Purpose:     Gets the elapsed, system and user times on Windows platforms.
+ *              All time values are in seconds.
+ *
+ * Return:      Success:  0
+ *              Failure:  -1
+ *
+ * Programmer:  Dana Robinson
+ *              May 2011
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifdef H5_HAVE_WIN32_API
+int
+H5_get_win32_times(H5_timevals_t *tvs /*in,out*/)
+{
+    static HANDLE process_handle;
+    ULARGE_INTEGER kernel_start;
+    ULARGE_INTEGER user_start;
+    FILETIME KernelTime;
+    FILETIME UserTime;
+    FILETIME CreationTime;
+    FILETIME ExitTime;
+    LARGE_INTEGER counts_start;
+    static LARGE_INTEGER counts_freq;
+    static hbool_t is_initialized = FALSE;
+    BOOL err;
+
+    HDassert(tvs);
+
+    if(!is_initialized) {
+        /* NOTE: This is just a pseudo handle and does not need to be closed. */
+        process_handle = GetCurrentProcess();
+        err = QueryPerformanceFrequency(&counts_freq);
+        if(0 == err)
+            return -1;
+        is_initialized = TRUE;
+    } /* end if */
+
+    /*************************
+     * System and user times *
+     *************************/
+
+    err = GetProcessTimes(process_handle, &CreationTime, &ExitTime, &KernelTime,
+            &UserTime);
+    if(0 == err)
+        return -1;
+
+    /* The 1.0E7 factor seems strange but it's due to the clock
+     * ticking in 100 ns increments.
+     */
+    kernel_start.HighPart = KernelTime.dwHighDateTime;
+    kernel_start.LowPart = KernelTime.dwLowDateTime;
+    tvs->system = (double)(kernel_start.QuadPart / 1.0E7F);
+
+    user_start.HighPart = UserTime.dwHighDateTime;
+    user_start.LowPart = UserTime.dwLowDateTime;
+    tvs->user = (double)(user_start.QuadPart / 1.0E7F);
+
+    /****************
+     * Elapsed time *
+     ****************/
+
+    err = QueryPerformanceCounter(&counts_start);
+    if(0 == err)
+        return -1;
+
+    tvs->elapsed = (double)(counts_start.QuadPart) / (double)counts_freq.QuadPart;
+
+    return 0;
+} /* end H5_get_win32_times() */
+#endif
+
 #define WloginBuffer_count 256
 static char Wlogin_buffer[WloginBuffer_count];
 
+
 char*
-Wgetlogin()
+Wgetlogin(void)
 {
 
 #ifdef H5_HAVE_WINSOCK2_H
diff --git a/src/H5timer.c b/src/H5timer.c
index 0ba8bd1ec2d..2cb8cea2073 100644
--- a/src/H5timer.c
+++ b/src/H5timer.c
@@ -12,12 +12,11 @@
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 /*-------------------------------------------------------------------------
- *
  * Created:		H5timer.c
  *			Aug 21 2006
  *			Quincey Koziol <koziol@hdfgroup.org>
  *
- * Purpose:		Internal 'timer' routines & support routines.
+ * Purpose:             Internal, platform-independent 'timer' support routines.
  *
  *-------------------------------------------------------------------------
  */
@@ -32,20 +31,22 @@
 /***********/
 #include "H5private.h"		/* Generic Functions			*/
 
-/* We need this for the struct rusage declaration */
-#if defined(H5_HAVE_GETRUSAGE) && defined(H5_HAVE_SYS_RESOURCE_H)
-#   include <sys/resource.h>
-#endif
-
-#if defined(H5_HAVE_GETTIMEOFDAY) && defined(H5_HAVE_SYS_TIME_H)
-#include <sys/time.h>
-#endif
-
 
 /****************/
 /* Local Macros */
 /****************/
 
+/* Size of a generated time string.
+ * Most time strings should be < 20 or so characters (max!) so this should be a
+ * safe size.  Dynamically allocating the correct size would be painful.
+ */
+#define H5TIMER_TIME_STRING_LEN 256
+
+/* Conversion factors */
+#define H5_SEC_PER_DAY  (double)(24.0F * 60.0F * 60.0F)
+#define H5_SEC_PER_HOUR (double)(60.0F * 60.0F)
+#define H5_SEC_PER_MIN  (double)(60.0F)
+
 
 /******************/
 /* Local Typedefs */
@@ -76,104 +77,6 @@
 /* Local Variables */
 /*******************/
 
-
-/*-------------------------------------------------------------------------
- * Function:	H5_timer_reset
- *
- * Purpose:	Resets the timer struct to zero.  Use this to reset a timer
- *		that's being used as an accumulator for summing times.
- *
- * Return:	void
- *
- * Programmer:	Robb Matzke
- *              Thursday, April 16, 1998
- *
- *-------------------------------------------------------------------------
- */
-void
-H5_timer_reset (H5_timer_t *timer)
-{
-    HDassert(timer);
-    HDmemset(timer, 0, sizeof *timer);
-} /* end H5_timer_reset() */
-
-
-/*-------------------------------------------------------------------------
- * Function:	H5_timer_begin
- *
- * Purpose:	Initialize a timer to time something.
- *
- * Return:	void
- *
- * Programmer:	Robb Matzke
- *              Thursday, April 16, 1998
- *
- *-------------------------------------------------------------------------
- */
-void
-H5_timer_begin (H5_timer_t *timer)
-{
-#ifdef H5_HAVE_GETRUSAGE
-    struct rusage	rusage;
-#endif
-#ifdef H5_HAVE_GETTIMEOFDAY
-    struct timeval	etime;
-#endif
-
-    HDassert(timer);
-
-#ifdef H5_HAVE_GETRUSAGE
-    HDgetrusage (RUSAGE_SELF, &rusage);
-    timer->utime = (double)rusage.ru_utime.tv_sec +
-                   ((double)rusage.ru_utime.tv_usec / (double)1e6F);
-    timer->stime = (double)rusage.ru_stime.tv_sec +
-                   ((double)rusage.ru_stime.tv_usec / (double)1e6F);
-#else
-    timer->utime = 0.0F;
-    timer->stime = 0.0F;
-#endif
-#ifdef H5_HAVE_GETTIMEOFDAY
-    HDgettimeofday (&etime, NULL);
-    timer->etime = (double)etime.tv_sec + ((double)etime.tv_usec / (double)1e6F);
-#else
-    timer->etime = 0.0F;
-#endif
-} /* end H5_timer_begin() */
-
-
-/*-------------------------------------------------------------------------
- * Function:	H5_timer_end
- *
- * Purpose:	This function should be called at the end of a timed region.
- *		The SUM is an optional pointer which will accumulate times.
- *		TMS is the same struct that was passed to H5_timer_start().
- *		On return, TMS will contain total times for the timed region.
- *
- * Return:	void
- *
- * Programmer:	Robb Matzke
- *              Thursday, April 16, 1998
- *
- *-------------------------------------------------------------------------
- */
-void
-H5_timer_end (H5_timer_t *sum/*in,out*/, H5_timer_t *timer/*in,out*/)
-{
-    H5_timer_t		now;
-
-    HDassert(timer);
-    H5_timer_begin(&now);
-
-    timer->utime = MAX((double)0.0F, now.utime - timer->utime);
-    timer->stime = MAX((double)0.0F, now.stime - timer->stime);
-    timer->etime = MAX((double)0.0F, now.etime - timer->etime);
-
-    if (sum) {
-        sum->utime += timer->utime;
-        sum->stime += timer->stime;
-        sum->etime += timer->etime;
-    }
-} /* end H5_timer_end() */
 
 
 /*-------------------------------------------------------------------------
@@ -209,32 +112,35 @@ H5_bandwidth(char *buf/*out*/, double nbytes, double nseconds)
     if(nseconds <= (double)0.0F)
         HDstrcpy(buf, "       NaN");
     else {
-        bw = nbytes/nseconds;
+        bw = nbytes / nseconds;
         if(H5_DBL_ABS_EQUAL(bw, (double)0.0F))
             HDstrcpy(buf, "0.000  B/s");
         else if(bw < (double)1.0F)
-            sprintf(buf, "%10.4e", bw);
+            HDsprintf(buf, "%10.4e", bw);
         else if(bw < (double)H5_KB) {
-            sprintf(buf, "%05.4f", bw);
-            HDstrcpy(buf+5, "  B/s");
+            HDsprintf(buf, "%05.4f", bw);
+            HDstrcpy(buf + 5, "  B/s");
         } else if(bw < (double)H5_MB) {
-            sprintf(buf, "%05.4f", bw / (double)H5_KB);
-            HDstrcpy(buf+5, " kB/s");
+            HDsprintf(buf, "%05.4f", bw / (double)H5_KB);
+            HDstrcpy(buf + 5, " kB/s");
         } else if(bw < (double)H5_GB) {
-            sprintf(buf, "%05.4f", bw / (double)H5_MB);
-            HDstrcpy(buf+5, " MB/s");
+            HDsprintf(buf, "%05.4f", bw / (double)H5_MB);
+            HDstrcpy(buf + 5, " MB/s");
         } else if(bw < (double)H5_TB) {
-            sprintf(buf, "%05.4f", bw / (double)H5_GB);
-            HDstrcpy(buf+5, " GB/s");
+            HDsprintf(buf, "%05.4f", bw / (double)H5_GB);
+            HDstrcpy(buf + 5, " GB/s");
         } else if(bw < (double)H5_PB) {
-            sprintf(buf, "%05.4f", bw / (double)H5_TB);
-            HDstrcpy(buf+5, " TB/s");
+            HDsprintf(buf, "%05.4f", bw / (double)H5_TB);
+            HDstrcpy(buf + 5, " TB/s");
+        } else if(bw < (double)H5_EB) {
+            HDsprintf(buf, "%05.4f", bw / (double)H5_PB);
+            HDstrcpy(buf + 5, " PB/s");
         } else {
-            sprintf(buf, "%10.4e", bw);
+            HDsprintf(buf, "%10.4e", bw);
             if(HDstrlen(buf) > 10)
-                sprintf(buf, "%10.3e", bw);
-        }
-    }
+                HDsprintf(buf, "%10.3e", bw);
+        } /* end else-if */
+    } /* end else */
 } /* end H5_bandwidth() */
 
 
@@ -269,3 +175,455 @@ H5_now(void)
     return(now);
 } /* end H5_now() */
 
+
+/*-------------------------------------------------------------------------
+ * Function:	H5_now_usec
+ *
+ * Purpose:	Retrieves the current time, as microseconds after the UNIX epoch.
+ *
+ * Return:	# of microseconds from the epoch (can't fail)
+ *
+ * Programmer:	Quincey Koziol
+ *              Tuesday, November 28, 2006
+ *
+ *-------------------------------------------------------------------------
+ */
+uint64_t
+H5_now_usec(void)
+{
+    uint64_t	now;                    /* Current time, in microseconds */
+
+#ifdef H5_HAVE_GETTIMEOFDAY
+    {
+        struct timeval now_tv;
+
+        HDgettimeofday(&now_tv, NULL);
+        now = (uint64_t)(now_tv.tv_sec * (1000 * 1000)) + (uint64_t)now_tv.tv_usec;
+    }
+#else /* H5_HAVE_GETTIMEOFDAY */
+    now = (uint64_t)(HDtime(NULL) * (1000 * 1000));
+#endif /* H5_HAVE_GETTIMEOFDAY */
+
+    return(now);
+} /* end H5_now_usec() */
+
+
+/*-------------------------------------------------------------------------
+ * Function:    H5__timer_get_timevals
+ *
+ * Purpose:     Internal platform-specific function to get time system,
+ *              user and elapsed time values.
+ *
+ * Return:      Success:    0
+ *              Failure:    -1
+ *
+ * Programmer:  Dana Robinson
+ *              May 2011
+ *
+ *-------------------------------------------------------------------------
+ */
+static herr_t
+H5__timer_get_timevals(H5_timevals_t *times /*in,out*/)
+{
+    /* Sanity check */
+    HDassert(times);
+
+    /* Windows call handles both system/user and elapsed times */
+#ifdef H5_HAVE_WIN32_API
+    if(H5_get_win32_times(times) < 0) {
+        times->elapsed   = -1;
+        times->system    = -1;
+        times->user      = -1;
+
+        return -1;
+    } /* end if */
+#else /* H5_HAVE_WIN32_API */
+
+    /*************************
+     * System and user times *
+     *************************/
+#if defined(H5_HAVE_GETRUSAGE)
+{
+    struct rusage res;
+
+    if(HDgetrusage(RUSAGE_SELF, &res) < 0)
+        return -1;
+    times->system = (double)res.ru_stime.tv_sec + ((double)res.ru_stime.tv_usec / (double)1.0E6F);
+    times->user   = (double)res.ru_utime.tv_sec + ((double)res.ru_utime.tv_usec / (double)1.0E6F);
+}
+#else
+    /* No suitable way to get system/user times */
+    /* This is not an error condition, they just won't be available */
+    times->system = -1.0;
+    times->user   = -1.0;
+#endif
+
+    /****************
+     * Elapsed time *
+     ****************/
+
+    /* NOTE: Not having a way to get elapsed time IS an error, unlike
+     * the system and user times.
+     */
+
+#if defined(H5_HAVE_CLOCK_GETTIME)
+{
+    struct timespec ts;
+
+    if(HDclock_gettime(CLOCK_MONOTONIC, &ts) != 0)
+        return -1;
+    times->elapsed = (double)ts.tv_sec + ((double)ts.tv_nsec / (double)1.0E9F);
+}
+#else
+    /* Die here.  We'd like to know about this so we can support some
+     * other time functionality.
+     */
+    HDassert(0);
+#endif
+#endif /* H5_HAVE_WIN32_API */
+
+    return 0;
+} /* end H5__timer_get_timevals() */
+
+
+/*-------------------------------------------------------------------------
+ * Function:    H5_timer_init
+ *
+ * Purpose:     Initialize a platform-independent timer.
+ *
+ *              Timer usage is as follows:
+ *
+ *              1) Call H5_timer_init(), passing in a timer struct, to set
+ *                 up the timer.
+ *
+ *              2) Wrap any code you'd like to time with calls to
+ *                 H5_timer_start/stop().  For accurate timing, place these
+ *                 calls as close to the code of interest as possible.  You
+ *                 can call start/stop multiple times on the same timer -
+ *                 when you do this, H5_timer_get_times() will return time
+ *                 values for the current/last session and
+ *                 H5_timer_get_total_times() will return the summed times
+ *                 of all sessions (see #3 and #4, below).
+ *
+ *              3) Use H5_timer_get_times() to get the current system, user
+ *                 and elapsed times from a running timer.  If called on a
+ *                 stopped timer, this will return the time recorded at the
+ *                 stop point.
+ *
+ *              4) Call H5_timer_get_total_times() to get the total system,
+ *                 user and elapsed times recorded across multiple start/stop
+ *                 sessions.  If called on a running timer, it will return the
+ *                 time recorded up to that point.  On a stopped timer, it
+ *                 will return the time recorded at the stop point.
+ *
+ *              NOTE: Obtaining a time point is not free!  Keep in mind that
+ *                    the time functions make system calls and can have
+ *                    non-trivial overhead.  If you call one of the get_time
+ *                    functions on a running timer, that overhead will be
+ *                    added to the reported times.
+ *
+ *              5) All times recorded will be in seconds.  These can be
+ *                 converted into human-readable strings with the
+ *                 H5_timer_get_time_string() function.
+ *
+ *              6) A timer can be reset using by calling H5_timer_init() on
+ *                 it.  This will set its state to 'stopped' and reset all
+ *                 accumulated times to zero.
+ *
+ *
+ * Return:      Success:    0
+ *              Failure:    -1
+ *
+ * Programmer:  Dana Robinson
+ *              May 2011
+ *
+ *-------------------------------------------------------------------------
+ */
+herr_t
+H5_timer_init(H5_timer_t *timer /*in,out*/)
+{
+    /* Sanity check */
+    HDassert(timer);
+
+    /* Initialize everything */
+    HDmemset(timer, 0, sizeof(H5_timer_t));
+
+    return 0;
+} /* end H5_timer_init() */
+
+
+/*-------------------------------------------------------------------------
+ * Function:    H5_timer_start
+ *
+ * Purpose:     Start tracking time in a platform-independent timer.
+ *
+ * Return:      Success:    0
+ *              Failure:    -1
+ *
+ * Programmer:  Dana Robinson
+ *              May 2011
+ *
+ *-------------------------------------------------------------------------
+ */
+herr_t
+H5_timer_start(H5_timer_t *timer /*in,out*/)
+{
+    /* Sanity check */
+    HDassert(timer);
+
+    /* Start the timer
+     * This sets the "initial" times to the system-defined start times.
+     */
+    if(H5__timer_get_timevals(&(timer->initial)) < 0)
+        return -1;
+
+    timer->is_running = TRUE;
+
+    return 0;
+} /* end H5_timer_start() */
+
+
+/*-------------------------------------------------------------------------
+ * Function:    H5_timer_stop
+ *
+ * Purpose:     Stop tracking time in a platform-independent timer.
+ *
+ * Return:      Success:    0
+ *              Failure:    -1
+ *
+ * Programmer:  Dana Robinson
+ *              May 2011
+ *
+ *-------------------------------------------------------------------------
+ */
+herr_t
+H5_timer_stop(H5_timer_t *timer /*in,out*/)
+{
+    /* Sanity check */
+    HDassert(timer);
+
+    /* Stop the timer */
+    if(H5__timer_get_timevals(&(timer->final_interval)) < 0)
+        return -1;
+
+    /* The "final" times are stored as intervals (final - initial)
+     * for more useful reporting to the user.
+     */
+    timer->final_interval.elapsed = timer->final_interval.elapsed - timer->initial.elapsed;
+    timer->final_interval.system  = timer->final_interval.system  - timer->initial.system;
+    timer->final_interval.user    = timer->final_interval.user    - timer->initial.user;
+
+    /* Add the intervals to the elapsed time */
+    timer->total.elapsed += timer->final_interval.elapsed;
+    timer->total.system  += timer->final_interval.system;
+    timer->total.user    += timer->final_interval.user;
+
+    timer->is_running = FALSE;
+
+    return 0;
+} /* end H5_timer_stop() */
+
+
+/*-------------------------------------------------------------------------
+ * Function:    H5_timer_get_times
+ *
+ * Purpose:     Get the system, user and elapsed times from a timer.  These
+ *              are the times since the timer was last started and will be
+ *              0.0 in a timer that has not been started since it was
+ *              initialized.
+ *
+ *              This function can be called either before or after
+ *              H5_timer_stop() has been called.  If it is called before the
+ *              stop function, the timer will continue to run.
+ *
+ *              The system and user times will be -1.0 if those times cannot
+ *              be computed on a particular platform.  The elapsed time will
+ *              always be present.
+ *
+ * Return:      Success:    0
+ *              Failure:    -1
+ *
+ * Programmer:  Dana Robinson
+ *              May 2011
+ *
+ *-------------------------------------------------------------------------
+ */
+herr_t
+H5_timer_get_times(H5_timer_t timer, H5_timevals_t *times /*in,out*/)
+{
+    /* Sanity check */
+    HDassert(times);
+
+    if(timer.is_running) {
+        H5_timevals_t   now;
+
+        /* Get the current times and report the current intervals without
+         * stopping the timer.
+         */
+        if(H5__timer_get_timevals(&now) < 0)
+            return -1;
+
+        times->elapsed = now.elapsed - timer.initial.elapsed;
+        times->system  = now.system  - timer.initial.system;
+        times->user    = now.user    - timer.initial.user;
+    } /* end if */
+    else {
+        times->elapsed = timer.final_interval.elapsed;
+        times->system  = timer.final_interval.system;
+        times->user    = timer.final_interval.user;
+    } /* end else */
+
+    return 0;
+} /* end H5_timer_get_times() */
+
+
+/*-------------------------------------------------------------------------
+ * Function:    H5_timer_get_total_times
+ *
+ * Purpose:     Get the TOTAL system, user and elapsed times recorded by
+ *              the timer since its initialization.  This is the sum of all
+ *              times recorded while the timer was running.
+ *
+ *              These will be 0.0 in a timer that has not been started
+ *              since it was initialized.  Calling H5_timer_init() on a
+ *              timer will reset these values to 0.0.
+ *
+ *              This function can be called either before or after
+ *              H5_timer_stop() has been called.  If it is called before the
+ *              stop function, the timer will continue to run.
+ *
+ *              The system and user times will be -1.0 if those times cannot
+ *              be computed on a particular platform.  The elapsed time will
+ *              always be present.
+ *
+ * Return:      Success:    0
+ *              Failure:    -1
+ *
+ * Programmer:  Dana Robinson
+ *              May 2011
+ *
+ *-------------------------------------------------------------------------
+ */
+herr_t
+H5_timer_get_total_times(H5_timer_t timer, H5_timevals_t *times /*in,out*/)
+{
+    /* Sanity check */
+    HDassert(times);
+
+    if(timer.is_running) {
+        H5_timevals_t   now;
+
+        /* Get the current times and report the current totals without
+         * stopping the timer.
+         */
+        if(H5__timer_get_timevals(&now) < 0)
+            return -1;
+
+        times->elapsed = timer.total.elapsed + (now.elapsed - timer.initial.elapsed);
+        times->system  = timer.total.system  + (now.system  - timer.initial.system);
+        times->user    = timer.total.user    + (now.user    - timer.initial.user);
+    } /* end if */
+    else {
+        times->elapsed = timer.total.elapsed;
+        times->system  = timer.total.system;
+        times->user    = timer.total.user;
+    } /* end else */
+
+    return 0;
+} /* end H5_timer_get_total_times() */
+
+
+/*-------------------------------------------------------------------------
+ * Function:    H5_timer_get_time_string
+ *
+ * Purpose:     Converts a time (in seconds) into a human-readable string
+ *              suitable for log messages.
+ *
+ * Return:      Success:  The time string.
+ *
+ *                        The general format of the time string is:
+ *
+ *                        "N/A"                 time < 0 (invalid time)
+ *                        "%.f ns"              time < 1 microsecond
+ *                        "%.1f us"             time < 1 millisecond
+ *                        "%.1f ms"             time < 1 second
+ *                        "%.2f s"              time < 1 minute
+ *                        "%.f m %.f s"         time < 1 hour
+ *                        "%.f h %.f m %.f s"   longer times
+ *
+ *              Failure:  NULL
+ *
+ * Programmer:  Dana Robinson
+ *              May 2011
+ *
+ *-------------------------------------------------------------------------
+ */
+char *
+H5_timer_get_time_string(double seconds)
+{
+    char *s;                /* output string */
+
+    /* Used when the time is greater than 59 seconds */
+    double days;
+    double hours;
+    double minutes;
+    double remainder_sec;
+
+    /* Extract larger time units from count of seconds */
+    if(seconds > (double)60.0F) {
+        /* Set initial # of seconds */
+        remainder_sec = seconds;
+
+        /* Extract days */
+        days = HDfloor(remainder_sec / H5_SEC_PER_DAY);
+        remainder_sec -= (days * H5_SEC_PER_DAY);
+
+        /* Extract hours */
+        hours = HDfloor(remainder_sec / H5_SEC_PER_HOUR);
+        remainder_sec -= (hours * H5_SEC_PER_HOUR);
+
+        /* Extract minutes */
+        minutes = HDfloor(remainder_sec / H5_SEC_PER_MIN);
+        remainder_sec -= (minutes * H5_SEC_PER_MIN);
+
+        /* The # of seconds left is in remainder_sec */
+    } /* end if */
+
+    /* Allocate */
+    if(NULL == (s = (char *)HDcalloc(H5TIMER_TIME_STRING_LEN, sizeof(char))))
+        return NULL;
+
+    /* Do we need a format string? Some people might like a certain
+     * number of milliseconds or s before spilling to the next highest
+     * time unit.  Perhaps this could be passed as an integer.
+     * (name? round_up_size? ?)
+     */
+    if(seconds < (double)0.0F)
+        HDsprintf(s, "N/A");
+    else if(H5_DBL_ABS_EQUAL((double)0.0F, seconds))
+        HDsprintf(s, "0.0 s");
+    else if(seconds < (double)1.0E-6F)
+        /* t < 1 us, Print time in ns */
+        HDsprintf(s, "%.f ns", seconds * (double)1.0E9F);
+    else if(seconds < (double)1.0E-3F)
+        /* t < 1 ms, Print time in us */
+        HDsprintf(s, "%.1f us", seconds * (double)1.0E6F);
+    else if(seconds < (double)1.0F)
+        /* t < 1 s, Print time in ms */
+        HDsprintf(s, "%.1f ms", seconds * (double)1.0E3F);
+    else if(seconds < H5_SEC_PER_MIN)
+        /* t < 1 m, Print time in s */
+        HDsprintf(s, "%.2f s", seconds);
+    else if(seconds < H5_SEC_PER_HOUR)
+        /* t < 1 h, Print time in m and s */
+        HDsprintf(s, "%.f m %.f s", minutes, remainder_sec);
+    else if(seconds < H5_SEC_PER_DAY)
+        /* t < 1 d, Print time in h, m and s */
+        HDsprintf(s, "%.f h %.f m %.f s", hours, minutes, remainder_sec);
+    else
+        /* Print time in d, h, m and s */
+        HDsprintf(s, "%.f d %.f h %.f m %.f s", days, hours, minutes, remainder_sec);
+
+    return s;
+} /* end H5_timer_get_time_string() */
+
diff --git a/src/H5trace.c b/src/H5trace.c
index 9fb8a7253b4..c21aa6f863a 100644
--- a/src/H5trace.c
+++ b/src/H5trace.c
@@ -125,8 +125,11 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
     hssize_t            i;
     void                *vp = NULL;
     FILE                *out = H5_debug_g.trace;
-    H5_timer_t          event_time;
-    static H5_timer_t   first_time = {0.0F, 0.0F, 0.0F};
+    static hbool_t      is_first_invocation = TRUE;
+    H5_timer_t          function_timer;
+    H5_timevals_t       function_times;
+    static H5_timer_t   running_timer;
+    H5_timevals_t       running_times;
     static int          current_depth = 0;
     static int          last_call_depth = 0;
 
@@ -152,13 +155,18 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
         } /* end else */
     } /* end if */
 
-    /* Get time for event */
-    if(H5_DBL_ABS_EQUAL(first_time.etime, H5_DOUBLE(0.0)))
-        H5_timer_begin(&first_time);
-    if(H5_debug_g.ttimes)
-        H5_timer_begin(&event_time);
-    else
-        HDmemset(&event_time, 0, sizeof event_time);
+    /* Get time for event if the trace times flag is set */
+    if(is_first_invocation && H5_debug_g.ttimes) {
+        /* start the library-wide timer */
+        is_first_invocation = FALSE;
+        H5_timer_init(&running_timer);
+        H5_timer_start(&running_timer);
+    } /* end if */
+    if(H5_debug_g.ttimes) {
+        /* start the timer for this function */
+        H5_timer_init(&function_timer);
+        H5_timer_start(&function_timer);
+    } /* end if */
 
     /* Print the first part of the line.  This is the indication of the
      * nesting depth followed by the function name and either start of
@@ -174,7 +182,9 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
             if(H5_debug_g.ttimes) {
                 char tmp[128];
 
-                sprintf(tmp, "%.6f", event_time.etime-first_time.etime);
+                H5_timer_get_times(function_timer, &function_times);
+                H5_timer_get_times(running_timer, &running_times);
+                sprintf(tmp, "%.6f", (function_times.elapsed - running_times.elapsed));
                 fprintf(out, " %*s ", (int)HDstrlen(tmp), "");
             } /* end if */
             for(i = 0; i < current_depth; i++)
@@ -189,8 +199,11 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
     else {
         if(current_depth>last_call_depth)
             HDfputs(" = <delayed>\n", out);
-        if(H5_debug_g.ttimes)
-            fprintf(out, "@%.6f ", event_time.etime - first_time.etime);
+        if(H5_debug_g.ttimes) {
+            H5_timer_get_times(function_timer, &function_times);
+            H5_timer_get_times(running_timer, &running_times);
+            fprintf(out, "@%.6f ", (function_times.elapsed - running_times.elapsed));
+        } /* end if */
         for(i = 0; i < current_depth; i++)
             HDfputc('+', out);
         fprintf(out, "%*s%s(", 2*current_depth, "", func);
@@ -2639,9 +2652,12 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
     } /* end for */
 
     /* Display event time for return */
-    if(returning && H5_debug_g.ttimes)
-        fprintf(out, " @%.6f [dt=%.6f]", (event_time.etime - first_time.etime),
-                (event_time.etime - *returning));
+    if(returning && H5_debug_g.ttimes) {
+        H5_timer_get_times(function_timer, &function_times);
+        H5_timer_get_times(running_timer, &running_times);
+        fprintf(out, " @%.6f [dt=%.6f]", (function_times.elapsed - running_times.elapsed),
+                (function_times.elapsed - *returning));
+    } /* end if */
 
 error:
     va_end(ap);
@@ -2653,6 +2669,9 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
     } /* end else */
     HDfflush(out);
 
-    return event_time.etime;
+    if(H5_debug_g.ttimes)
+        return function_times.elapsed;
+    else
+        return 0.0F;
 } /* end H5_trace() */
 
diff --git a/test/Makefile.am b/test/Makefile.am
index 53dbf0d486c..610c6199dd8 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -58,7 +58,8 @@ TEST_PROG= testhdf5 \
            twriteorder big mtime fillval mount flush1 flush2 app_ref enum \
            set_extent ttsafe enc_dec_plist enc_dec_plist_cross_platform\
            getname vfd ntypes dangle dtransform reserved cross_read \
-           freespace mf vds file_image unregister cache_logging cork swmr
+           freespace mf vds file_image unregister cache_logging cork swmr \
+           timer
 
 # List programs to be built when testing here.
 # error_test and err_compat are built at the same time as the other tests, but executed by testerror.sh.
diff --git a/test/timer.c b/test/timer.c
new file mode 100644
index 00000000000..3a82b82151c
--- /dev/null
+++ b/test/timer.c
@@ -0,0 +1,415 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the files COPYING and Copyright.html.  COPYING can be found at the root   *
+ * of the source code distribution tree; Copyright.html can be found at the  *
+ * root level of an installed copy of the electronic HDF5 document set and   *
+ * is linked from the top-level documents page.  It can also be found at     *
+ * http://hdfgroup.org/HDF5/doc/Copyright.html.  If you do not have          *
+ * access to either file, you may request a copy from help@hdfgroup.org.     *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:  Dana Robinson
+ *              May, 2011
+ *
+ * Purpose:     Tests the operation of the platform-independent timers.
+ */
+
+#include "h5test.h"
+
+
+
+
+/*-------------------------------------------------------------------------
+ * Function:    test_time_formatting
+ *
+ * Purpose:     Tests time string creation.
+ *
+ * Return:      Success:        0
+ *              Failure:        -1
+ *
+ * Programmer:  Dana Robinson
+ *              May 2011
+ *
+ *-------------------------------------------------------------------------
+ */
+static herr_t
+test_time_formatting(void)
+{
+    char *s = NULL;
+
+    TESTING("Time string formats");
+
+    /*      < 0,            N/A             */
+    s = H5_timer_get_time_string(-1.0F);
+    if(NULL == s || HDstrcmp(s, "N/A") != 0)
+        TEST_ERROR;
+    HDfree(s);
+
+    /*      0               0               */
+    s = H5_timer_get_time_string(0.0F);
+    if(NULL == s || HDstrcmp(s, "0.0 s") != 0)
+        TEST_ERROR;
+    HDfree(s);
+
+    /*      < 1 us          nanoseconds     */
+    s = H5_timer_get_time_string(123.0E-9F);
+    if(NULL == s || HDstrcmp(s, "123 ns") != 0)
+        TEST_ERROR;
+    HDfree(s);
+
+    /*      < 1 ms          microseconds    */
+    s = H5_timer_get_time_string(23.456E-6F);
+    if(NULL == s || HDstrcmp(s, "23.5 us") != 0)
+        TEST_ERROR;
+    HDfree(s);
+
+    /*      < 1 s           milliseconds    */
+    s = H5_timer_get_time_string(4.56789E-3);
+    if(NULL == s || HDstrcmp(s, "4.6 ms") != 0)
+        TEST_ERROR;
+    HDfree(s);
+
+    /*      < 1 min         seconds         */
+    s = H5_timer_get_time_string(3.14);
+    if(NULL == s || HDstrcmp(s, "3.14 s") != 0)
+        TEST_ERROR;
+    HDfree(s);
+
+    /*      < 1 hr          mins, secs      */
+    s = H5_timer_get_time_string(2521.0F);
+    if(NULL == s || HDstrcmp(s, "42 m 1 s") != 0)
+        TEST_ERROR;
+    HDfree(s);
+
+    /*      < 1 d           hrs, mins, secs */
+    s = H5_timer_get_time_string(9756.0F);
+    if(NULL == s || HDstrcmp(s, "2 h 42 m 36 s") != 0)
+        TEST_ERROR;
+    HDfree(s);
+
+    /*      > 1 d            days, hrs, mins, secs */
+    s = H5_timer_get_time_string(280802.0F);
+    if(NULL == s || HDstrcmp(s, "3 d 6 h 0 m 2 s") != 0)
+        TEST_ERROR;
+    HDfree(s);
+
+    PASSED();
+    return 0;
+
+error:
+    if(s)
+        HDfree(s);
+    return -1;
+
+}
+
+
+/*-------------------------------------------------------------------------
+ * Function:    test_timer_system_user
+ *
+ * Purpose:     Tests the ability to get system and user times from the
+ *              timers.
+ *              Some platforms may require special code to get system and
+ *              user times.  If we do not support that particular platform
+ *              dependent functionality, this test is skipped.
+ *
+ * Return:      Success:        0
+ *              Failure:        -1
+ *
+ * Programmer:  Dana Robinson
+ *              May 2011
+ *
+ *-------------------------------------------------------------------------
+ */
+static herr_t
+test_timer_system_user(void)
+{
+    int             i;
+    char            *buf = NULL;
+    H5_timer_t      timer;
+    H5_timevals_t   times;
+    herr_t          err;
+
+    TESTING("system/user times");
+
+    err = H5_timer_init(&timer);
+    if(err < 0)
+        TEST_ERROR;
+
+    err = H5_timer_start(&timer);
+    if(err < 0)
+        TEST_ERROR;
+
+    /* The system and user times may not be present on some systems.  They
+      * will be -1.0 if they are not.
+     */
+    if(timer.initial.system < 0.0 || timer.initial.user < 0.0) {
+        SKIPPED();
+        printf("NOTE: No suitable way to get system/user times on this platform.\n");
+        return 0;
+    }
+
+    /* Do some fake work */
+    for(i=0; i < 1024; i++) {
+        buf = (char *)HDmalloc(1024 * i * sizeof(char));
+        HDfree(buf);
+    }
+
+    err = H5_timer_stop(&timer);
+    if(err < 0)
+        TEST_ERROR;
+
+    err = H5_timer_get_times(timer, &times);
+    if(err < 0)
+        TEST_ERROR;
+
+    /* System and user times should be non-negative. */
+    if(times.system < 0.0 || times.user < 0.0)
+        TEST_ERROR;
+
+    PASSED();
+    return 0;
+
+error:
+    return -1;
+}
+
+
+/*-------------------------------------------------------------------------
+ * Function:    test_timer_elapsed
+ *
+ * Purpose:     Tests the ability to get elapsed times from the timers.
+ *              We should always be able to get an elapsed time,
+ *              regardless of the time libraries or platform.
+ *
+ * Return:      Success:        0
+ *              Failure:        -1
+ *
+ * Programmer:  Dana Robinson
+ *              May 2011
+ *
+ *-------------------------------------------------------------------------
+ */
+static herr_t
+test_timer_elapsed(void)
+{
+    int             i;
+    char            *buf = NULL;
+    H5_timer_t      timer;
+    H5_timevals_t   times;
+    herr_t          err;
+
+    TESTING("elapsed times");
+
+    err = H5_timer_init(&timer);
+    if(err < 0)
+        TEST_ERROR;
+
+    err = H5_timer_start(&timer);
+    if(err < 0)
+        TEST_ERROR;
+
+    /* Do some fake work */
+    for(i=0; i < 1024; i++) {
+        buf = (char *)HDmalloc(1024 * i * sizeof(char));
+        HDfree(buf);
+    }
+
+    err = H5_timer_stop(&timer);
+    if(err < 0)
+        TEST_ERROR;
+
+    err = H5_timer_get_times(timer, &times);
+    if(err < 0)
+        TEST_ERROR;
+
+    /* Elapsed time should be non-negative. */
+    if(times.elapsed < 0.0)
+        TEST_ERROR;
+
+    PASSED();
+    return 0;
+
+error:
+    return -1;
+}
+
+
+
+static herr_t
+test_timer_functionality(void)
+{
+    int             i;
+    char            *buf = NULL;
+    H5_timer_t      timer;
+    
+    H5_timevals_t   times;
+    double          prev_etime;
+    double          prev_total_etime;
+
+    herr_t          err;
+
+    TESTING("timer functionality");
+
+    /*****************
+     * CHECK STARTUP *
+     *****************/
+
+    /* Timer should be running after start */
+    err = H5_timer_init(&timer);
+    if(err < 0 || timer.is_running)
+        TEST_ERROR;
+
+    /* Times should be initialized to zero */
+    err = H5_timer_get_times(timer, &times);
+    if(err < 0 || !H5_DBL_ABS_EQUAL(times.elapsed, 0.0))
+        TEST_ERROR;
+
+    err = H5_timer_get_total_times(timer, &times);
+    if(err < 0 || !H5_DBL_ABS_EQUAL(times.elapsed, 0.0))
+        TEST_ERROR;
+
+
+    /********************
+     * CHECK START/STOP *
+     ********************/
+
+    /* Running state should change after start */
+    err = H5_timer_start(&timer);
+    if(err < 0 || !timer.is_running)
+        TEST_ERROR;
+
+    /* Do some fake work */
+    for(i=0; i < 1024; i++) {
+        buf = (char *)HDmalloc(1024 * i * sizeof(char));
+        HDfree(buf);
+    }
+
+    /* Running state should change after stop */
+    err = H5_timer_stop(&timer);
+    if(err < 0 || timer.is_running)
+        TEST_ERROR;
+
+    /* Times should be positive and non-negative */
+    err = H5_timer_get_times(timer, &times);
+    if(err < 0 || times.elapsed < 0.0)
+        TEST_ERROR;
+
+    err = H5_timer_get_total_times(timer, &times);
+    if(err < 0 || times.elapsed < 0.0)
+        TEST_ERROR;
+
+
+    /**********************
+     * CHECK INTERRUPTING *
+     **********************/
+
+    /* Timer should change stat and refresh to 0s */
+    err = H5_timer_init(&timer);
+    if(err < 0 || timer.is_running)
+        TEST_ERROR;
+
+    err = H5_timer_get_times(timer, &times);
+    if(err < 0 || !H5_DBL_ABS_EQUAL(times.elapsed, 0.0))
+        TEST_ERROR;
+
+    err = H5_timer_get_total_times(timer, &times);
+    if(err < 0 || !H5_DBL_ABS_EQUAL(times.elapsed, 0.0))
+        TEST_ERROR;
+
+    /* Timer state should flip */
+    err = H5_timer_start(&timer);
+    if(err < 0 || !timer.is_running)
+        TEST_ERROR;
+
+    /* Do some fake work */
+    for(i=0; i < 1024; i++) {
+        buf = (char *)HDmalloc(1024 * i * sizeof(char));
+        HDfree(buf);
+    }
+
+    /* Times should be non-negative */
+    err = H5_timer_get_times(timer, &times);
+    if(err < 0 || times.elapsed < 0.0)
+        TEST_ERROR;
+    prev_etime = times.elapsed;
+
+    err = H5_timer_get_total_times(timer, &times);
+    if(err < 0 || times.elapsed < 0.0)
+        TEST_ERROR;
+    prev_total_etime = times.elapsed;
+    
+    /* Do some fake work */
+    for(i=0; i < 1024; i++) {
+        buf = (char *)HDmalloc(1024 * i * sizeof(char));
+        HDfree(buf);
+    }
+
+    /* State should flip on stop */
+    err = H5_timer_stop(&timer);
+    if(err < 0 || timer.is_running)
+        TEST_ERROR;
+
+    /* Times should be >= than the cached intermediate times */
+    err = H5_timer_get_times(timer, &times);
+    if(err < 0 || times.elapsed < prev_etime)
+        TEST_ERROR;
+
+    err = H5_timer_get_total_times(timer, &times);
+    if(err < 0 || times.elapsed < prev_total_etime)
+        TEST_ERROR;
+
+
+    PASSED();
+    return 0;
+
+error:
+    return -1;
+}
+
+
+/*-------------------------------------------------------------------------
+ * Function:    main
+ *
+ * Purpose:     Tests the basic functionality of the platform-independent
+ *              timers
+ *
+ * Return:      Success:        0
+ *              Failure:        1
+ *
+ * Programmer:  Dana Robinson
+ *              May, 2011
+ *
+ *-------------------------------------------------------------------------
+ */
+int
+main(void)
+{
+    int             nerrors = 0;
+
+    h5_reset();
+
+    printf("Testing platform-independent timer functionality.\n");
+
+    nerrors += test_time_formatting()       < 0 ? 1 : 0;
+    nerrors += test_timer_system_user()     < 0 ? 1 : 0;
+    nerrors += test_timer_elapsed()         < 0 ? 1 : 0;
+    nerrors += test_timer_functionality()   < 0 ? 1 : 0;
+    
+
+    if(nerrors) {
+        printf("***** %d platform-independent timer TEST%s FAILED! *****\n",
+        nerrors, nerrors > 1 ? "S" : "");
+        return 1;
+    } else {
+        printf("All platform-independent timer tests passed.\n");
+        return 0;
+    }
+}
+

From e70dc43d6bfea81a565e3b420795bd351112458e Mon Sep 17 00:00:00 2001
From: Quincey Koziol <koziol@hdfgroup.org>
Date: Sat, 23 Sep 2017 21:47:07 -0500
Subject: [PATCH 02/55] Update H5_now_usec to prefer using clock_gettime.

---
 src/H5timer.c | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/src/H5timer.c b/src/H5timer.c
index 2cb8cea2073..4a1f3f0c4d9 100644
--- a/src/H5timer.c
+++ b/src/H5timer.c
@@ -193,7 +193,14 @@ H5_now_usec(void)
 {
     uint64_t	now;                    /* Current time, in microseconds */
 
-#ifdef H5_HAVE_GETTIMEOFDAY
+#if defined(H5_HAVE_CLOCK_GETTIME)
+    {
+        struct timespec ts;
+
+        HDclock_gettime(CLOCK_MONOTONIC, &ts);
+        now = (uint64_t)(ts.tv_sec * (1000 * 1000)) + (uint64_t)(ts.tv_nsec * 1000);
+    }
+#elif defined(H5_HAVE_GETTIMEOFDAY)
     {
         struct timeval now_tv;
 

From 395473b2f4b5f03733aab9a785ac23c59ea84d0b Mon Sep 17 00:00:00 2001
From: Quincey Koziol <koziol@hdfgroup.org>
Date: Sat, 23 Sep 2017 21:47:36 -0500
Subject: [PATCH 03/55] Remove detection for mach/mach/time.h, since we're no
 longer using the time routines from that header.

---
 config/cmake/H5pubconf.h.in                | 3 ---
 config/cmake_ext_mod/ConfigureChecks.cmake | 3 ---
 configure.ac                               | 2 --
 3 files changed, 8 deletions(-)

diff --git a/config/cmake/H5pubconf.h.in b/config/cmake/H5pubconf.h.in
index 8c01dba6b91..b427254f079 100644
--- a/config/cmake/H5pubconf.h.in
+++ b/config/cmake/H5pubconf.h.in
@@ -258,9 +258,6 @@
 /* Define to 1 if you have the `lstat' function. */
 #cmakedefine H5_HAVE_LSTAT @H5_HAVE_LSTAT@
 
-/* Define to 1 if you have the <mach/mach_time.h> header file. */
-#cmakedefine H5_HAVE_MACH_MACH_TIME_H @H5_HAVE_MACH_MACH_TIME_H@
-
 /* Define to 1 if you have the <memory.h> header file. */
 #cmakedefine H5_HAVE_MEMORY_H @H5_HAVE_MEMORY_H@
 
diff --git a/config/cmake_ext_mod/ConfigureChecks.cmake b/config/cmake_ext_mod/ConfigureChecks.cmake
index 56d45f97f2d..88cd77be095 100644
--- a/config/cmake_ext_mod/ConfigureChecks.cmake
+++ b/config/cmake_ext_mod/ConfigureChecks.cmake
@@ -234,9 +234,6 @@ if (${HDF_PREFIX}_HAVE_STDINT_H AND CMAKE_CXX_COMPILER_LOADED)
   endif ()
 endif ()
 
-# Darwin
-CHECK_INCLUDE_FILE_CONCAT ("mach/mach_time.h" ${HDF_PREFIX}_HAVE_MACH_MACH_TIME_H)
-
 # Windows
 CHECK_INCLUDE_FILE_CONCAT ("io.h"            ${HDF_PREFIX}_HAVE_IO_H)
 if (NOT CYGWIN)
diff --git a/configure.ac b/configure.ac
index 91800e7b5f0..ea4e4bd20f2 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1050,8 +1050,6 @@ AC_CHECK_HEADERS([stdint.h], [C9x=yes])
 AC_CHECK_HEADERS([stdbool.h])
 
 ## Darwin
-AC_CHECK_HEADERS([mach/mach_time.h])
-## Also need to detect Darwin for pubconf
 case $host_os in
   darwin*)
     AC_DEFINE([HAVE_DARWIN], [1], [Define if Darwin or Mac OS X])

From 949649a2b6e00297cbdc49437e70a27e455e92d2 Mon Sep 17 00:00:00 2001
From: Quincey Koziol <koziol@hdfgroup.org>
Date: Sun, 24 Sep 2017 14:08:40 -0500
Subject: [PATCH 04/55] Correct mistake in H5_now_usec calculation for
 clock_gettime.

---
 src/H5timer.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/H5timer.c b/src/H5timer.c
index 4a1f3f0c4d9..8603b1c7947 100644
--- a/src/H5timer.c
+++ b/src/H5timer.c
@@ -198,7 +198,7 @@ H5_now_usec(void)
         struct timespec ts;
 
         HDclock_gettime(CLOCK_MONOTONIC, &ts);
-        now = (uint64_t)(ts.tv_sec * (1000 * 1000)) + (uint64_t)(ts.tv_nsec * 1000);
+        now = (uint64_t)(ts.tv_sec * (1000 * 1000)) + (uint64_t)(ts.tv_nsec / 1000);
     }
 #elif defined(H5_HAVE_GETTIMEOFDAY)
     {

From 7a4d7da14a745333c4e8f3955a0afd9db70969c0 Mon Sep 17 00:00:00 2001
From: Binh-Minh Ribler <bmribler@hdfgroup.org>
Date: Tue, 26 May 2020 15:39:39 -0500
Subject: [PATCH 05/55] Fix HDFFV-11053

Description:
    A superblock pointer was set to a temporary structure, as a kluge,
    and meant to be reset back to NULL after the processing was completed.
    However, in the case of failure before the completion, this setting
    caused the superblock pointer to be unpinned twice in the error
    recovery process.  As a result, that generated a segfault in h5clear.
    The fix resets the superblock pointer to NULL after H5F__super_ext_remove_msg
    fails so that h5clear can fail properly.

    Note: After the fix, when built in debug mode, there will be an
    assertion failure with the user's file, which appeared to be corrupted:
H5MM_final_sanity_check: Assertion `0 == H5MM_curr_alloc_bytes_s' failed.

    This did not happen on a good file or on the corrupted file with the
    library built in production mode.  The un-freed memory were allocated
    during error recovery.
Platforms tested:
    Linux/64 (jelly)
---
 src/H5Fsuper.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/H5Fsuper.c b/src/H5Fsuper.c
index e5d4cde43df..40e93ec610d 100644
--- a/src/H5Fsuper.c
+++ b/src/H5Fsuper.c
@@ -897,7 +897,11 @@ H5F__super_read(H5F_t *f, H5P_genplist_t *fa_plist, hbool_t initial_read)
                     }
                     else {
                         if(H5F__super_ext_remove_msg(f, H5O_FSINFO_ID) < 0)
+                        {
+                            f->shared->sblock = NULL;
+
                             HGOTO_ERROR(H5E_FILE, H5E_CANTDELETE, FAIL,  "error in removing message from superblock extension")
+                        }
 
                         if(H5F__super_ext_write_msg(f, H5O_FSINFO_ID, &fsinfo, TRUE, H5O_MSG_FLAG_MARK_IF_UNKNOWN) < 0)
                             HGOTO_ERROR(H5E_FILE, H5E_WRITEERROR, FAIL, "error in writing fsinfo message to superblock extension")

From c12da4884f18dda4c9dbc23efd10eb053ec7cf0d Mon Sep 17 00:00:00 2001
From: Binh-Minh Ribler <bmribler@hdfgroup.org>
Date: Fri, 19 Jun 2020 10:53:32 -0500
Subject: [PATCH 06/55] Fix HDFFV-10591

Description:
    h52gif produced a segfault when a buffer overflow occurred because
    the data size was corrupted and became very large.  This commit added
    a check on the data size against the buffer size to prevent the segfault.
    It also added error reporting to h52gif to display an error message
    instead of silently exiting when the failure occurred.
Platforms tested:
    Linux/64 (jelly)
    SunOS 5.11 (emu)
---
 hl/src/H5IM.c             |  3 ++-
 hl/tools/gif2h5/hdf2gif.c | 33 ++++++++++++++++++++++-----------
 src/H5Oattr.c             |  5 +++++
 3 files changed, 29 insertions(+), 12 deletions(-)

diff --git a/hl/src/H5IM.c b/hl/src/H5IM.c
index 2a7ed9b66dc..6f7414bb39d 100644
--- a/hl/src/H5IM.c
+++ b/hl/src/H5IM.c
@@ -274,7 +274,8 @@ herr_t H5IMget_image_info( hid_t loc_id,
         return -1;
 
     /* Try to find the attribute "INTERLACE_MODE" on the >>image<< dataset */
-    has_attr = H5LT_find_attribute(did, "INTERLACE_MODE");
+    if ((has_attr = H5LT_find_attribute(did, "INTERLACE_MODE")) < 0)
+        goto out;
 
     /* It exists, get it */
     if(has_attr == 1)
diff --git a/hl/tools/gif2h5/hdf2gif.c b/hl/tools/gif2h5/hdf2gif.c
index e32facbb51b..0e2a8984087 100644
--- a/hl/tools/gif2h5/hdf2gif.c
+++ b/hl/tools/gif2h5/hdf2gif.c
@@ -149,30 +149,41 @@ int main(int argc , char **argv)
             goto out;
         }
 
-        /* read image */
+        /* get image's information */
         if ( H5IMget_image_info( fid, image_name, &width, &height, &planes, interlace, &npals ) < 0 )
+        {
+            fprintf(stderr , "Unable to get information of the image. Aborting.\n");
             goto out;
+        }
 
-	if (width > IMAGE_WIDTH_MAX || height > IMAGE_HEIGHT_MAX){
-	    fprintf(stderr, "HDF5 image is too large. Limit is %d by %d.\n", IMAGE_WIDTH_MAX, IMAGE_HEIGHT_MAX);
-	    goto out;
-	}
+    	if (width > IMAGE_WIDTH_MAX || height > IMAGE_HEIGHT_MAX)
+        {
+	        fprintf(stderr, "HDF5 image is too large. Limit is %d by %d.\n", IMAGE_WIDTH_MAX, IMAGE_HEIGHT_MAX);
+	        goto out;
+	    }
 
-	/* tool can handle single plane images only. */
-	if (planes > 1){
-	    fprintf(stderr, "Cannot handle multiple planes image\n");
-	    goto out;
-	}
+	    /* tool can handle single plane images only. */
+	    if (planes > 1)
+        {
+	        fprintf(stderr, "Cannot handle multiple planes image\n");
+	        goto out;
+	    }
 
         Image = (GIFBYTE*) malloc( (size_t) width * (size_t) height );
 
         if ( H5IMread_image( fid, image_name, Image ) < 0 )
+        {
+            fprintf(stderr , "Unable to read the image. Aborting.\n");
             goto out;
+        }
 
         if (npals)
         {
             if ( H5IMget_palette_info( fid, image_name, 0, pal_dims ) < 0 )
+            {
+                fprintf(stderr , "Unable to get information of the palette. Aborting.\n");
                 goto out;
+            }
 
             pal = (GIFBYTE*) malloc( (size_t) pal_dims[0] * (size_t) pal_dims[1] );
 
@@ -246,7 +257,7 @@ int main(int argc , char **argv)
             if (j==i)
             {
                 /* wasn't found */
-	      pc2nc[i] = (GIFBYTE)nc;
+	            pc2nc[i] = (GIFBYTE)nc;
                 r1[nc] = Red[i];
                 g1[nc] = Green[i];
                 b1[nc] = Blue[i];
diff --git a/src/H5Oattr.c b/src/H5Oattr.c
index aeaebea672a..e38ef5cc6c1 100644
--- a/src/H5Oattr.c
+++ b/src/H5Oattr.c
@@ -238,6 +238,11 @@ H5O_attr_decode(H5F_t *f, H5O_t *open_oh, unsigned H5_ATTR_UNUSED mesg_flags,
 
     /* Go get the data */
     if(attr->shared->data_size) {
+        /* Ensure that data size doesn't exceed buffer size, in case of
+           it's being corrupted in the file */
+        if(attr->shared->data_size > p_size)
+            HGOTO_ERROR(H5E_RESOURCE, H5E_OVERFLOW, NULL, "data size exceeds buffer size")
+
         if(NULL == (attr->shared->data = H5FL_BLK_MALLOC(attr_buf, attr->shared->data_size)))
             HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, NULL, "memory allocation failed")
         H5MM_memcpy(attr->shared->data, p, attr->shared->data_size);

From 7d58d115079d286a566207c529e59bbccc952b03 Mon Sep 17 00:00:00 2001
From: Binh-Minh Ribler <bmribler@hdfgroup.org>
Date: Fri, 19 Jun 2020 16:08:37 -0500
Subject: [PATCH 07/55] Added note for HDFFV-10591.

---
 release_docs/RELEASE.txt | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/release_docs/RELEASE.txt b/release_docs/RELEASE.txt
index 102402eb1d2..72cab28362c 100644
--- a/release_docs/RELEASE.txt
+++ b/release_docs/RELEASE.txt
@@ -631,6 +631,18 @@ Bug Fixes since HDF5-1.10.3 release
 
     Library
     -------
+    - Fixed the decoding of an attribute message to prevent a segfault by h52gif
+
+      The tool h52gif produced a segfault when the size of an attribute
+      message was corrupted and caused a buffer overflow.
+
+      The problem was fixed by verifying the attribute message's size
+      against the buffer size before accessing the buffer.  h52gif was
+      also fixed to display the failure instead of silently exiting
+      after the segfault was eliminated.
+
+      (BMR - 2020/6/19, HDFFV-10591)
+
     - Improved peformance when creating a large number of small datasets by
       retrieving default property values from the API context instead of doing
       skip list searches.

From e1215177b6b87887233a90992a0264f11d78b88c Mon Sep 17 00:00:00 2001
From: Jacob Smith <jake.smith@hdfgroup.org>
Date: Thu, 25 Jun 2020 12:24:05 -0500
Subject: [PATCH 08/55] * Fix intermittent error with Splitter VFD.    
 Mismatch in time of test file creation was creating false negatives.

    Add file-duplication routine: `h5_duplicate_file_by_bytes()`.

* Change library calls in `h5test.c:h5_compare_file_bytes()` to their HD-prefixed equivalents.
---
 test/h5test.c | 107 ++++++++++++++++++++++++++++++++++++++++----------
 test/h5test.h |   1 +
 test/vfd.c    |  80 +++++++++++++++++++++----------------
 3 files changed, 134 insertions(+), 54 deletions(-)

diff --git a/test/h5test.c b/test/h5test.c
index 9cca100e449..1b445dd8d56 100644
--- a/test/h5test.c
+++ b/test/h5test.c
@@ -2057,23 +2057,23 @@ h5_get_version_string(H5F_libver_t libver)
 int
 h5_compare_file_bytes(char *f1name, char *f2name)
 {
-    FILE    *f1ptr = NULL;  /* two file pointers */
-    FILE    *f2ptr = NULL;
-    hsize_t  f1size = 0; /* size of the files */
-    hsize_t  f2size = 0;
-    char     f1char = 0; /* one char from each file */
-    char     f2char = 0;
-    hsize_t  ii = 0;
-    int      ret_value = 0; /* for error handling */
+    FILE       *f1ptr = NULL;  /* two file pointers */
+    FILE       *f2ptr = NULL;
+    off_t       f1size = 0;    /* size of the files */
+    off_t       f2size = 0;
+    char        f1char = 0;    /* one char from each file */
+    char        f2char = 0;
+    off_t       ii = 0;
+    int         ret_value = 0; /* for error handling */
 
     /* Open files for reading */
-    f1ptr = fopen(f1name, "r");
+    f1ptr = HDfopen(f1name, "r");
     if (f1ptr == NULL) {
         HDfprintf(stderr, "Unable to fopen() %s\n", f1name);
         ret_value = -1;
         goto done;
     }
-    f2ptr = fopen(f2name, "r");
+    f2ptr = HDfopen(f2name, "r");
     if (f2ptr == NULL) {
         HDfprintf(stderr, "Unable to fopen() %s\n", f2name);
         ret_value = -1;
@@ -2081,11 +2081,11 @@ h5_compare_file_bytes(char *f1name, char *f2name)
     }
 
     /* Get the file sizes and verify that they equal */
-    fseek(f1ptr , 0 , SEEK_END);
-    f1size = ftell(f1ptr);
+    HDfseek(f1ptr , 0 , SEEK_END);
+    f1size = HDftell(f1ptr);
 
-    fseek(f2ptr , 0 , SEEK_END);
-    f2size = ftell(f2ptr);
+    HDfseek(f2ptr , 0 , SEEK_END);
+    f2size = HDftell(f2ptr);
 
     if (f1size != f2size) {
         HDfprintf(stderr, "Files differ in size, %llu vs. %llu\n", f1size, f2size);
@@ -2094,11 +2094,11 @@ h5_compare_file_bytes(char *f1name, char *f2name)
     }
 
     /* Compare each byte and fail if a difference is found */
-    rewind(f1ptr);
-    rewind(f2ptr);
+    HDrewind(f1ptr);
+    HDrewind(f2ptr);
     for (ii = 0; ii < f1size; ii++) {
-        fread(&f1char, 1, 1, f1ptr);
-        fread(&f2char, 1, 1, f2ptr);
+        HDfread(&f1char, 1, 1, f1ptr);
+        HDfread(&f2char, 1, 1, f2ptr);
         if (f1char != f2char) {
             HDfprintf(stderr, "Mismatch @ 0x%llX: 0x%X != 0x%X\n", ii, f1char, f2char);
             ret_value = -1;
@@ -2108,10 +2108,10 @@ h5_compare_file_bytes(char *f1name, char *f2name)
 
 done:
     if (f1ptr) {
-        fclose(f1ptr);
+        HDfclose(f1ptr);
     }
     if (f2ptr) {
-        fclose(f2ptr);
+        HDfclose(f2ptr);
     }
     return(ret_value);
 } /* end h5_compare_file_bytes() */
@@ -2169,3 +2169,70 @@ const char *H5_get_srcdir(void)
         return(NULL);
 } /* end H5_get_srcdir() */
 
+/*-------------------------------------------------------------------------
+ * Function:    h5_duplicate_file_by_bytes
+ *
+ * Purpose:     Duplicate a file byte-for-byte at filename/path 'orig'
+ *              to a new (or replaced) file at 'dest'.
+ *
+ * Return:      Success:  0, completed successfully
+ *              Failure: -1
+ *
+ * Programmer:  Jake Smith
+ *              24 June 2020
+ *
+ *-------------------------------------------------------------------------
+ */
+int
+h5_duplicate_file_by_bytes(const char *orig, const char *dest)
+{
+    FILE *orig_ptr = NULL;
+    FILE *dest_ptr = NULL;
+    hsize_t fsize = 0;
+    hsize_t read_size = 0;
+    hsize_t max_buf = 0;
+    void *dup_buf = NULL;
+    int ret_value = 0;
+
+    max_buf = 4096 * sizeof(char);
+
+    orig_ptr = HDfopen(orig, "r");
+    if (NULL == orig_ptr) {
+        ret_value = -1;
+        goto done;
+    }
+
+    HDfseek(orig_ptr , 0 , SEEK_END);
+    fsize = (hsize_t)HDftell(orig_ptr);
+    HDrewind(orig_ptr);
+
+    dest_ptr = HDfopen(dest, "w");
+    if (NULL == dest_ptr) {
+        ret_value = -1;
+        goto done;
+    }
+
+    read_size = MIN(fsize, max_buf);
+    dup_buf = HDmalloc(read_size);
+    if (NULL == dup_buf) {
+        ret_value = -1;
+        goto done;
+    }
+
+    while (read_size > 0) {
+        HDfread(dup_buf, read_size, 1, orig_ptr); /* warning: no error-check */
+        HDfwrite(dup_buf, read_size, 1, dest_ptr);
+        fsize -= read_size;
+        read_size = MIN(fsize, max_buf);
+    }
+
+done:
+    if (orig_ptr != NULL)
+        HDfclose(orig_ptr);
+    if (dest_ptr != NULL)
+        HDfclose(dest_ptr);
+    if (dup_buf != NULL)
+        HDfree(dup_buf);
+    return ret_value;
+} /* end h5_duplicate_file_by_bytes() */
+
diff --git a/test/h5test.h b/test/h5test.h
index b1ddc58120c..3eeb1f8774f 100644
--- a/test/h5test.h
+++ b/test/h5test.h
@@ -210,6 +210,7 @@ H5TEST_DLL H5FD_class_t *h5_get_dummy_vfd_class(void);
 H5TEST_DLL H5VL_class_t *h5_get_dummy_vol_class(void);
 H5TEST_DLL const char *h5_get_version_string(H5F_libver_t libver);
 H5TEST_DLL int h5_compare_file_bytes(char *fname1, char *fname2);
+H5TEST_DLL int h5_duplicate_file_by_bytes(const char *orig, const char *dest);
 
 /* Functions that will replace components of a FAPL */
 H5TEST_DLL herr_t h5_get_vfd_fapl(hid_t fapl_id);
diff --git a/test/vfd.c b/test/vfd.c
index d94aec6b6ef..038c9670690 100644
--- a/test/vfd.c
+++ b/test/vfd.c
@@ -2880,6 +2880,7 @@ splitter_compare_expected_data(hid_t file_id,
 static int
 splitter_tentative_open_test(hid_t child_fapl_id)
 {
+    const char  filename_tmp[H5FD_SPLITTER_PATH_MAX + 1] = "splitter_tmp.h5";
     char        filename_rw[H5FD_SPLITTER_PATH_MAX + 1];
     H5FD_splitter_vfd_config_t  vfd_config;
     hid_t       fapl_id = H5I_INVALID_HID;
@@ -2926,7 +2927,16 @@ splitter_tentative_open_test(hid_t child_fapl_id)
         SPLITTER_TEST_FAULT("set FAPL not SPLITTER\n");
     }
 
-    /* H5Fopen() with RDWR access.
+    /* Create instance of file on disk.
+     * Will be copied verbatim as needed, to avoid issues where differences in
+     * the creation time would befoul comparisons.
+     */
+    if (splitter_create_single_file_at(filename_tmp, child_fapl_id, &data) < 0) {
+        SPLITTER_TEST_FAULT("can't write W/O file\n");
+    }
+
+    /*
+     * H5Fopen() with RDWR access.
      * Neither file exist already
      * Should fail.
      */
@@ -2944,13 +2954,14 @@ splitter_tentative_open_test(hid_t child_fapl_id)
         SPLITTER_TEST_FAULT("W/O file unexpectedly created\n");
     }
 
-    /* H5Fopen() with RDWR access.
-     * W/O file exists already.
+    /*
+     * H5Fopen() with RDWR access.
+     * Only W/O file present.
      * Should fail.
      */
 
-    if (splitter_create_single_file_at(vfd_config.wo_path, child_fapl_id, &data) < 0) {
-        SPLITTER_TEST_FAULT("can't write W/O file\n");
+    if (h5_duplicate_file_by_bytes(filename_tmp, vfd_config.wo_path) < 0) {
+        SPLITTER_TEST_FAULT("Can't create W/O file copy.\n");
     }
     H5E_BEGIN_TRY {
         file_id = H5Fopen(filename_rw, H5F_ACC_RDWR, fapl_id);
@@ -2969,13 +2980,14 @@ splitter_tentative_open_test(hid_t child_fapl_id)
         SPLITTER_TEST_FAULT("failed to remove W/O file\n");
     }
 
-    /* H5Fopen() with RDWR access.
-     * R/W file exists already.
+    /*
+     * H5Fopen() with RDWR access.
+     * Only R/W file present.
      * Should fail.
      */
 
-    if (splitter_create_single_file_at(filename_rw, child_fapl_id, &data) < 0) {
-        SPLITTER_TEST_FAULT("can't write R/W file\n");
+    if (h5_duplicate_file_by_bytes(filename_tmp, filename_rw) < 0) {
+        SPLITTER_TEST_FAULT("Can't create R/W file copy.\n");
     }
     H5E_BEGIN_TRY {
         file_id = H5Fopen(filename_rw, H5F_ACC_RDWR, fapl_id);
@@ -2990,12 +3002,13 @@ splitter_tentative_open_test(hid_t child_fapl_id)
         SPLITTER_TEST_FAULT("W/O file unexpectedly created\n");
     }
 
-    /* H5Fopen() with RDWR access.
-     * Both files already exist.
+    /*
+     * H5Fopen() with RDWR access.
+     * Both files present.
      */
 
-    if (splitter_create_single_file_at(vfd_config.wo_path, child_fapl_id, &data) < 0) {
-        SPLITTER_TEST_FAULT("can't write W/O file\n");
+    if (h5_duplicate_file_by_bytes(filename_tmp, vfd_config.wo_path) < 0) {
+        SPLITTER_TEST_FAULT("Can't create W/O file copy.\n");
     }
     file_id = H5Fopen(filename_rw, H5F_ACC_RDWR, fapl_id);
     if (file_id == H5I_INVALID_HID) {
@@ -3011,12 +3024,10 @@ splitter_tentative_open_test(hid_t child_fapl_id)
     if (!file_exists(vfd_config.wo_path, child_fapl_id)) {
         SPLITTER_TEST_FAULT("W/O file mysteriously disappeared\n");
     }
-    if (h5_compare_file_bytes(filename_rw, vfd_config.wo_path) < 0) {
-        SPLITTER_TEST_FAULT("files are not byte-for-byte equivalent\n");
-    }
 
-    /* H5Fcreate() with TRUNC access.
-     * Both files already exist.
+    /*
+     * H5Fcreate() with TRUNC access.
+     * Both files present.
      */
 
     file_id = H5Fcreate(filename_rw, H5F_ACC_TRUNC, H5P_DEFAULT, fapl_id);
@@ -3036,17 +3047,17 @@ splitter_tentative_open_test(hid_t child_fapl_id)
     if (h5_compare_file_bytes(filename_rw, vfd_config.wo_path) < 0) {
         SPLITTER_TEST_FAULT("files are not byte-for-byte equivalent\n");
     }
+    HDremove(filename_rw);
+    HDremove(vfd_config.wo_path);
 
-    /* H5Fcreate() with TRUNC access.
+    /*
+     * H5Fcreate() with TRUNC access.
      * R/W already exists.
      */
 
-    HDremove(filename_rw);
-    HDremove(vfd_config.wo_path);
-    if (splitter_create_single_file_at(filename_rw, child_fapl_id, &data) < 0) {
-        SPLITTER_TEST_FAULT("can't write R/W file\n");
+    if (h5_duplicate_file_by_bytes(filename_tmp, filename_rw) < 0) {
+        SPLITTER_TEST_FAULT("Can't create R/W file copy.\n");
     }
-
     if (file_exists(vfd_config.wo_path, child_fapl_id)) {
         SPLITTER_TEST_FAULT("failed to remove W/O file\n");
     }
@@ -3067,17 +3078,17 @@ splitter_tentative_open_test(hid_t child_fapl_id)
     if (h5_compare_file_bytes(filename_rw, vfd_config.wo_path) < 0) {
         SPLITTER_TEST_FAULT("files are not byte-for-byte equivalent\n");
     }
+    HDremove(filename_rw);
+    HDremove(vfd_config.wo_path);
 
-    /* H5Fcreate() with TRUNC access.
-     * W/O already exists.
+    /*
+     * H5Fcreate() with TRUNC access.
+     * Only W/O present.
      */
 
-    HDremove(filename_rw);
-    HDremove(vfd_config.wo_path);
-    if (splitter_create_single_file_at(vfd_config.wo_path, child_fapl_id, &data) < 0) {
-        SPLITTER_TEST_FAULT("can't write R/W file\n");
+    if (h5_duplicate_file_by_bytes(filename_tmp, vfd_config.wo_path) < 0) {
+        SPLITTER_TEST_FAULT("Can't create W/O file copy.\n");
     }
-
     if (file_exists(filename_rw, child_fapl_id)) {
         SPLITTER_TEST_FAULT("failed to remove R/W file\n");
     }
@@ -3098,10 +3109,13 @@ splitter_tentative_open_test(hid_t child_fapl_id)
     if (h5_compare_file_bytes(filename_rw, vfd_config.wo_path) < 0) {
         SPLITTER_TEST_FAULT("files are not byte-for-byte equivalent\n");
     }
+    HDremove(filename_rw);
+    HDremove(vfd_config.wo_path);
 
     /* H5Fcreate with both files absent is tested elsewhere */
 
-    /* Cleanup
+    /*
+     * Cleanup
      */
 
     if (H5Pclose(fapl_id) < 0) {
@@ -3225,7 +3239,6 @@ test_splitter(void)
         TEST_ERROR;
     }
 
-
     /* Test file creation, utilizing different child FAPLs (default vs.
      * specified), logfile, and Write Channel error ignoring behavior.
      */
@@ -3251,7 +3264,6 @@ test_splitter(void)
 /* TODO: SWMR open? */
 /* Concurrent opens with both drivers using the Splitter */
 
-
     if (H5Pclose(child_fapl_id) == FAIL) {
         TEST_ERROR;
     }

From 7bdab523b3eb8eb5a83c3a6eca622171b88856ab Mon Sep 17 00:00:00 2001
From: Quincey Koziol <koziol@koziol.gov>
Date: Sat, 27 Jun 2020 09:47:55 -0500
Subject: [PATCH 09/55] Refactor code to remove remaining checks for
 H5_HAVE_GETTIMEOFDAY scattered around in various places.  Also clean up
 iopipe.c.

---
 config/cmake/H5pubconf.h.in                |   3 -
 config/cmake_ext_mod/ConfigureChecks.cmake |   1 -
 src/H5system.c                             |  32 --
 src/H5timer.c                              |  41 +++
 tools/test/perform/chunk_cache.c           |  38 +-
 tools/test/perform/iopipe.c                | 403 +++++++--------------
 6 files changed, 190 insertions(+), 328 deletions(-)

diff --git a/config/cmake/H5pubconf.h.in b/config/cmake/H5pubconf.h.in
index 6edf6b46ed1..eea12cdabe2 100644
--- a/config/cmake/H5pubconf.h.in
+++ b/config/cmake/H5pubconf.h.in
@@ -424,9 +424,6 @@
 /* Define to 1 if you have the <sys/stat.h> header file. */
 #cmakedefine H5_HAVE_SYS_STAT_H @H5_HAVE_SYS_STAT_H@
 
-/* Define to 1 if you have the <sys/timeb.h> header file. */
-#cmakedefine H5_HAVE_SYS_TIMEB_H @H5_HAVE_SYS_TIMEB_H@
-
 /* Define to 1 if you have the <sys/time.h> header file. */
 #cmakedefine H5_HAVE_SYS_TIME_H @H5_HAVE_SYS_TIME_H@
 
diff --git a/config/cmake_ext_mod/ConfigureChecks.cmake b/config/cmake_ext_mod/ConfigureChecks.cmake
index 0875aad7924..82527360ce3 100644
--- a/config/cmake_ext_mod/ConfigureChecks.cmake
+++ b/config/cmake_ext_mod/ConfigureChecks.cmake
@@ -145,7 +145,6 @@ CHECK_INCLUDE_FILE_CONCAT ("io.h"            ${HDF_PREFIX}_HAVE_IO_H)
 if (NOT CYGWIN)
   CHECK_INCLUDE_FILE_CONCAT ("winsock2.h"      ${HDF_PREFIX}_HAVE_WINSOCK2_H)
 endif ()
-CHECK_INCLUDE_FILE_CONCAT ("sys/timeb.h"     ${HDF_PREFIX}_HAVE_SYS_TIMEB_H)
 
 if (CMAKE_SYSTEM_NAME MATCHES "OSF")
   CHECK_INCLUDE_FILE_CONCAT ("sys/sysinfo.h" ${HDF_PREFIX}_HAVE_SYS_SYSINFO_H)
diff --git a/src/H5system.c b/src/H5system.c
index 7f953d7958e..a9185719bd1 100644
--- a/src/H5system.c
+++ b/src/H5system.c
@@ -1461,38 +1461,6 @@ H5_nanosleep(uint64_t nanosec)
     FUNC_LEAVE_NOAPI_VOID
 } /* end H5_nanosleep() */
 
-
-/*--------------------------------------------------------------------------
- * Function:    H5_get_time
- *
- * Purpose:     Get the current time, as the time of seconds after the UNIX epoch
- *
- * Return:      SUCCEED/FAIL
- *
- * Programmer:  Quincey Koziol
- *              October 05, 2016
- *--------------------------------------------------------------------------
- */
-double
-H5_get_time(void)
-{
-#ifdef H5_HAVE_GETTIMEOFDAY
-    struct timeval curr_time;
-#endif /* H5_HAVE_GETTIMEOFDAY */
-    double ret_value = (double)0.0f;
-
-    FUNC_ENTER_NOAPI_NOINIT_NOERR
-
-#ifdef H5_HAVE_GETTIMEOFDAY
-    HDgettimeofday(&curr_time, NULL);
-
-    ret_value = (double)curr_time.tv_sec + ((double)curr_time.tv_usec / (double)1000000.0f);
-#endif /* H5_HAVE_GETTIMEOFDAY */
-
-    FUNC_LEAVE_NOAPI(ret_value)
-} /* end H5_get_time() */
-
-
 #ifdef H5_HAVE_WIN32_API
 
 #define H5_WIN32_ENV_VAR_BUFFER_SIZE    32767
diff --git a/src/H5timer.c b/src/H5timer.c
index 8603b1c7947..180c7744e37 100644
--- a/src/H5timer.c
+++ b/src/H5timer.c
@@ -214,6 +214,47 @@ H5_now_usec(void)
     return(now);
 } /* end H5_now_usec() */
 
+
+/*--------------------------------------------------------------------------
+ * Function:    H5_get_time
+ *
+ * Purpose:     Get the current time, as the time of seconds after the UNIX epoch
+ *
+ * Return:      SUCCEED/FAIL
+ *
+ * Programmer:  Quincey Koziol
+ *              October 05, 2016
+ *--------------------------------------------------------------------------
+ */
+double
+H5_get_time(void)
+{
+    double ret_value = (double)0.0f;
+
+    FUNC_ENTER_NOAPI_NOINIT_NOERR
+
+#if defined(H5_HAVE_CLOCK_GETTIME)
+    {
+        struct timespec ts;
+
+        HDclock_gettime(CLOCK_MONOTONIC, &ts);
+        ret_value = (double)ts.tv_sec + ((double)ts.tv_nsec / (double)1000000000.0f);
+    }
+#elif defined(H5_HAVE_GETTIMEOFDAY)
+    {
+        struct timeval now_tv;
+
+        HDgettimeofday(&now_tv, NULL);
+        ret_value = (double)now_tv.tv_sec + ((double)now_tv.tv_usec / (double)1000000.0f);
+    }
+#else /* H5_HAVE_GETTIMEOFDAY */
+    ret_value = (double)HDtime(NULL);
+#endif /* H5_HAVE_GETTIMEOFDAY */
+
+    FUNC_LEAVE_NOAPI(ret_value)
+} /* end H5_get_time() */
+
+
 
 /*-------------------------------------------------------------------------
  * Function:    H5__timer_get_timevals
diff --git a/tools/test/perform/chunk_cache.c b/tools/test/perform/chunk_cache.c
index e594e34d5e3..f630da72acf 100644
--- a/tools/test/perform/chunk_cache.c
+++ b/tools/test/perform/chunk_cache.c
@@ -78,18 +78,6 @@ counter (unsigned H5_ATTR_UNUSED flags, size_t H5_ATTR_UNUSED cd_nelmts,
     return nbytes;
 }
 
-/*---------------------------------------------------------------------------*/
-static double retrieve_time(void)
-{
-#ifdef H5_HAVE_GETTIMEOFDAY
-    struct timeval t;
-    HDgettimeofday(&t, NULL);
-    return ((double)t.tv_sec + (double)t.tv_usec / 1000000);
-#else
-    return 0.0;
-#endif
-}
-
 /*---------------------------------------------------------------------------*/
 static void
 cleanup (void)
@@ -253,7 +241,7 @@ static int check_partial_chunks_perf(hid_t file)
 
     nbytes_global = 0;
 
-    start_t = retrieve_time();
+    start_t = H5_get_time();
 
     /* Read the data row by row */
     for(i = 0; i < DSET1_DIM1; i++) {
@@ -267,13 +255,12 @@ static int check_partial_chunks_perf(hid_t file)
             goto error;
     }
 
-    end_t = retrieve_time();
+    end_t = H5_get_time();
 
-#ifdef H5_HAVE_GETTIMEOFDAY
-    printf("1. Partial chunks: total read time is %lf; number of bytes being read from file is %lu\n", (end_t -start_t), nbytes_global);
-#else
-    printf("1. Partial chunks: no total read time because gettimeofday() is not available; number of bytes being read from file is %lu\n", nbytes_global);
-#endif
+    if((end_t - start_t) > 0.0f)
+        printf("1. Partial chunks: total read time is %lf; number of bytes being read from file is %lu\n", (end_t -start_t), nbytes_global);
+    else
+        printf("1. Partial chunks: no total read time because timer is not available; number of bytes being read from file is %lu\n", nbytes_global);
 
     H5Dclose (dataset);
     H5Sclose (filespace);
@@ -328,7 +315,7 @@ static int check_hash_value_perf(hid_t file)
 
     nbytes_global = 0;
 
-    start_t = retrieve_time();
+    start_t = H5_get_time();
 
     /* Read the data column by column */
     for(i = 0; i < DSET2_DIM2; i++) {
@@ -342,13 +329,12 @@ static int check_hash_value_perf(hid_t file)
             goto error;
     }
 
-    end_t = retrieve_time();
+    end_t = H5_get_time();
 
-#ifdef H5_HAVE_GETTIMEOFDAY
-    printf("2. Hash value: total read time is %lf; number of bytes being read from file is %lu\n", (end_t -start_t), nbytes_global);
-#else
-    printf("2. Hash value: no total read time because gettimeofday() is not available; number of bytes being read from file is %lu\n", nbytes_global);
-#endif
+    if((end_t - start_t) > 0.0)
+        printf("2. Hash value: total read time is %lf; number of bytes being read from file is %lu\n", (end_t -start_t), nbytes_global);
+    else
+        printf("2. Hash value: no total read time because timer is not available; number of bytes being read from file is %lu\n", nbytes_global);
 
     H5Dclose (dataset);
     H5Sclose (filespace);
diff --git a/tools/test/perform/iopipe.c b/tools/test/perform/iopipe.c
index bf4728db54d..de56281bedc 100644
--- a/tools/test/perform/iopipe.c
+++ b/tools/test/perform/iopipe.c
@@ -21,10 +21,6 @@
 
 #include "H5private.h"
 
-#ifdef H5_HAVE_SYS_TIMEB
-#include <sys/timeb.h>
-#endif
-
 
 #define RAW_FILE_NAME  "iopipe.raw"
 #define HDF5_FILE_NAME  "iopipe.h5"
@@ -56,25 +52,18 @@
  * Programmer:  Robb Matzke
  *              Thursday, March 12, 1998
  *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
-#ifdef H5_HAVE_GETRUSAGE
 static void
-print_stats (const char *prefix,
+print_stats(const char *prefix,
+#ifdef H5_HAVE_GETRUSAGE
        struct rusage *r_start, struct rusage *r_stop,
-       struct timeval *t_start, struct timeval *t_stop,
-       size_t nbytes)
-#else /* H5_HAVE_GETRUSAGE */
-static void
-print_stats (const char *prefix,
-       struct timeval *r_start, struct timeval *r_stop,
-       struct timeval *t_start, struct timeval *t_stop,
-       size_t nbytes)
 #endif /* H5_HAVE_GETRUSAGE */
+       double t_start, double t_stop,
+       size_t nbytes)
 {
-    double  e_time, bw;
+    double  e_time;
+    char bw[16];
 #ifdef H5_HAVE_GETRUSAGE
     double  u_time, s_time;
 
@@ -88,27 +77,16 @@ print_stats (const char *prefix,
        ((double)(r_start->ru_stime.tv_sec)+
         (double)(r_start->ru_stime.tv_usec)/(double)1000000.0F);
 #endif
-#ifndef H5_HAVE_SYS_TIMEB
-    e_time = ((double)(t_stop->tv_sec)+
-        (double)(t_stop->tv_usec)/(double)1000000.0F) -
-       ((double)(t_start->tv_sec)+
-        (double)(t_start->tv_usec)/(double)1000000.0F);
-#else
-    e_time = ((double)(t_stop->tv_sec)+
-        (double)(t_stop->tv_usec)/(double)1000.0F) -
-       ((double)(t_start->tv_sec)+
-        (double)(t_start->tv_usec)/(double)1000.0F);
-#endif
-    bw = (double)nbytes / e_time;
+    e_time = t_stop - t_start;
+    H5_bandwidth(bw, (double)nbytes, e_time);
 
 #ifdef H5_HAVE_GETRUSAGE
-    printf (HEADING "%1.2fuser %1.2fsystem %1.2felapsed %1.2fMB/s\n",
-      prefix, u_time, s_time, e_time, bw/(1024*1024));
+    HDprintf(HEADING "%1.2fuser %1.2fsystem %1.2felapsed %s\n",
+      prefix, u_time, s_time, e_time, bw);
 #else
-    printf (HEADING "%1.2felapsed %1.2fMB/s\n",
-      prefix, e_time, bw/(1024*1024));
+    HDprintf(HEADING "%1.2felapsed %s\n",
+      prefix, e_time, bw);
 #endif
-
 }
 
 
@@ -122,12 +100,10 @@ print_stats (const char *prefix,
  * Programmer:  Robb Matzke
  *              Thursday, March 12, 1998
  *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 static void
-synchronize (void)
+synchronize(void)
 {
 #ifdef H5_HAVE_SYSTEM
 #if defined(H5_HAVE_WIN32_API) && ! defined(__CYGWIN__)
@@ -157,24 +133,20 @@ synchronize (void)
  * Programmer:  Robb Matzke
  *              Thursday, March 12, 1998
  *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 int
-main (void)
+main(void)
 {
-    static hsize_t  size[2] = {REQUEST_SIZE_X, REQUEST_SIZE_Y};
-    static unsigned  nread = NREAD_REQUESTS, nwrite = NWRITE_REQUESTS;
+    hsize_t  size[2] = {REQUEST_SIZE_X, REQUEST_SIZE_Y};
+    unsigned  nread = NREAD_REQUESTS, nwrite = NWRITE_REQUESTS;
 
     unsigned char  *the_data = NULL;
     hid_t    file, dset, file_space = H5I_INVALID_HID;
 #ifdef H5_HAVE_GETRUSAGE
     struct rusage  r_start, r_stop;
-#else
-    struct timeval r_start, r_stop;
 #endif
-    struct timeval  t_start, t_stop;
+    double  t_start, t_stop;
     int      fd;
     unsigned    u;
     herr_t      H5_ATTR_NDEBUG_UNUSED status;
@@ -184,322 +156,221 @@ main (void)
     hsize_t    count[2];
 
 
-#ifdef H5_HAVE_SYS_TIMEB
-  struct _timeb *tbstart = malloc(sizeof(struct _timeb));
-  struct _timeb *tbstop = malloc(sizeof(struct _timeb));
-#endif
     /*
      * The extra cast in the following statement is a bug workaround for the
      * Win32 version 5.0 compiler.
      * 1998-11-06 ptl
      */
-    printf ("I/O request size is %1.1fMB\n",
-      (double)(hssize_t)(size[0]*size[1])/(double)1024.0F*(double)1024);
+    HDprintf("I/O request size is %1.1fMB\n",
+      (double)(hssize_t)(size[0] * size[1]) / (double)1024.0F * (double)1024);
 
     /* Open the files */
-    file = H5Fcreate (HDF5_FILE_NAME, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
-    HDassert (file>=0);
-    fd = HDopen (RAW_FILE_NAME, O_RDWR|O_CREAT|O_TRUNC, 0666);
-    HDassert (fd>=0);
+    file = H5Fcreate(HDF5_FILE_NAME, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
+    HDassert(file >= 0);
+    fd = HDopen(RAW_FILE_NAME, O_RDWR|O_CREAT|O_TRUNC, 0666);
+    HDassert(fd >= 0);
 
     /* Create the dataset */
-    file_space = H5Screate_simple (2, size, size);
+    file_space = H5Screate_simple(2, size, size);
     HDassert(file_space >= 0);
     dset = H5Dcreate2(file, "dset", H5T_NATIVE_UCHAR, file_space, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
     HDassert(dset >= 0);
-    the_data = (unsigned char *)malloc((size_t)(size[0] * size[1]));
+    the_data = (unsigned char *)HDmalloc((size_t)(size[0] * size[1]));
 
     /* initial fill for lazy malloc */
     HDmemset(the_data, 0xAA, (size_t)(size[0] * size[1]));
 
+
     /* Fill raw */
-    synchronize ();
+    synchronize();
 #ifdef H5_HAVE_GETRUSAGE
     HDgetrusage(RUSAGE_SELF, &r_start);
 #endif
-#ifdef H5_HAVE_GETTIMEOFDAY
-    HDgettimeofday(&t_start, NULL);
-#else
-#ifdef H5_HAVE_SYS_TIMEB
-  _ftime(tbstart);
-#endif
-#endif
-    HDfprintf (stderr, HEADING, "fill raw");
+    t_start = H5_get_time();
+    HDfprintf(stderr, HEADING, "fill raw");
     for(u = 0; u < nwrite; u++) {
-  putc (PROGRESS, stderr);
-  HDfflush(stderr);
-  HDmemset(the_data, 0xAA, (size_t)(size[0]*size[1]));
+      HDputc(PROGRESS, stderr);
+      HDfflush(stderr);
+      HDmemset(the_data, 0xAA, (size_t)(size[0] * size[1]));
     }
 #ifdef H5_HAVE_GETRUSAGE
     HDgetrusage(RUSAGE_SELF, &r_stop);
 #endif
-#ifdef H5_HAVE_GETTIMEOFDAY
-    HDgettimeofday(&t_stop, NULL);
-#else
-#ifdef H5_HAVE_SYS_TIMEB
-  _ftime(tbstop);
-  t_start.tv_sec = tbstart->time;
-  t_start.tv_usec = tbstart->millitm;
-  t_stop.tv_sec = tbstop->time;
-  t_stop.tv_usec = tbstop->millitm;
-#endif
-#endif
-    putc ('\n', stderr);
-    print_stats ("fill raw",
-     &r_start, &r_stop, &t_start, &t_stop,
-     (size_t)(nread*size[0]*size[1]));
+    t_stop = H5_get_time();
+    HDputc('\n', stderr);
+    print_stats("fill raw",
+#ifdef H5_HAVE_GETRUSAGE
+            &r_start, &r_stop,
+#endif /* H5_HAVE_GETRUSAGE */
+            t_start, t_stop, (size_t)(nread * size[0] * size[1]));
 
 
     /* Fill hdf5 */
-    synchronize ();
+    synchronize();
 #ifdef H5_HAVE_GETRUSAGE
     HDgetrusage(RUSAGE_SELF, &r_start);
 #endif
-#ifdef H5_HAVE_GETTIMEOFDAY
-    HDgettimeofday(&t_start, NULL);
-#else
-#ifdef H5_HAVE_SYS_TIMEB
-  _ftime(tbstart);
-#endif
-#endif
-    HDfprintf (stderr, HEADING, "fill hdf5");
+    t_start = H5_get_time();
+    HDfprintf(stderr, HEADING, "fill hdf5");
     for(u = 0; u < nread; u++) {
-  putc (PROGRESS, stderr);
-  HDfflush(stderr);
-  status = H5Dread (dset, H5T_NATIVE_UCHAR, file_space, file_space,
-        H5P_DEFAULT, the_data);
-  HDassert (status>=0);
+      HDputc(PROGRESS, stderr);
+      HDfflush(stderr);
+      status = H5Dread(dset, H5T_NATIVE_UCHAR, file_space, file_space,
+            H5P_DEFAULT, the_data);
+      HDassert(status >= 0);
     }
 #ifdef H5_HAVE_GETRUSAGE
     HDgetrusage(RUSAGE_SELF, &r_stop);
 #endif
-#ifdef H5_HAVE_GETTIMEOFDAY
-    HDgettimeofday(&t_stop, NULL);
-#else
-#ifdef H5_HAVE_SYS_TIMEB
-  _ftime(tbstop);
-  t_start.tv_sec = tbstart->time;
-  t_start.tv_usec = tbstart->millitm;
-  t_stop.tv_sec = tbstop->time;
-  t_stop.tv_usec = tbstop->millitm;
-#endif
-#endif
-    putc ('\n', stderr);
-    print_stats ("fill hdf5",
-     &r_start, &r_stop, &t_start, &t_stop,
-     (size_t)(nread*size[0]*size[1]));
+    t_stop = H5_get_time();
+    HDputc('\n', stderr);
+    print_stats("fill hdf5",
+#ifdef H5_HAVE_GETRUSAGE
+            &r_start, &r_stop,
+#endif /* H5_HAVE_GETRUSAGE */
+            t_start, t_stop, (size_t)(nread * size[0] * size[1]));
 
     /* Write the raw dataset */
-    synchronize ();
+    synchronize();
 #ifdef H5_HAVE_GETRUSAGE
     HDgetrusage(RUSAGE_SELF, &r_start);
 #endif
-#ifdef H5_HAVE_GETTIMEOFDAY
-    HDgettimeofday(&t_start, NULL);
-#else
-#ifdef H5_HAVE_SYS_TIMEB
-  _ftime(tbstart);
-#endif
-#endif
-    HDfprintf (stderr, HEADING, "out raw");
+    t_start = H5_get_time();
+    HDfprintf(stderr, HEADING, "out raw");
     for(u = 0; u < nwrite; u++) {
-  putc (PROGRESS, stderr);
-  HDfflush(stderr);
-  offset = HDlseek (fd, (off_t)0, SEEK_SET);
-  HDassert (0==offset);
-  n = HDwrite (fd, the_data, (size_t)(size[0]*size[1]));
-  HDassert (n>=0 && (size_t)n==size[0]*size[1]);
+      HDputc(PROGRESS, stderr);
+      HDfflush(stderr);
+      offset = HDlseek(fd, (off_t)0, SEEK_SET);
+      HDassert(0 == offset);
+      n = HDwrite(fd, the_data, (size_t)(size[0] * size[1]));
+      HDassert(n >= 0 && (size_t)n == (size[0] * size[1]));
     }
 #ifdef H5_HAVE_GETRUSAGE
     HDgetrusage(RUSAGE_SELF, &r_stop);
 #endif
-#ifdef H5_HAVE_GETTIMEOFDAY
-    HDgettimeofday(&t_stop, NULL);
-#else
-#ifdef H5_HAVE_SYS_TIMEB
-  _ftime(tbstop);
-  t_start.tv_sec = tbstart->time;
-  t_start.tv_usec = tbstart->millitm;
-  t_stop.tv_sec = tbstop->time;
-  t_stop.tv_usec = tbstop->millitm;
-#endif
-#endif
-    putc ('\n', stderr);
-    print_stats ("out raw",
-     &r_start, &r_stop, &t_start, &t_stop,
-     (size_t)(nread*size[0]*size[1]));
+    t_stop = H5_get_time();
+    HDputc('\n', stderr);
+    print_stats("out raw",
+#ifdef H5_HAVE_GETRUSAGE
+            &r_start, &r_stop,
+#endif /* H5_HAVE_GETRUSAGE */
+            t_start, t_stop, (size_t)(nread * size[0] * size[1]));
 
     /* Write the hdf5 dataset */
-    synchronize ();
+    synchronize();
 #ifdef H5_HAVE_GETRUSAGE
     HDgetrusage(RUSAGE_SELF, &r_start);
 #endif
-#ifdef H5_HAVE_GETTIMEOFDAY
-    HDgettimeofday(&t_start, NULL);
-#else
-#ifdef H5_HAVE_SYS_TIMEB
-  _ftime(tbstart);
-#endif
-#endif
-    HDfprintf (stderr, HEADING, "out hdf5");
+    t_start = H5_get_time();
+    HDfprintf(stderr, HEADING, "out hdf5");
     for(u = 0; u < nwrite; u++) {
-  putc (PROGRESS, stderr);
-  HDfflush(stderr);
-  status = H5Dwrite (dset, H5T_NATIVE_UCHAR, H5S_ALL, H5S_ALL,
-         H5P_DEFAULT, the_data);
-  HDassert (status>=0);
+      HDputc(PROGRESS, stderr);
+      HDfflush(stderr);
+      status = H5Dwrite(dset, H5T_NATIVE_UCHAR, H5S_ALL, H5S_ALL,
+             H5P_DEFAULT, the_data);
+      HDassert(status >= 0);
     }
 #ifdef H5_HAVE_GETRUSAGE
     HDgetrusage(RUSAGE_SELF, &r_stop);
 #endif
-#ifdef H5_HAVE_GETTIMEOFDAY
-    HDgettimeofday(&t_stop, NULL);
-#else
-#ifdef H5_HAVE_SYS_TIMEB
-  _ftime(tbstop);
-  t_start.tv_sec = tbstart->time;
-  t_start.tv_usec = tbstart->millitm;
-  t_stop.tv_sec = tbstop->time;
-  t_stop.tv_usec = tbstop->millitm;
-#endif
-#endif
-    putc ('\n', stderr);
-    print_stats ("out hdf5",
-     &r_start, &r_stop, &t_start, &t_stop,
-     (size_t)(nread*size[0]*size[1]));
+    t_stop = H5_get_time();
+    HDputc('\n', stderr);
+    print_stats("out hdf5",
+#ifdef H5_HAVE_GETRUSAGE
+            &r_start, &r_stop,
+#endif /* H5_HAVE_GETRUSAGE */
+            t_start, t_stop, (size_t)(nread * size[0] * size[1]));
 
     /* Read the raw dataset */
-    synchronize ();
+    synchronize();
 #ifdef H5_HAVE_GETRUSAGE
     HDgetrusage(RUSAGE_SELF, &r_start);
 #endif
-#ifdef H5_HAVE_GETTIMEOFDAY
-    HDgettimeofday(&t_start, NULL);
-#else
-#ifdef H5_HAVE_SYS_TIMEB
-  _ftime(tbstart);
-#endif
-#endif
-    HDfprintf (stderr, HEADING, "in raw");
+    t_start = H5_get_time();
+    HDfprintf(stderr, HEADING, "in raw");
     for(u = 0; u < nread; u++) {
-  putc (PROGRESS, stderr);
-  HDfflush(stderr);
-  offset = HDlseek (fd, (off_t)0, SEEK_SET);
-  HDassert (0==offset);
-  n = HDread (fd, the_data, (size_t)(size[0]*size[1]));
-  HDassert (n>=0 && (size_t)n==size[0]*size[1]);
+      HDputc(PROGRESS, stderr);
+      HDfflush(stderr);
+      offset = HDlseek(fd, (off_t)0, SEEK_SET);
+      HDassert(0 == offset);
+      n = HDread(fd, the_data, (size_t)(size[0] * size[1]));
+      HDassert(n >= 0 && (size_t)n == (size[0] * size[1]));
     }
 #ifdef H5_HAVE_GETRUSAGE
     HDgetrusage(RUSAGE_SELF, &r_stop);
 #endif
-#ifdef H5_HAVE_GETTIMEOFDAY
-    HDgettimeofday(&t_stop, NULL);
-#else
-#ifdef H5_HAVE_SYS_TIMEB
-  _ftime(tbstop);
-  t_start.tv_sec = tbstart->time;
-  t_start.tv_usec = tbstart->millitm;
-  t_stop.tv_sec = tbstop->time;
-  t_stop.tv_usec = tbstop->millitm;
-#endif
-#endif
-    putc ('\n', stderr);
-    print_stats ("in raw",
-     &r_start, &r_stop, &t_start, &t_stop,
-     (size_t)(nread*size[0]*size[1]));
+    t_stop = H5_get_time();
+    HDputc('\n', stderr);
+    print_stats("in raw",
+#ifdef H5_HAVE_GETRUSAGE
+            &r_start, &r_stop,
+#endif /* H5_HAVE_GETRUSAGE */
+            t_start, t_stop, (size_t)(nread * size[0] * size[1]));
 
 
     /* Read the hdf5 dataset */
-    synchronize ();
+    synchronize();
 #ifdef H5_HAVE_GETRUSAGE
     HDgetrusage(RUSAGE_SELF, &r_start);
 #endif
-#ifdef H5_HAVE_GETTIMEOFDAY
-    HDgettimeofday(&t_start, NULL);
-#else
-#ifdef H5_HAVE_SYS_TIMEB
-  _ftime(tbstart);
-#endif
-#endif
-    HDfprintf (stderr, HEADING, "in hdf5");
+    t_start = H5_get_time();
+    HDfprintf(stderr, HEADING, "in hdf5");
     for(u = 0; u < nread; u++) {
-  putc (PROGRESS, stderr);
-  HDfflush(stderr);
-  status = H5Dread (dset, H5T_NATIVE_UCHAR, file_space, file_space,
-        H5P_DEFAULT, the_data);
-  HDassert (status>=0);
+      HDputc(PROGRESS, stderr);
+      HDfflush(stderr);
+      status = H5Dread(dset, H5T_NATIVE_UCHAR, file_space, file_space,
+            H5P_DEFAULT, the_data);
+      HDassert(status >= 0);
     }
 #ifdef H5_HAVE_GETRUSAGE
     HDgetrusage(RUSAGE_SELF, &r_stop);
 #endif
-#ifdef H5_HAVE_GETTIMEOFDAY
-    HDgettimeofday(&t_stop, NULL);
-#else
-#ifdef H5_HAVE_SYS_TIMEB
-  _ftime(tbstop);
-  t_start.tv_sec = tbstart->time;
-  t_start.tv_usec = tbstart->millitm;
-  t_stop.tv_sec = tbstop->time;
-  t_stop.tv_usec = tbstop->millitm;
-#endif
-#endif
-    putc ('\n', stderr);
-    print_stats ("in hdf5",
-     &r_start, &r_stop, &t_start, &t_stop,
-     (size_t)(nread*size[0]*size[1]));
+    t_stop = H5_get_time();
+    HDputc('\n', stderr);
+    print_stats("in hdf5",
+#ifdef H5_HAVE_GETRUSAGE
+            &r_start, &r_stop,
+#endif /* H5_HAVE_GETRUSAGE */
+            t_start, t_stop, (size_t)(nread * size[0] * size[1]));
 
     /* Read hyperslab */
-    HDassert (size[0]>20 && size[1]>20);
+    HDassert(size[0] > 20 && size[1] > 20);
     start[0] = start[1] = 10;
-    count[0] = count[1] = size[0]-20;
-    status = H5Sselect_hyperslab (file_space, H5S_SELECT_SET, start, NULL, count, NULL);
-    HDassert (status>=0);
-    synchronize ();
+    count[0] = count[1] = size[0] - 20;
+    status = H5Sselect_hyperslab(file_space, H5S_SELECT_SET, start, NULL, count, NULL);
+    HDassert(status >= 0);
+    synchronize();
 #ifdef H5_HAVE_GETRUSAGE
     HDgetrusage(RUSAGE_SELF, &r_start);
 #endif
-#ifdef H5_HAVE_GETTIMEOFDAY
-    HDgettimeofday(&t_start, NULL);
-#else
-#ifdef H5_HAVE_SYS_TIMEB
-  _ftime(tbstart);
-#endif
-#endif
-    HDfprintf (stderr, HEADING, "in hdf5 partial");
+    t_start = H5_get_time();
+    HDfprintf(stderr, HEADING, "in hdf5 partial");
     for(u = 0; u < nread; u++) {
-  putc (PROGRESS, stderr);
-  HDfflush(stderr);
-  status = H5Dread (dset, H5T_NATIVE_UCHAR, file_space, file_space,
-        H5P_DEFAULT, the_data);
-  HDassert (status>=0);
+      HDputc(PROGRESS, stderr);
+      HDfflush(stderr);
+      status = H5Dread(dset, H5T_NATIVE_UCHAR, file_space, file_space,
+            H5P_DEFAULT, the_data);
+      HDassert(status >= 0);
     }
 #ifdef H5_HAVE_GETRUSAGE
     HDgetrusage(RUSAGE_SELF, &r_stop);
 #endif
-#ifdef H5_HAVE_GETTIMEOFDAY
-    HDgettimeofday(&t_stop, NULL);
-#else
-#ifdef H5_HAVE_SYS_TIMEB
-  _ftime(tbstop);
-  t_start.tv_sec = tbstart->time;
-  t_start.tv_usec = tbstart->millitm;
-  t_stop.tv_sec = tbstop->time;
-  t_stop.tv_usec = tbstop->millitm;
-#endif
-#endif
-    putc('\n', stderr);
+    t_stop = H5_get_time();
+    HDputc('\n', stderr);
     print_stats("in hdf5 partial",
-     &r_start, &r_stop, &t_start, &t_stop,
-     (size_t)(nread*count[0]*count[1]));
-
-
+#ifdef H5_HAVE_GETRUSAGE
+            &r_start, &r_stop,
+#endif /* H5_HAVE_GETRUSAGE */
+            t_start, t_stop, (size_t)(nread * size[0] * size[1]));
 
     /* Close everything */
     HDclose(fd);
+
     H5Dclose(dset);
     H5Sclose(file_space);
     H5Fclose(file);
-    free(the_data);
+
+    HDfree(the_data);
 
     return 0;
 }

From ee4eb09b5f5a562b82ab7c48272edf91988eaf82 Mon Sep 17 00:00:00 2001
From: Quincey Koziol <koziol@koziol.gov>
Date: Sat, 27 Jun 2020 13:44:24 -0500
Subject: [PATCH 10/55] va_arg -> HDva_arg

---
 src/H5system.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/H5system.c b/src/H5system.c
index a9185719bd1..b3db39c069a 100644
--- a/src/H5system.c
+++ b/src/H5system.c
@@ -419,7 +419,7 @@ HDfprintf(FILE *stream, const char *fmt, ...)
 
                 case 'T':       /* Elapsed time, in seconds */
                     {
-                        double seconds = va_arg(ap, double);
+                        double seconds = HDva_arg(ap, double);
                         char *time_string = H5_timer_get_time_string(seconds);
 
                         if(time_string) {

From 32c483cb86031962a09ecdb49dcb331d28dddee9 Mon Sep 17 00:00:00 2001
From: Larry Knox <lrknox@hdfgroup.org>
Date: Sat, 27 Jun 2020 15:39:53 -0500
Subject: [PATCH 11/55] Copy lib files for junit.sh to temporary subdirectory
 of <build directory>/java/test instead of to the prefix/lib directory.  Fix
 for HDFFV-11063.

---
 java/test/junit.sh.in | 8 ++------
 1 file changed, 2 insertions(+), 6 deletions(-)

diff --git a/java/test/junit.sh.in b/java/test/junit.sh.in
index 598b3d2c617..d9ff5a594ee 100644
--- a/java/test/junit.sh.in
+++ b/java/test/junit.sh.in
@@ -15,7 +15,6 @@
 top_builddir=@top_builddir@
 top_srcdir=@top_srcdir@
 srcdir=@srcdir@
-prefix=@prefix@
 
 USE_FILTER_SZIP="@USE_FILTER_SZIP@"
 USE_FILTER_DEFLATE="@USE_FILTER_DEFLATE@"
@@ -43,8 +42,8 @@ myos=`uname -s`
 
 # where the libs exist
 HDFLIB_HOME="$top_srcdir/java/lib"
-BLDLIBDIR="$prefix/lib"
 BLDDIR="."
+BLDLIBDIR="$BLDDIR/testlibs"
 HDFTEST_HOME="$top_srcdir/java/test"
 JARFILE=jar@PACKAGE_TARNAME@-@PACKAGE_VERSION@.jar
 TESTJARFILE=jar@PACKAGE_TARNAME@test.jar
@@ -204,10 +203,7 @@ CLEAN_LIBFILES_AND_BLDLIBDIR()
     INODE_SDIR=`$LS -i -d $SDIR | $AWK -F' ' '{print $1}'`
     INODE_DDIR=`$LS -i -d $BLDLIBDIR | $AWK -F' ' '{print $1}'`
     if [ "$INODE_SDIR" != "$INODE_DDIR" ]; then
-        for tstfile in $COPY_JARTESTFILES
-        do
-            $RM $BLDLIBDIR/tstfile
-        done
+        $RM -rf $BLDLIBDIR
     fi
 }
 

From 71b601d0d3610d508a5dfa0d3a3ff54b71f5090a Mon Sep 17 00:00:00 2001
From: Quincey Koziol <koziol@koziol.gov>
Date: Sat, 27 Jun 2020 20:02:51 -0500
Subject: [PATCH 12/55] Clean up warnings

---
 MANIFEST                                   |  2 +
 config/cmake/H5pubconf.h.in                |  3 --
 config/cmake_ext_mod/ConfigureChecks.cmake |  3 --
 src/H5FDlog.c                              |  8 +++-
 src/H5timer.c                              |  2 +-
 test/timer.c                               | 41 +++++++++---------
 tools/test/perform/chunk_cache.c           | 48 +++++++++++-----------
 7 files changed, 53 insertions(+), 54 deletions(-)

diff --git a/MANIFEST b/MANIFEST
index e3c3c50becc..a20b24822a7 100644
--- a/MANIFEST
+++ b/MANIFEST
@@ -192,6 +192,7 @@
 ./examples/h5_chunk_read.c
 ./examples/h5_compound.c
 ./examples/h5_crtgrpd.c
+./examples/h5_debug_trace.c
 ./examples/h5_subset.c
 ./examples/h5_cmprss.c
 ./examples/h5_rdwt.c
@@ -1228,6 +1229,7 @@
 ./test/theap.c
 ./test/thread_id.c
 ./test/tid.c
+./test/timer.c
 ./test/titerate.c
 ./test/tlayouto.h5
 ./test/tmeta.c
diff --git a/config/cmake/H5pubconf.h.in b/config/cmake/H5pubconf.h.in
index eea12cdabe2..64b4852af9b 100644
--- a/config/cmake/H5pubconf.h.in
+++ b/config/cmake/H5pubconf.h.in
@@ -267,9 +267,6 @@
 /* Define to 1 if you have the `lstat' function. */
 #cmakedefine H5_HAVE_LSTAT @H5_HAVE_LSTAT@
 
-/* Define to 1 if you have the <mach/mach_time.h> header file. */
-#cmakedefine H5_HAVE_MACH_MACH_TIME_H @H5_HAVE_MACH_MACH_TIME_H@
-
 /* Define if the map API (H5M) should be compiled */
 #cmakedefine H5_HAVE_MAP_API @H5_HAVE_MAP_API@
 
diff --git a/config/cmake_ext_mod/ConfigureChecks.cmake b/config/cmake_ext_mod/ConfigureChecks.cmake
index 82527360ce3..6f5a8354e76 100644
--- a/config/cmake_ext_mod/ConfigureChecks.cmake
+++ b/config/cmake_ext_mod/ConfigureChecks.cmake
@@ -137,9 +137,6 @@ CHECK_INCLUDE_FILE_CONCAT ("stddef.h"        ${HDF_PREFIX}_HAVE_STDDEF_H)
 CHECK_INCLUDE_FILE_CONCAT ("stdint.h"        ${HDF_PREFIX}_HAVE_STDINT_H)
 CHECK_INCLUDE_FILE_CONCAT ("unistd.h"        ${HDF_PREFIX}_HAVE_UNISTD_H)
 
-# Darwin
-CHECK_INCLUDE_FILE_CONCAT ("mach/mach_time.h" ${HDF_PREFIX}_HAVE_MACH_MACH_TIME_H)
-
 # Windows
 CHECK_INCLUDE_FILE_CONCAT ("io.h"            ${HDF_PREFIX}_HAVE_IO_H)
 if (NOT CYGWIN)
diff --git a/src/H5FDlog.c b/src/H5FDlog.c
index 27002863a83..78b7742adb7 100644
--- a/src/H5FDlog.c
+++ b/src/H5FDlog.c
@@ -1146,9 +1146,11 @@ H5FD_log_read(H5FD_t *_file, H5FD_mem_t type, hid_t H5_ATTR_UNUSED dxpl_id, hadd
     size_t              orig_size = size; /* Save the original size for later */
     haddr_t             orig_addr = addr;
     H5_timer_t          read_timer;             /* Timer for read operation */
-    H5_timer_t          seek_timer;             /* Timer for seek operation */
     H5_timevals_t       read_times;             /* Elapsed time for read operation */
+#ifndef H5_HAVE_PREADWRITE
+    H5_timer_t          seek_timer;             /* Timer for seek operation */
     H5_timevals_t       seek_times;             /* Elapsed time for seek operation */
+#endif /* H5_HAVE_PREADWRITE */
     HDoff_t             offset = (HDoff_t)addr;
     herr_t              ret_value = SUCCEED;    /* Return value */
 
@@ -1348,9 +1350,11 @@ H5FD_log_write(H5FD_t *_file, H5FD_mem_t type, hid_t H5_ATTR_UNUSED dxpl_id, had
     size_t              orig_size = size; /* Save the original size for later */
     haddr_t             orig_addr = addr;
     H5_timer_t          write_timer;            /* Timer for write operation */
-    H5_timer_t          seek_timer;             /* Timer for seek operation */
     H5_timevals_t       write_times;            /* Elapsed time for write operation */
+#ifndef H5_HAVE_PREADWRITE
+    H5_timer_t          seek_timer;             /* Timer for seek operation */
     H5_timevals_t       seek_times;             /* Elapsed time for seek operation */
+#endif /* H5_HAVE_PREADWRITE */
     HDoff_t             offset = (HDoff_t)addr;
     herr_t              ret_value = SUCCEED;    /* Return value */
 
diff --git a/src/H5timer.c b/src/H5timer.c
index 180c7744e37..8f3d30583fc 100644
--- a/src/H5timer.c
+++ b/src/H5timer.c
@@ -40,7 +40,7 @@
  * Most time strings should be < 20 or so characters (max!) so this should be a
  * safe size.  Dynamically allocating the correct size would be painful.
  */
-#define H5TIMER_TIME_STRING_LEN 256
+#define H5TIMER_TIME_STRING_LEN 1536
 
 /* Conversion factors */
 #define H5_SEC_PER_DAY  (double)(24.0F * 60.0F * 60.0F)
diff --git a/test/timer.c b/test/timer.c
index 3a82b82151c..1014e75866e 100644
--- a/test/timer.c
+++ b/test/timer.c
@@ -70,13 +70,13 @@ test_time_formatting(void)
     HDfree(s);
 
     /*      < 1 s           milliseconds    */
-    s = H5_timer_get_time_string(4.56789E-3);
+    s = H5_timer_get_time_string(4.56789E-3F);
     if(NULL == s || HDstrcmp(s, "4.6 ms") != 0)
         TEST_ERROR;
     HDfree(s);
 
     /*      < 1 min         seconds         */
-    s = H5_timer_get_time_string(3.14);
+    s = H5_timer_get_time_string(3.14F);
     if(NULL == s || HDstrcmp(s, "3.14 s") != 0)
         TEST_ERROR;
     HDfree(s);
@@ -149,7 +149,7 @@ test_timer_system_user(void)
     /* The system and user times may not be present on some systems.  They
       * will be -1.0 if they are not.
      */
-    if(timer.initial.system < 0.0 || timer.initial.user < 0.0) {
+    if(timer.initial.system < (double)0.0f || timer.initial.user < (double)0.0f) {
         SKIPPED();
         printf("NOTE: No suitable way to get system/user times on this platform.\n");
         return 0;
@@ -157,7 +157,7 @@ test_timer_system_user(void)
 
     /* Do some fake work */
     for(i=0; i < 1024; i++) {
-        buf = (char *)HDmalloc(1024 * i * sizeof(char));
+        buf = (char *)HDmalloc(1024 * (size_t)i);
         HDfree(buf);
     }
 
@@ -170,7 +170,7 @@ test_timer_system_user(void)
         TEST_ERROR;
 
     /* System and user times should be non-negative. */
-    if(times.system < 0.0 || times.user < 0.0)
+    if(times.system < (double)0.0f || times.user < (double)0.0f)
         TEST_ERROR;
 
     PASSED();
@@ -217,7 +217,7 @@ test_timer_elapsed(void)
 
     /* Do some fake work */
     for(i=0; i < 1024; i++) {
-        buf = (char *)HDmalloc(1024 * i * sizeof(char));
+        buf = (char *)HDmalloc(1024 * (size_t)i);
         HDfree(buf);
     }
 
@@ -230,7 +230,7 @@ test_timer_elapsed(void)
         TEST_ERROR;
 
     /* Elapsed time should be non-negative. */
-    if(times.elapsed < 0.0)
+    if(times.elapsed < (double)0.0f)
         TEST_ERROR;
 
     PASSED();
@@ -248,7 +248,7 @@ test_timer_functionality(void)
     int             i;
     char            *buf = NULL;
     H5_timer_t      timer;
-    
+
     H5_timevals_t   times;
     double          prev_etime;
     double          prev_total_etime;
@@ -268,11 +268,11 @@ test_timer_functionality(void)
 
     /* Times should be initialized to zero */
     err = H5_timer_get_times(timer, &times);
-    if(err < 0 || !H5_DBL_ABS_EQUAL(times.elapsed, 0.0))
+    if(err < 0 || !H5_DBL_ABS_EQUAL(times.elapsed, (double)0.0f))
         TEST_ERROR;
 
     err = H5_timer_get_total_times(timer, &times);
-    if(err < 0 || !H5_DBL_ABS_EQUAL(times.elapsed, 0.0))
+    if(err < 0 || !H5_DBL_ABS_EQUAL(times.elapsed, (double)0.0f))
         TEST_ERROR;
 
 
@@ -287,7 +287,7 @@ test_timer_functionality(void)
 
     /* Do some fake work */
     for(i=0; i < 1024; i++) {
-        buf = (char *)HDmalloc(1024 * i * sizeof(char));
+        buf = (char *)HDmalloc(1024 * (size_t)i);
         HDfree(buf);
     }
 
@@ -298,11 +298,11 @@ test_timer_functionality(void)
 
     /* Times should be positive and non-negative */
     err = H5_timer_get_times(timer, &times);
-    if(err < 0 || times.elapsed < 0.0)
+    if(err < 0 || times.elapsed < (double)0.0f)
         TEST_ERROR;
 
     err = H5_timer_get_total_times(timer, &times);
-    if(err < 0 || times.elapsed < 0.0)
+    if(err < 0 || times.elapsed < (double)0.0f)
         TEST_ERROR;
 
 
@@ -316,11 +316,11 @@ test_timer_functionality(void)
         TEST_ERROR;
 
     err = H5_timer_get_times(timer, &times);
-    if(err < 0 || !H5_DBL_ABS_EQUAL(times.elapsed, 0.0))
+    if(err < 0 || !H5_DBL_ABS_EQUAL(times.elapsed, (double)0.0f))
         TEST_ERROR;
 
     err = H5_timer_get_total_times(timer, &times);
-    if(err < 0 || !H5_DBL_ABS_EQUAL(times.elapsed, 0.0))
+    if(err < 0 || !H5_DBL_ABS_EQUAL(times.elapsed, (double)0.0f))
         TEST_ERROR;
 
     /* Timer state should flip */
@@ -330,24 +330,24 @@ test_timer_functionality(void)
 
     /* Do some fake work */
     for(i=0; i < 1024; i++) {
-        buf = (char *)HDmalloc(1024 * i * sizeof(char));
+        buf = (char *)HDmalloc(1024 * (size_t)i);
         HDfree(buf);
     }
 
     /* Times should be non-negative */
     err = H5_timer_get_times(timer, &times);
-    if(err < 0 || times.elapsed < 0.0)
+    if(err < 0 || times.elapsed < (double)0.0f)
         TEST_ERROR;
     prev_etime = times.elapsed;
 
     err = H5_timer_get_total_times(timer, &times);
-    if(err < 0 || times.elapsed < 0.0)
+    if(err < 0 || times.elapsed < (double)0.0f)
         TEST_ERROR;
     prev_total_etime = times.elapsed;
-    
+
     /* Do some fake work */
     for(i=0; i < 1024; i++) {
-        buf = (char *)HDmalloc(1024 * i * sizeof(char));
+        buf = (char *)HDmalloc(1024 * (size_t)i);
         HDfree(buf);
     }
 
@@ -401,7 +401,6 @@ main(void)
     nerrors += test_timer_system_user()     < 0 ? 1 : 0;
     nerrors += test_timer_elapsed()         < 0 ? 1 : 0;
     nerrors += test_timer_functionality()   < 0 ? 1 : 0;
-    
 
     if(nerrors) {
         printf("***** %d platform-independent timer TEST%s FAILED! *****\n",
diff --git a/tools/test/perform/chunk_cache.c b/tools/test/perform/chunk_cache.c
index f630da72acf..d7c56afccf0 100644
--- a/tools/test/perform/chunk_cache.c
+++ b/tools/test/perform/chunk_cache.c
@@ -19,6 +19,7 @@
  */
 #include "hdf5.h"
 #include "H5private.h"
+#include "h5test.h"
 
 #define FILENAME    "chunk_cache_perf.h5"
 
@@ -98,8 +99,7 @@ static int create_dset1(hid_t file)
     hid_t        dcpl = H5I_INVALID_HID;
     hsize_t      dims[RANK]  = {DSET1_DIM1, DSET1_DIM2};
     hsize_t      chunk_dims[RANK] = {CHUNK1_DIM1, CHUNK1_DIM2};
-    int          data[DSET1_DIM1][DSET1_DIM2];    /* data for writing */
-    int          i, j;
+    int          **data;                /* data for writing */
 
     /* Create the data space. */
     if((dataspace = H5Screate_simple (RANK, dims, NULL)) < 0)
@@ -123,9 +123,10 @@ static int create_dset1(hid_t file)
                           H5P_DEFAULT, dcpl, H5P_DEFAULT)) < 0)
         goto error;
 
-    for (i = 0; i < DSET1_DIM1; i++)
-        for (j = 0; j < DSET1_DIM2; j++)
-            data[i][j] = i+j;
+    /* Create & fill array */
+    H5TEST_ALLOCATE_2D_ARRAY(data,  int,  DSET1_DIM1, DSET1_DIM2);
+    H5TEST_FILL_2D_ARRAY(data, int, DSET1_DIM1, DSET1_DIM2);
+
 
     /* Write data to dataset */
     if(H5Dwrite (dataset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL,
@@ -159,17 +160,16 @@ static int create_dset2(hid_t file)
     hid_t        dcpl = H5I_INVALID_HID;
     hsize_t      dims[RANK]  = {DSET2_DIM1, DSET2_DIM2};
     hsize_t      chunk_dims[RANK] = {CHUNK2_DIM1, CHUNK2_DIM2};
-    int          data[DSET2_DIM1][DSET2_DIM2];    /* data for writing */
-    int          i, j;
+    int          **data;                /* data for writing */
 
     /* Create the data space. */
-    if((dataspace = H5Screate_simple (RANK, dims, NULL)) < 0)
+    if((dataspace = H5Screate_simple(RANK, dims, NULL)) < 0)
         goto error;
 
     /* Modify dataset creation properties, i.e. enable chunking  */
-    if((dcpl = H5Pcreate (H5P_DATASET_CREATE)) < 0)
+    if((dcpl = H5Pcreate(H5P_DATASET_CREATE)) < 0)
         goto error;
-    if(H5Pset_chunk (dcpl, RANK, chunk_dims) < 0)
+    if(H5Pset_chunk(dcpl, RANK, chunk_dims) < 0)
         goto error;
 
     /* Set the dummy filter simply for counting the number of bytes being read into the memory */
@@ -179,35 +179,35 @@ static int create_dset2(hid_t file)
         goto error;
 
     /* Create a new dataset within the file using chunk creation properties.  */
-    if((dataset = H5Dcreate2 (file, DSET2_NAME, H5T_NATIVE_INT, dataspace,
+    if((dataset = H5Dcreate2(file, DSET2_NAME, H5T_NATIVE_INT, dataspace,
                           H5P_DEFAULT, dcpl, H5P_DEFAULT)) < 0)
         goto error;
 
-    for (i = 0; i < DSET2_DIM1; i++)
-        for (j = 0; j < DSET2_DIM2; j++)
-            data[i][j] = i+j;
+    /* Create & fill array */
+    H5TEST_ALLOCATE_2D_ARRAY(data,  int,  DSET2_DIM1, DSET2_DIM2);
+    H5TEST_FILL_2D_ARRAY(data, int, DSET2_DIM1, DSET2_DIM2);
 
     /* Write data to dataset */
-    if(H5Dwrite (dataset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL,
-                       H5P_DEFAULT, data) < 0)
+    if(H5Dwrite(dataset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, data) < 0)
         goto error;
 
     /* Close resources */
-    H5Dclose (dataset);
-    H5Pclose (dcpl);
-    H5Sclose (dataspace);
+    H5Dclose(dataset);
+    H5Pclose(dcpl);
+    H5Sclose(dataspace);
 
     return 0;
 
 error:
     H5E_BEGIN_TRY {
-        H5Dclose (dataset);
-        H5Pclose (dcpl);
-        H5Sclose (dataspace);
+        H5Dclose(dataset);
+        H5Pclose(dcpl);
+        H5Sclose(dataspace);
     } H5E_END_TRY;
 
     return 1;
 }
+
 /*---------------------------------------------------------------------------
  *      Check the performance of the chunk cache when partial chunks exist
  *      along the dataset dimensions.
@@ -257,7 +257,7 @@ static int check_partial_chunks_perf(hid_t file)
 
     end_t = H5_get_time();
 
-    if((end_t - start_t) > 0.0f)
+    if((end_t - start_t) > (double)0.0f)
         printf("1. Partial chunks: total read time is %lf; number of bytes being read from file is %lu\n", (end_t -start_t), nbytes_global);
     else
         printf("1. Partial chunks: no total read time because timer is not available; number of bytes being read from file is %lu\n", nbytes_global);
@@ -331,7 +331,7 @@ static int check_hash_value_perf(hid_t file)
 
     end_t = H5_get_time();
 
-    if((end_t - start_t) > 0.0)
+    if((end_t - start_t) > (double)0.0f)
         printf("2. Hash value: total read time is %lf; number of bytes being read from file is %lu\n", (end_t -start_t), nbytes_global);
     else
         printf("2. Hash value: no total read time because timer is not available; number of bytes being read from file is %lu\n", nbytes_global);

From c5258211e7ad24671ccd12889d3cbae3e2e5fe67 Mon Sep 17 00:00:00 2001
From: Quincey Koziol <koziol@koziol.gov>
Date: Sat, 27 Jun 2020 22:14:52 -0500
Subject: [PATCH 13/55] Add new source files to CMake build

---
 examples/CMakeLists.txt | 1 +
 test/CMakeLists.txt     | 1 +
 2 files changed, 2 insertions(+)

diff --git a/examples/CMakeLists.txt b/examples/CMakeLists.txt
index 1bcbbf294f9..527b11f8d4b 100644
--- a/examples/CMakeLists.txt
+++ b/examples/CMakeLists.txt
@@ -31,6 +31,7 @@ set (examples
     h5_extlink
     h5_elink_unix2win
     h5_shared_mesg
+    h5_debug_trace
     h5_vds
     h5_vds-exc
     h5_vds-exclim
diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt
index e3bfeb3292f..009a0717665 100644
--- a/test/CMakeLists.txt
+++ b/test/CMakeLists.txt
@@ -295,6 +295,7 @@ set (H5_TESTS
     swmr
     thread_id # special link
     vol
+    timer
 )
 
 macro (ADD_H5_EXE file)

From ef05e68c38d2086c6f262744b4087f65a6e58957 Mon Sep 17 00:00:00 2001
From: Jacob Smith <jake.smith@hdfgroup.org>
Date: Mon, 29 Jun 2020 12:06:57 -0500
Subject: [PATCH 14/55] Fix typo in HDftell macro definition: 'ftello -> ftell'

---
 src/H5private.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/H5private.h b/src/H5private.h
index aca4851b751..dc7ca579a47 100644
--- a/src/H5private.h
+++ b/src/H5private.h
@@ -959,7 +959,7 @@ typedef off_t               h5_stat_size_t;
 #define H5_SIZEOF_H5_STAT_SIZE_T H5_SIZEOF_OFF_T
 
 #ifndef HDftell
-    #define HDftell(F)    ftello(F)
+    #define HDftell(F)    ftell(F)
 #endif /* HDftell */
 #ifndef HDftruncate
     #define HDftruncate(F,L)        ftruncate(F,L)

From 7c006fd7617d54ab1b97e9aa1d7d8600385f3f3f Mon Sep 17 00:00:00 2001
From: Binh-Minh Ribler <bmribler@hdfgroup.org>
Date: Mon, 29 Jun 2020 14:16:35 -0500
Subject: [PATCH 15/55] - added comment to explain a kluge - added the
 associated entry to release notes

---
 release_docs/RELEASE.txt | 10 +++++++++-
 src/H5Fsuper.c           |  2 ++
 2 files changed, 11 insertions(+), 1 deletion(-)

diff --git a/release_docs/RELEASE.txt b/release_docs/RELEASE.txt
index 72cab28362c..d9267e8814f 100644
--- a/release_docs/RELEASE.txt
+++ b/release_docs/RELEASE.txt
@@ -631,7 +631,15 @@ Bug Fixes since HDF5-1.10.3 release
 
     Library
     -------
-    - Fixed the decoding of an attribute message to prevent a segfault by h52gif
+    - Fixed CVE-2020-10810
+
+      The tool h5clear produced a segfault during an error recovery in
+      the superblock decoding.  An internal pointer was reset to prevent
+      further accessing when it is not assigned with a value.
+
+      (BMR - 2020/6/29, HDFFV-11053)
+
+    - Fixed CVE-2018-17435
 
       The tool h52gif produced a segfault when the size of an attribute
       message was corrupted and caused a buffer overflow.
diff --git a/src/H5Fsuper.c b/src/H5Fsuper.c
index 40e93ec610d..459a0467f62 100644
--- a/src/H5Fsuper.c
+++ b/src/H5Fsuper.c
@@ -898,7 +898,9 @@ H5F__super_read(H5F_t *f, H5P_genplist_t *fa_plist, hbool_t initial_read)
                     else {
                         if(H5F__super_ext_remove_msg(f, H5O_FSINFO_ID) < 0)
                         {
+#if 1 /* when removing "KLUGE ALERT" above, tidy this up as well */ /* BMR */
                             f->shared->sblock = NULL;
+#endif /* BMR */
 
                             HGOTO_ERROR(H5E_FILE, H5E_CANTDELETE, FAIL,  "error in removing message from superblock extension")
                         }

From b155a777629e991374fa2f8609719cb861de4cc2 Mon Sep 17 00:00:00 2001
From: Binh-Minh Ribler <bmribler@hdfgroup.org>
Date: Tue, 30 Jun 2020 00:57:46 -0500
Subject: [PATCH 16/55] Changed wording in comment.

---
 src/H5Fsuper.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/H5Fsuper.c b/src/H5Fsuper.c
index 459a0467f62..9fd283126cb 100644
--- a/src/H5Fsuper.c
+++ b/src/H5Fsuper.c
@@ -898,9 +898,9 @@ H5F__super_read(H5F_t *f, H5P_genplist_t *fa_plist, hbool_t initial_read)
                     else {
                         if(H5F__super_ext_remove_msg(f, H5O_FSINFO_ID) < 0)
                         {
-#if 1 /* when removing "KLUGE ALERT" above, tidy this up as well */ /* BMR */
+#if 1 /* bug fix test code -- tidy this up if all goes well */ /* JRM */
                             f->shared->sblock = NULL;
-#endif /* BMR */
+#endif /* JRM */
 
                             HGOTO_ERROR(H5E_FILE, H5E_CANTDELETE, FAIL,  "error in removing message from superblock extension")
                         }

From 7371c83f9777b34b31909e99e052398b93c31bed Mon Sep 17 00:00:00 2001
From: Quincey Koziol <koziol@koziol.gov>
Date: Tue, 30 Jun 2020 08:53:17 -0500
Subject: [PATCH 17/55] Remove non-existent example

---
 examples/Makefile.am | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/examples/Makefile.am b/examples/Makefile.am
index 6c601b70bfe..944a9d80874 100644
--- a/examples/Makefile.am
+++ b/examples/Makefile.am
@@ -35,7 +35,7 @@ EXAMPLE_PROG = h5_write h5_read h5_extend_write h5_chunk_read h5_compound \
             h5_crtgrpd h5_subset h5_cmprss h5_rdwt h5_crtgrpar h5_extend \
             h5_crtatt h5_crtgrp h5_crtdat \
             h5_group h5_select h5_attribute h5_mount h5_drivers \
-            h5_reference_deprec h5_ref_extern h5_ref_compat h5_ref2reg h5_ref2reg_deprec \
+            h5_reference_deprec h5_ref_extern h5_ref_compat h5_ref2reg_deprec \
             h5_extlink h5_elink_unix2win h5_shared_mesg h5_debug_trace \
             h5_vds h5_vds-exc h5_vds-exclim h5_vds-eiger h5_vds-simpleIO \
             h5_vds-percival h5_vds-percival-unlim h5_vds-percival-unlim-maxmin
@@ -48,7 +48,7 @@ INSTALL_FILES = h5_write.c h5_read.c h5_extend_write.c h5_chunk_read.c h5_compou
             h5_crtgrpd.c h5_subset.c h5_cmprss.c h5_rdwt.c h5_crtgrpar.c h5_extend.c \
             h5_crtatt.c h5_crtgrp.c h5_crtdat.c \
             h5_group.c h5_select.c h5_attribute.c h5_mount.c h5_drivers.c \
-            h5_reference_deprec.c h5_ref_extern.c h5_ref_compat.c h5_ref2reg.c h5_ref2reg_deprec.c \
+            h5_reference_deprec.c h5_ref_extern.c h5_ref_compat.c h5_ref2reg_deprec.c \
             h5_extlink.c h5_elink_unix2win.c h5_shared_mesg.c h5_debug_trace.c \
             ph5example.c \
             h5_vds.c h5_vds-exc.c h5_vds-exclim.c h5_vds-eiger.c h5_vds-simpleIO.c \

From fc69de0e8ae30e80c1c3c542b156226a75444525 Mon Sep 17 00:00:00 2001
From: Larry Knox <lrknox@hdfgroup.org>
Date: Thu, 2 Jul 2020 11:29:12 -0500
Subject: [PATCH 18/55] Lib files needed are now copied to a subdirectory in
 the java/test directory, and on Macs the loader path for libhdf5.xxxs.so is
 changed in the temporary copy of libhdf5_java.dylib. Fix for HDFFV-11063

---
 configure.ac             | 5 ++++-
 java/test/junit.sh.in    | 8 ++++++++
 release_docs/RELEASE.txt | 8 ++++++++
 3 files changed, 20 insertions(+), 1 deletion(-)

diff --git a/configure.ac b/configure.ac
index 72223bbc66c..88157c3e2e7 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1150,10 +1150,13 @@ AC_CHECK_HEADERS([stdbool.h])
 AC_CHECK_HEADERS([netdb.h netinet/in.h arpa/inet.h])
 
 ## Darwin
+AC_SUBST([H5_IS_DARWIN])
+H5_IS_DARWIN="no
 case $host_os in
   darwin*)
     AC_DEFINE([HAVE_DARWIN], [1], [Define if Darwin or Mac OS X])
-  ;;
+    H5_IS_DARWIN="yes"
+    ;;
 esac
 
 ## Windows
diff --git a/java/test/junit.sh.in b/java/test/junit.sh.in
index d9ff5a594ee..cbc57e97740 100644
--- a/java/test/junit.sh.in
+++ b/java/test/junit.sh.in
@@ -20,6 +20,7 @@ USE_FILTER_SZIP="@USE_FILTER_SZIP@"
 USE_FILTER_DEFLATE="@USE_FILTER_DEFLATE@"
 USE_ROS3_VFD="@HAVE_ROS3_VFD@"
 USE_HDFS_VFD="@HAVE_LIBHDFS@"
+IS_DARWIN="@H5_IS_DARWIN@"
 
 TESTNAME=JUnitInterface
 EXIT_SUCCESS=0
@@ -145,6 +146,13 @@ COPY_LIBFILES_TO_BLDLIBDIR()
             fi
         fi
     done
+    if [ "$IS_DARWIN" = "yes" ]; then 
+       (cd testlibs; \
+         install_name_tool -add_rpath @loader_path libhdf5_java.dylib; \
+         exist_path=` otool -l libhdf5_java.dylib | grep libhdf5 | grep -v java | awk '{print $2}'`; \
+         echo $exist_path; \
+         install_name_tool -change $exist_path @rpath/libhdf5.1000.dylib libhdf5_java.dylib)
+    fi
     # copy jar files. Used -f to make sure get a new copy
     for tstfile in $COPY_JARTESTFILES
     do
diff --git a/release_docs/RELEASE.txt b/release_docs/RELEASE.txt
index d9267e8814f..665a156152e 100644
--- a/release_docs/RELEASE.txt
+++ b/release_docs/RELEASE.txt
@@ -1013,6 +1013,14 @@ Bug Fixes since HDF5-1.10.3 release
 
     Testing
     -------
+    - Stopped java/test/junit.sh.in installing libs for testing under ${prefix}
+
+      Lib files needed are now copied to a subdirectory in the java/test 
+      directory, and on Macs the loader path for libhdf5.xxxs.so is changed 
+      in the temporary copy of libhdf5_java.dylib. 
+
+      (LRK, 2020/7/2, HDFFV-11063)
+
     - Fixed a test failure in testpar/t_dset.c caused by
       the test trying to use the parallel filters feature
       on MPI-2 implementations.

From 88e8597cdef826c1087e4ec1383657a91dcb2a43 Mon Sep 17 00:00:00 2001
From: Allen Byrne <byrn@hdfgroup.org>
Date: Thu, 2 Jul 2020 13:52:03 -0500
Subject: [PATCH 19/55] Small changes discovered with mingw and windows defines
 moved

---
 config/cmake/HDFFortranCompilerFlags.cmake |   2 +-
 src/CMakeLists.txt                         |   4 +-
 src/H5I.c                                  | 240 ++++++++++-----------
 src/H5Tdbg.c                               |  52 ++---
 src/H5public.h                             | 100 +++------
 src/H5win32defs.h                          |  48 ++++-
 6 files changed, 222 insertions(+), 224 deletions(-)

diff --git a/config/cmake/HDFFortranCompilerFlags.cmake b/config/cmake/HDFFortranCompilerFlags.cmake
index 15edaa8ce52..2bbb35d8d82 100644
--- a/config/cmake/HDFFortranCompilerFlags.cmake
+++ b/config/cmake/HDFFortranCompilerFlags.cmake
@@ -48,7 +48,7 @@ endif ()
 # CDash is configured to only allow 3000 warnings, so
 # break into groups (from the config/gnu-flags file)
 #-----------------------------------------------------------------------------
-if (NOT MSVC)
+if (NOT MSVC AND NOT MINGW)
   # General flags
   if (CMAKE_Fortran_COMPILER_ID STREQUAL "Intel")
     ADD_H5_FLAGS (HDF5_CMAKE_Fortran_FLAGS "${HDF5_SOURCE_DIR}/config/intel-warnings/ifort-general")
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index c0915c8cbf3..39a9e3ea7e5 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -1139,7 +1139,7 @@ if (NOT ONLY_SHARED_LIBS)
   add_library (${HDF5_LIB_TARGET} STATIC ${common_SRCS} ${gen_SRCS} ${H5_PUBLIC_HEADERS} ${H5_PRIVATE_HEADERS} ${H5_GENERATED_HEADERS})
   target_include_directories (${HDF5_LIB_TARGET}
       PRIVATE "${HDF5_SRC_DIR};${HDF5_BINARY_DIR};$<$<BOOL:${HDF5_ENABLE_PARALLEL}>:${MPI_C_INCLUDE_DIRS}>"
-      INTERFACE "$<INSTALL_INTERFACE:$<INSTALL_PREFIX>/include>"
+      INTERFACE "$<INSTALL_INTERFACE:$<INSTALL_PREFIX>/include>;$<BUILD_INTERFACE:${HDF5_BINARY_DIR}>"
   )
   target_compile_options(${HDF5_LIB_TARGET} PRIVATE "${HDF5_CMAKE_C_FLAGS}")
   target_compile_definitions(${HDF5_LIB_TARGET}
@@ -1176,7 +1176,7 @@ if (BUILD_SHARED_LIBS)
   target_include_directories (${HDF5_LIBSH_TARGET}
       PRIVATE "${HDF5_SRC_DIR};${HDF5_BINARY_DIR};$<$<BOOL:${HDF5_ENABLE_PARALLEL}>:${MPI_C_INCLUDE_DIRS}>"
       PUBLIC "$<$<BOOL:${HDF5_ENABLE_HDFS}>:${HDFS_INCLUDE_DIR}>"
-      INTERFACE "$<INSTALL_INTERFACE:$<INSTALL_PREFIX>/include>"
+      INTERFACE "$<INSTALL_INTERFACE:$<INSTALL_PREFIX>/include>;$<BUILD_INTERFACE:${HDF5_BINARY_DIR}>"
   )
   target_compile_options(${HDF5_LIBSH_TARGET} PRIVATE "${HDF5_CMAKE_C_FLAGS}")
   target_compile_definitions(${HDF5_LIBSH_TARGET}
diff --git a/src/H5I.c b/src/H5I.c
index 1752e5e277c..11209d6f278 100644
--- a/src/H5I.c
+++ b/src/H5I.c
@@ -33,9 +33,9 @@
 #include "H5ACprivate.h"        /* Metadata cache                           */
 #include "H5CXprivate.h"        /* API Contexts                             */
 #include "H5Dprivate.h"         /* Datasets                                 */
-#include "H5Eprivate.h"		/* Error handling                           */
-#include "H5Fprivate.h"		/* File access				    */
-#include "H5FLprivate.h"	/* Free Lists                               */
+#include "H5Eprivate.h"        /* Error handling                           */
+#include "H5Fprivate.h"        /* File access                    */
+#include "H5FLprivate.h"    /* Free Lists                               */
 #include "H5Gprivate.h"         /* Groups                                   */
 #include "H5Ipkg.h"             /* IDs                                      */
 #include "H5MMprivate.h"        /* Memory management                        */
@@ -48,25 +48,25 @@
 /* Local Macros */
 
 /* Combine a Type number and an atom index into an atom */
-#define H5I_MAKE(g,i)	((((hid_t)(g) & TYPE_MASK) << ID_BITS) |	  \
-			     ((hid_t)(i) & ID_MASK))
+#define H5I_MAKE(g,i)    ((((hid_t)(g) & TYPE_MASK) << ID_BITS) |      \
+                ((hid_t)(i) & ID_MASK))
 
 /* Local typedefs */
 
 /* Atom information structure used */
 typedef struct H5I_id_info_t {
-    hid_t	id;		/* ID for this info			    */
-    unsigned	count;		/* ref. count for this atom		    */
+    hid_t    id;        /* ID for this info                */
+    unsigned    count;        /* ref. count for this atom            */
     unsigned    app_count;      /* ref. count of application visible atoms  */
-    const void	*obj_ptr;	/* pointer associated with the atom	    */
+    const void    *obj_ptr;    /* pointer associated with the atom        */
 } H5I_id_info_t;
 
 /* ID type structure used */
 typedef struct {
     const H5I_class_t *cls;     /* Pointer to ID class                      */
-    unsigned	init_count;	/* # of times this type has been initialized*/
-    uint64_t	id_count;	/* Current number of IDs held		    */
-    uint64_t	nextid;		/* ID to use for the next atom		    */
+    unsigned    init_count;    /* # of times this type has been initialized*/
+    uint64_t    id_count;    /* Current number of IDs held            */
+    uint64_t    nextid;        /* ID to use for the next atom            */
     H5I_id_info_t *last_info;   /* Info for most recent ID looked up        */
     H5SL_t      *ids;           /* Pointer to skip list that stores IDs     */
 } H5I_id_type_t;
@@ -145,7 +145,7 @@ static int H5I__iterate_pub_cb(void *obj, hid_t id, void *udata);
 static int H5I__find_id_cb(void *_item, void *_key, void *_udata);
 static int H5I__id_dump_cb(void *_item, void *_key, void *_udata);
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_term_package
  *
@@ -156,14 +156,14 @@ static int H5I__id_dump_cb(void *_item, void *_key, void *_udata);
  * Return:      Success:    Positive if any action was taken that might
  *                          affect some other interface; zero otherwise.
  *
- *              Failure:	Negative
+ *              Failure:    Negative
  *
  *-------------------------------------------------------------------------
  */
 int
 H5I_term_package(void)
 {
-    int	n = 0;
+    int    n = 0;
 
     FUNC_ENTER_NOAPI_NOINIT_NOERR
 
@@ -197,7 +197,7 @@ H5I_term_package(void)
     FUNC_LEAVE_NOAPI(n)
 } /* end H5I_term_package() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iregister_type
  *
@@ -278,7 +278,7 @@ H5Iregister_type(size_t H5_ATTR_DEBUG_API_USED hash_size, unsigned reserved,
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iregister_type() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_register_type
  *
@@ -293,7 +293,7 @@ H5Iregister_type(size_t H5_ATTR_DEBUG_API_USED hash_size, unsigned reserved,
 herr_t
 H5I_register_type(const H5I_class_t *cls)
 {
-    H5I_id_type_t *type_ptr = NULL;	/* Ptr to the atomic type*/
+    H5I_id_type_t *type_ptr = NULL;    /* Ptr to the atomic type*/
     herr_t ret_value = SUCCEED;         /* Return value */
 
     FUNC_ENTER_NOAPI(FAIL)
@@ -328,7 +328,7 @@ H5I_register_type(const H5I_class_t *cls)
     type_ptr->init_count++;
 
 done:
-    if(ret_value < 0) {	/* Clean up on error */
+    if(ret_value < 0) {    /* Clean up on error */
         if(type_ptr) {
             if(type_ptr->ids)
                 H5SL_close(type_ptr->ids);
@@ -339,7 +339,7 @@ H5I_register_type(const H5I_class_t *cls)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_register_type() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Itype_exists
  *
@@ -371,7 +371,7 @@ H5Itype_exists(H5I_type_t type)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Itype_exists() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Inmembers
  *
@@ -382,8 +382,8 @@ H5Itype_exists(H5I_type_t type)
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:	James Laird
- *		Nathaniel Furrer
+ * Programmer:    James Laird
+ *        Nathaniel Furrer
  *              Friday, April 23, 2004
  *
  *-------------------------------------------------------------------------
@@ -421,7 +421,7 @@ H5Inmembers(H5I_type_t type, hsize_t *num_members)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Inmembers() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_nmembers
  *
@@ -432,7 +432,7 @@ H5Inmembers(H5I_type_t type, hsize_t *num_members)
  *
  *              Failure:    Negative
  *
- * Programmer:	Robb Matzke
+ * Programmer:    Robb Matzke
  *              Wednesday, March 24, 1999
  *
  *-------------------------------------------------------------------------
@@ -458,7 +458,7 @@ H5I_nmembers(H5I_type_t type)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_nmembers() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__unwrap
  *
@@ -502,7 +502,7 @@ H5I__unwrap(void *obj_ptr, H5I_type_t type)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__unwrap() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iclear_type
  *
@@ -512,8 +512,8 @@ H5I__unwrap(void *obj_ptr, H5I_type_t type)
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:	James Laird
- *		Nathaniel Furrer
+ * Programmer:    James Laird
+ *        Nathaniel Furrer
  *              Friday, April 23, 2004
  *
  *-------------------------------------------------------------------------
@@ -535,7 +535,7 @@ H5Iclear_type(H5I_type_t type, hbool_t force)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iclear_type() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_clear_type
  *
@@ -544,7 +544,7 @@ H5Iclear_type(H5I_type_t type, hbool_t force)
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:	Robb Matzke
+ * Programmer:    Robb Matzke
  *              Wednesday, March 24, 1999
  *
  *-------------------------------------------------------------------------
@@ -577,7 +577,7 @@ H5I_clear_type(H5I_type_t type, hbool_t force, hbool_t app_ref)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_clear_type() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__clear_type_cb
  *
@@ -643,7 +643,7 @@ H5I__clear_type_cb(void *_id, void H5_ATTR_UNUSED *key, void *_udata)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__clear_type_cb() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Idestroy_type
  *
@@ -655,8 +655,8 @@ H5I__clear_type_cb(void *_id, void H5_ATTR_UNUSED *key, void *_udata)
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:	Nathaniel Furrer
- *		James Laird
+ * Programmer:    Nathaniel Furrer
+ *        James Laird
  *
  *-------------------------------------------------------------------------
  */
@@ -677,7 +677,7 @@ H5Idestroy_type(H5I_type_t type)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Idestroy_type() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__destroy_type
  *
@@ -688,15 +688,15 @@ H5Idestroy_type(H5I_type_t type)
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:	Nathaniel Furrer
- *		James Laird
+ * Programmer:    Nathaniel Furrer
+ *        James Laird
  *
  *-------------------------------------------------------------------------
  */
 static herr_t
 H5I__destroy_type(H5I_type_t type)
 {
-    H5I_id_type_t *type_ptr;	/* ptr to the atomic type */
+    H5I_id_type_t *type_ptr;    /* ptr to the atomic type */
     herr_t ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_STATIC
@@ -729,7 +729,7 @@ H5I__destroy_type(H5I_type_t type)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__destroy_type() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iregister
  *
@@ -757,7 +757,7 @@ H5Iregister(H5I_type_t type, const void *object)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iregister() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_register
  *
@@ -819,7 +819,7 @@ H5I_register(H5I_type_t type, const void *object, hbool_t app_ref)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_register() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_register_using_existing_id
  *
@@ -890,7 +890,7 @@ H5I_register_using_existing_id(H5I_type_t type, void *object, hbool_t app_ref, h
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_register_using_existing_id() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_subst
  *
@@ -900,8 +900,8 @@ H5I_register_using_existing_id(H5I_type_t type, void *object, hbool_t app_ref, h
  *                          with the specified ID.
  *              Failure:    NULL
  *
- * Programmer:	Quincey Koziol
- *		Saturday, February 27, 2010
+ * Programmer:    Quincey Koziol
+ *        Saturday, February 27, 2010
  *
  *-------------------------------------------------------------------------
  */
@@ -909,7 +909,7 @@ void *
 H5I_subst(hid_t id, const void *new_object)
 {
     H5I_id_info_t *id_ptr;      /* Pointer to the atom */
-    void *ret_value = NULL;	/* Return value */
+    void *ret_value = NULL;    /* Return value */
 
     FUNC_ENTER_NOAPI(NULL)
 
@@ -927,7 +927,7 @@ H5I_subst(hid_t id, const void *new_object)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_subst() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_object
  *
@@ -943,8 +943,8 @@ H5I_subst(hid_t id, const void *new_object)
 void *
 H5I_object(hid_t id)
 {
-    H5I_id_info_t	*id_ptr;            /* Pointer to the new atom  */
-    void		    *ret_value = NULL;  /* Return value             */
+    H5I_id_info_t    *id_ptr;            /* Pointer to the new atom  */
+    void            *ret_value = NULL;  /* Return value             */
 
     FUNC_ENTER_NOAPI_NOERR
 
@@ -957,7 +957,7 @@ H5I_object(hid_t id)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_object() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iobject_verify
  *
@@ -991,7 +991,7 @@ H5Iobject_verify(hid_t id, H5I_type_t id_type)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iobject_verify() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_object_verify
  *
@@ -1002,8 +1002,8 @@ H5Iobject_verify(hid_t id, H5I_type_t id_type)
  *                          specified ID.
  *              Failure:    NULL
  *
- * Programmer:	Quincey Koziol
- *		Wednesday, July 31, 2002
+ * Programmer:    Quincey Koziol
+ *        Wednesday, July 31, 2002
  *
  *-------------------------------------------------------------------------
  */
@@ -1026,7 +1026,7 @@ H5I_object_verify(hid_t id, H5I_type_t id_type)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* H5I_object_verify() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_get_type
  *
@@ -1040,8 +1040,8 @@ H5I_object_verify(hid_t id, H5I_type_t id_type)
  *                          ID types).
  *              Failure:    H5I_BADID
  *
- * Programmer:	Robb Matzke
- *		Friday, February 19, 1999
+ * Programmer:    Robb Matzke
+ *        Friday, February 19, 1999
  *
  *-------------------------------------------------------------------------
  */
@@ -1060,7 +1060,7 @@ H5I_get_type(hid_t id)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_get_type() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iget_type
  *
@@ -1087,13 +1087,13 @@ H5Iget_type(hid_t id)
     ret_value = H5I_get_type(id);
 
     if(ret_value <= H5I_BADID || (int)ret_value >= H5I_next_type || NULL == H5I_object(id))
-	HGOTO_DONE(H5I_BADID);
+    HGOTO_DONE(H5I_BADID);
 
 done:
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iget_type() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_is_file_object
  *
@@ -1144,7 +1144,7 @@ H5I_is_file_object(hid_t id)
     FUNC_LEAVE_NOAPI(ret_value);
 } /* H5I_is_file_object() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iremove_verify
  *
@@ -1157,8 +1157,8 @@ H5I_is_file_object(hid_t id)
  *                          calling H5I_object().
  *              Failure:    NULL
  *
- * Programmer:	James Laird
- *		Nathaniel Furrer
+ * Programmer:    James Laird
+ *        Nathaniel Furrer
  *
  *-------------------------------------------------------------------------
  */
@@ -1180,7 +1180,7 @@ H5Iremove_verify(hid_t id, H5I_type_t id_type)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iremove_verify() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__remove_verify
  *
@@ -1192,15 +1192,15 @@ H5Iremove_verify(hid_t id, H5I_type_t id_type)
  *                          calling H5I_object().
  *              Failure:    NULL
  *
- * Programmer:	James Laird
- *		Nat Furrer
+ * Programmer:    James Laird
+ *        Nat Furrer
  *
  *-------------------------------------------------------------------------
  */
 static void *
 H5I__remove_verify(hid_t id, H5I_type_t id_type)
 {
-    void * ret_value = NULL;	/*return value			*/
+    void * ret_value = NULL;    /*return value            */
 
     FUNC_ENTER_STATIC_NOERR
 
@@ -1213,7 +1213,7 @@ H5I__remove_verify(hid_t id, H5I_type_t id_type)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__remove_verify() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__remove_common
  *
@@ -1232,8 +1232,8 @@ H5I__remove_verify(hid_t id, H5I_type_t id_type)
 static void *
 H5I__remove_common(H5I_id_type_t *type_ptr, hid_t id)
 {
-    H5I_id_info_t *curr_id;	/* Pointer to the current atom */
-    void *ret_value = NULL;	/* Return value */
+    H5I_id_info_t *curr_id;    /* Pointer to the current atom */
+    void *ret_value = NULL;    /* Return value */
 
     FUNC_ENTER_STATIC
 
@@ -1258,7 +1258,7 @@ H5I__remove_common(H5I_id_type_t *type_ptr, hid_t id)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__remove_common() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_remove
  *
@@ -1269,16 +1269,16 @@ H5I__remove_common(H5I_id_type_t *type_ptr, hid_t id)
  *                          calling H5I_object().
  *              Failure:    NULL
  *
- * Programmer:	Unknown
+ * Programmer:    Unknown
  *
  *-------------------------------------------------------------------------
  */
 void *
 H5I_remove(hid_t id)
 {
-    H5I_id_type_t	*type_ptr;	        /* Pointer to the atomic type */
-    H5I_type_t		type;		        /* Atom's atomic type */
-    void *	        ret_value = NULL;	/* Return value */
+    H5I_id_type_t    *type_ptr;            /* Pointer to the atomic type */
+    H5I_type_t        type;                /* Atom's atomic type */
+    void *            ret_value = NULL;    /* Return value */
 
     FUNC_ENTER_NOAPI(NULL)
 
@@ -1298,7 +1298,7 @@ H5I_remove(hid_t id)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_remove() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Idec_ref
  *
@@ -1334,7 +1334,7 @@ H5Idec_ref(hid_t id)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Idec_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_dec_ref
  *
@@ -1380,7 +1380,7 @@ H5I_dec_ref(hid_t id)
      * file.  We have to close the dataset anyway. (SLU - 2010/9/7)
      */
     if(1 == id_ptr->count) {
-        H5I_id_type_t	*type_ptr;		/*ptr to the type	*/
+        H5I_id_type_t    *type_ptr;        /*ptr to the type    */
 
         /* Get the ID's type */
         type_ptr = H5I_id_type_list_g[H5I_TYPE(id)];
@@ -1404,7 +1404,7 @@ H5I_dec_ref(hid_t id)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_dec_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_dec_app_ref
  *
@@ -1452,7 +1452,7 @@ H5I_dec_app_ref(hid_t id)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_dec_app_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_dec_app_ref_always_close
  *
@@ -1494,7 +1494,7 @@ H5I_dec_app_ref_always_close(hid_t id)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_dec_app_ref_always_close() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iinc_ref
  *
@@ -1525,7 +1525,7 @@ H5Iinc_ref(hid_t id)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iinc_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_inc_ref
  *
@@ -1563,7 +1563,7 @@ H5I_inc_ref(hid_t id, hbool_t app_ref)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_inc_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iget_ref
  *
@@ -1594,7 +1594,7 @@ H5Iget_ref(hid_t id)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iget_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_get_ref
  *
@@ -1627,7 +1627,7 @@ H5I_get_ref(hid_t id, hbool_t app_ref)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_get_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iinc_type_ref
  *
@@ -1660,7 +1660,7 @@ H5Iinc_type_ref(H5I_type_t type)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iinc_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__inc_type_ref
  *
@@ -1694,14 +1694,14 @@ H5I__inc_type_ref(H5I_type_t type)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__inc_type_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Idec_type_ref
  *
  * Purpose:     Decrements the reference count on an entire type of IDs.
  *              If the type reference count becomes zero then the type is
  *              destroyed along with all atoms in that type regardless of
- *              their reference counts.	 Destroying IDs involves calling
+ *              their reference counts.     Destroying IDs involves calling
  *              the free-func for each ID's object and then adding the ID
  *              struct to the ID free list.  Public interface to
  *              H5I_dec_type_ref.
@@ -1736,14 +1736,14 @@ H5Idec_type_ref(H5I_type_t type)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Idec_type_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_dec_type_ref
  *
  * Purpose:     Decrements the reference count on an entire type of IDs.
  *              If the type reference count becomes zero then the type is
  *              destroyed along with all atoms in that type regardless of
- *              their reference counts.	 Destroying IDs involves calling
+ *              their reference counts.     Destroying IDs involves calling
  *              the free-func for each ID's object and then adding the ID
  *              struct to the ID free list.
  *              Returns the number of references to the type on success; a
@@ -1789,7 +1789,7 @@ H5I_dec_type_ref(H5I_type_t type)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_dec_type_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iget_type_ref
  *
@@ -1822,7 +1822,7 @@ H5Iget_type_ref(H5I_type_t type)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iget_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__get_type_ref
  *
@@ -1857,7 +1857,7 @@ H5I__get_type_ref(H5I_type_t type)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__get_type_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iis_valid
  *
@@ -1887,7 +1887,7 @@ H5Iis_valid(hid_t id)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iis_valid() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__search_cb
  *
@@ -1913,7 +1913,7 @@ H5I__search_cb(void *obj, hid_t id, void *_udata)
 
     /* Set the return value based on the callback's return value */
     if(cb_ret_val > 0) {
-        ret_value = H5_ITER_STOP;	/* terminate iteration early */
+        ret_value = H5_ITER_STOP;    /* terminate iteration early */
         udata->ret_obj = obj;       /* also set out parameter */
     }
     else if(cb_ret_val < 0)
@@ -1922,7 +1922,7 @@ H5I__search_cb(void *obj, hid_t id, void *_udata)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__search_cb() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Isearch
  *
@@ -1973,7 +1973,7 @@ H5Isearch(H5I_type_t type, H5I_search_func_t func, void *key)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Isearch() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__iterate_pub_cb
  *
@@ -2004,7 +2004,7 @@ H5I__iterate_pub_cb(void H5_ATTR_UNUSED *obj, hid_t id, void *_udata)
 
     /* Set the return value based on the callback's return value */
     if(cb_ret_val > 0)
-        ret_value = H5_ITER_STOP;	/* terminate iteration early */
+        ret_value = H5_ITER_STOP;    /* terminate iteration early */
     else if(cb_ret_val < 0)
         ret_value = H5_ITER_ERROR;  /* indicate failure (which terminates iteration) */
     else
@@ -2013,7 +2013,7 @@ H5I__iterate_pub_cb(void H5_ATTR_UNUSED *obj, hid_t id, void *_udata)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__iterate_pub_cb() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iiterate
  *
@@ -2060,7 +2060,7 @@ H5Iiterate(H5I_type_t type, H5I_iterate_func_t op, void *op_data)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iiterate() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__iterate_cb
  *
@@ -2100,7 +2100,7 @@ H5I__iterate_cb(void *_item, void H5_ATTR_UNUSED *_key, void *_udata)
 
         /* Set the return value based on the callback's return value */
         if(cb_ret_val > 0)
-            ret_value = H5_ITER_STOP;	/* terminate iteration early */
+            ret_value = H5_ITER_STOP;    /* terminate iteration early */
         else if(cb_ret_val < 0)
             ret_value = H5_ITER_ERROR;  /* indicate failure (which terminates iteration) */
     } /* end if */
@@ -2108,9 +2108,9 @@ H5I__iterate_cb(void *_item, void H5_ATTR_UNUSED *_key, void *_udata)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__iterate_cb() */
 
-
+
 /*-------------------------------------------------------------------------
- * Function:	H5I_iterate
+ * Function:    H5I_iterate
  *
  * Purpose:     Apply function FUNC to each member of type TYPE (with
  *              non-zero application reference count if app_ref is TRUE).
@@ -2138,7 +2138,7 @@ herr_t
 H5I_iterate(H5I_type_t type, H5I_search_func_t func, void *udata, hbool_t app_ref)
 {
     H5I_id_type_t *type_ptr;            /* Pointer to the type  */
-    herr_t	   ret_value = SUCCEED;     /* Return value         */
+    herr_t       ret_value = SUCCEED;     /* Return value         */
 
     FUNC_ENTER_NOAPI(FAIL)
 
@@ -2167,7 +2167,7 @@ H5I_iterate(H5I_type_t type, H5I_search_func_t func, void *udata, hbool_t app_re
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_iterate() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__find_id
  *
@@ -2183,9 +2183,9 @@ H5I_iterate(H5I_type_t type, H5I_search_func_t func, void *udata, hbool_t app_re
 static H5I_id_info_t *
 H5I__find_id(hid_t id)
 {
-    H5I_type_t		type;			/*ID's type		*/
-    H5I_id_type_t	*type_ptr;		/*ptr to the type	*/
-    H5I_id_info_t	*ret_value = NULL;	/* Return value */
+    H5I_type_t        type;            /*ID's type        */
+    H5I_id_type_t    *type_ptr;        /*ptr to the type    */
+    H5I_id_info_t    *ret_value = NULL;    /* Return value */
 
     FUNC_ENTER_STATIC_NOERR
 
@@ -2212,7 +2212,7 @@ H5I__find_id(hid_t id)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__find_id() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iget_name
  *
@@ -2263,7 +2263,7 @@ H5Iget_name(hid_t id, char *name/*out*/, size_t size)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iget_name() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iget_file_id
  *
@@ -2307,7 +2307,7 @@ H5Iget_file_id(hid_t obj_id)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iget_file_id() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__find_id_cb
  *
@@ -2345,7 +2345,7 @@ H5I__find_id_cb(void *_item, void H5_ATTR_UNUSED *_key, void *_udata)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__find_id_cb() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_find_id
  *
@@ -2394,7 +2394,7 @@ H5I_find_id(const void *object, H5I_type_t type, hid_t *id)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_find_id() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__id_dump_cb
  *
@@ -2414,9 +2414,9 @@ H5I__id_dump_cb(void *_item, void H5_ATTR_UNUSED *_key, void *_udata)
 
     FUNC_ENTER_STATIC_NOERR
 
-    HDfprintf(stderr, "		 id = %lu\n", (unsigned long)(item->id));
-    HDfprintf(stderr, "		 count = %u\n", item->count);
-    HDfprintf(stderr, "		 obj   = 0x%08lx\n", (unsigned long)(item->obj_ptr));
+    HDfprintf(stderr, "         id = %lu\n", (unsigned long)(item->id));
+    HDfprintf(stderr, "         count = %u\n", item->count);
+    HDfprintf(stderr, "         obj   = 0x%08p\n", item->obj_ptr);
 
     /* Get the group location, so we get get the name */
     switch (type) {
@@ -2482,7 +2482,7 @@ H5I__id_dump_cb(void *_item, void H5_ATTR_UNUSED *_key, void *_udata)
     FUNC_LEAVE_NOAPI(H5_ITER_CONT)
 } /* end H5I__id_dump_cb() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_dump_ids_for_type
  *
@@ -2505,14 +2505,14 @@ H5I_dump_ids_for_type(H5I_type_t type)
     if(type_ptr) {
 
         /* Header */
-        HDfprintf(stderr, "	 init_count = %u\n", type_ptr->init_count);
-        HDfprintf(stderr, "	 reserved   = %u\n", type_ptr->cls->reserved);
-        HDfprintf(stderr, "	 id_count   = %llu\n", (unsigned long long)type_ptr->id_count);
-        HDfprintf(stderr, "	 nextid	    = %llu\n", (unsigned long long)type_ptr->nextid);
+        HDfprintf(stderr, "     init_count = %u\n", type_ptr->init_count);
+        HDfprintf(stderr, "     reserved   = %u\n", type_ptr->cls->reserved);
+        HDfprintf(stderr, "     id_count   = %llu\n", (unsigned long long)type_ptr->id_count);
+        HDfprintf(stderr, "     nextid        = %llu\n", (unsigned long long)type_ptr->nextid);
 
         /* List */
         if(type_ptr->id_count > 0) {
-            HDfprintf(stderr, "	 List:\n");
+            HDfprintf(stderr, "     List:\n");
             H5SL_iterate(type_ptr->ids, H5I__id_dump_cb, &type);
         }
     }
diff --git a/src/H5Tdbg.c b/src/H5Tdbg.c
index 693174adf85..7af736afe73 100644
--- a/src/H5Tdbg.c
+++ b/src/H5Tdbg.c
@@ -13,11 +13,11 @@
 
 /*-------------------------------------------------------------------------
  *
- * Created:		H5Tdbg.c
- *			Jul 19 2007
- *			Quincey Koziol <koziol@hdfgroup.org>
+ * Created:        H5Tdbg.c
+ *            Jul 19 2007
+ *            Quincey Koziol <koziol@hdfgroup.org>
  *
- * Purpose:		Dump debugging information about a datatype
+ * Purpose:        Dump debugging information about a datatype
  *
  *-------------------------------------------------------------------------
  */
@@ -72,7 +72,7 @@
 /*******************/
 
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5T__print_stats
  *
@@ -99,18 +99,18 @@ H5T__print_stats(H5T_path_t H5_ATTR_UNUSED * path, int H5_ATTR_UNUSED * nprint/*
 
 #ifdef H5T_DEBUG
     if(H5DEBUG(T) && path->stats.ncalls > 0) {
-        hsize_t	nbytes;
-        char	bandwidth[32];
-
-	if(nprint && 0 == (*nprint)++) {
-	    HDfprintf(H5DEBUG(T), "H5T: type conversion statistics:\n");
-	    HDfprintf(H5DEBUG(T), "   %-16s %10s %10s %8s %8s %8s %10s\n",
-		       "Conversion", "Elmts", "Calls", "User",
-		       "System", "Elapsed", "Bandwidth");
-	    HDfprintf(H5DEBUG(T), "   %-16s %10s %10s %8s %8s %8s %10s\n",
-		       "----------", "-----", "-----", "----",
-		       "------", "-------", "---------");
-	} /* end if */
+        hsize_t    nbytes;
+        char    bandwidth[32];
+
+    if(nprint && 0 == (*nprint)++) {
+        HDfprintf(H5DEBUG(T), "H5T: type conversion statistics:\n");
+        HDfprintf(H5DEBUG(T), "   %-16s %10s %10s %8s %8s %8s %10s\n",
+            "Conversion", "Elmts", "Calls", "User",
+            "System", "Elapsed", "Bandwidth");
+        HDfprintf(H5DEBUG(T), "   %-16s %10s %10s %8s %8s %8s %10s\n",
+            "----------", "-----", "-----", "----",
+            "------", "-------", "---------");
+    } /* end if */
 
         if(path->src && path->dst)
             nbytes = MAX(H5T_get_size(path->src), H5T_get_size(path->dst));
@@ -121,23 +121,23 @@ H5T__print_stats(H5T_path_t H5_ATTR_UNUSED * path, int H5_ATTR_UNUSED * nprint/*
         else
             nbytes = 0;
 
-	nbytes *= path->stats.nelmts;
+    nbytes *= path->stats.nelmts;
         H5_bandwidth(bandwidth, (double)nbytes, path->stats.times.elapsed);
         HDfprintf(H5DEBUG(T), "   %-16s %10Hd %10d %8T %8T %8T %10s\n",
-		   path->name,
-		   path->stats.nelmts,
-		   path->stats.ncalls,
+        path->name,
+        path->stats.nelmts,
+        path->stats.ncalls,
                    path->stats.times.user,
                    path->stats.times.system,
                    path->stats.times.elapsed,
-		   bandwidth);
+        bandwidth);
     } /* end if */
 #endif
 
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5T__print_stats() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5T_debug
  *
@@ -406,18 +406,18 @@ H5T_debug(const H5T_t *dt, FILE *stream)
         } /* end else */
     }
     else if (H5T_ENUM == dt->shared->type) {
-        size_t	base_size;
+        size_t    base_size;
 
         /* Enumeration data type */
         HDfprintf(stream, " ");
         H5T_debug(dt->shared->parent, stream);
         base_size = dt->shared->parent->shared->size;
         for (i = 0; i < dt->shared->u.enumer.nmembs; i++) {
-            size_t	k;
+            size_t    k;
 
             HDfprintf(stream, "\n\"%s\" = 0x", dt->shared->u.enumer.name[i]);
             for (k = 0; k < base_size; k++)
-                HDfprintf(stream, "%02lx", (unsigned long)((uint8_t *)dt->shared->u.enumer.value + (i * base_size) + k));
+                HDfprintf(stream, "%02p", ((uint8_t *)dt->shared->u.enumer.value + (i * base_size) + k));
         } /* end for */
         HDfprintf(stream, "\n");
     }
diff --git a/src/H5public.h b/src/H5public.h
index 0fd9f3bc4fa..93cb2ea071e 100644
--- a/src/H5public.h
+++ b/src/H5public.h
@@ -26,7 +26,7 @@
  * it via H5public.h.  The #ifndef _H5public_H guard above would
  * prevent repeated include.
  */
-#include "H5pubconf.h"		/*from configure                             */
+#include "H5pubconf.h"        /*from configure                             */
 
 /* API Version macro wrapper definitions */
 #include "H5version.h"
@@ -38,58 +38,20 @@
 #include <sys/types.h>
 #endif
 #ifdef H5_STDC_HEADERS
-#   include <limits.h>		/*for H5T_NATIVE_CHAR defn in H5Tpublic.h    */
+#   include <limits.h>        /*for H5T_NATIVE_CHAR defn in H5Tpublic.h    */
 #   include <stdarg.h>      /*for variadic functions in H5VLpublic.h     */
 #endif
 #ifndef __cplusplus
 # ifdef H5_HAVE_STDINT_H
-#   include <stdint.h>		/*for C9x types				     */
+#   include <stdint.h>        /*for C9x types                     */
 # endif
 #else
 # ifdef H5_HAVE_STDINT_H_CXX
-#   include <stdint.h>		/*for C9x types	when include from C++	     */
+#   include <stdint.h>        /*for C9x types    when include from C++         */
 # endif
 #endif
 #ifdef H5_HAVE_INTTYPES_H
 #   include <inttypes.h>        /* C99/POSIX.1 header for uint64_t, PRIu64 */
-#else /* H5_HAVE_INTTYPES_H */
-/* The following definitions should be suitable for 64-bit Windows, which is
- * LLP64, and for 32-bit Windows, which is ILP32.  Those are the only
- * platforms where <inttypes.h> is likely to be missing.  VS2015 and later
- * *may* provide these definitions.
- */
-#ifdef _WIN64
-#       define PRIdPTR "lld"
-#       define PRIoPTR "llo"
-#       define PRIuPTR "llu"
-#       define PRIxPTR "llx"
-#else /* _WIN64 */
-#       define PRIdPTR "ld"
-#       define PRIoPTR "lo"
-#       define PRIuPTR "lu"
-#       define PRIxPTR "lx"
-#endif /* _WIN64 */
-
-#   define PRId8 "d"
-#   define PRIo8 "o"
-#   define PRIu8 "u"
-#   define PRIx8 "x"
-#   define PRId16 "d"
-#   define PRIo16 "o"
-#   define PRIu16 "u"
-#   define PRIx16 "x"
-#   define PRId32 "d"
-#   define PRIo32 "o"
-#   define PRIu32 "u"
-#   define PRIx32 "x"
-#   define PRId64 "lld"
-#   define PRIo64 "llo"
-#   define PRIu64 "llu"
-#   define PRIx64 "llx"
-#   define PRIdMAX "lld"
-#   define PRIoMAX "llo"
-#   define PRIuMAX "llu"
-#   define PRIxMAX "llx"
 #endif
 #ifdef H5_HAVE_STDDEF_H
 #   include <stddef.h>
@@ -99,7 +61,7 @@
 #   define MPICH_SKIP_MPICXX 1
 #   define OMPI_SKIP_MPICXX 1
 #   include <mpi.h>
-#ifndef MPI_FILE_NULL		/*MPIO may be defined in mpi.h already       */
+#ifndef MPI_FILE_NULL        /*MPIO may be defined in mpi.h already       */
 #   include <mpio.h>
 #endif
 #endif
@@ -132,15 +94,15 @@ extern "C" {
 #endif
 
 /* Version numbers */
-#define H5_VERS_MAJOR	1	/* For major interface/format changes  	     */
-#define H5_VERS_MINOR	13	/* For minor interface/format changes  	     */
-#define H5_VERS_RELEASE	0	/* For tweaks, bug-fixes, or development     */
-#define H5_VERS_SUBRELEASE ""	/* For pre-releases like snap0       */
-				/* Empty string for real releases.           */
+#define H5_VERS_MAJOR    1    /* For major interface/format changes           */
+#define H5_VERS_MINOR    13    /* For minor interface/format changes           */
+#define H5_VERS_RELEASE    0    /* For tweaks, bug-fixes, or development     */
+#define H5_VERS_SUBRELEASE ""    /* For pre-releases like snap0       */
+                /* Empty string for real releases.           */
 #define H5_VERS_INFO    "HDF5 library version: 1.13.0"      /* Full version string */
 
-#define H5check()	H5check_version(H5_VERS_MAJOR,H5_VERS_MINOR,	      \
-				        H5_VERS_RELEASE)
+#define H5check()    H5check_version(H5_VERS_MAJOR,H5_VERS_MINOR,          \
+                        H5_VERS_RELEASE)
 
 /* macros for comparing the version */
 #define H5_VERSION_GE(Maj,Min,Rel) \
@@ -160,8 +122,8 @@ extern "C" {
  * The negative failure value is most commonly -1, but don't bet on it.  The
  * proper way to detect failure is something like:
  *
- * 	if((dset = H5Dopen2(file, name)) < 0)
- *	    fprintf(stderr, "unable to open the requested dataset\n");
+ *     if((dset = H5Dopen2(file, name)) < 0)
+ *        fprintf(stderr, "unable to open the requested dataset\n");
  */
 typedef int herr_t;
 
@@ -173,13 +135,13 @@ typedef int herr_t;
  * (false), positive (true), or negative (failure). The proper way to test
  * for truth from a htri_t function is:
  *
- * 	if ((retval = H5Tcommitted(type))>0) {
- *	    printf("data type is committed\n");
- *	} else if (!retval) {
- * 	    printf("data type is not committed\n");
- *	} else {
- * 	    printf("error determining whether data type is committed\n");
- *	}
+ *     if ((retval = H5Tcommitted(type))>0) {
+ *        printf("data type is committed\n");
+ *    } else if (!retval) {
+ *         printf("data type is not committed\n");
+ *    } else {
+ *         printf("error determining whether data type is committed\n");
+ *    }
  */
 #ifdef H5_HAVE_STDBOOL_H
   #include <stdbool.h>
@@ -221,8 +183,8 @@ typedef long long ssize_t;
  */
 #if H5_SIZEOF_LONG_LONG >= 8
 H5_GCC_DIAG_OFF(long-long)
-typedef unsigned long long 	hsize_t;
-typedef signed long long	hssize_t;
+typedef unsigned long long     hsize_t;
+typedef signed long long    hssize_t;
 H5_GCC_DIAG_ON(long-long)
 #       define H5_SIZEOF_HSIZE_T H5_SIZEOF_LONG_LONG
 #       define H5_SIZEOF_HSSIZE_T H5_SIZEOF_LONG_LONG
@@ -267,7 +229,7 @@ H5_GCC_DIAG_ON(long-long)
 #else
 #   error "nothing appropriate for H5_PRINTF_HADDR_FMT"
 #endif
-#define HADDR_MAX		(HADDR_UNDEF-1)
+#define HADDR_MAX        (HADDR_UNDEF-1)
 
 /* uint32_t type is used for creation order field for messages.  It may be
  * defined in Posix.1g, otherwise it is defined here.
@@ -335,7 +297,7 @@ typedef enum {
     H5_ITER_INC,                /* Increasing order */
     H5_ITER_DEC,                /* Decreasing order */
     H5_ITER_NATIVE,             /* No particular order, whatever is fastest */
-    H5_ITER_N		        /* Number of iteration orders */
+    H5_ITER_N                /* Number of iteration orders */
 } H5_iter_order_t;
 
 /* Iteration callback values */
@@ -352,10 +314,10 @@ typedef enum {
  * links in groups/attributes on objects.
  */
 typedef enum H5_index_t {
-    H5_INDEX_UNKNOWN = -1,	/* Unknown index type			*/
-    H5_INDEX_NAME,		/* Index on names 			*/
-    H5_INDEX_CRT_ORDER,		/* Index on creation order 		*/
-    H5_INDEX_N			/* Number of indices defined 		*/
+    H5_INDEX_UNKNOWN = -1,    /* Unknown index type            */
+    H5_INDEX_NAME,        /* Index on names             */
+    H5_INDEX_CRT_ORDER,        /* Index on creation order         */
+    H5_INDEX_N            /* Number of indices defined         */
 } H5_index_t;
 
 /*
@@ -403,9 +365,9 @@ H5_DLL herr_t H5get_free_list_sizes(size_t *reg_size, size_t *arr_size,
     size_t *blk_size, size_t *fac_size);
 H5_DLL herr_t H5get_alloc_stats(H5_alloc_stats_t *stats);
 H5_DLL herr_t H5get_libversion(unsigned *majnum, unsigned *minnum,
-				unsigned *relnum);
+                unsigned *relnum);
 H5_DLL herr_t H5check_version(unsigned majnum, unsigned minnum,
-			       unsigned relnum);
+                unsigned relnum);
 H5_DLL herr_t H5is_library_threadsafe(hbool_t *is_ts);
 H5_DLL herr_t H5free_memory(void *mem);
 H5_DLL void *H5allocate_memory(size_t size, hbool_t clear);
diff --git a/src/H5win32defs.h b/src/H5win32defs.h
index 00df56d1802..71162eb4f25 100644
--- a/src/H5win32defs.h
+++ b/src/H5win32defs.h
@@ -20,6 +20,45 @@
  *          inside H5private.h
  *
  */
+#ifndef H5_HAVE_INTTYPES_H
+/* The following definitions should be suitable for 64-bit Windows, which is
+ * LLP64, and for 32-bit Windows, which is ILP32.  Those are the only
+ * platforms where <inttypes.h> is likely to be missing.  VS2015 and later
+ * *may* provide these definitions.
+ */
+#ifdef _WIN64
+#       define PRIdPTR "lld"
+#       define PRIoPTR "llo"
+#       define PRIuPTR "llu"
+#       define PRIxPTR "llx"
+#else /* _WIN64 */
+#       define PRIdPTR "ld"
+#       define PRIoPTR "lo"
+#       define PRIuPTR "lu"
+#       define PRIxPTR "lx"
+#endif /* _WIN64 */
+
+#   define PRId8 "d"
+#   define PRIo8 "o"
+#   define PRIu8 "u"
+#   define PRIx8 "x"
+#   define PRId16 "d"
+#   define PRIo16 "o"
+#   define PRIu16 "u"
+#   define PRIx16 "x"
+#   define PRId32 "d"
+#   define PRIo32 "o"
+#   define PRIu32 "u"
+#   define PRIx32 "x"
+#   define PRId64 "lld"
+#   define PRIo64 "llo"
+#   define PRIu64 "llu"
+#   define PRIx64 "llx"
+#   define PRIdMAX "lld"
+#   define PRIoMAX "llo"
+#   define PRIuMAX "llu"
+#   define PRIxMAX "llx"
+#endif
 
 /*
  * _MSC_VER = 1900 VS2015
@@ -41,11 +80,6 @@ typedef __int64             h5_stat_size_t;
 #define HDfstat(F,B)        _fstati64(F,B)
 #define HDisatty(F)         _isatty(F)
 
-/* The isnan function needs underscore in VS2012 and earlier */
-#if (_MSC_VER <= 1700)
-  #define HDisnan(X)      _isnan(X)
-#endif /* MSC_VER < 1700 */
-
 #define HDgetcwd(S,Z)       _getcwd(S,Z)
 #define HDgetdcwd(D,S,Z)    _getdcwd(D,S,Z)
 #define HDgetdrive()        _getdrive()
@@ -111,8 +145,10 @@ struct timespec
 };
 #endif /* MSC_VER < 1900 */
 
-/* The round functions do not exist in VS2012 and earlier */
 #if (_MSC_VER <= 1700)
+/* The isnan function needs underscore in VS2012 and earlier */
+#define HDisnan(X)         _isnan(X)
+/* The round functions do not exist in VS2012 and earlier */
 #define HDllround(V)        Wllround(V)
 #define HDllroundf(V)       Wllroundf(V)
 #define HDlround(V)         Wlround(V)

From 870e3ba3f45e90a43ea824d67cc8562aa63a3f6f Mon Sep 17 00:00:00 2001
From: Larry Knox <lrknox@hdfgroup.org>
Date: Thu, 2 Jul 2020 18:20:36 -0500
Subject: [PATCH 20/55] Add missing '"'.

---
 configure.ac | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/configure.ac b/configure.ac
index 88157c3e2e7..d7e3cb5da9f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1151,7 +1151,7 @@ AC_CHECK_HEADERS([netdb.h netinet/in.h arpa/inet.h])
 
 ## Darwin
 AC_SUBST([H5_IS_DARWIN])
-H5_IS_DARWIN="no
+H5_IS_DARWIN="no"
 case $host_os in
   darwin*)
     AC_DEFINE([HAVE_DARWIN], [1], [Define if Darwin or Mac OS X])

From 13c9b3768e6193db89d06faf59194b77d7747f45 Mon Sep 17 00:00:00 2001
From: Quincey Koziol <koziol@lbl.gov>
Date: Fri, 3 Jul 2020 11:28:12 -0500
Subject: [PATCH 21/55] Address CMake and deprecated API build failures from
 monotonic timer patch.

---
 examples/h5_debug_trace.c         | 2 +-
 tools/test/perform/CMakeLists.txt | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/examples/h5_debug_trace.c b/examples/h5_debug_trace.c
index 3d89ba46074..5da55ed7d7c 100644
--- a/examples/h5_debug_trace.c
+++ b/examples/h5_debug_trace.c
@@ -121,7 +121,7 @@ main(int argc, char **argv)
     err = H5Pset_shuffle(pid);
     
     sid = H5Screate_simple(1, dims, dims);
-    did = H5Dcreate(fid, "somedata", H5T_NATIVE_INT, sid, H5P_DEFAULT, pid, H5P_DEFAULT);
+    did = H5Dcreate2(fid, "somedata", H5T_NATIVE_INT, sid, H5P_DEFAULT, pid, H5P_DEFAULT);
     err = H5Dwrite(did, H5T_NATIVE_INT, sid, sid, H5P_DEFAULT, data);
     
     H5Sclose(sid);
diff --git a/tools/test/perform/CMakeLists.txt b/tools/test/perform/CMakeLists.txt
index 6780c06f372..3c45e859398 100644
--- a/tools/test/perform/CMakeLists.txt
+++ b/tools/test/perform/CMakeLists.txt
@@ -78,7 +78,7 @@ set (chunk_cache_SOURCES
     ${HDF5_TOOLS_TEST_PERFORM_SOURCE_DIR}/chunk_cache.c
 )
 add_executable (chunk_cache ${chunk_cache_SOURCES})
-target_include_directories (chunk_cache PRIVATE "${HDF5_SRC_DIR};${HDF5_BINARY_DIR};$<$<BOOL:${HDF5_ENABLE_PARALLEL}>:${MPI_C_INCLUDE_DIRS}>")
+target_include_directories (chunk_cache PRIVATE "${HDF5_TEST_SRC_DIR};${HDF5_SRC_DIR};${HDF5_BINARY_DIR};$<$<BOOL:${HDF5_ENABLE_PARALLEL}>:${MPI_C_INCLUDE_DIRS}>")
 if (NOT BUILD_SHARED_LIBS)
   TARGET_C_PROPERTIES (chunk_cache STATIC)
   target_link_libraries (chunk_cache PRIVATE ${HDF5_TOOLS_LIB_TARGET} ${HDF5_LIB_TARGET})

From d9105b2fcf04f36ea348bf9726a49c05cacc0b78 Mon Sep 17 00:00:00 2001
From: Dana Robinson <derobins@hdfgroup.org>
Date: Mon, 6 Jul 2020 16:09:49 -0500
Subject: [PATCH 22/55] Fixes Autotools builds on Solaris after monotonic timer
 changes

clock_gettime() wasn't being found, so some configure changes
were needed to set an appropriate POSIX level and use a C99
compiler. This required several compiler flag changes.

Autotools only
---
 config/solaris | 21 ++++++++++++++++-----
 configure.ac   |  7 +++++++
 2 files changed, 23 insertions(+), 5 deletions(-)

diff --git a/config/solaris b/config/solaris
index 656fee131f5..a424503eb18 100644
--- a/config/solaris
+++ b/config/solaris
@@ -29,7 +29,9 @@ fi
 
 # Try solaris native compiler flags
 if test "X-" = "X-$cc_flags_set"; then
-  H5_CFLAGS="$H5_CFLAGS -erroff=%none -DBSD_COMP"
+  # HDF5 must be built with a C99 compiler on Solaris
+  # -erroff=%none turns on all warnings
+  H5_CFLAGS="$H5_CFLAGS -xc99=all -erroff=%none"
 
   # Production
   # NDEBUG is handled explicitly by the configure script
@@ -41,17 +43,26 @@ if test "X-" = "X-$cc_flags_set"; then
   DEBUG_CFLAGS=
 
   # Symbols
+  # -g produces output for dbx, NOT gdb. You can use "gdb on" from
+  # inside gdb to use gdb commands if you need to debug.
+  # If you want a LOT of debugging information (at the expense of
+  # really slow code), try using -g3. That will even let you debug
+  # into macros.
+  # -s strips symbols, as in gcc
   NO_SYMBOLS_CFLAGS="-s"
   SYMBOLS_CFLAGS="-g"
 
   # Profile
+  # This produces profiling output for gprof. If you want to use
+  # the Solaris profiler, use -xprofile instead.
   PROFILE_CFLAGS="-xpg"
 
   # Optimization
-  # -g produces rather slow code. "-g -O" produces much faster code with some
-  # loss of debugger functions such as not able to print local variables.
-  HIGH_OPT_CFLAGS="-O"
-  DEBUG_OPT_CFLAGS="-O"
+  # -O has switched to -xO{1|2|3|4|5}. -xO3 is probably a good compromise
+  # for the daily tests, but you might want to switch to -xO2 or lower
+  # if you are actively debugging.
+  HIGH_OPT_CFLAGS="-xO5"
+  DEBUG_OPT_CFLAGS="-xO3"
   NO_OPT_CFLAGS=
 
   cc_flags_set=yes
diff --git a/configure.ac b/configure.ac
index d7e3cb5da9f..e16cbbad383 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1249,6 +1249,13 @@ case "$host_cpu-$host_vendor-$host_os" in
     ## VFD on Linux systems.
     H5_CPPFLAGS="-D_GNU_SOURCE $H5_CPPFLAGS"
     ;;
+
+  *solaris*)
+    ## Solaris also needs _POSIX_C_SOURCE set correctly to pick up
+    ## clock_gettime().
+    H5_CPPFLAGS="-D_POSIX_C_SOURCE=200112L $H5_CPPFLAGS"
+    H5_CPPFLAGS="-D_GNU_SOURCE $H5_CPPFLAGS"
+    ;;
 esac
 
 ## Need to add the AM_ and H5_ into CFLAGS/CPPFLAGS to make them visible

From da607fe4638c9cc08f717fbe65e799c1676c17ff Mon Sep 17 00:00:00 2001
From: Larry Knox <lrknox@hdfgroup.org>
Date: Tue, 7 Jul 2020 10:52:58 -0500
Subject: [PATCH 23/55] Change load path in libhdf5_java.dylib to unversioned
 libhdf5.dylib for junit tests on Macs.

---
 java/test/junit.sh.in | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/java/test/junit.sh.in b/java/test/junit.sh.in
index cbc57e97740..62a51046b8f 100644
--- a/java/test/junit.sh.in
+++ b/java/test/junit.sh.in
@@ -151,7 +151,7 @@ COPY_LIBFILES_TO_BLDLIBDIR()
          install_name_tool -add_rpath @loader_path libhdf5_java.dylib; \
          exist_path=` otool -l libhdf5_java.dylib | grep libhdf5 | grep -v java | awk '{print $2}'`; \
          echo $exist_path; \
-         install_name_tool -change $exist_path @rpath/libhdf5.1000.dylib libhdf5_java.dylib)
+         install_name_tool -change $exist_path @rpath/libhdf5.dylib libhdf5_java.dylib)
     fi
     # copy jar files. Used -f to make sure get a new copy
     for tstfile in $COPY_JARTESTFILES

From 127d1cfdf06e9c1cd264595c496a063848358a0a Mon Sep 17 00:00:00 2001
From: Dana Robinson <derobins@hdfgroup.org>
Date: Thu, 9 Jul 2020 08:34:01 -0700
Subject: [PATCH 24/55] Minor changes from normalization with 1.10

---
 src/H5Bdbg.c     | 204 ++++++++-------
 src/H5Dbtree2.c  |   2 +-
 src/H5Dchunk.c   |  20 +-
 src/H5Dearray.c  | 398 ++++++++++++++---------------
 src/H5Dfarray.c  | 180 ++++++-------
 src/H5Dio.c      |  21 +-
 src/H5Dlayout.c  |  36 +--
 src/H5Dmpio.c    |   2 +-
 src/H5Dselect.c  |   2 +-
 src/H5EAdbg.c    | 108 ++++----
 src/H5Pdcpl.c    |  20 +-
 src/H5S.c        | 645 ++++++++++++++++++++++++-----------------------
 src/H5Sall.c     |   8 +-
 src/H5Sdbg.c     |  25 +-
 src/H5Shyper.c   | 211 ++++++++--------
 src/H5Smpio.c    |  32 +--
 src/H5Snone.c    |  69 +++--
 src/H5Spkg.h     |   6 +-
 src/H5Spoint.c   | 132 +++++-----
 src/H5Sprivate.h |   1 +
 src/H5Sselect.c  |   7 +-
 21 files changed, 1055 insertions(+), 1074 deletions(-)

diff --git a/src/H5Bdbg.c b/src/H5Bdbg.c
index 665e82637c1..d90085276f5 100644
--- a/src/H5Bdbg.c
+++ b/src/H5Bdbg.c
@@ -13,11 +13,11 @@
 
 /*-------------------------------------------------------------------------
  *
- * Created:		H5Bdbg.c
- *			Dec 11 2008
- *			Quincey Koziol <koziol@hdfgroup.org>
+ * Created:         H5Bdbg.c
+ *                  Dec 11 2008
+ *                  Quincey Koziol
  *
- * Purpose:		Debugging routines for B-link tree package.
+ * Purpose:         Debugging routines for B-link tree package.
  *
  *-------------------------------------------------------------------------
  */
@@ -32,35 +32,33 @@
 /***********/
 /* Headers */
 /***********/
-#include "H5private.h"		/* Generic Functions			*/
-#include "H5Bpkg.h"		/* B-link trees				*/
-#include "H5Eprivate.h"		/* Error handling		  	*/
-#include "H5MMprivate.h"	/* Memory management			*/
+#include "H5private.h"          /* Generic Functions            */
+#include "H5Bpkg.h"             /* B-link trees                 */
+#include "H5Eprivate.h"         /* Error handling               */
+#include "H5MMprivate.h"        /* Memory management            */
 
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5B_debug
+ * Function:    H5B_debug
  *
- * Purpose:	Prints debugging info about a B-tree.
+ * Purpose:     Prints debugging info about a B-tree.
  *
- * Return:	Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:	Robb Matzke
- *		matzke@llnl.gov
- *		Aug  4 1997
+ * Programmer:  Robb Matzke
+ *              Aug  4 1997
  *
  *-------------------------------------------------------------------------
  */
 herr_t
-H5B_debug(H5F_t *f, haddr_t addr, FILE *stream, int indent, int fwidth,
-	  const H5B_class_t *type, void *udata)
+H5B_debug(H5F_t *f, haddr_t addr, FILE *stream, int indent, int fwidth, const H5B_class_t *type, void *udata)
 {
-    H5B_t	*bt = NULL;
-    H5UC_t	*rc_shared;             /* Ref-counted shared info */
+    H5B_t       *bt = NULL;
+    H5UC_t      *rc_shared;             /* Ref-counted shared info */
     H5B_shared_t *shared;               /* Pointer to shared B-tree info */
     H5B_cache_ud_t cache_udata;         /* User-data for metadata cache callback */
-    unsigned	u;                      /* Local index variable */
+    unsigned    u;                      /* Local index variable */
     herr_t      ret_value = SUCCEED;    /* Return value */
 
     FUNC_ENTER_NOAPI(FAIL)
@@ -97,55 +95,53 @@ H5B_debug(H5F_t *f, haddr_t addr, FILE *stream, int indent, int fwidth,
      * Print the values.
      */
     HDfprintf(stream, "%*s%-*s %s\n", indent, "", fwidth,
-	      "Tree type ID:",
-	      ((shared->type->id) == H5B_SNODE_ID ? "H5B_SNODE_ID" :
+        "Tree type ID:",
+        ((shared->type->id) == H5B_SNODE_ID ? "H5B_SNODE_ID" :
             ((shared->type->id) == H5B_CHUNK_ID ? "H5B_CHUNK_ID" : "Unknown!")));
     HDfprintf(stream, "%*s%-*s %Zu\n", indent, "", fwidth,
-	      "Size of node:",
-	      shared->sizeof_rnode);
+        "Size of node:",
+        shared->sizeof_rnode);
     HDfprintf(stream, "%*s%-*s %Zu\n", indent, "", fwidth,
-	      "Size of raw (disk) key:",
-	      shared->sizeof_rkey);
+        "Size of raw (disk) key:",
+        shared->sizeof_rkey);
     HDfprintf(stream, "%*s%-*s %s\n", indent, "", fwidth,
-	      "Dirty flag:",
-	      bt->cache_info.is_dirty ? "True" : "False");
+        "Dirty flag:",
+        bt->cache_info.is_dirty ? "True" : "False");
     HDfprintf(stream, "%*s%-*s %u\n", indent, "", fwidth,
-	      "Level:",
-	      bt->level);
+        "Level:",
+        bt->level);
     HDfprintf(stream, "%*s%-*s %a\n", indent, "", fwidth,
-	      "Address of left sibling:",
-	      bt->left);
+        "Address of left sibling:",
+        bt->left);
     HDfprintf(stream, "%*s%-*s %a\n", indent, "", fwidth,
-	      "Address of right sibling:",
-	      bt->right);
+        "Address of right sibling:",
+        bt->right);
     HDfprintf(stream, "%*s%-*s %u (%u)\n", indent, "", fwidth,
-	      "Number of children (max):",
-	      bt->nchildren, shared->two_k);
+        "Number of children (max):",
+        bt->nchildren, shared->two_k);
 
     /*
      * Print the child addresses
      */
     for(u = 0; u < bt->nchildren; u++) {
-	HDfprintf(stream, "%*sChild %d...\n", indent, "", u);
-	HDfprintf(stream, "%*s%-*s %a\n", indent + 3, "", MAX(0, fwidth - 3),
-		  "Address:", bt->child[u]);
+        HDfprintf(stream, "%*sChild %d...\n", indent, "", u);
+        HDfprintf(stream, "%*s%-*s %a\n", indent + 3, "", MAX(0, fwidth - 3),
+            "Address:", bt->child[u]);
 
         /* If there is a key debugging routine, use it to display the left & right keys */
-	if(type->debug_key) {
+        if(type->debug_key) {
             /* Decode the 'left' key & print it */
             HDfprintf(stream, "%*s%-*s\n", indent + 3, "", MAX(0, fwidth - 3),
                       "Left Key:");
             HDassert(H5B_NKEY(bt,shared,u));
-	    (void)(type->debug_key)(stream, indent + 6, MAX(0, fwidth - 6),
-			      H5B_NKEY(bt, shared, u), udata);
+            (void)(type->debug_key)(stream, indent + 6, MAX(0, fwidth - 6), H5B_NKEY(bt, shared, u), udata);
 
             /* Decode the 'right' key & print it */
             HDfprintf(stream, "%*s%-*s\n", indent + 3, "", MAX(0, fwidth - 3),
                       "Right Key:");
             HDassert(H5B_NKEY(bt, shared, u + 1));
-	    (void)(type->debug_key)(stream, indent + 6, MAX (0, fwidth - 6),
-			      H5B_NKEY(bt, shared, u + 1), udata);
-	} /* end if */
+            (void)(type->debug_key)(stream, indent + 6, MAX (0, fwidth - 6), H5B_NKEY(bt, shared, u + 1), udata);
+        } /* end if */
     } /* end for */
 
 done:
@@ -157,16 +153,16 @@ H5B_debug(H5F_t *f, haddr_t addr, FILE *stream, int indent, int fwidth,
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5B__assert
+ * Function:    H5B__assert
  *
- * Purpose:	Verifies that the tree is structured correctly.
+ * Purpose:     Verifies that the tree is structured correctly.
  *
- * Return:	Success:	SUCCEED
+ * Return:      Success:    SUCCEED
  *
- *		Failure:	aborts if something is wrong.
+ *              Failure:    aborts if something is wrong.
  *
- * Programmer:	Robb Matzke
- *		Tuesday, November  4, 1997
+ * Programmer:  Robb Matzke
+ *              Tuesday, November  4, 1997
  *
  *-------------------------------------------------------------------------
  */
@@ -174,20 +170,20 @@ H5B_debug(H5F_t *f, haddr_t addr, FILE *stream, int indent, int fwidth,
 herr_t
 H5B__assert(H5F_t *f, haddr_t addr, const H5B_class_t *type, void *udata)
 {
-    H5B_t	*bt = NULL;
-    H5UC_t	*rc_shared;             /* Ref-counted shared info */
+    H5B_t       *bt = NULL;
+    H5UC_t      *rc_shared;             /* Ref-counted shared info */
     H5B_shared_t *shared;               /* Pointer to shared B-tree info */
     H5B_cache_ud_t cache_udata;         /* User-data for metadata cache callback */
-    int	        ncell, cmp;
-    static int	ncalls = 0;
-    herr_t	status;
+    int         ncell, cmp;
+    static int  ncalls = 0;
+    herr_t      status;
     herr_t      ret_value = SUCCEED;    /* Return value */
 
     /* A queue of child data */
     struct child_t {
-	haddr_t			addr;
-	unsigned		level;
-	struct child_t	       *next;
+        haddr_t             addr;
+        unsigned            level;
+        struct child_t      *next;
     } *head = NULL, *tail = NULL, *prev = NULL, *cur = NULL, *tmp = NULL;
 
     FUNC_ENTER_PACKAGE
@@ -228,60 +224,60 @@ H5B__assert(H5F_t *f, haddr_t addr, const H5B_class_t *type, void *udata)
      * test.
      */
     for(ncell = 0; cur; ncell++) {
-	bt = (H5B_t *)H5AC_protect(f, H5AC_BT, cur->addr, &cache_udata, H5AC__READ_ONLY_FLAG);
-	HDassert(bt);
-
-	/* Check node header */
-	HDassert(bt->level == cur->level);
-	if(cur->next && cur->next->level == bt->level)
-	    HDassert(H5F_addr_eq(bt->right, cur->next->addr));
-	else
-	    HDassert(!H5F_addr_defined(bt->right));
-	if(prev && prev->level == bt->level)
-	    HDassert(H5F_addr_eq(bt->left, prev->addr));
-	else
-	    HDassert(!H5F_addr_defined(bt->left));
-
-	if(cur->level > 0) {
+        bt = (H5B_t *)H5AC_protect(f, H5AC_BT, cur->addr, &cache_udata, H5AC__READ_ONLY_FLAG);
+        HDassert(bt);
+
+        /* Check node header */
+        HDassert(bt->level == cur->level);
+        if(cur->next && cur->next->level == bt->level)
+            HDassert(H5F_addr_eq(bt->right, cur->next->addr));
+        else
+            HDassert(!H5F_addr_defined(bt->right));
+        if(prev && prev->level == bt->level)
+            HDassert(H5F_addr_eq(bt->left, prev->addr));
+        else
+            HDassert(!H5F_addr_defined(bt->left));
+
+        if(cur->level > 0) {
             unsigned u;
 
-	    for(u = 0; u < bt->nchildren; u++) {
-		/*
-		 * Check that child nodes haven't already been seen.  If they
-		 * have then the tree has a cycle.
-		 */
-		for(tmp = head; tmp; tmp = tmp->next)
-		    HDassert(H5F_addr_ne(tmp->addr, bt->child[u]));
-
-		/* Add the child node to the end of the queue */
-		tmp = (struct child_t *)H5MM_calloc(sizeof(struct child_t));
-		HDassert(tmp);
-		tmp->addr = bt->child[u];
-		tmp->level = bt->level - 1;
-		tail->next = tmp;
-		tail = tmp;
-
-		/* Check that the keys are monotonically increasing */
-		cmp = (type->cmp2)(H5B_NKEY(bt, shared, u), udata, H5B_NKEY(bt, shared, u + 1));
-		HDassert(cmp < 0);
-	    } /* end for */
-	} /* end if */
-
-	/* Release node */
-	status = H5AC_unprotect(f, H5AC_BT, cur->addr, bt, H5AC__NO_FLAGS_SET);
-	HDassert(status >= 0);
+            for(u = 0; u < bt->nchildren; u++) {
+                /*
+                 * Check that child nodes haven't already been seen.  If they
+                 * have then the tree has a cycle.
+                 */
+                for(tmp = head; tmp; tmp = tmp->next)
+                    HDassert(H5F_addr_ne(tmp->addr, bt->child[u]));
+
+                /* Add the child node to the end of the queue */
+                tmp = (struct child_t *)H5MM_calloc(sizeof(struct child_t));
+                HDassert(tmp);
+                tmp->addr = bt->child[u];
+                tmp->level = bt->level - 1;
+                tail->next = tmp;
+                tail = tmp;
+
+                /* Check that the keys are monotonically increasing */
+                cmp = (type->cmp2)(H5B_NKEY(bt, shared, u), udata, H5B_NKEY(bt, shared, u + 1));
+                HDassert(cmp < 0);
+            } /* end for */
+        } /* end if */
+
+        /* Release node */
+        status = H5AC_unprotect(f, H5AC_BT, cur->addr, bt, H5AC__NO_FLAGS_SET);
+        HDassert(status >= 0);
         bt = NULL;    /* Make certain future references will be caught */
 
-	/* Advance current location in queue */
-	prev = cur;
-	cur = cur->next;
+        /* Advance current location in queue */
+        prev = cur;
+        cur = cur->next;
     } /* end for */
 
     /* Free all entries from queue */
     while(head) {
-	tmp = head->next;
-	H5MM_xfree(head);
-	head = tmp;
+        tmp = head->next;
+        H5MM_xfree(head);
+        head = tmp;
     } /* end while */
 
 done:
diff --git a/src/H5Dbtree2.c b/src/H5Dbtree2.c
index ae986548355..ccb786b6e60 100644
--- a/src/H5Dbtree2.c
+++ b/src/H5Dbtree2.c
@@ -292,7 +292,7 @@ H5D__bt2_dst_context(void *_ctx)
 
     /* Free array for chunk dimension sizes */
     if(ctx->dim)
-	(void)H5FL_ARR_FREE(uint32_t, ctx->dim);
+        H5FL_ARR_FREE(uint32_t, ctx->dim);
     /* Release callback context */
     ctx = H5FL_FREE(H5D_bt2_ctx_t, ctx);
 
diff --git a/src/H5Dchunk.c b/src/H5Dchunk.c
index 5fda3c0ddb8..62e3ec5a4ad 100644
--- a/src/H5Dchunk.c
+++ b/src/H5Dchunk.c
@@ -1914,7 +1914,7 @@ H5D__create_chunk_file_map_hyper(H5D_chunk_map_t *fm, const H5D_io_info_t
             new_chunk_info->mspace_shared = FALSE;
 
             /* Copy the chunk's scaled coordinates */
-        H5MM_memcpy(new_chunk_info->scaled, scaled, sizeof(hsize_t) * fm->f_ndims);
+            H5MM_memcpy(new_chunk_info->scaled, scaled, sizeof(hsize_t) * fm->f_ndims);
             new_chunk_info->scaled[fm->f_ndims] = 0;
 
             /* Insert the new chunk into the skip list */
@@ -2095,7 +2095,7 @@ H5D__create_chunk_mem_map_hyper(const H5D_chunk_map_t *fm)
                 for(u = 0; u < fm->f_ndims; u++) {
                     /* Compensate for the chunk offset */
                     H5_CHECK_OVERFLOW(coords[u], hsize_t, hssize_t);
-                    chunk_adjust[u] = adjust[u] - (hssize_t)coords[u]; /*lint !e771 The adjust array will always be initialized */
+                    chunk_adjust[u] = adjust[u] - (hssize_t)coords[u];
                 } /* end for */
 
                 /* Adjust the selection */
@@ -2329,7 +2329,7 @@ H5D__chunk_mem_cb(void H5_ATTR_UNUSED *elem, const H5T_t H5_ATTR_UNUSED *type, u
 {
     H5D_chunk_map_t      *fm = (H5D_chunk_map_t *)_fm;  /* File<->memory chunk mapping info */
     H5D_chunk_info_t *chunk_info;               /* Chunk information for current chunk */
-    hsize_t     coords_in_mem[H5S_MAX_RANK];    /* Coordinates of element in memory */
+    hsize_t    coords_in_mem[H5S_MAX_RANK];    /* Coordinates of element in memory */
     hsize_t     chunk_index;                    /* Chunk index */
     herr_t    ret_value = SUCCEED;            /* Return value        */
 
@@ -5991,7 +5991,7 @@ H5D__chunk_copy_cb(const H5D_chunk_rec_t *chunk_rec, void *_udata)
         if((udata->common.layout->flags & H5O_LAYOUT_CHUNK_DONT_FILTER_PARTIAL_BOUND_CHUNKS) &&
             H5D__chunk_is_partial_edge_chunk(udata->dset_ndims, udata->common.layout->dim, chunk_rec->scaled, udata->dset_dims))
             must_filter = FALSE;
-    } /* end if */
+    }
 
     /* Check parameter for type conversion */
     if(udata->do_convert) {
@@ -6029,7 +6029,7 @@ H5D__chunk_copy_cb(const H5D_chunk_rec_t *chunk_rec, void *_udata)
         HDassert(!H5F_addr_defined(chunk_rec->chunk_addr));
         H5MM_memcpy(buf, udata->chunk, nbytes);
         udata->chunk = NULL;
-    } /* end if */
+    }
     else {
         H5D_rdcc_ent_t *ent = NULL;    /* Cache entry */
         unsigned idx;                   /* Index of chunk in cache, if present */
@@ -6062,13 +6062,13 @@ H5D__chunk_copy_cb(const H5D_chunk_rec_t *chunk_rec, void *_udata)
 
             H5_CHECKED_ASSIGN(nbytes, size_t, shared_fo->layout.u.chunk.size, uint32_t);
             H5MM_memcpy(buf, ent->chunk, nbytes);
-        } /* end if */
+        }
         else {
             /* read chunk data from the source file */
             if(H5F_block_read(udata->file_src, H5FD_MEM_DRAW, chunk_rec->chunk_addr, nbytes, buf) < 0)
                 HGOTO_ERROR(H5E_IO, H5E_READERROR, H5_ITER_ERROR, "unable to read raw data chunk")
-        } /* end else */
-    } /* end else */
+        }
+    }
 
     /* Need to uncompress filtered variable-length & reference data elements that are not found in chunk cache */
     if(must_filter && (is_vlen || fix_ref) && !udata->chunk_in_cache) {
@@ -7201,7 +7201,7 @@ H5D__get_num_chunks(const H5D_t *dset, const H5S_t H5_ATTR_UNUSED *space, hsize_
         if((dset->shared->layout.storage.u.chunk.ops->iterate)(&idx_info, H5D__get_num_chunks_cb, &num_chunks) < 0)
             HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "unable to retrieve allocated chunk information from index")
         *nchunks = num_chunks;
-    } /* end else */
+    }
 
 done:
     FUNC_LEAVE_NOAPI_TAG(ret_value)
@@ -7248,7 +7248,7 @@ H5D__get_chunk_info_cb(const H5D_chunk_rec_t *chunk_rec, void *_udata)
 
         /* Stop iterating */
         ret_value = H5_ITER_STOP;
-    } /* end if */
+    }
     /* Go to the next chunk */
     else
         chunk_info->curr_idx++;
diff --git a/src/H5Dearray.c b/src/H5Dearray.c
index eaa8c464aec..a53489e8cd6 100644
--- a/src/H5Dearray.c
+++ b/src/H5Dearray.c
@@ -11,10 +11,10 @@
  * help@hdfgroup.org.                                                        *
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
-/* Programmer: 	Quincey Koziol <koziol@hdfgroup.org>
- *	       	Tuesday, January 27, 2009
+/* Programmer:      Quincey Koziol
+ *                  Tuesday, January 27, 2009
  *
- * Purpose:	Extensible array indexed (chunked) I/O functions.  The chunks
+ * Purpose:     Extensible array indexed (chunked) I/O functions.  The chunks
  *              are given a single-dimensional index which is used as the
  *              offset in an extensible array that maps a chunk coordinate to
  *              a disk address.
@@ -183,7 +183,7 @@ const H5EA_class_t H5EA_CLS_CHUNK[1]={{
     H5D__earray_fill,           /* Fill block of missing elements callback */
     H5D__earray_encode,         /* Element encoding callback */
     H5D__earray_decode,         /* Element decoding callback */
-    H5D__earray_debug,		/* Element debugging callback */
+    H5D__earray_debug,          /* Element debugging callback */
     H5D__earray_crt_dbg_context, /* Create debugging context */
     H5D__earray_dst_dbg_context  /* Destroy debugging context */
 }};
@@ -216,14 +216,14 @@ H5FL_DEFINE_STATIC(H5D_earray_ctx_ud_t);
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_crt_context
+ * Function:    H5D__earray_crt_context
  *
- * Purpose:	Create context for callbacks
+ * Purpose:     Create context for callbacks
  *
- * Return:	Success:	non-NULL
- *		Failure:	NULL
+ * Return:      Success:    non-NULL
+ *              Failure:    NULL
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Thursday, January 29, 2009
  *
  *-------------------------------------------------------------------------
@@ -265,14 +265,14 @@ H5D__earray_crt_context(void *_udata)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_dst_context
+ * Function:    H5D__earray_dst_context
  *
- * Purpose:	Destroy context for callbacks
+ * Purpose:     Destroy context for callbacks
  *
- * Return:	Success:	non-NULL
- *		Failure:	NULL
+ * Return:      Success:    non-NULL
+ *              Failure:    NULL
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Thursday, January 29, 2009
  *
  *-------------------------------------------------------------------------
@@ -295,14 +295,14 @@ H5D__earray_dst_context(void *_ctx)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_fill
+ * Function:    H5D__earray_fill
  *
- * Purpose:	Fill "missing elements" in block of elements
+ * Purpose:    Fill "missing elements" in block of elements
  *
- * Return:	Success:	non-negative
- *		Failure:	negative
+ * Return:    Success:    non-negative
+ *        Failure:    negative
  *
- * Programmer:	Quincey Koziol
+ * Programmer:    Quincey Koziol
  *              Tuesday, January 27, 2009
  *
  *-------------------------------------------------------------------------
@@ -325,14 +325,14 @@ H5D__earray_fill(void *nat_blk, size_t nelmts)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_encode
+ * Function:    H5D__earray_encode
  *
- * Purpose:	Encode an element from "native" to "raw" form
+ * Purpose:     Encode an element from "native" to "raw" form
  *
- * Return:	Success:	non-negative
- *		Failure:	negative
+ * Return:      Success:    non-negative
+ *              Failure:    negative
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Tuesday, January 27, 2009
  *
  *-------------------------------------------------------------------------
@@ -369,14 +369,14 @@ H5D__earray_encode(void *raw, const void *_elmt, size_t nelmts, void *_ctx)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_decode
+ * Function:    H5D__earray_decode
  *
- * Purpose:	Decode an element from "raw" to "native" form
+ * Purpose:     Decode an element from "raw" to "native" form
  *
- * Return:	Success:	non-negative
- *		Failure:	negative
+ * Return:      Success:    non-negative
+ *              Failure:    negative
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Thursday, January 29, 2009
  *
  *-------------------------------------------------------------------------
@@ -413,14 +413,14 @@ H5D__earray_decode(const void *_raw, void *_elmt, size_t nelmts, void *_ctx)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_debug
+ * Function:    H5D__earray_debug
  *
- * Purpose:	Display an element for debugging
+ * Purpose:     Display an element for debugging
  *
- * Return:	Success:	non-negative
- *		Failure:	negative
+ * Return:      Success:    non-negative
+ *              Failure:    negative
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Thursday, January 29, 2009
  *
  *-------------------------------------------------------------------------
@@ -447,14 +447,14 @@ H5D__earray_debug(FILE *stream, int indent, int fwidth, hsize_t idx,
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_filt_fill
+ * Function:    H5D__earray_filt_fill
  *
- * Purpose:	Fill "missing elements" in block of elements
+ * Purpose:     Fill "missing elements" in block of elements
  *
- * Return:	Success:	non-negative
- *		Failure:	negative
+ * Return:      Success:    non-negative
+ *              Failure:    negative
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Saturday, January 31, 2009
  *
  *-------------------------------------------------------------------------
@@ -478,14 +478,14 @@ H5D__earray_filt_fill(void *nat_blk, size_t nelmts)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_filt_encode
+ * Function:    H5D__earray_filt_encode
  *
- * Purpose:	Encode an element from "native" to "raw" form
+ * Purpose:     Encode an element from "native" to "raw" form
  *
- * Return:	Success:	non-negative
- *		Failure:	negative
+ * Return:      Success:    non-negative
+ *              Failure:    negative
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Saturday, January 31, 2009
  *
  *-------------------------------------------------------------------------
@@ -525,14 +525,14 @@ H5D__earray_filt_encode(void *_raw, const void *_elmt, size_t nelmts, void *_ctx
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_filt_decode
+ * Function:    H5D__earray_filt_decode
  *
- * Purpose:	Decode an element from "raw" to "native" form
+ * Purpose:     Decode an element from "raw" to "native" form
  *
- * Return:	Success:	non-negative
- *		Failure:	negative
+ * Return:      Success:    non-negative
+ *              Failure:    negative
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Saturday, January 31, 2009
  *
  *-------------------------------------------------------------------------
@@ -571,14 +571,14 @@ H5D__earray_filt_decode(const void *_raw, void *_elmt, size_t nelmts, void *_ctx
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_filt_debug
+ * Function:    H5D__earray_filt_debug
  *
- * Purpose:	Display an element for debugging
+ * Purpose:     Display an element for debugging
  *
- * Return:	Success:	non-negative
- *		Failure:	negative
+ * Return:      Success:    non-negative
+ *              Failure:    negative
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Saturday, January 31, 2009
  *
  *-------------------------------------------------------------------------
@@ -606,15 +606,15 @@ H5D__earray_filt_debug(FILE *stream, int indent, int fwidth, hsize_t idx,
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_crt_dbg_context
+ * Function:    H5D__earray_crt_dbg_context
  *
- * Purpose:	Create context for debugging callback
- *		(get the layout message in the specified object header)
+ * Purpose:     Create context for debugging callback
+ *              (get the layout message in the specified object header)
  *
- * Return:	Success:	non-NULL
- *		Failure:	NULL
+ * Return:      Success:    non-NULL
+ *              Failure:    NULL
  *
- * Programmer:	Vailin Choi; July 2010
+ * Programmer:  Vailin Choi; July 2010
  *
  *-------------------------------------------------------------------------
  */
@@ -680,15 +680,15 @@ H5D__earray_crt_dbg_context(H5F_t *f, haddr_t obj_addr)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_dst_dbg_context
+ * Function:    H5D__earray_dst_dbg_context
  *
- * Purpose:	Destroy context for debugging callback
- *		(free the layout message from the specified object header)
+ * Purpose:     Destroy context for debugging callback
+ *              (free the layout message from the specified object header)
  *
- * Return:	Success:	non-negative
- *		Failure:	negative
+ * Return:      Success:    non-negative
+ *              Failure:    negative
  *
- * Programmer:	Vailin Choi; July 2010
+ * Programmer:  Vailin Choi; July 2010
  *
  *-------------------------------------------------------------------------
  */
@@ -710,16 +710,16 @@ H5D__earray_dst_dbg_context(void *_dbg_ctx)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_idx_depend
+ * Function:    H5D__earray_idx_depend
  *
- * Purpose:	Create flush dependency between extensible array and dataset's
+ * Purpose:     Create flush dependency between extensible array and dataset's
  *              object header.
  *
- * Return:	Success:	non-negative
- *		Failure:	negative
+ * Return:      Success:    non-negative
+ *              Failure:    negative
  *
- * Programmer:	Quincey Koziol
- *		Tuesday, June  2, 2009
+ * Programmer:  Quincey Koziol
+ *              Tuesday, June  2, 2009
  *
  *-------------------------------------------------------------------------
  */
@@ -772,20 +772,20 @@ H5D__earray_idx_depend(const H5D_chk_idx_info_t *idx_info)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_idx_open
+ * Function:    H5D__earray_idx_open
  *
- * Purpose:	Opens an existing extensible array.
+ * Purpose:     Opens an existing extensible array.
  *
- * Note:	This information is passively initialized from each index
+ * Note:        This information is passively initialized from each index
  *              operation callback because those abstract chunk index operations
  *              are designed to work with the v1 B-tree chunk indices also,
  *              which don't require an 'open' for the data structure.
  *
- * Return:	Success:	non-negative
- *		Failure:	negative
+ * Return:      Success:    non-negative
+ *              Failure:    negative
  *
- * Programmer:	Quincey Koziol
- *		Thursday, January 29, 2009
+ * Programmer:  Quincey Koziol
+ *              Thursday, January 29, 2009
  *
  *-------------------------------------------------------------------------
  */
@@ -814,7 +814,7 @@ H5D__earray_idx_open(const H5D_chk_idx_info_t *idx_info)
 
     /* Open the extensible array for the chunk index */
     if(NULL == (idx_info->storage->u.earray.ea = H5EA_open(idx_info->f, idx_info->storage->idx_addr, &udata)))
-	HGOTO_ERROR(H5E_DATASET, H5E_CANTINIT, FAIL, "can't open extensible array")
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTINIT, FAIL, "can't open extensible array")
 
     /* Check for SWMR writes to the file */
     if(H5F_INTENT(idx_info->f) & H5F_ACC_SWMR_WRITE)
@@ -827,13 +827,13 @@ H5D__earray_idx_open(const H5D_chk_idx_info_t *idx_info)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_idx_init
+ * Function:    H5D__earray_idx_init
  *
- * Purpose:	Initialize the indexing information for a dataset.
+ * Purpose:     Initialize the indexing information for a dataset.
  *
- * Return:	Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Wednesday, May 27, 2009
  *
  *-------------------------------------------------------------------------
@@ -862,7 +862,7 @@ H5D__earray_idx_init(const H5D_chk_idx_info_t *idx_info, const H5S_t *space,
 
     /* Get the dim info for dataset */
     if((sndims = H5S_get_simple_extent_dims(space, NULL, max_dims)) < 0)
-	HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "can't get dataspace dimensions")
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "can't get dataspace dimensions")
     H5_CHECKED_ASSIGN(ndims, unsigned, sndims, int);
 
     /* Find the rank of the unlimited dimension */
@@ -895,20 +895,20 @@ H5D__earray_idx_init(const H5D_chk_idx_info_t *idx_info, const H5S_t *space,
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_idx_create
+ * Function:    H5D__earray_idx_create
  *
- * Purpose:	Creates a new indexed-storage extensible array and initializes
+ * Purpose:     Creates a new indexed-storage extensible array and initializes
  *              the layout struct with information about the storage.  The
- *		struct should be immediately written to the object header.
+ *              struct should be immediately written to the object header.
  *
- *		This function must be called before passing LAYOUT to any of
- *		the other indexed storage functions!
+ *              This function must be called before passing LAYOUT to any of
+ *              the other indexed storage functions!
  *
- * Return:	Non-negative on success (with the LAYOUT argument initialized
- *		and ready to write to an object header). Negative on failure.
+ * Return:      Non-negative on success (with the LAYOUT argument initialized
+ *              and ready to write to an object header). Negative on failure.
  *
- * Programmer:	Quincey Koziol
- *		Tuesday, January 27, 2009
+ * Programmer:  Quincey Koziol
+ *              Tuesday, January 27, 2009
  *
  *-------------------------------------------------------------------------
  */
@@ -965,11 +965,11 @@ H5D__earray_idx_create(const H5D_chk_idx_info_t *idx_info)
 
     /* Create the extensible array for the chunk index */
     if(NULL == (idx_info->storage->u.earray.ea = H5EA_create(idx_info->f, &cparam, &udata)))
-	HGOTO_ERROR(H5E_DATASET, H5E_CANTINIT, FAIL, "can't create extensible array")
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTINIT, FAIL, "can't create extensible array")
 
     /* Get the address of the extensible array in file */
     if(H5EA_get_addr(idx_info->storage->u.earray.ea, &(idx_info->storage->idx_addr)) < 0)
-	HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "can't query extensible array address")
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "can't query extensible array address")
 
     /* Check for SWMR writes to the file */
     if(H5F_INTENT(idx_info->f) & H5F_ACC_SWMR_WRITE)
@@ -982,14 +982,14 @@ H5D__earray_idx_create(const H5D_chk_idx_info_t *idx_info)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_idx_is_space_alloc
+ * Function:    H5D__earray_idx_is_space_alloc
  *
- * Purpose:	Query if space is allocated for index method
+ * Purpose:     Query if space is allocated for index method
  *
- * Return:	Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:	Quincey Koziol
- *		Thursday, January 29, 2009
+ * Programmer:  Quincey Koziol
+ *              Thursday, January 29, 2009
  *
  *-------------------------------------------------------------------------
  */
@@ -1006,13 +1006,13 @@ H5D__earray_idx_is_space_alloc(const H5O_storage_chunk_t *storage)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_idx_insert
+ * Function:    H5D__earray_idx_insert
  *
- * Purpose:	Insert chunk address into the indexing structure.
+ * Purpose:     Insert chunk address into the indexing structure.
  *
- * Return:	Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:	Vailin Choi; May 2014
+ * Programmer:  Vailin Choi; May 2014
  *
  *-------------------------------------------------------------------------
  */
@@ -1021,7 +1021,7 @@ H5D__earray_idx_insert(const H5D_chk_idx_info_t *idx_info, H5D_chunk_ud_t *udata
     const H5D_t H5_ATTR_UNUSED *dset)
 {
     H5EA_t      *ea;                    /* Pointer to extensible array structure */
-    herr_t	ret_value = SUCCEED;	/* Return value */
+    herr_t    ret_value = SUCCEED;    /* Return value */
 
     FUNC_ENTER_STATIC
 
@@ -1046,26 +1046,26 @@ H5D__earray_idx_insert(const H5D_chk_idx_info_t *idx_info, H5D_chunk_ud_t *udata
     ea = idx_info->storage->u.earray.ea;
 
     if(!H5F_addr_defined(udata->chunk_block.offset))
-	HGOTO_ERROR(H5E_DATASET, H5E_CANTALLOC, FAIL, "The chunk should have allocated already")
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTALLOC, FAIL, "The chunk should have allocated already")
     if(udata->chunk_idx != (udata->chunk_idx & 0xffffffff)) /* negative value */
-	HGOTO_ERROR(H5E_ARGS, H5E_BADRANGE, FAIL, "chunk index must be less than 2^32")
+        HGOTO_ERROR(H5E_ARGS, H5E_BADRANGE, FAIL, "chunk index must be less than 2^32")
 
     /* Check for filters on chunks */
     if(idx_info->pline->nused > 0) {
-	H5D_earray_filt_elmt_t elmt;            /* Extensible array element */
+        H5D_earray_filt_elmt_t elmt;            /* Extensible array element */
 
-	elmt.addr = udata->chunk_block.offset;
+        elmt.addr = udata->chunk_block.offset;
         H5_CHECKED_ASSIGN(elmt.nbytes, uint32_t, udata->chunk_block.length, hsize_t);
-	elmt.filter_mask = udata->filter_mask;
+        elmt.filter_mask = udata->filter_mask;
 
-	/* Set the info for the chunk */
-	if(H5EA_set(ea, udata->chunk_idx, &elmt) < 0)
-	    HGOTO_ERROR(H5E_DATASET, H5E_CANTSET, FAIL, "can't set chunk info")
+        /* Set the info for the chunk */
+        if(H5EA_set(ea, udata->chunk_idx, &elmt) < 0)
+            HGOTO_ERROR(H5E_DATASET, H5E_CANTSET, FAIL, "can't set chunk info")
     } /* end if */
     else {
-	/* Set the address for the chunk */
-	if(H5EA_set(ea, udata->chunk_idx, &udata->chunk_block.offset) < 0)
-	    HGOTO_ERROR(H5E_DATASET, H5E_CANTSET, FAIL, "can't set chunk address")
+        /* Set the address for the chunk */
+        if(H5EA_set(ea, udata->chunk_idx, &udata->chunk_block.offset) < 0)
+            HGOTO_ERROR(H5E_DATASET, H5E_CANTSET, FAIL, "can't set chunk address")
     } /* end else */
 
 done:
@@ -1074,15 +1074,15 @@ H5D__earray_idx_insert(const H5D_chk_idx_info_t *idx_info, H5D_chunk_ud_t *udata
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_idx_get_addr
+ * Function:    H5D__earray_idx_get_addr
  *
- * Purpose:	Get the file address of a chunk if file space has been
- *		assigned.  Save the retrieved information in the udata
- *		supplied.
+ * Purpose:     Get the file address of a chunk if file space has been
+ *              assigned.  Save the retrieved information in the udata
+ *              supplied.
  *
- * Return:	Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Thursday, January 29, 2009
  *
  *-------------------------------------------------------------------------
@@ -1092,7 +1092,7 @@ H5D__earray_idx_get_addr(const H5D_chk_idx_info_t *idx_info, H5D_chunk_ud_t *uda
 {
     H5EA_t      *ea;                    /* Pointer to extensible array structure */
     hsize_t     idx;                    /* Array index of chunk */
-    herr_t	ret_value = SUCCEED;	/* Return value */
+    herr_t      ret_value = SUCCEED;    /* Return value */
 
     FUNC_ENTER_STATIC
 
@@ -1118,13 +1118,13 @@ H5D__earray_idx_get_addr(const H5D_chk_idx_info_t *idx_info, H5D_chunk_ud_t *uda
 
     /* Check for unlimited dim. not being the slowest-changing dim. */
     if(idx_info->layout->u.earray.unlim_dim > 0) {
-        hsize_t swizzled_coords[H5O_LAYOUT_NDIMS];	/* swizzled chunk coordinates */
+        hsize_t swizzled_coords[H5O_LAYOUT_NDIMS];    /* swizzled chunk coordinates */
         unsigned ndims = (idx_info->layout->ndims - 1); /* Number of dimensions */
-	unsigned u;
+        unsigned u;
 
-	/* Compute coordinate offset from scaled offset */
-	for(u = 0; u < ndims; u++)
-	    swizzled_coords[u] = udata->common.scaled[u] * idx_info->layout->dim[u];
+        /* Compute coordinate offset from scaled offset */
+        for(u = 0; u < ndims; u++)
+            swizzled_coords[u] = udata->common.scaled[u] * idx_info->layout->dim[u];
 
         H5VM_swizzle_coords(hsize_t, swizzled_coords, idx_info->layout->u.earray.unlim_dim);
 
@@ -1157,12 +1157,12 @@ H5D__earray_idx_get_addr(const H5D_chk_idx_info_t *idx_info, H5D_chunk_ud_t *uda
             HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "can't get chunk address")
 
         /* Update the other (constant) information for the chunk */
-	udata->chunk_block.length = idx_info->layout->size;
+        udata->chunk_block.length = idx_info->layout->size;
         udata->filter_mask = 0;
     } /* end else */
 
     if(!H5F_addr_defined(udata->chunk_block.offset))
-	udata->chunk_block.length = 0;
+        udata->chunk_block.length = 0;
 
 done:
     FUNC_LEAVE_NOAPI(ret_value)
@@ -1170,14 +1170,14 @@ H5D__earray_idx_get_addr(const H5D_chk_idx_info_t *idx_info, H5D_chunk_ud_t *uda
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_idx_resize
+ * Function:    H5D__earray_idx_resize
  *
- * Purpose:	Calculate/setup the swizzled down chunk array, used for chunk
+ * Purpose:     Calculate/setup the swizzled down chunk array, used for chunk
  *              index calculations.
  *
- * Return:	Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Thursday, July 23, 2009
  *
  *-------------------------------------------------------------------------
@@ -1224,13 +1224,13 @@ H5D__earray_idx_resize(H5O_layout_chunk_t *layout)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_idx_iterate_cb
+ * Function:    H5D__earray_idx_iterate_cb
  *
- * Purpose:	Callback routine for extensible array element iteration.
+ * Purpose:     Callback routine for extensible array element iteration.
  *
- * Return:	Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:	Vailin Choi; Feb 2015
+ * Programmer:  Vailin Choi; Feb 2015
  *
  *-------------------------------------------------------------------------
  */
@@ -1257,8 +1257,8 @@ H5D__earray_idx_iterate_cb(hsize_t H5_ATTR_UNUSED idx, const void *_elmt, void *
 
     /* Make "generic chunk" callback */
     if(H5F_addr_defined(udata->chunk_rec.chunk_addr))
-	if((ret_value = (udata->cb)(&udata->chunk_rec, udata->udata)) < 0)
-	    HERROR(H5E_DATASET, H5E_CALLBACK, "failure in generic chunk iterator callback");
+        if((ret_value = (udata->cb)(&udata->chunk_rec, udata->udata)) < 0)
+            HERROR(H5E_DATASET, H5E_CALLBACK, "failure in generic chunk iterator callback");
 
     /* Update coordinates of chunk in dataset */
     ndims = udata->common.layout->ndims - 1;
@@ -1283,18 +1283,18 @@ H5D__earray_idx_iterate_cb(hsize_t H5_ATTR_UNUSED idx, const void *_elmt, void *
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_idx_iterate
+ * Function:    H5D__earray_idx_iterate
  *
- * Purpose:	Iterate over the chunks in an index, making a callback
+ * Purpose:     Iterate over the chunks in an index, making a callback
  *              for each one.
  *
- * Note:	This implementation is slow, particularly for sparse
+ * Note:        This implementation is slow, particularly for sparse
  *              extensible arrays, replace it with call to H5EA_iterate()
  *              when that's available.
  *
- * Return:	Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Thursday, January 29, 2009
  *
  *-------------------------------------------------------------------------
@@ -1332,27 +1332,27 @@ H5D__earray_idx_iterate(const H5D_chk_idx_info_t *idx_info,
 
     /* Get the extensible array statistics */
     if(H5EA_get_stats(ea, &ea_stat) < 0)
-	HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "can't query extensible array statistics")
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "can't query extensible array statistics")
 
     if(ea_stat.stored.max_idx_set > 0) {
         H5D_earray_it_ud_t udata;   /* User data for iteration callback */
 
-	/* Initialize userdata */
-	HDmemset(&udata, 0, sizeof udata);
-	udata.common.layout = idx_info->layout;
-	udata.common.storage = idx_info->storage;
+        /* Initialize userdata */
+        HDmemset(&udata, 0, sizeof udata);
+        udata.common.layout = idx_info->layout;
+        udata.common.storage = idx_info->storage;
         HDmemset(&udata.chunk_rec, 0, sizeof(udata.chunk_rec));
         udata.filtered = (idx_info->pline->nused > 0);
         if(!udata.filtered) {
             udata.chunk_rec.nbytes = idx_info->layout->size;
             udata.chunk_rec.filter_mask = 0;
         } /* end if */
-	udata.cb = chunk_cb;
-	udata.udata = chunk_udata;
+        udata.cb = chunk_cb;
+        udata.udata = chunk_udata;
 
         /* Iterate over the extensible array elements */
-	if((ret_value = H5EA_iterate(ea, H5D__earray_idx_iterate_cb, &udata)) < 0)
-	    HERROR(H5E_DATASET, H5E_BADITER, "unable to iterate over fixed array chunk index");
+        if((ret_value = H5EA_iterate(ea, H5D__earray_idx_iterate_cb, &udata)) < 0)
+            HERROR(H5E_DATASET, H5E_BADITER, "unable to iterate over fixed array chunk index");
     } /* end if */
 
 done:
@@ -1361,13 +1361,13 @@ H5D__earray_idx_iterate(const H5D_chk_idx_info_t *idx_info,
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_idx_remove
+ * Function:    H5D__earray_idx_remove
  *
- * Purpose:	Remove chunk from index.
+ * Purpose:     Remove chunk from index.
  *
- * Return:	Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Thursday, January 29, 2009
  *
  *-------------------------------------------------------------------------
@@ -1377,7 +1377,7 @@ H5D__earray_idx_remove(const H5D_chk_idx_info_t *idx_info, H5D_chunk_common_ud_t
 {
     H5EA_t      *ea;                    /* Pointer to extensible array structure */
     hsize_t     idx;                    /* Array index of chunk */
-    herr_t	ret_value = SUCCEED;	/* Return value */
+    herr_t      ret_value = SUCCEED;    /* Return value */
 
     FUNC_ENTER_STATIC
 
@@ -1404,13 +1404,13 @@ H5D__earray_idx_remove(const H5D_chk_idx_info_t *idx_info, H5D_chunk_common_ud_t
 
     /* Check for unlimited dim. not being the slowest-changing dim. */
     if(idx_info->layout->u.earray.unlim_dim > 0) {
-        hsize_t swizzled_coords[H5O_LAYOUT_NDIMS];	/* swizzled chunk coordinates */
+        hsize_t swizzled_coords[H5O_LAYOUT_NDIMS];    /* swizzled chunk coordinates */
         unsigned ndims = (idx_info->layout->ndims - 1); /* Number of dimensions */
-	unsigned u;
+        unsigned u;
 
-	/* Compute coordinate offset from scaled offset */
-	for(u = 0; u < ndims; u++)
-	    swizzled_coords[u] = udata->scaled[u] * idx_info->layout->dim[u];
+        /* Compute coordinate offset from scaled offset */
+        for(u = 0; u < ndims; u++)
+            swizzled_coords[u] = udata->scaled[u] * idx_info->layout->dim[u];
 
         H5VM_swizzle_coords(hsize_t, swizzled_coords, idx_info->layout->u.earray.unlim_dim);
 
@@ -1472,14 +1472,14 @@ H5D__earray_idx_remove(const H5D_chk_idx_info_t *idx_info, H5D_chunk_common_ud_t
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_idx_delete_cb
+ * Function:    H5D__earray_idx_delete_cb
  *
- * Purpose:	Delete space for chunk in file
+ * Purpose:     Delete space for chunk in file
  *
- * Return:	Success:	Non-negative
- *		Failure:	negative
+ * Return:      Success:    Non-negative
+ *              Failure:    negative
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Saturday, January 31, 2009
  *
  *-------------------------------------------------------------------------
@@ -1509,19 +1509,19 @@ H5D__earray_idx_delete_cb(const H5D_chunk_rec_t *chunk_rec, void *_udata)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_idx_delete
+ * Function:    H5D__earray_idx_delete
  *
- * Purpose:	Delete index and raw data storage for entire dataset
+ * Purpose:     Delete index and raw data storage for entire dataset
  *              (i.e. all chunks)
  *
- * Note:	This implementation is slow, particularly for sparse
+ * Note:        This implementation is slow, particularly for sparse
  *              extensible arrays, replace it with call to H5EA_iterate()
  *              when that's available.
  *
- * Return:	Success:	Non-negative
- *		Failure:	negative
+ * Return:      Success:    Non-negative
+ *              Failure:    negative
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Thursday, January 29, 2009
  *
  *-------------------------------------------------------------------------
@@ -1571,13 +1571,13 @@ H5D__earray_idx_delete(const H5D_chk_idx_info_t *idx_info)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_idx_copy_setup
+ * Function:    H5D__earray_idx_copy_setup
  *
- * Purpose:	Set up any necessary information for copying chunks
+ * Purpose:     Set up any necessary information for copying chunks
  *
- * Return:	Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Saturday, January 31, 2009
  *
  *-------------------------------------------------------------------------
@@ -1626,13 +1626,13 @@ H5D__earray_idx_copy_setup(const H5D_chk_idx_info_t *idx_info_src,
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_idx_copy_shutdown
+ * Function:    H5D__earray_idx_copy_shutdown
  *
- * Purpose:	Shutdown any information from copying chunks
+ * Purpose:     Shutdown any information from copying chunks
  *
- * Return:	Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Saturday, January 31, 2009
  *
  *-------------------------------------------------------------------------
@@ -1704,7 +1704,7 @@ H5D__earray_idx_size(const H5D_chk_idx_info_t *idx_info, hsize_t *index_size)
 
     /* Get the extensible array statistics */
     if(H5EA_get_stats(ea, &ea_stat) < 0)
-	HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "can't query extensible array statistics")
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "can't query extensible array statistics")
 
     /* Set the size of the extensible array */
     *index_size = ea_stat.computed.hdr_size + ea_stat.computed.index_blk_size
@@ -1722,13 +1722,13 @@ H5D__earray_idx_size(const H5D_chk_idx_info_t *idx_info, hsize_t *index_size)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_idx_reset
+ * Function:    H5D__earray_idx_reset
  *
- * Purpose:	Reset indexing information.
+ * Purpose:     Reset indexing information.
  *
- * Return:	Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Saturday, January 31, 2009
  *
  *-------------------------------------------------------------------------
@@ -1743,7 +1743,7 @@ H5D__earray_idx_reset(H5O_storage_chunk_t *storage, hbool_t reset_addr)
 
     /* Reset index info */
     if(reset_addr) {
-	storage->idx_addr = HADDR_UNDEF;
+        storage->idx_addr = HADDR_UNDEF;
         storage->u.earray.dset_ohdr_addr = HADDR_UNDEF;
     } /* end if */
     storage->u.earray.ea = NULL;
@@ -1753,13 +1753,13 @@ H5D__earray_idx_reset(H5O_storage_chunk_t *storage, hbool_t reset_addr)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_idx_dump
+ * Function:    H5D__earray_idx_dump
  *
- * Purpose:	Dump indexing information to a stream.
+ * Purpose:     Dump indexing information to a stream.
  *
- * Return:	Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Saturday, January 31, 2009
  *
  *-------------------------------------------------------------------------
@@ -1780,13 +1780,13 @@ H5D__earray_idx_dump(const H5O_storage_chunk_t *storage, FILE *stream)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__earray_idx_dest
+ * Function:    H5D__earray_idx_dest
  *
- * Purpose:	Release indexing information in memory.
+ * Purpose:     Release indexing information in memory.
  *
- * Return:	Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Saturday, January 31, 2009
  *
  *-------------------------------------------------------------------------
@@ -1806,7 +1806,7 @@ H5D__earray_idx_dest(const H5D_chk_idx_info_t *idx_info)
     /* Check if the extensible array is open */
     if(idx_info->storage->u.earray.ea) {
 
-	/* Patch the top level file pointer contained in ea if needed */
+        /* Patch the top level file pointer contained in ea if needed */
         if(H5EA_patch_file(idx_info->storage->u.earray.ea, idx_info->f) < 0)
             HGOTO_ERROR(H5E_DATASET, H5E_CANTOPENOBJ, FAIL, "can't patch earray file pointer")
 
diff --git a/src/H5Dfarray.c b/src/H5Dfarray.c
index 4eedf04dd0b..a9202c2fb7c 100644
--- a/src/H5Dfarray.c
+++ b/src/H5Dfarray.c
@@ -261,14 +261,14 @@ H5D__farray_crt_context(void *_udata)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__farray_dst_context
+ * Function:    H5D__farray_dst_context
  *
- * Purpose:	Destroy context for callbacks
+ * Purpose:     Destroy context for callbacks
  *
- * Return:	Success:	non-NULL
- *		Failure:	NULL
+ * Return:      Success:    non-NULL
+ *              Failure:    NULL
  *
- * Programmer:	Vailin Choi
+ * Programmer:  Vailin Choi
  *              Thursday, April 30, 2009
  *
  *-------------------------------------------------------------------------
@@ -291,14 +291,14 @@ H5D__farray_dst_context(void *_ctx)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__farray_fill
+ * Function:    H5D__farray_fill
  *
- * Purpose:	Fill "missing elements" in block of elements
+ * Purpose:     Fill "missing elements" in block of elements
  *
- * Return:	Success:	non-negative
- *		Failure:	negative
+ * Return:      Success:    non-negative
+ *              Failure:    negative
  *
- * Programmer:	Vailin Choi
+ * Programmer:  Vailin Choi
  *              Thursday, April 30, 2009
  *
  *-------------------------------------------------------------------------
@@ -321,14 +321,14 @@ H5D__farray_fill(void *nat_blk, size_t nelmts)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__farray_encode
+ * Function:    H5D__farray_encode
  *
- * Purpose:	Encode an element from "native" to "raw" form
+ * Purpose:     Encode an element from "native" to "raw" form
  *
- * Return:	Success:	non-negative
- *		Failure:	negative
+ * Return:      Success:    non-negative
+ *              Failure:    negative
  *
- * Programmer:	Vailin Choi
+ * Programmer:  Vailin Choi
  *              Thursday, April 30, 2009
  *
  *-------------------------------------------------------------------------
@@ -365,14 +365,14 @@ H5D__farray_encode(void *raw, const void *_elmt, size_t nelmts, void *_ctx)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__farray_decode
+ * Function:    H5D__farray_decode
  *
- * Purpose:	Decode an element from "raw" to "native" form
+ * Purpose:     Decode an element from "raw" to "native" form
  *
- * Return:	Success:	non-negative
- *		Failure:	negative
+ * Return:      Success:    non-negative
+ *              Failure:    negative
  *
- * Programmer:	Vailin Choi
+ * Programmer:  Vailin Choi
  *              Thursday, April 30, 2009
  *
  *-------------------------------------------------------------------------
@@ -409,14 +409,14 @@ H5D__farray_decode(const void *_raw, void *_elmt, size_t nelmts, void *_ctx)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__farray_debug
+ * Function:    H5D__farray_debug
  *
- * Purpose:	Display an element for debugging
+ * Purpose:     Display an element for debugging
  *
- * Return:	Success:	non-negative
- *		Failure:	negative
+ * Return:      Success:    non-negative
+ *              Failure:    negative
  *
- * Programmer:	Vailin Choi
+ * Programmer:  Vailin Choi
  *              Thursday, April 30, 2009
  *
  *-------------------------------------------------------------------------
@@ -443,23 +443,23 @@ H5D__farray_debug(FILE *stream, int indent, int fwidth, hsize_t idx,
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__farray_crt_dbg_context
+ * Function:    H5D__farray_crt_dbg_context
  *
- * Purpose:	Create context for debugging callback
- *		(get the layout message in the specified object header)
+ * Purpose:     Create context for debugging callback
+ *              (get the layout message in the specified object header)
  *
- * Return:	Success:	non-NULL
- *		Failure:	NULL
+ * Return:      Success:    non-NULL
+ *              Failure:    NULL
  *
- * Programmer:	Vailin Choi
- *		5th August, 2009
+ * Programmer:  Vailin Choi
+ *              5th August, 2009
  *
  *-------------------------------------------------------------------------
  */
 static void *
 H5D__farray_crt_dbg_context(H5F_t *f, haddr_t obj_addr)
 {
-    H5D_farray_ctx_ud_t	*dbg_ctx = NULL;   /* Context for fixed array callback */
+    H5D_farray_ctx_ud_t     *dbg_ctx = NULL;   /* Context for fixed array callback */
     H5O_loc_t obj_loc;          /* Pointer to an object's location */
     hbool_t obj_opened = FALSE; /* Flag to indicate that the object header was opened */
     H5O_layout_t layout;        /* Layout message */
@@ -518,16 +518,16 @@ H5D__farray_crt_dbg_context(H5F_t *f, haddr_t obj_addr)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__farray_dst_dbg_context
+ * Function:    H5D__farray_dst_dbg_context
  *
- * Purpose:	Destroy context for debugging callback
- *		(free the layout message from the specified object header)
+ * Purpose:     Destroy context for debugging callback
+ *              (free the layout message from the specified object header)
  *
- * Return:	Success:	non-negative
- *		Failure:	negative
+ * Return:      Success:    non-negative
+ *              Failure:    negative
  *
- * Programmer:	Quincey Koziol
- *		24th September, 2009
+ * Programmer:  Quincey Koziol
+ *              24th September, 2009
  *
  *-------------------------------------------------------------------------
  */
@@ -549,14 +549,14 @@ H5D__farray_dst_dbg_context(void *_dbg_ctx)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__farray_filt_fill
+ * Function:    H5D__farray_filt_fill
  *
- * Purpose:	Fill "missing elements" in block of elements
+ * Purpose:     Fill "missing elements" in block of elements
  *
- * Return:	Success:	non-negative
- *		Failure:	negative
+ * Return:      Success:    non-negative
+ *              Failure:    negative
  *
- * Programmer:	Vailin Choi
+ * Programmer:  Vailin Choi
  *              Thursday, April 30, 2009
  *
  *-------------------------------------------------------------------------
@@ -580,14 +580,14 @@ H5D__farray_filt_fill(void *nat_blk, size_t nelmts)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__farray_filt_encode
+ * Function:    H5D__farray_filt_encode
  *
- * Purpose:	Encode an element from "native" to "raw" form
+ * Purpose:     Encode an element from "native" to "raw" form
  *
- * Return:	Success:	non-negative
- *		Failure:	negative
+ * Return:      Success:    non-negative
+ *              Failure:    negative
  *
- * Programmer:	Vailin Choi
+ * Programmer:  Vailin Choi
  *              Thursday, April 30, 2009
  *
  *-------------------------------------------------------------------------
@@ -627,14 +627,14 @@ H5D__farray_filt_encode(void *_raw, const void *_elmt, size_t nelmts, void *_ctx
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__farray_filt_decode
+ * Function:    H5D__farray_filt_decode
  *
- * Purpose:	Decode an element from "raw" to "native" form
+ * Purpose:     Decode an element from "raw" to "native" form
  *
- * Return:	Success:	non-negative
- *		Failure:	negative
+ * Return:      Success:    non-negative
+ *              Failure:    negative
  *
- * Programmer:	Vailin Choi
+ * Programmer:  Vailin Choi
  *              Thursday, April 30, 2009
  *
  *-------------------------------------------------------------------------
@@ -673,14 +673,14 @@ H5D__farray_filt_decode(const void *_raw, void *_elmt, size_t nelmts, void *_ctx
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__farray_filt_debug
+ * Function:    H5D__farray_filt_debug
  *
- * Purpose:	Display an element for debugging
+ * Purpose:     Display an element for debugging
  *
- * Return:	Success:	non-negative
- *		Failure:	negative
+ * Return:      Success:    non-negative
+ *              Failure:    negative
  *
- * Programmer:	Vailin Choi
+ * Programmer:  Vailin Choi
  *              Thursday, April 30, 2009
  *
  *-------------------------------------------------------------------------
@@ -708,15 +708,15 @@ H5D__farray_filt_debug(FILE *stream, int indent, int fwidth, hsize_t idx,
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__farray_idx_depend
+ * Function:    H5D__farray_idx_depend
  *
- * Purpose:	Create flush dependency between fixed array and dataset's
+ * Purpose:     Create flush dependency between fixed array and dataset's
  *              object header.
  *
- * Return:	Success:	non-negative
- *		Failure:	negative
+ * Return:      Success:    non-negative
+ *              Failure:    negative
  *
- * Programmer:	Vailin Choi
+ * Programmer:  Vailin Choi
  *              Thursday, April 30, 2009
  *
  *-------------------------------------------------------------------------
@@ -798,15 +798,15 @@ H5D__farray_idx_init(const H5D_chk_idx_info_t *idx_info, const H5S_t H5_ATTR_UNU
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__farray_idx_open
+ * Function:    H5D__farray_idx_open
  *
- * Purpose:	Opens an existing fixed array and initializes
+ * Purpose:     Opens an existing fixed array and initializes
  *              the layout struct with information about the storage.
  *
- * Return:	Success:	non-negative
- *		Failure:	negative
+ * Return:      Success:    non-negative
+ *              Failure:    negative
  *
- * Programmer:	Vailin Choi
+ * Programmer:  Vailin Choi
  *              Thursday, April 30, 2009
  *
  *-------------------------------------------------------------------------
@@ -849,19 +849,19 @@ H5D__farray_idx_open(const H5D_chk_idx_info_t *idx_info)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__farray_idx_create
+ * Function:    H5D__farray_idx_create
  *
- * Purpose:	Creates a new indexed-storage fixed array and initializes
+ * Purpose:     Creates a new indexed-storage fixed array and initializes
  *              the layout struct with information about the storage.  The
- *		struct should be immediately written to the object header.
+ *              struct should be immediately written to the object header.
  *
- *		This function must be called before passing LAYOUT to any of
- *		the other indexed storage functions!
+ *              This function must be called before passing LAYOUT to any of
+ *              the other indexed storage functions!
  *
- * Return:	Non-negative on success (with the LAYOUT argument initialized
- *		and ready to write to an object header). Negative on failure.
+ * Return:      Non-negative on success (with the LAYOUT argument initialized
+ *              and ready to write to an object header). Negative on failure.
  *
- * Programmer:	Vailin Choi
+ * Programmer:  Vailin Choi
  *              Thursday, April 30, 2009
  *
  *-------------------------------------------------------------------------
@@ -869,9 +869,9 @@ H5D__farray_idx_open(const H5D_chk_idx_info_t *idx_info)
 static herr_t
 H5D__farray_idx_create(const H5D_chk_idx_info_t *idx_info)
 {
-    H5FA_create_t 	cparam; /* Fixed array creation parameters */
+    H5FA_create_t     cparam; /* Fixed array creation parameters */
     H5D_farray_ctx_ud_t udata;  /* User data for fixed array create call */
-    herr_t 	ret_value = SUCCEED; 	/* Return value */
+    herr_t     ret_value = SUCCEED;     /* Return value */
 
     FUNC_ENTER_STATIC
 
@@ -930,13 +930,13 @@ H5D__farray_idx_create(const H5D_chk_idx_info_t *idx_info)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__farray_idx_is_space_alloc
+ * Function:    H5D__farray_idx_is_space_alloc
  *
- * Purpose:	Query if space is allocated for index method
+ * Purpose:     Query if space is allocated for index method
  *
- * Return:	Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:	Vailin Choi
+ * Programmer:  Vailin Choi
  *              Thursday, April 30, 2009
  *
  *-------------------------------------------------------------------------
@@ -954,13 +954,13 @@ H5D__farray_idx_is_space_alloc(const H5O_storage_chunk_t *storage)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5D__farray_idx_insert
+ * Function:    H5D__farray_idx_insert
  *
- * Purpose:	Insert chunk address into the indexing structure.
+ * Purpose:     Insert chunk address into the indexing structure.
  *
- * Return:	Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:	Vailin Choi; 5 May 2014
+ * Programmer:  Vailin Choi; 5 May 2014
  *
  *-------------------------------------------------------------------------
  */
@@ -968,8 +968,8 @@ static herr_t
 H5D__farray_idx_insert(const H5D_chk_idx_info_t *idx_info, H5D_chunk_ud_t *udata,
     const H5D_t H5_ATTR_UNUSED *dset)
 {
-    H5FA_t      *fa;  	/* Pointer to fixed array structure */
-    herr_t	ret_value = SUCCEED;		/* Return value */
+    H5FA_t      *fa;      /* Pointer to fixed array structure */
+    herr_t      ret_value = SUCCEED;        /* Return value */
 
     FUNC_ENTER_STATIC
 
diff --git a/src/H5Dio.c b/src/H5Dio.c
index 84b7e7a01b3..a972e0082c5 100644
--- a/src/H5Dio.c
+++ b/src/H5Dio.c
@@ -149,7 +149,7 @@ H5D__get_offset_copy(const H5D_t *dset, const hsize_t *offset, hsize_t *offset_c
  *              The PLIST_ID can be the constant H5P_DEFAULT in which
  *              case the default data transfer properties are used.
  *
- * Return:      SUCCEED/FAIL
+ * Return:      Non-negative on success/Negative on failure
  *
  * Programmer:  Robb Matzke
  *              Thursday, December 4, 1997
@@ -271,7 +271,7 @@ H5Dread_chunk(hid_t dset_id, hid_t dxpl_id, const hsize_t *offset, uint32_t *fil
  *              The PLIST_ID can be the constant H5P_DEFAULT in which
  *              case the default data transfer properties are used.
  *
- * Return:      SUCCEED/FAIL
+ * Return:      Non-negative on success/Negative on failure
  *
  * Programmer:  Robb Matzke
  *              Thursday, December 4, 1997
@@ -280,7 +280,7 @@ H5Dread_chunk(hid_t dset_id, hid_t dxpl_id, const hsize_t *offset, uint32_t *fil
  */
 herr_t
 H5Dwrite(hid_t dset_id, hid_t mem_type_id, hid_t mem_space_id,
-	 hid_t file_space_id, hid_t dxpl_id, const void *buf)
+    hid_t file_space_id, hid_t dxpl_id, const void *buf)
 {
     H5VL_object_t          *vol_obj = NULL;
     herr_t                  ret_value = SUCCEED;    /* Return value */
@@ -410,7 +410,7 @@ H5D__read(H5D_t *dataset, hid_t mem_type_id, const H5S_t *mem_space,
                                         /* projected mem space must be discarded at the   */
                                         /* end of the function to avoid a memory leak.    */
     H5D_storage_t store;                /* union of EFL and chunk pointer in file space */
-    hsize_t	nelmts;                     /* total number of elmts	*/
+    hsize_t     nelmts;                 /* total number of elmts	*/
     hbool_t     io_op_init = FALSE;     /* Whether the I/O op has been initialized */
     char        fake_char;              /* Temporary variable for NULL buffer pointers */
     herr_t	ret_value = SUCCEED;	/* Return value	*/
@@ -621,7 +621,7 @@ H5D__write(H5D_t *dataset, hid_t mem_type_id, const H5S_t *mem_space,
                                         /* projected mem space must be discarded at the   */
                                         /* end of the function to avoid a memory leak.    */
     H5D_storage_t store;                /* union of EFL and chunk pointer in file space */
-    hsize_t	nelmts;                     /* total number of elmts	*/
+    hsize_t     nelmts;                 /* total number of elmts	*/
     hbool_t     io_op_init = FALSE;     /* Whether the I/O op has been initialized */
     char        fake_char;              /* Temporary variable for NULL buffer pointers */
     herr_t	ret_value = SUCCEED;	/* Return value	*/
@@ -1153,10 +1153,7 @@ H5D__ioinfo_adjust(H5D_io_info_t *io_info, const H5D_t *dset,
 
                 /* Append each of the "reason for breaking collective I/O" error messages to the
                  * local and global no collective cause strings */
-                for (cause = 1, idx = 0;
-                     (cause < H5D_MPIO_NO_COLLECTIVE_MAX_CAUSE) &&
-                     (idx < cause_strings_len);
-                     cause <<= 1, idx++) {
+                for (cause = 1, idx = 0; (cause < H5D_MPIO_NO_COLLECTIVE_MAX_CAUSE) && (idx < cause_strings_len); cause <<= 1, idx++) {
                     size_t cause_strlen = HDstrlen(cause_strings[idx]);
 
                     if (cause & local_no_collective_cause) {
@@ -1166,8 +1163,7 @@ H5D__ioinfo_adjust(H5D_io_info_t *io_info, const H5D_t *dset,
                         if(local_error_message_previously_written)
                             HDstrncat(local_no_collective_cause_string, "; ", 2);
 
-                        HDstrncat(local_no_collective_cause_string,
-				  cause_strings[idx], cause_strlen);
+                        HDstrncat(local_no_collective_cause_string, cause_strings[idx], cause_strlen);
 
                         local_error_message_previously_written = TRUE;
                     } /* end if */
@@ -1179,8 +1175,7 @@ H5D__ioinfo_adjust(H5D_io_info_t *io_info, const H5D_t *dset,
                         if(global_error_message_previously_written)
                             HDstrncat(global_no_collective_cause_string, "; ", 2);
 
-                        HDstrncat(global_no_collective_cause_string,
-				  cause_strings[idx], cause_strlen);
+                        HDstrncat(global_no_collective_cause_string, cause_strings[idx], cause_strlen);
 
                         global_error_message_previously_written = TRUE;
                     } /* end if */
diff --git a/src/H5Dlayout.c b/src/H5Dlayout.c
index e2571402325..679a33b5da2 100644
--- a/src/H5Dlayout.c
+++ b/src/H5Dlayout.c
@@ -66,7 +66,7 @@ const unsigned H5O_layout_ver_bounds[] = {
 
 
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5D__layout_set_io_ops
  *
@@ -153,7 +153,7 @@ H5D__layout_set_io_ops(const H5D_t *dataset)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5D__layout_set_io_ops() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5D__layout_meta_size
  *
@@ -284,7 +284,7 @@ H5D__layout_meta_size(const H5F_t *f, const H5O_layout_t *layout, hbool_t includ
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5D__layout_meta_size() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5D__layout_set_version
  *
@@ -322,7 +322,7 @@ H5D__layout_set_version(H5F_t *f, H5O_layout_t *layout)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5D__layout_set_version() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5D__layout_set_latest_indexing
  *
@@ -362,7 +362,7 @@ H5D__layout_set_latest_indexing(H5O_layout_t *layout, const H5S_t *space,
         if(ndims > 0) {
             hsize_t max_dims[H5O_LAYOUT_NDIMS]; /* Maximum dimension sizes */
             hsize_t cur_dims[H5O_LAYOUT_NDIMS]; /* Current dimension sizes */
-            unsigned unlim_count = 0;              /* Count of unlimited max. dimensions */
+            unsigned unlim_count = 0;           /* Count of unlimited max. dimensions */
             hbool_t single = TRUE;              /* Fulfill single chunk indexing */
             unsigned u;                         /* Local index variable */
 
@@ -446,7 +446,7 @@ H5D__layout_set_latest_indexing(H5O_layout_t *layout, const H5S_t *space,
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5D__layout_set_latest_indexing() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5D__layout_oh_create
  *
@@ -589,17 +589,17 @@ H5D__layout_oh_create(H5F_t *file, H5O_t *oh, H5D_t *dset, hid_t dapl_id)
     FUNC_LEAVE_NOAPI_TAG(ret_value)
 } /* end H5D__layout_oh_create() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5D__layout_oh_read
  *
- * Purpose:    Read layout/pline/efl information for dataset
+ * Purpose:     Read layout/pline/efl information for dataset
  *
- * Return:    Success:    SUCCEED
- *        Failure:    FAIL
+ * Return:      Success:    SUCCEED
+ *              Failure:    FAIL
  *
- * Programmer:    Quincey Koziol
- *        Monday, July 27, 2009
+ * Programmer:  Quincey Koziol
+ *              Monday, July 27, 2009
  *
  *-------------------------------------------------------------------------
  */
@@ -683,17 +683,17 @@ H5D__layout_oh_read(H5D_t *dataset, hid_t dapl_id, H5P_genplist_t *plist)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5D__layout_oh_read() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5D__layout_oh_write
  *
- * Purpose:    Write layout information for dataset
+ * Purpose:     Write layout information for dataset
  *
- * Return:    Success:    SUCCEED
- *        Failure:    FAIL
+ * Return:      Success:    SUCCEED
+ *              Failure:    FAIL
  *
- * Programmer:    Quincey Koziol
- *        Monday, July 27, 2009
+ * Programmer:  Quincey Koziol
+ *              Monday, July 27, 2009
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Dmpio.c b/src/H5Dmpio.c
index 492902b67a0..cfed02e2e3d 100644
--- a/src/H5Dmpio.c
+++ b/src/H5Dmpio.c
@@ -3272,7 +3272,7 @@ H5D__filtered_collective_chunk_entry_io(H5D_filtered_collective_io_info_t *chunk
                     if(H5S_close(dataspace) < 0)
                         HGOTO_ERROR(H5E_DATASPACE, H5E_CANTFREE, FAIL, "can't close dataspace")
                     dataspace = NULL;
-                } /* end if */
+                }
                 H5MM_free(chunk_entry->async_info.receive_buffer_array[i]);
             } /* end for */
 
diff --git a/src/H5Dselect.c b/src/H5Dselect.c
index c5469c2b444..5a5c49146ae 100644
--- a/src/H5Dselect.c
+++ b/src/H5Dselect.c
@@ -11,7 +11,7 @@
  * help@hdfgroup.org.                                                        *
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
-/* Programmer:  Quincey Koziol <koziol@ncsa.uiuc.ued>
+/* Programmer:  Quincey Koziol
  *              Thursday, September 30, 2004
  *
  * Purpose:	Dataspace I/O functions.
diff --git a/src/H5EAdbg.c b/src/H5EAdbg.c
index 3d6c2ed9ea6..eb3624be99c 100644
--- a/src/H5EAdbg.c
+++ b/src/H5EAdbg.c
@@ -13,11 +13,11 @@
 
 /*-------------------------------------------------------------------------
  *
- * Created:		H5EAdbg.c
- *			Sep 11 2008
- *			Quincey Koziol <koziol@hdfgroup.org>
+ * Created:         H5EAdbg.c
+ *                  Sep 11 2008
+ *                  Quincey Koziol
  *
- * Purpose:		Dump debugging information about an extensible array.
+ * Purpose:        Dump debugging information about an extensible array.
  *
  *-------------------------------------------------------------------------
  */
@@ -37,9 +37,9 @@
 /***********/
 /* Headers */
 /***********/
-#include "H5private.h"		/* Generic Functions			*/
-#include "H5Eprivate.h"		/* Error handling		  	*/
-#include "H5EApkg.h"		/* Extensible Arrays			*/
+#include "H5private.h"          /* Generic Functions            */
+#include "H5Eprivate.h"         /* Error handling               */
+#include "H5EApkg.h"            /* Extensible Arrays            */
 
 
 /****************/
@@ -79,15 +79,14 @@
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5EA__hdr_debug
+ * Function:    H5EA__hdr_debug
  *
- * Purpose:	Prints debugging info about a extensible array header.
+ * Purpose:     Prints debugging info about a extensible array header.
  *
- * Return:	Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
- *		Sep 11 2008
+ * Programmer:  Quincey Koziol
+ *              Sep 11 2008
  *
  *-------------------------------------------------------------------------
  */
@@ -97,7 +96,7 @@ H5EA__hdr_debug(H5F_t *f, haddr_t addr, FILE *stream, int indent,
     int fwidth, const H5EA_class_t *cls, haddr_t obj_addr))
 
     /* Local variables */
-    H5EA_hdr_t *hdr = NULL; 	/* Shared extensible array header */
+    H5EA_hdr_t *hdr = NULL;     /* Shared extensible array header */
     void *dbg_ctx = NULL;       /* Extensible array debugging context */
 
     /* Check arguments */
@@ -117,59 +116,59 @@ H5EA__hdr_debug(H5F_t *f, haddr_t addr, FILE *stream, int indent,
 
     /* Load the extensible array header */
     if(NULL == (hdr = H5EA__hdr_protect(f, addr, dbg_ctx, H5AC__READ_ONLY_FLAG)))
-	H5E_THROW(H5E_CANTPROTECT, "unable to load extensible array header")
+        H5E_THROW(H5E_CANTPROTECT, "unable to load extensible array header")
 
     /* Print opening message */
     HDfprintf(stream, "%*sExtensible Array Header...\n", indent, "");
 
     /* Print the values */
     HDfprintf(stream, "%*s%-*s %s\n", indent, "", fwidth,
-	      "Array class ID:",  hdr->cparam.cls->name);
+        "Array class ID:",  hdr->cparam.cls->name);
     HDfprintf(stream, "%*s%-*s %Zu\n", indent, "", fwidth,
-	      "Header size:",
-	      hdr->size);
+        "Header size:",
+        hdr->size);
     HDfprintf(stream, "%*s%-*s %u\n", indent, "", fwidth,
-	      "Raw Element Size:",
-	      (unsigned)hdr->cparam.raw_elmt_size);
+        "Raw Element Size:",
+        (unsigned)hdr->cparam.raw_elmt_size);
     HDfprintf(stream, "%*s%-*s %Zu\n", indent, "", fwidth,
-	      "Native Element Size (on this platform):",
-	      hdr->cparam.cls->nat_elmt_size);
+        "Native Element Size (on this platform):",
+        hdr->cparam.cls->nat_elmt_size);
     HDfprintf(stream, "%*s%-*s %u\n", indent, "", fwidth,
-	      "Log2(Max. # of elements in array):",
-	      (unsigned)hdr->cparam.max_nelmts_bits);
+        "Log2(Max. # of elements in array):",
+        (unsigned)hdr->cparam.max_nelmts_bits);
     HDfprintf(stream, "%*s%-*s %u\n", indent, "", fwidth,
-	      "# of elements in index block:",
-	      (unsigned)hdr->cparam.idx_blk_elmts);
+        "# of elements in index block:",
+        (unsigned)hdr->cparam.idx_blk_elmts);
     HDfprintf(stream, "%*s%-*s %u\n", indent, "", fwidth,
-	      "Min. # of elements per data block:",
-	      (unsigned)hdr->cparam.data_blk_min_elmts);
+        "Min. # of elements per data block:",
+        (unsigned)hdr->cparam.data_blk_min_elmts);
     HDfprintf(stream, "%*s%-*s %u\n", indent, "", fwidth,
-	      "Min. # of data block pointers for a super block:",
-	      (unsigned)hdr->cparam.sup_blk_min_data_ptrs);
+        "Min. # of data block pointers for a super block:",
+        (unsigned)hdr->cparam.sup_blk_min_data_ptrs);
     HDfprintf(stream, "%*s%-*s %u\n", indent, "", fwidth,
-	      "Log2(Max. # of elements in data block page):",
-	      (unsigned)hdr->cparam.max_dblk_page_nelmts_bits);
+        "Log2(Max. # of elements in data block page):",
+        (unsigned)hdr->cparam.max_dblk_page_nelmts_bits);
     HDfprintf(stream, "%*s%-*s %Hu\n", indent, "", fwidth,
-	      "Highest element index stored (+1):",
-	      hdr->stats.stored.max_idx_set);
+        "Highest element index stored (+1):",
+        hdr->stats.stored.max_idx_set);
     HDfprintf(stream, "%*s%-*s %Hu\n", indent, "", fwidth,
-	      "Number of super blocks created:",
-	      hdr->stats.stored.nsuper_blks);
+        "Number of super blocks created:",
+        hdr->stats.stored.nsuper_blks);
     HDfprintf(stream, "%*s%-*s %Hu\n", indent, "", fwidth,
-	      "Number of data blocks created:",
-	      hdr->stats.stored.ndata_blks);
+        "Number of data blocks created:",
+        hdr->stats.stored.ndata_blks);
     HDfprintf(stream, "%*s%-*s %Hu\n", indent, "", fwidth,
-	      "Number of elements 'realized':",
-	      hdr->stats.stored.nelmts);
+        "Number of elements 'realized':",
+        hdr->stats.stored.nelmts);
     HDfprintf(stream, "%*s%-*s %a\n", indent, "", fwidth,
-	      "Index Block Address:",
-	      hdr->idx_blk_addr);
+        "Index Block Address:",
+        hdr->idx_blk_addr);
 
 CATCH
     if(dbg_ctx && cls->dst_dbg_ctx(dbg_ctx) < 0)
         H5E_THROW(H5E_CANTRELEASE, "unable to release extensible array debugging context")
     if(hdr && H5EA__hdr_unprotect(hdr, H5AC__NO_FLAGS_SET) < 0)
-	H5E_THROW(H5E_CANTUNPROTECT, "unable to release extensible array header")
+        H5E_THROW(H5E_CANTUNPROTECT, "unable to release extensible array header")
 
 END_FUNC(PKG)   /* end H5EA__hdr_debug() */
 
@@ -384,21 +383,20 @@ CATCH
     if(sblock && H5EA__sblock_unprotect(sblock, H5AC__NO_FLAGS_SET) < 0)
         H5E_THROW(H5E_CANTUNPROTECT, "unable to release extensible array super block")
     if(hdr && H5EA__hdr_unprotect(hdr, H5AC__NO_FLAGS_SET) < 0)
-	H5E_THROW(H5E_CANTUNPROTECT, "unable to release extensible array header")
+        H5E_THROW(H5E_CANTUNPROTECT, "unable to release extensible array header")
 
 END_FUNC(PKG)   /* end H5EA__sblock_debug() */
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5EA__dblock_debug
+ * Function:    H5EA__dblock_debug
  *
- * Purpose:	Prints debugging info about a extensible array data block.
+ * Purpose:     Prints debugging info about a extensible array data block.
  *
- * Return:	Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
- *		Sep 22 2008
+ * Programmer:  Quincey Koziol
+ *              Sep 22 2008
  *
  *-------------------------------------------------------------------------
  */
@@ -432,7 +430,7 @@ H5EA__dblock_debug(H5F_t *f, haddr_t addr, FILE *stream, int indent,
 
     /* Load the extensible array header */
     if(NULL == (hdr = H5EA__hdr_protect(f, hdr_addr, dbg_ctx, H5AC__READ_ONLY_FLAG)))
-	H5E_THROW(H5E_CANTPROTECT, "unable to load extensible array header")
+        H5E_THROW(H5E_CANTPROTECT, "unable to load extensible array header")
 
     /* Protect data block */
     /* (Note: setting parent of data block to 'hdr' for this operation should be OK -QAK) */
@@ -444,10 +442,10 @@ H5EA__dblock_debug(H5F_t *f, haddr_t addr, FILE *stream, int indent,
 
     /* Print the values */
     HDfprintf(stream, "%*s%-*s %s\n", indent, "", fwidth,
-	      "Array class ID:",  hdr->cparam.cls->name);
+        "Array class ID:",  hdr->cparam.cls->name);
     HDfprintf(stream, "%*s%-*s %Zu\n", indent, "", fwidth,
-	      "Data Block size:",
-	      dblock->size);
+        "Data Block size:",
+        dblock->size);
 
 
     /* Print the elements in the index block */
@@ -466,7 +464,7 @@ CATCH
     if(dblock && H5EA__dblock_unprotect(dblock, H5AC__NO_FLAGS_SET) < 0)
         H5E_THROW(H5E_CANTUNPROTECT, "unable to release extensible array data block")
     if(hdr && H5EA__hdr_unprotect(hdr, H5AC__NO_FLAGS_SET) < 0)
-	H5E_THROW(H5E_CANTUNPROTECT, "unable to release extensible array header")
+        H5E_THROW(H5E_CANTUNPROTECT, "unable to release extensible array header")
 
 END_FUNC(PKG)   /* end H5EA__dblock_debug() */
 
diff --git a/src/H5Pdcpl.c b/src/H5Pdcpl.c
index 7e49c4bd5bd..064a9b89505 100644
--- a/src/H5Pdcpl.c
+++ b/src/H5Pdcpl.c
@@ -246,7 +246,7 @@ static hbool_t H5P_dcrt_def_layout_init_g = FALSE;
 static herr_t
 H5P__dcrt_reg_prop(H5P_genclass_t *pclass)
 {
-    herr_t  ret_value   = SUCCEED;         /* Return value */
+    herr_t ret_value = SUCCEED;         /* Return value */
 
     FUNC_ENTER_STATIC
 
@@ -421,13 +421,13 @@ H5P__dcrt_layout_enc(const void *value, void **_pp, size_t *size)
             for(u = 0; u < layout->storage.u.virt.list_nused; u++) {
                 /* Source file name */
                 tmp_size = HDstrlen(layout->storage.u.virt.list[u].source_file_name) + (size_t)1;
-                (void)H5MM_memcpy(*pp, layout->storage.u.virt.list[u].source_file_name, tmp_size);
+                H5MM_memcpy(*pp, layout->storage.u.virt.list[u].source_file_name, tmp_size);
                 *pp += tmp_size;
                 *size += tmp_size;
 
                 /* Source dataset name */
                 tmp_size = HDstrlen(layout->storage.u.virt.list[u].source_dset_name) + (size_t)1;
-                (void)H5MM_memcpy(*pp, layout->storage.u.virt.list[u].source_dset_name, tmp_size);
+                H5MM_memcpy(*pp, layout->storage.u.virt.list[u].source_dset_name, tmp_size);
                 *pp += tmp_size;
                 *size += tmp_size;
 
@@ -597,14 +597,14 @@ H5P__dcrt_layout_dec(const void **_pp, void *value)
                         tmp_size = HDstrlen((const char *)*pp) + 1;
                         if(NULL == (tmp_layout.storage.u.virt.list[u].source_file_name = (char *)H5MM_malloc(tmp_size)))
                             HGOTO_ERROR(H5E_PLIST, H5E_CANTALLOC, FAIL, "unable to allocate memory for source file name")
-                        (void)H5MM_memcpy(tmp_layout.storage.u.virt.list[u].source_file_name, *pp, tmp_size);
+                        H5MM_memcpy(tmp_layout.storage.u.virt.list[u].source_file_name, *pp, tmp_size);
                         *pp += tmp_size;
 
                         /* Source dataset name */
                         tmp_size = HDstrlen((const char *)*pp) + 1;
                         if(NULL == (tmp_layout.storage.u.virt.list[u].source_dset_name = (char *)H5MM_malloc(tmp_size)))
                             HGOTO_ERROR(H5E_PLIST, H5E_CANTALLOC, FAIL, "unable to allocate memory for source dataset name")
-                        (void)H5MM_memcpy(tmp_layout.storage.u.virt.list[u].source_dset_name, *pp, tmp_size);
+                        H5MM_memcpy(tmp_layout.storage.u.virt.list[u].source_dset_name, *pp, tmp_size);
                         *pp += tmp_size;
 
                         /* Source selection */
@@ -2375,7 +2375,7 @@ H5Pget_virtual_vspace(hid_t dcpl_id, size_t idx)
 
     /* Get the virtual space */
     if(idx >= layout.storage.u.virt.list_nused)
-        HGOTO_ERROR(H5E_ARGS, H5E_BADRANGE, FAIL, "invalid idx (out of range)")
+        HGOTO_ERROR(H5E_ARGS, H5E_BADRANGE, FAIL, "invalid index (out of range)")
     HDassert(layout.storage.u.virt.list_nused <= layout.storage.u.virt.list_nalloc);
     if(NULL == (space = H5S_copy(layout.storage.u.virt.list[idx].source_dset.virtual_select, FALSE, TRUE)))
         HGOTO_ERROR(H5E_PLIST, H5E_CANTCOPY, FAIL, "unable to copy virtual selection")
@@ -2431,9 +2431,9 @@ H5Pget_virtual_srcspace(hid_t dcpl_id, size_t idx)
     if(H5D_VIRTUAL != layout.type)
         HGOTO_ERROR(H5E_ARGS, H5E_BADVALUE, FAIL, "not a virtual storage layout")
 
-    /* Check idx */
+    /* Check index */
     if(idx >= layout.storage.u.virt.list_nused)
-        HGOTO_ERROR(H5E_ARGS, H5E_BADRANGE, FAIL, "invalid idx (out of range)")
+        HGOTO_ERROR(H5E_ARGS, H5E_BADRANGE, FAIL, "invalid index (out of range)")
     HDassert(layout.storage.u.virt.list_nused <= layout.storage.u.virt.list_nalloc);
 
     /* Attempt to open source dataset and patch extent if extent status is not
@@ -2537,7 +2537,7 @@ H5Pget_virtual_filename(hid_t dcpl_id, size_t idx, char *name/*out*/,
 
     /* Get the virtual filename */
     if(idx >= layout.storage.u.virt.list_nused)
-        HGOTO_ERROR(H5E_ARGS, H5E_BADRANGE, FAIL, "invalid idx (out of range)")
+        HGOTO_ERROR(H5E_ARGS, H5E_BADRANGE, FAIL, "invalid index (out of range)")
     HDassert(layout.storage.u.virt.list_nused <= layout.storage.u.virt.list_nalloc);
     HDassert(layout.storage.u.virt.list[idx].source_file_name);
     if(name && (size > 0))
@@ -2600,7 +2600,7 @@ H5Pget_virtual_dsetname(hid_t dcpl_id, size_t idx, char *name/*out*/,
 
     /* Get the virtual filename */
     if(idx >= layout.storage.u.virt.list_nused)
-        HGOTO_ERROR(H5E_ARGS, H5E_BADRANGE, FAIL, "invalid idx (out of range)")
+        HGOTO_ERROR(H5E_ARGS, H5E_BADRANGE, FAIL, "invalid index (out of range)")
     HDassert(layout.storage.u.virt.list_nused <= layout.storage.u.virt.list_nalloc);
     HDassert(layout.storage.u.virt.list[idx].source_dset_name);
     if(name && (size > 0))
diff --git a/src/H5S.c b/src/H5S.c
index ddfd0646f92..bea86caf280 100644
--- a/src/H5S.c
+++ b/src/H5S.c
@@ -88,18 +88,18 @@ H5FL_ARR_DEFINE(hsize_t, H5S_MAX_RANK);
 
 /* Dataspace ID class */
 static const H5I_class_t H5I_DATASPACE_CLS[1] = {{
-    H5I_DATASPACE,        /* ID class value */
-    0,                /* Class flags */
-    2,                /* # of reserved IDs for class */
-    (H5I_free_t)H5S_close    /* Callback routine for closing objects of this class */
+    H5I_DATASPACE,              /* ID class value */
+    0,                          /* Class flags */
+    2,                          /* # of reserved IDs for class */
+    (H5I_free_t)H5S_close       /* Callback routine for closing objects of this class */
 }};
 
 /* Dataspace selection iterator ID class */
 static const H5I_class_t H5I_SPACE_SEL_ITER_CLS[1] = {{
-    H5I_SPACE_SEL_ITER,        /* ID class value */
-    0,                /* Class flags */
-    0,                /* # of reserved IDs for class */
-    (H5I_free_t)H5S_sel_iter_close    /* Callback routine for closing objects of this class */
+    H5I_SPACE_SEL_ITER,                 /* ID class value */
+    0,                                  /* Class flags */
+    0,                                  /* # of reserved IDs for class */
+    (H5I_free_t)H5S_sel_iter_close      /* Callback routine for closing objects of this class */
 }};
 
 
@@ -107,7 +107,7 @@ static const H5I_class_t H5I_SPACE_SEL_ITER_CLS[1] = {{
 static hbool_t H5S_top_package_initialize_s = FALSE;
 
 
-
+
 /*--------------------------------------------------------------------------
 NAME
    H5S__init_package -- Initialize interface-specific information
@@ -127,11 +127,11 @@ H5S__init_package(void)
 
     /* Initialize the atom group for the dataspace IDs */
     if(H5I_register_type(H5I_DATASPACE_CLS) < 0)
-    HGOTO_ERROR(H5E_DATASPACE, H5E_CANTINIT, FAIL, "unable to initialize dataspace ID class")
+        HGOTO_ERROR(H5E_DATASPACE, H5E_CANTINIT, FAIL, "unable to initialize dataspace ID class")
 
     /* Initialize the atom group for the dataspace selction iterator IDs */
     if(H5I_register_type(H5I_SPACE_SEL_ITER_CLS) < 0)
-    HGOTO_ERROR(H5E_DATASPACE, H5E_CANTINIT, FAIL, "unable to initialize dataspace selection iterator ID class")
+        HGOTO_ERROR(H5E_DATASPACE, H5E_CANTINIT, FAIL, "unable to initialize dataspace selection iterator ID class")
 
     /* Mark "top" of interface as initialized, too */
     H5S_top_package_initialize_s = TRUE;
@@ -140,7 +140,7 @@ H5S__init_package(void)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__init_package() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S_top_term_package
@@ -162,22 +162,22 @@ H5S__init_package(void)
 int
 H5S_top_term_package(void)
 {
-    int    n = 0;
+    int     n = 0;
 
     FUNC_ENTER_NOAPI_NOINIT_NOERR
 
     if(H5S_top_package_initialize_s) {
-    if(H5I_nmembers(H5I_DATASPACE) > 0) {
-        (void)H5I_clear_type(H5I_DATASPACE, FALSE, FALSE);
+        if(H5I_nmembers(H5I_DATASPACE) > 0) {
+            (void)H5I_clear_type(H5I_DATASPACE, FALSE, FALSE);
             n++; /*H5I*/
-    } /* end if */
+        } /* end if */
 
-    if(H5I_nmembers(H5I_SPACE_SEL_ITER) > 0) {
-        (void)H5I_clear_type(H5I_SPACE_SEL_ITER, FALSE, FALSE);
+        if(H5I_nmembers(H5I_SPACE_SEL_ITER) > 0) {
+            (void)H5I_clear_type(H5I_SPACE_SEL_ITER, FALSE, FALSE);
             n++; /*H5I*/
-    } /* end if */
+        } /* end if */
 
-    /* Mark "top" of interface as closed */
+        /* Mark "top" of interface as closed */
         if(0 == n)
             H5S_top_package_initialize_s = FALSE;
     } /* end if */
@@ -185,7 +185,7 @@ H5S_top_term_package(void)
     FUNC_LEAVE_NOAPI(n)
 } /* end H5S_top_term_package() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S_term_package
@@ -209,7 +209,7 @@ H5S_top_term_package(void)
 int
 H5S_term_package(void)
 {
-    int    n = 0;
+    int     n = 0;
 
     FUNC_ENTER_NOAPI_NOINIT_NOERR
 
@@ -225,7 +225,7 @@ H5S_term_package(void)
         /* Destroy the dataspace selection iterator object id group */
         n += (H5I_dec_type_ref(H5I_SPACE_SEL_ITER) > 0);
 
-    /* Mark interface as closed */
+        /* Mark interface as closed */
         if(0 == n)
             H5_PKG_INIT_VAR = FALSE;
     } /* end if */
@@ -234,7 +234,7 @@ H5S_term_package(void)
 } /* end H5S_term_package() */
 
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S_get_validiated_dataspace
@@ -278,13 +278,13 @@ H5S_get_validated_dataspace(hid_t space_id, const H5S_t **space)
         /* Check for valid selection */
         if(H5S_SELECT_VALID(*space) != TRUE)
             HGOTO_ERROR(H5E_DATASPACE, H5E_BADRANGE, FAIL, "selection + offset not within extent")
-    } /* end else */
+    }
 
 done:
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_get_validated_dataspace() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S_create
@@ -362,7 +362,7 @@ H5S_create(H5S_class_t type)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_create() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5Screate
@@ -409,16 +409,16 @@ H5Screate(H5S_class_t type)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Screate() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S__extent_release
  *
- * Purpose:    Releases all memory associated with a dataspace extent.
+ * Purpose:     Releases all memory associated with a dataspace extent.
  *
- * Return:    Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:    Quincey Koziol
- *        Thursday, July 23, 1998
+ * Programmer:  Quincey Koziol
+ *              Thursday, July 23, 1998
  *
  *-------------------------------------------------------------------------
  */
@@ -440,16 +440,16 @@ H5S__extent_release(H5S_extent_t *extent)
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5S__extent_release() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S_close
  *
- * Purpose:    Releases all memory associated with a dataspace.
+ * Purpose:     Releases all memory associated with a dataspace.
  *
- * Return:    Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:    Robb Matzke
- *        Tuesday, December  9, 1997
+ * Programmer:  Robb Matzke
+ *              Tuesday, December  9, 1997
  *
  *-------------------------------------------------------------------------
  */
@@ -481,16 +481,16 @@ H5S_close(H5S_t *ds)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_close() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Sclose
  *
- * Purpose:    Release access to a dataspace object.
+ * Purpose:     Release access to a dataspace object.
  *
- * Return:    Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:    Robb Matzke
- *        Tuesday, December  9, 1997
+ * Programmer:  Robb Matzke
+ *              Tuesday, December  9, 1997
  *
  *-------------------------------------------------------------------------
  */
@@ -514,69 +514,70 @@ H5Sclose(hid_t space_id)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Sclose() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Scopy
  *
- * Purpose:    Copies a dataspace.
+ * Purpose:     Copies a dataspace.
  *
- * Return:    Success:    ID of the new dataspace
- *        Failure:    Negative
+ * Return:      Success:    ID of the new dataspace
  *
- * Programmer:    Robb Matzke
- *        Friday, January 30, 1998
+ *              Failure:    H5I_INVALID_HID
+ *
+ * Programmer:  Robb Matzke
+ *              Friday, January 30, 1998
  *
  *-------------------------------------------------------------------------
  */
 hid_t
 H5Scopy(hid_t space_id)
 {
-    H5S_t    *src;
-    H5S_t    *dst = NULL;
-    hid_t    ret_value;
+    H5S_t   *src = NULL;
+    H5S_t   *dst = NULL;
+    hid_t   ret_value = H5I_INVALID_HID;
 
-    FUNC_ENTER_API(FAIL)
+    FUNC_ENTER_API(H5I_INVALID_HID)
     H5TRACE1("i", "i", space_id);
 
     /* Check args */
     if(NULL == (src = (H5S_t *)H5I_object_verify(space_id, H5I_DATASPACE)))
-        HGOTO_ERROR(H5E_ARGS, H5E_BADTYPE, FAIL, "not a dataspace")
+        HGOTO_ERROR(H5E_ARGS, H5E_BADTYPE, H5I_INVALID_HID, "not a dataspace")
 
     /* Copy */
     if(NULL == (dst = H5S_copy(src, FALSE, TRUE)))
-        HGOTO_ERROR(H5E_DATASPACE, H5E_CANTINIT, FAIL, "unable to copy dataspace")
+        HGOTO_ERROR(H5E_DATASPACE, H5E_CANTINIT, H5I_INVALID_HID, "unable to copy dataspace")
 
     /* Atomize */
     if((ret_value = H5I_register (H5I_DATASPACE, dst, TRUE)) < 0)
-        HGOTO_ERROR(H5E_ATOM, H5E_CANTREGISTER, FAIL, "unable to register dataspace atom")
+        HGOTO_ERROR(H5E_ATOM, H5E_CANTREGISTER, H5I_INVALID_HID, "unable to register dataspace atom")
 
 done:
     if(ret_value < 0)
         if(dst && H5S_close(dst) < 0)
-            HDONE_ERROR(H5E_DATASPACE, H5E_CANTRELEASE, FAIL, "unable to release dataspace")
+            HDONE_ERROR(H5E_DATASPACE, H5E_CANTRELEASE, H5I_INVALID_HID, "unable to release dataspace")
 
     FUNC_LEAVE_API(ret_value)
 } /* end H5Scopy() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Sextent_copy
  *
- * Purpose:    Copies a dataspace extent.
+ * Purpose:     Copies a dataspace extent.
  *
- * Return:    Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:    Quincey Koziol
- *        Thursday, July 23, 1998
+ * Programmer:  Quincey Koziol
+ *              Thursday, July 23, 1998
  *
  *-------------------------------------------------------------------------
  */
 herr_t
 H5Sextent_copy(hid_t dst_id,hid_t src_id)
 {
-    H5S_t    *src;
-    H5S_t    *dst;
-    herr_t    ret_value = SUCCEED;
+    H5S_t       *src;
+    H5S_t       *dst;
+    herr_t      ret_value = SUCCEED;
 
     FUNC_ENTER_API(FAIL)
     H5TRACE2("e", "ii", dst_id, src_id);
@@ -595,7 +596,7 @@ H5Sextent_copy(hid_t dst_id,hid_t src_id)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Sextent_copy() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S_extent_copy
  *
@@ -632,16 +633,16 @@ H5S_extent_copy(H5S_t *dst, const H5S_t *src)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_extent_copy() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S__extent_copy_real
  *
- * Purpose:    Copies a dataspace extent
+ * Purpose:     Copies a dataspace extent
  *
- * Return:    Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:    Quincey Koziol
- *        Wednesday, June  3, 1998
+ * Programmer:  Quincey Koziol
+ *              Wednesday, June  3, 1998
  *
  *-------------------------------------------------------------------------
  */
@@ -701,29 +702,30 @@ H5S__extent_copy_real(H5S_extent_t *dst, const H5S_extent_t *src, hbool_t copy_m
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__extent_copy_real() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S_copy
  *
- * Purpose:    Copies a dataspace, by copying the extent and selection through
- *          H5S_extent_copy and H5S_select_copy.  If the SHARE_SELECTION flag
- *          is set, then the selection can be shared between the source and
- *          destination dataspaces.  (This should only occur in situations
- *          where the destination dataspace will immediately change to a new
- *          selection)
+ * Purpose:     Copies a dataspace, by copying the extent and selection through
+ *              H5S_extent_copy and H5S_select_copy.  If the SHARE_SELECTION flag
+ *              is set, then the selection can be shared between the source and
+ *              destination dataspaces.  (This should only occur in situations
+ *              where the destination dataspace will immediately change to a new
+ *              selection)
  *
- * Return:    Success:    A pointer to a new copy of SRC
- *        Failure:    NULL
+ * Return:      Success:    A pointer to a new copy of SRC
  *
- * Programmer:    Robb Matzke
- *        Thursday, December  4, 1997
+ *              Failure:    NULL
+ *
+ * Programmer:  Robb Matzke
+ *              Thursday, December  4, 1997
  *
  *-------------------------------------------------------------------------
  */
 H5S_t *
 H5S_copy(const H5S_t *src, hbool_t share_selection, hbool_t copy_max)
 {
-    H5S_t    *dst = NULL;
+    H5S_t       *dst = NULL;
     H5S_t       *ret_value = NULL;      /* Return value */
 
     FUNC_ENTER_NOAPI(NULL)
@@ -750,17 +752,18 @@ H5S_copy(const H5S_t *src, hbool_t share_selection, hbool_t copy_max)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_copy() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S_get_simple_extent_npoints
  *
- * Purpose:    Determines how many data points a dataset extent has.
+ * Purpose:     Determines how many data points a dataset extent has.
+ *
+ * Return:      Success:    Number of data points in the dataset extent.
  *
- * Return:    Success:    Number of data points in the dataset extent.
- *        Failure:    negative
+ *              Failure:    Negative
  *
- * Programmer:    Robb Matzke
- *        Tuesday, December  9, 1997
+ * Programmer:  Robb Matzke
+ *              Tuesday, December  9, 1997
  *
  * Note:        This routine participates in the "Inlining C function pointers"
  *              pattern, don't call it directly, use the appropriate macro
@@ -785,17 +788,17 @@ H5S_get_simple_extent_npoints(const H5S_t *ds)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_get_simple_extent_npoints() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Sget_simple_extent_npoints
  *
- * Purpose:    Determines how many data points a dataset extent has.
+ * Purpose:     Determines how many data points a dataset extent has.
  *
- * Return:    Success:    Number of data points in the dataset.
- *        Failure:    negative
+ * Return:      Success:    Number of data points in the dataset.
+ *              Failure:    Negative
  *
- * Programmer:    Robb Matzke
- *        Tuesday, December  9, 1997
+ * Programmer:  Robb Matzke
+ *              Tuesday, December  9, 1997
  *
  *-------------------------------------------------------------------------
  */
@@ -803,7 +806,7 @@ hssize_t
 H5Sget_simple_extent_npoints(hid_t space_id)
 {
     H5S_t           *ds;
-    hssize_t            ret_value;
+    hssize_t        ret_value;
 
     FUNC_ENTER_API(FAIL)
     H5TRACE1("Hs", "i", space_id);
@@ -818,22 +821,22 @@ H5Sget_simple_extent_npoints(hid_t space_id)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Sget_simple_extent_npoints() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S_get_npoints_max
  *
- * Purpose:    Determines the maximum number of data points a dataspace may
- *        have.  If the `max' array is null then the maximum number of
- *        data points is the same as the current number of data points
- *        without regard to the hyperslab.  If any element of the `max'
- *        array is zero then the maximum possible size is returned.
+ * Purpose:     Determines the maximum number of data points a dataspace may
+ *              have.  If the `max' array is null then the maximum number of
+ *              data points is the same as the current number of data points
+ *              without regard to the hyperslab.  If any element of the `max'
+ *              array is zero then the maximum possible size is returned.
  *
- * Return:    Success:    Maximum number of data points the dataspace
- *                may have.
- *        Failure:    0
+ * Return:      Success:    Maximum number of data points the dataspace
+ *                          may have.
+ *              Failure:    0
  *
- * Programmer:    Robb Matzke
- *        Tuesday, December  9, 1997
+ * Programmer:  Robb Matzke
+ *              Tuesday, December  9, 1997
  *
  *-------------------------------------------------------------------------
  */
@@ -841,7 +844,7 @@ hsize_t
 H5S_get_npoints_max(const H5S_t *ds)
 {
     unsigned        u;
-    hsize_t        ret_value = 0;      /* Return value */
+    hsize_t         ret_value = 0;      /* Return value */
 
     FUNC_ENTER_NOAPI(0)
 
@@ -863,11 +866,11 @@ H5S_get_npoints_max(const H5S_t *ds)
                     if(H5S_UNLIMITED == ds->extent.max[u]) {
                         ret_value = HSIZET_MAX;
                         break;
-                    } /* end if */
+                    }
                     else
                         ret_value *= ds->extent.max[u];
-                } /* end for */
-            } /* end if */
+                }
+            }
             else
                 for(ret_value = 1, u = 0; u < ds->extent.rank; u++)
                     ret_value *= ds->extent.size[u];
@@ -877,38 +880,38 @@ H5S_get_npoints_max(const H5S_t *ds)
         default:
             HDassert("unknown dataspace class" && 0);
             HGOTO_ERROR(H5E_DATASPACE, H5E_UNSUPPORTED, 0, "internal error (unknown dataspace class)")
-    } /* end switch */
+    }
 
 done:
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_get_npoints_max() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Sget_simple_extent_ndims
  *
- * Purpose:    Determines the dimensionality of a dataspace.
+ * Purpose:     Determines the dimensionality of a dataspace.
  *
- * Return:    Success:    The number of dimensions in a dataspace.
- *        Failure:    Negative
+ * Return:      Success:    The number of dimensions in a dataspace.
+ *              Failure:    Negative
  *
- * Programmer:    Robb Matzke
- *        Thursday, December 11, 1997
+ * Programmer:  Robb Matzke
+ *              Thursday, December 11, 1997
  *
  *-------------------------------------------------------------------------
  */
 int
 H5Sget_simple_extent_ndims(hid_t space_id)
 {
-    H5S_t   *ds;
-    int       ret_value;           /* Return value */
+    H5S_t       *ds;
+    int         ret_value = -1;
 
-    FUNC_ENTER_API(FAIL)
+    FUNC_ENTER_API((-1))
     H5TRACE1("Is", "i", space_id);
 
     /* Check args */
     if(NULL == (ds = (H5S_t *)H5I_object_verify(space_id, H5I_DATASPACE)))
-        HGOTO_ERROR(H5E_ARGS, H5E_BADTYPE, FAIL, "not a dataspace")
+        HGOTO_ERROR(H5E_ARGS, H5E_BADTYPE, (-1), "not a dataspace")
 
     ret_value = (int)H5S_GET_EXTENT_NDIMS(ds);
 
@@ -916,18 +919,19 @@ H5Sget_simple_extent_ndims(hid_t space_id)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Sget_simple_extent_ndims() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S_get_simple_extent_ndims
  *
- * Purpose:    Returns the number of dimensions in a dataspace.
+ * Purpose:     Returns the number of dimensions in a dataspace.
  *
- * Return:    Success:    Non-negative number of dimensions.  Zero
- *                implies a scalar.
- *        Failure:    Negative
+ * Return:      Success:    Non-negative number of dimensions.
+ *                          Zero implies a scalar.
  *
- * Programmer:    Robb Matzke
- *        Thursday, December 11, 1997
+ *              Failure:    Negative
+ *
+ * Programmer:  Robb Matzke
+ *              hursday, December 11, 1997
  *
  * Note:        This routine participates in the "Inlining C function pointers"
  *              pattern, don't call it directly, use the appropriate macro
@@ -938,7 +942,7 @@ H5Sget_simple_extent_ndims(hid_t space_id)
 int
 H5S_get_simple_extent_ndims(const H5S_t *ds)
 {
-    int    ret_value = -1;         /* Return value */
+    int     ret_value = -1;         /* Return value */
 
     FUNC_ENTER_NOAPI(FAIL)
 
@@ -962,35 +966,35 @@ H5S_get_simple_extent_ndims(const H5S_t *ds)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_get_simple_extent_ndims() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Sget_simple_extent_dims
  *
- * Purpose:    Returns the size and maximum sizes in each dimension of
- *        a dataspace DS through the DIMS and MAXDIMS arguments.
+ * Purpose:     Returns the size and maximum sizes in each dimension of
+ *              a dataspace DS through the DIMS and MAXDIMS arguments.
+ *
+ * Return:      Success:    Number of dimensions, the same value as
+ *                          returned by H5Sget_simple_extent_ndims().
  *
- * Return:    Success:    Number of dimensions, the same value as
- *                returned by H5Sget_simple_extent_ndims().
- *        Failure:    Negative
+ *              Failure:    Negative
  *
- * Programmer:    Robb Matzke
- *        Thursday, December 11, 1997
+ * Programmer:  Robb Matzke
+ *              Thursday, December 11, 1997
  *
  *-------------------------------------------------------------------------
  */
 int
-H5Sget_simple_extent_dims(hid_t space_id, hsize_t dims[]/*out*/,
-    hsize_t maxdims[]/*out*/)
+H5Sget_simple_extent_dims(hid_t space_id, hsize_t dims[]/*out*/, hsize_t maxdims[]/*out*/)
 {
-    H5S_t   *ds;
-    int       ret_value;           /* Return value */
+    H5S_t       *ds;
+    int         ret_value = -1;
 
-    FUNC_ENTER_API(FAIL)
+    FUNC_ENTER_API((-1))
     H5TRACE3("Is", "ixx", space_id, dims, maxdims);
 
     /* Check args */
     if(NULL == (ds = (H5S_t *)H5I_object_verify(space_id, H5I_DATASPACE)))
-        HGOTO_ERROR(H5E_ARGS, H5E_BADTYPE, FAIL, "not a dataspace")
+        HGOTO_ERROR(H5E_ARGS, H5E_BADTYPE, (-1), "not a dataspace")
 
     ret_value = H5S_get_simple_extent_dims(ds, dims, maxdims);
 
@@ -998,26 +1002,26 @@ H5Sget_simple_extent_dims(hid_t space_id, hsize_t dims[]/*out*/,
     FUNC_LEAVE_API(ret_value)
 } /* end H5Sget_simple_extent_dims() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S_extent_get_dims
  *
- * Purpose:    Returns the size in each dimension of a dataspace.  This
- *        function may not be meaningful for all types of dataspaces.
+ * Purpose:     Returns the size in each dimension of a dataspace.  This
+ *              function may not be meaningful for all types of dataspaces.
  *
- * Return:    Success:    Number of dimensions.  Zero implies scalar.
- *        Failure:    Negative
+ * Return:      Success:    Number of dimensions.  Zero implies scalar.
+ *              Failure:    Negative
  *
- * Programmer:    Quincey Koziol
- *        Tuesday, June 30, 2009
+ * Programmer:  Quincey Koziol
+ *              Tuesday, June 30, 2009
  *
  *-------------------------------------------------------------------------
  */
 int
 H5S_extent_get_dims(const H5S_extent_t *ext, hsize_t dims[], hsize_t max_dims[])
 {
-    int    i;                      /* Local index variable */
-    int    ret_value = -1;         /* Return value */
+    int     i;                      /* Local index variable */
+    int     ret_value = -1;         /* Return value */
 
     FUNC_ENTER_NOAPI(FAIL)
 
@@ -1054,25 +1058,25 @@ H5S_extent_get_dims(const H5S_extent_t *ext, hsize_t dims[], hsize_t max_dims[])
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_extent_get_dims() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S_get_simple_extent_dims
  *
- * Purpose:    Returns the size in each dimension of a dataspace.  This
- *        function may not be meaningful for all types of dataspaces.
+ * Purpose:     Returns the size in each dimension of a dataspace.  This
+ *              function may not be meaningful for all types of dataspaces.
  *
- * Return:    Success:    Number of dimensions.  Zero implies scalar.
- *        Failure:    Negative
+ * Return:      Success:    Number of dimensions.  Zero implies scalar.
+ *              Failure:    Negative
  *
- * Programmer:    Robb Matzke
- *        Thursday, December 11, 1997
+ * Programmer:  Robb Matzke
+ *              Thursday, December 11, 1997
  *
  *-------------------------------------------------------------------------
  */
 int
 H5S_get_simple_extent_dims(const H5S_t *ds, hsize_t dims[], hsize_t max_dims[])
 {
-    int    ret_value = -1;         /* Return value */
+    int     ret_value = -1;         /* Return value */
 
     FUNC_ENTER_NOAPI(FAIL)
 
@@ -1087,17 +1091,17 @@ H5S_get_simple_extent_dims(const H5S_t *ds, hsize_t dims[], hsize_t max_dims[])
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_get_simple_extent_dims() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S_write
  *
- * Purpose:    Updates a dataspace by writing a message to an object
- *        header.
+ * Purpose:     Updates a dataspace by writing a message to an object
+ *              header.
  *
- * Return:    Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:    Robb Matzke
- *        Tuesday, December  9, 1997
+ * Programmer:  Robb Matzke
+ *              Tuesday, December  9, 1997
  *
  *-------------------------------------------------------------------------
  */
@@ -1121,17 +1125,16 @@ H5S_write(H5F_t *f, H5O_t *oh, unsigned update_flags, H5S_t *ds)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_write() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S_append
  *
- * Purpose:    Updates a dataspace by adding a message to an object
- *        header.
+ * Purpose:     Updates a dataspace by adding a message to an object header.
  *
- * Return:    Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:    Quincey Koziol
- *        Tuesday, December 31, 2002
+ * Programmer:  Quincey Koziol
+ *              Tuesday, December 31, 2002
  *
  *-------------------------------------------------------------------------
  */
@@ -1155,24 +1158,25 @@ H5S_append(H5F_t *f, H5O_t *oh, H5S_t *ds)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_append() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S_read
  *
- * Purpose:    Reads the dataspace from an object header.
+ * Purpose:     Reads the dataspace from an object header.
+ *
+ * Return:      Success:    Pointer to a new dataspace.
  *
- * Return:    Success:    Pointer to a new dataspace.
- *        Failure:    NULL
+ *              Failure:    NULL
  *
- * Programmer:    Robb Matzke
- *        Tuesday, December  9, 1997
+ * Programmer:  Robb Matzke
+ *              Tuesday, December  9, 1997
  *
  *-------------------------------------------------------------------------
  */
 H5S_t *
 H5S_read(const H5O_loc_t *loc)
 {
-    H5S_t    *ds = NULL;             /* Dataspace to return */
+    H5S_t       *ds = NULL;             /* Dataspace to return */
     H5S_t       *ret_value = NULL;      /* Return value */
 
     FUNC_ENTER_NOAPI(NULL)
@@ -1201,7 +1205,7 @@ H5S_read(const H5O_loc_t *loc)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_read() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__is_simple
@@ -1233,7 +1237,7 @@ H5S__is_simple(const H5S_t *sdim)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__is_simple() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5Sis_simple
@@ -1241,7 +1245,7 @@ H5S__is_simple(const H5S_t *sdim)
     Check if a dataspace is simple
  USAGE
     htri_t H5Sis_simple(space_id)
-    hid_t space_id;          IN: ID of dataspace object to query
+    hid_t space_id;         IN: ID of dataspace object to query
  RETURNS
     TRUE/FALSE/FAIL
  DESCRIPTION
@@ -1251,15 +1255,15 @@ H5S__is_simple(const H5S_t *sdim)
 htri_t
 H5Sis_simple(hid_t space_id)
 {
-    H5S_t      *space;            /* Dataspace to check */
-    htri_t    ret_value;        /* Return value */
+    H5S_t           *space;             /* Dataspace to check */
+    htri_t          ret_value;          /* Return value */
 
     FUNC_ENTER_API(FAIL)
     H5TRACE1("t", "i", space_id);
 
     /* Check args and all the boring stuff. */
     if(NULL == (space = (H5S_t *)H5I_object_verify(space_id, H5I_DATASPACE)))
-    HGOTO_ERROR(H5E_ATOM, H5E_BADATOM, FAIL, "not a dataspace")
+        HGOTO_ERROR(H5E_ATOM, H5E_BADATOM, FAIL, "not a dataspace")
 
     ret_value = H5S__is_simple(space);
 
@@ -1267,7 +1271,7 @@ H5Sis_simple(hid_t space_id)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Sis_simple() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5Sset_extent_simple
@@ -1275,11 +1279,11 @@ H5Sis_simple(hid_t space_id)
     Sets the size of a simple dataspace
  USAGE
     herr_t H5Sset_extent_simple(space_id, rank, dims, max)
-        hid_t space_id;          IN: Dataspace object to query
-        int rank;          IN: # of dimensions for the dataspace
-        const size_t *dims;   IN: Size of each dimension for the dataspace
-    const size_t *max;    IN: Maximum size of each dimension for the
-                dataspace
+        hid_t space_id;         IN: Dataspace object to query
+        int rank;               IN: # of dimensions for the dataspace
+        const size_t *dims;     IN: Size of each dimension for the dataspace
+        const size_t *max;      IN: Maximum size of each dimension for the
+                                    dataspace
  RETURNS
     Non-negative on success/Negative on failure
  DESCRIPTION
@@ -1298,8 +1302,8 @@ herr_t
 H5Sset_extent_simple(hid_t space_id, int rank, const hsize_t dims[/*rank*/],
     const hsize_t max[/*rank*/])
 {
-    H5S_t    *space;                    /* Dataspace to modify */
-    int            u;                    /* Local counting variable */
+    H5S_t       *space;                 /* Dataspace to modify */
+    int         u;                      /* Local counting variable */
     herr_t      ret_value = SUCCEED;    /* Return value */
 
     FUNC_ENTER_API(FAIL)
@@ -1322,26 +1326,25 @@ H5Sset_extent_simple(hid_t space_id, int rank, const hsize_t dims[/*rank*/],
         for(u = 0; u < rank; u++)
             if(max[u] != H5S_UNLIMITED && max[u] < dims[u])
                 HGOTO_ERROR(H5E_ARGS, H5E_BADVALUE, FAIL, "invalid maximum dimension size")
-    } /* end if */
+    }
 
     /* Do it */
     if(H5S_set_extent_simple(space, (unsigned)rank, dims, max) < 0)
-    HGOTO_ERROR(H5E_DATASPACE, H5E_CANTINIT, FAIL, "unable to set simple extent")
+        HGOTO_ERROR(H5E_DATASPACE, H5E_CANTINIT, FAIL, "unable to set simple extent")
 
 done:
     FUNC_LEAVE_API(ret_value)
 } /* end H5Sset_extent_simple() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S_set_extent_simple
  *
- * Purpose:    This is where the real work happens for
- *        H5Sset_extent_simple().
+ * Purpose:     This is where the real work happens for H5Sset_extent_simple().
  *
- * Return:    Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:    Robb Matzke
+ * Programmer:  Robb Matzke
  *              Wednesday, July  8, 1998
  *
  *-------------------------------------------------------------------------
@@ -1362,10 +1365,10 @@ H5S_set_extent_simple(H5S_t *space, unsigned rank, const hsize_t *dims,
     if(H5S__extent_release(&space->extent) < 0)
         HGOTO_ERROR(H5E_RESOURCE, H5E_CANTFREE, FAIL, "failed to release previous dataspace extent")
 
-    if(rank == 0) {        /* scalar variable */
+    if(rank == 0) {         /* scalar variable */
         space->extent.type = H5S_SCALAR;
         space->extent.nelem = 1;
-        space->extent.rank = 0;    /* set to scalar rank */
+        space->extent.rank = 0;     /* set to scalar rank */
     } /* end if */
     else {
         hsize_t nelem;  /* Number of elements in extent */
@@ -1408,91 +1411,90 @@ H5S_set_extent_simple(H5S_t *space, unsigned rank, const hsize_t *dims,
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_set_extent_simple() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Screate_simple
  *
- * Purpose:    Creates a new simple dataspace object and opens it for
- *        access. The DIMS argument is the size of the simple dataset
- *        and the MAXDIMS argument is the upper limit on the size of
- *        the dataset.  MAXDIMS may be the null pointer in which case
- *        the upper limit is the same as DIMS.  If an element of
- *        MAXDIMS is H5S_UNLIMITED then the corresponding dimension is
- *        unlimited, otherwise no element of MAXDIMS should be smaller
- *        than the corresponding element of DIMS.
+ * Purpose:     Creates a new simple dataspace object and opens it for
+ *              access. The DIMS argument is the size of the simple dataset
+ *              and the MAXDIMS argument is the upper limit on the size of
+ *              the dataset.  MAXDIMS may be the null pointer in which case
+ *              the upper limit is the same as DIMS.  If an element of
+ *              MAXDIMS is H5S_UNLIMITED then the corresponding dimension is
+ *              unlimited, otherwise no element of MAXDIMS should be smaller
+ *              than the corresponding element of DIMS.
+ *
+ * Return:      Success:    The ID for the new simple dataspace object.
  *
- * Return:    Success:    The ID for the new simple dataspace object.
- *        Failure:    Negative
+ *              Failure:    H5I_INVALID_HID
  *
- * Programmer:    Quincey Koziol
- *        Tuesday, January  27, 1998
+ * Programmer:  Quincey Koziol
+ *              Tuesday, January  27, 1998
  *
  *-------------------------------------------------------------------------
  */
 hid_t
-H5Screate_simple(int rank, const hsize_t dims[/*rank*/],
-    const hsize_t maxdims[/*rank*/])
+H5Screate_simple(int rank, const hsize_t dims[/*rank*/], const hsize_t maxdims[/*rank*/])
 {
-    H5S_t    *space = NULL;
-    int        i;
-    hid_t    ret_value;              /* Return value */
+    H5S_t   *space = NULL;
+    int     i;
+    hid_t   ret_value = H5I_INVALID_HID;
 
-    FUNC_ENTER_API(FAIL)
+    FUNC_ENTER_API(H5I_INVALID_HID)
     H5TRACE3("i", "Is*[a0]h*[a0]h", rank, dims, maxdims);
 
     /* Check arguments */
     if(rank < 0)
-        HGOTO_ERROR(H5E_ARGS, H5E_BADVALUE, FAIL, "dimensionality cannot be negative")
+        HGOTO_ERROR(H5E_ARGS, H5E_BADVALUE, H5I_INVALID_HID, "dimensionality cannot be negative")
     if(rank > H5S_MAX_RANK)
-        HGOTO_ERROR(H5E_ARGS, H5E_BADVALUE, FAIL, "dimensionality is too large")
+        HGOTO_ERROR(H5E_ARGS, H5E_BADVALUE, H5I_INVALID_HID, "dimensionality is too large")
 
     /* We allow users to use this function to create scalar or null dataspace.
      * Check DIMS isn't set when the RANK is 0.
      */
     if(!dims && rank != 0)
-        HGOTO_ERROR(H5E_ARGS, H5E_BADVALUE, FAIL, "invalid dataspace information")
+        HGOTO_ERROR(H5E_ARGS, H5E_BADVALUE, H5I_INVALID_HID, "invalid dataspace information")
 
     /* Check whether the current dimensions are valid */
     for(i = 0; i < rank; i++) {
         if(H5S_UNLIMITED == dims[i])
-            HGOTO_ERROR(H5E_ARGS, H5E_BADVALUE, FAIL, "current dimension must have a specific size, not H5S_UNLIMITED")
+            HGOTO_ERROR(H5E_ARGS, H5E_BADVALUE, H5I_INVALID_HID, "current dimension must have a specific size, not H5S_UNLIMITED")
         if(maxdims && H5S_UNLIMITED != maxdims[i] && maxdims[i]<dims[i])
-            HGOTO_ERROR(H5E_ARGS, H5E_BADVALUE, FAIL, "maxdims is smaller than dims")
+            HGOTO_ERROR(H5E_ARGS, H5E_BADVALUE, H5I_INVALID_HID, "maxdims is smaller than dims")
     } /* end for */
 
     /* Create the space and set the extent */
     if(NULL == (space = H5S_create_simple((unsigned)rank, dims, maxdims)))
-        HGOTO_ERROR(H5E_DATASPACE, H5E_CANTCREATE, FAIL, "can't create simple dataspace")
+        HGOTO_ERROR(H5E_DATASPACE, H5E_CANTCREATE, H5I_INVALID_HID, "can't create simple dataspace")
 
     /* Atomize */
     if((ret_value = H5I_register (H5I_DATASPACE, space, TRUE)) < 0)
-        HGOTO_ERROR(H5E_ATOM, H5E_CANTREGISTER, FAIL, "unable to register dataspace ID")
+        HGOTO_ERROR(H5E_ATOM, H5E_CANTREGISTER, H5I_INVALID_HID, "unable to register dataspace ID")
 
 done:
     if(ret_value < 0)
         if(space && H5S_close(space) < 0)
-            HDONE_ERROR(H5E_DATASPACE, H5E_CANTRELEASE, FAIL, "unable to release dataspace")
+            HDONE_ERROR(H5E_DATASPACE, H5E_CANTRELEASE, H5I_INVALID_HID, "unable to release dataspace")
 
     FUNC_LEAVE_API(ret_value)
 } /* end H5Screate_simple() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S_create_simple
  *
- * Purpose:    Internal function to create simple dataspace
+ * Purpose:     Internal function to create simple dataspace
  *
- * Return:    Success:    The ID for the new simple dataspace object.
- *        Failure:    Negative
+ * Return:      Success:    A pointer to a dataspace object
+ *              Failure:    NULL
  *
- * Programmer:    Quincey Koziol
- *        Thursday, April  3, 2003
+ * Programmer:  Quincey Koziol
+ *              Thursday, April  3, 2003
  *
  *-------------------------------------------------------------------------
  */
 H5S_t *
-H5S_create_simple(unsigned rank, const hsize_t dims[/*rank*/],
-    const hsize_t maxdims[/*rank*/])
+H5S_create_simple(unsigned rank, const hsize_t dims[/*rank*/], const hsize_t maxdims[/*rank*/])
 {
     H5S_t       *ret_value = NULL;      /* Return value */
 
@@ -1511,20 +1513,19 @@ H5S_create_simple(unsigned rank, const hsize_t dims[/*rank*/],
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_create_simple() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Sencode2
  *
- * Purpose:    Given a dataspace ID, converts the object description
+ * Purpose:     Given a dataspace ID, converts the object description
  *              (including selection) into binary in a buffer.
- *          The selection will be encoded according to the file
- *          format setting in fapl.
+ *              The selection will be encoded according to the file
+ *              format setting in the fapl.
  *
- * Return:    Success:    non-negative
- *          Failure: negative
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *
- * Programmer:    Raymond Lu
- *              slu@ncsa.uiuc.edu
+ * Programmer:  Raymond Lu
  *              July 14, 2004
  *
  *-------------------------------------------------------------------------
@@ -1540,33 +1541,30 @@ H5Sencode2(hid_t obj_id, void *buf, size_t *nalloc, hid_t fapl_id)
 
     /* Check argument and retrieve object */
     if(NULL == (dspace = (H5S_t *)H5I_object_verify(obj_id, H5I_DATASPACE)))
-         HGOTO_ERROR(H5E_ARGS, H5E_BADTYPE, FAIL, "not a dataspace")
+        HGOTO_ERROR(H5E_ARGS, H5E_BADTYPE, FAIL, "not a dataspace")
 
-     /* Verify access property list and set up collective metadata if appropriate */
+    /* Verify access property list and set up collective metadata if appropriate */
     if(H5CX_set_apl(&fapl_id, H5P_CLS_FACC, H5I_INVALID_HID, TRUE) < 0)
         HGOTO_ERROR(H5E_FILE, H5E_CANTSET, H5I_INVALID_HID, "can't set access property list info")
 
-
     if(H5S_encode(dspace, (unsigned char **)&buf, nalloc) < 0)
         HGOTO_ERROR(H5E_DATASPACE, H5E_CANTENCODE, FAIL, "can't encode dataspace")
 
 done:
     FUNC_LEAVE_API(ret_value)
-} /* H5Sencode2() */
-
+} /* end H5Sencode2() */
 
+
 /*-------------------------------------------------------------------------
  * Function:    H5S_encode
  *
- * Purpose:    Private function for H5Sencode.  Converts an object
+ * Purpose:     Private function for H5Sencode.  Converts an object
  *              description for dataspace and its selection into binary
  *              in a buffer.
  *
- * Return:    Success:    non-negative
- *        Failure:    negative
+ * Return:      SUCCEED/FAIL
  *
- * Programmer:    Raymond Lu
- *              slu@ncsa.uiuc.edu
+ * Programmer:  Raymond Lu
  *              July 14, 2004
  *
  *-------------------------------------------------------------------------
@@ -1584,15 +1582,15 @@ H5S_encode(H5S_t *obj, unsigned char **p, size_t *nalloc)
 
     /* Allocate "fake" file structure */
     if(NULL == (f = H5F_fake_alloc((uint8_t)0)))
-    HGOTO_ERROR(H5E_DATASPACE, H5E_CANTALLOC, FAIL, "can't allocate fake file struct")
+        HGOTO_ERROR(H5E_DATASPACE, H5E_CANTALLOC, FAIL, "can't allocate fake file struct")
 
     /* Find out the size of buffer needed for extent */
     if((extent_size = H5O_msg_raw_size(f, H5O_SDSPACE_ID, TRUE, obj)) == 0)
-    HGOTO_ERROR(H5E_DATASPACE, H5E_BADSIZE, FAIL, "can't find dataspace size")
+        HGOTO_ERROR(H5E_DATASPACE, H5E_BADSIZE, FAIL, "can't find dataspace size")
 
     /* Find out the size of buffer needed for selection */
     if((sselect_size = H5S_SELECT_SERIAL_SIZE(obj)) < 0)
-    HGOTO_ERROR(H5E_DATASPACE, H5E_BADSIZE, FAIL, "can't find dataspace selection size")
+        HGOTO_ERROR(H5E_DATASPACE, H5E_BADSIZE, FAIL, "can't find dataspace selection size")
     H5_CHECKED_ASSIGN(select_size, size_t, sselect_size, hssize_t);
 
     /* Verify the size of buffer.  If it's not big enough, simply return the
@@ -1633,18 +1631,18 @@ H5S_encode(H5S_t *obj, unsigned char **p, size_t *nalloc)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_encode() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Sdecode
  *
- * Purpose:    Decode a binary object description of dataspace and
+ * Purpose:     Decode a binary object description of dataspace and
  *              return a new object handle.
  *
- * Return:    Success:    dataspace ID(non-negative)
- *        Failure:    negative
+ * Return:      Success:    dataspace ID(non-negative)
+ *
+ *              Failure:    H5I_INVALID_HID
  *
- * Programmer:    Raymond Lu
- *              slu@ncsa.uiuc.edu
+ * Programmer:  Raymond Lu
  *              July 14, 2004
  *
  *-------------------------------------------------------------------------
@@ -1655,35 +1653,35 @@ H5Sdecode(const void *buf)
     H5S_t       *ds;
     hid_t       ret_value;
 
-    FUNC_ENTER_API(FAIL)
+    FUNC_ENTER_API(H5I_INVALID_HID)
     H5TRACE1("i", "*x", buf);
 
     if(buf == NULL)
-    HGOTO_ERROR(H5E_ARGS, H5E_BADVALUE, FAIL, "empty buffer")
+        HGOTO_ERROR(H5E_ARGS, H5E_BADVALUE, H5I_INVALID_HID, "empty buffer")
 
     if((ds = H5S_decode((const unsigned char **)&buf)) == NULL)
-    HGOTO_ERROR(H5E_DATASPACE, H5E_CANTDECODE, FAIL, "can't decode object")
+        HGOTO_ERROR(H5E_DATASPACE, H5E_CANTDECODE, H5I_INVALID_HID, "can't decode object")
 
     /* Register the type and return the ID */
     if((ret_value = H5I_register(H5I_DATASPACE, ds, TRUE)) < 0)
-    HGOTO_ERROR(H5E_DATASPACE, H5E_CANTREGISTER, FAIL, "unable to register dataspace")
+        HGOTO_ERROR(H5E_DATASPACE, H5E_CANTREGISTER, H5I_INVALID_HID, "unable to register dataspace")
 
 done:
     FUNC_LEAVE_API(ret_value)
 } /* end H5Sdecode() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S_decode
  *
- * Purpose:    Private function for H5Sdecode.  Reconstructs a binary
+ * Purpose:     Private function for H5Sdecode.  Reconstructs a binary
  *              description of dataspace and returns a new object handle.
  *
- * Return:    Success:    dataspace ID(non-negative)
- *        Failure:    negative
+ * Return:      Success:    Pointer to a dataspace buffer
+ *
+ *              Failure:	NULL
  *
- * Programmer:    Raymond Lu
- *              slu@ncsa.uiuc.edu
+ * Programmer:  Raymond Lu
  *              July 14, 2004
  *
  *-------------------------------------------------------------------------
@@ -1703,18 +1701,18 @@ H5S_decode(const unsigned char **p)
 
     /* Decode the type of the information */
     if(*pp++ != H5O_SDSPACE_ID)
-    HGOTO_ERROR(H5E_DATASPACE, H5E_BADMESG, NULL, "not an encoded dataspace")
+        HGOTO_ERROR(H5E_DATASPACE, H5E_BADMESG, NULL, "not an encoded dataspace")
 
     /* Decode the version of the dataspace information */
     if(*pp++ != H5S_ENCODE_VERSION)
-    HGOTO_ERROR(H5E_DATASPACE, H5E_VERSION, NULL, "unknown version of encoded dataspace")
+        HGOTO_ERROR(H5E_DATASPACE, H5E_VERSION, NULL, "unknown version of encoded dataspace")
 
     /* Decode the "size of size" information */
     sizeof_size = *pp++;
 
     /* Allocate "fake" file structure */
     if(NULL == (f = H5F_fake_alloc(sizeof_size)))
-    HGOTO_ERROR(H5E_DATASPACE, H5E_CANTALLOC, NULL, "can't allocate fake file struct")
+        HGOTO_ERROR(H5E_DATASPACE, H5E_CANTALLOC, NULL, "can't allocate fake file struct")
 
     /* Decode size of extent information */
     UINT32DECODE(pp, extent_size);
@@ -1729,7 +1727,7 @@ H5S_decode(const unsigned char **p)
     if(NULL == (ds = H5FL_CALLOC(H5S_t)))
         HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, NULL, "memory allocation failed for dataspace conversion path table")
     if(NULL == H5O_msg_copy(H5O_SDSPACE_ID, extent, &(ds->extent)))
-    HGOTO_ERROR(H5E_DATASPACE, H5E_CANTCOPY, NULL, "can't copy object")
+        HGOTO_ERROR(H5E_DATASPACE, H5E_CANTCOPY, NULL, "can't copy object")
     if(H5S__extent_release(extent) < 0)
         HGOTO_ERROR(H5E_RESOURCE, H5E_CANTDELETE, NULL, "can't release previous dataspace")
     extent = H5FL_FREE(H5S_extent_t, extent);
@@ -1754,17 +1752,18 @@ H5S_decode(const unsigned char **p)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_decode() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S_get_simple_extent_type
  *
- * Purpose:    Internal function for retrieving the type of extent for a dataspace object
+ * Purpose:     Internal function for retrieving the type of extent for a dataspace object
  *
- * Return:    Success:    The class of the dataspace object
- *        Failure:    N5S_NO_CLASS
+ * Return:      Success:    The class of the dataspace object
  *
- * Programmer:    Quincey Koziol
- *        Thursday, September 28, 2000
+ *              Failure:    N5S_NO_CLASS
+ *
+ * Programmer:  Quincey Koziol
+ *              Thursday, September 28, 2000
  *
  * Note:        This routine participates in the "Inlining C function pointers"
  *              pattern, don't call it directly, use the appropriate macro
@@ -1775,7 +1774,7 @@ H5S_decode(const unsigned char **p)
 H5S_class_t
 H5S_get_simple_extent_type(const H5S_t *space)
 {
-    H5S_class_t    ret_value = H5S_NO_CLASS;       /* Return value */
+    H5S_class_t     ret_value = H5S_NO_CLASS;       /* Return value */
 
     FUNC_ENTER_NOAPI(H5S_NO_CLASS)
 
@@ -1787,25 +1786,26 @@ H5S_get_simple_extent_type(const H5S_t *space)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_get_simple_extent_type() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Sget_simple_extent_type
  *
- * Purpose:    Retrieves the type of extent for a dataspace object
+ * Purpose:     Retrieves the type of extent for a dataspace object
+ *
+ * Return:      Success:    The class of the dataspace object
  *
- * Return:    Success:    The class of the dataspace object
- *        Failure:    N5S_NO_CLASS
+ *              Failure:    N5S_NO_CLASS
  *
- * Programmer:    Quincey Koziol
- *        Thursday, July 23, 1998
+ * Programmer:  Quincey Koziol
+ *              Thursday, July 23, 1998
  *
  *-------------------------------------------------------------------------
  */
 H5S_class_t
 H5Sget_simple_extent_type(hid_t sid)
 {
-    H5S_t    *space;
-    H5S_class_t    ret_value;      /* Return value */
+    H5S_t           *space;
+    H5S_class_t     ret_value;      /* Return value */
 
     FUNC_ENTER_API(H5S_NO_CLASS)
     H5TRACE1("Sc", "i", sid);
@@ -1820,7 +1820,7 @@ H5Sget_simple_extent_type(hid_t sid)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Sget_simple_extent_type() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5Sset_extent_none
@@ -1828,7 +1828,7 @@ H5Sget_simple_extent_type(hid_t sid)
     Resets the extent of a dataspace back to "none"
  USAGE
     herr_t H5Sset_extent_none(space_id)
-        hid_t space_id;          IN: Dataspace object to reset
+        hid_t space_id;         IN: Dataspace object to reset
  RETURNS
     Non-negative on success/Negative on failure
  DESCRIPTION
@@ -1838,8 +1838,8 @@ H5Sget_simple_extent_type(hid_t sid)
 herr_t
 H5Sset_extent_none(hid_t space_id)
 {
-    H5S_t  *space;            /* Dataspace to modify */
-    herr_t ret_value = SUCCEED; /* Return value */
+    H5S_t       *space;                 /* Dataspace to modify */
+    herr_t      ret_value = SUCCEED;    /* Return value */
 
     FUNC_ENTER_API(FAIL)
     H5TRACE1("e", "i", space_id);
@@ -1858,16 +1858,15 @@ H5Sset_extent_none(hid_t space_id)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Sset_extent_none() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S_set_extent
  *
  * Purpose:     Modify the dimensions of a dataspace.
  *
- * Return:      Success: Non-negative
- *              Failure: Negative
+ * Return:      TRUE/FALSE/FAIL
  *
- * Programmer:  Pedro Vicente, pvn@ncsa.uiuc.edu
+ * Programmer:  Pedro Vicente
  *              March 13, 2002
  *
  *-------------------------------------------------------------------------
@@ -1905,7 +1904,7 @@ H5S_set_extent(H5S_t *space, const hsize_t *size)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_set_extent() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function: H5S_has_extent
  *
@@ -1938,7 +1937,7 @@ H5S_has_extent(const H5S_t *ds)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_has_extent() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S_set_extent_real
  *
@@ -1947,7 +1946,7 @@ H5S_has_extent(const H5S_t *ds)
  * Return:      Success: Non-negative
  *              Failure: Negative
  *
- * Programmer:  Pedro Vicente, pvn@ncsa.uiuc.edu
+ * Programmer:  Pedro Vicente
  *              March 13, 2002
  *
  *-------------------------------------------------------------------------
@@ -1985,25 +1984,27 @@ H5S_set_extent_real(H5S_t *space, const hsize_t *size)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_set_extent_real() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Sextent_equal
  *
- * Purpose:    Determines if two dataspace extents are equal.
+ * Purpose:     Determines if two dataspace extents are equal.
  *
- * Return:    Success:    TRUE if equal, FALSE if unequal
- *        Failure:    Negative
+ * Return:      Success:    TRUE if equal, FALSE if unequal
  *
- * Programmer:    Quincey Koziol
- *        Monday, October 24, 2005
+ *              Failure:    FAIL
+ *
+ * Programmer:  Quincey Koziol
+ *              Monday, October 24, 2005
  *
  *-------------------------------------------------------------------------
  */
 htri_t
 H5Sextent_equal(hid_t space1_id, hid_t space2_id)
 {
-    const H5S_t    *ds1, *ds2;     /* Dataspaces to compare */
-    htri_t    ret_value;      /* Return value */
+    const H5S_t     *ds1;           /* Dataspaces to compare */
+    const H5S_t     *ds2;
+    htri_t          ret_value;
 
     FUNC_ENTER_API(FAIL)
     H5TRACE2("t", "ii", space1_id, space2_id);
@@ -2011,17 +2012,17 @@ H5Sextent_equal(hid_t space1_id, hid_t space2_id)
     /* check args */
     if(NULL == (ds1 = (const H5S_t *)H5I_object_verify(space1_id, H5I_DATASPACE)) ||
             NULL == (ds2 = (const H5S_t *)H5I_object_verify(space2_id, H5I_DATASPACE)))
-    HGOTO_ERROR(H5E_ARGS, H5E_BADTYPE, FAIL, "not a dataspace")
+        HGOTO_ERROR(H5E_ARGS, H5E_BADTYPE, FAIL, "not a dataspace")
 
     /* Check dataspaces for extent's equality */
     if((ret_value = H5S_extent_equal(ds1, ds2)) < 0)
-    HGOTO_ERROR(H5E_DATASPACE, H5E_CANTCOMPARE, FAIL, "dataspace comparison failed")
+        HGOTO_ERROR(H5E_DATASPACE, H5E_CANTCOMPARE, FAIL, "dataspace comparison failed")
 
 done:
     FUNC_LEAVE_API(ret_value)
 } /* end H5Sextent_equal() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S_extent_equal
@@ -2082,17 +2083,17 @@ H5S_extent_equal(const H5S_t *ds1, const H5S_t *ds2)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_extent_equal() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S_extent_nelem
  *
- * Purpose:    Determines how many elements a dataset extent describes.
+ * Purpose:     Determines how many elements a dataset extent describes.
  *
- * Return:    Success:    Number of data points in the dataset extent.
- *        Failure:    negative
+ * Return:      Success:    Number of data points in the dataset extent.
+ *              Failure:    Negative
  *
- * Programmer:    Quincey Koziol
- *        Thursday, November 30, 2006
+ * Programmer:  Quincey Koziol
+ *              Thursday, November 30, 2006
  *
  *-------------------------------------------------------------------------
  */
@@ -2108,7 +2109,7 @@ H5S_extent_nelem(const H5S_extent_t *ext)
     FUNC_LEAVE_NOAPI(ext->nelem)
 } /* end H5S_extent_nelem() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S_set_version
  *
diff --git a/src/H5Sall.c b/src/H5Sall.c
index 8290ae26a29..9026e7cedb6 100644
--- a/src/H5Sall.c
+++ b/src/H5Sall.c
@@ -29,7 +29,7 @@
 /* Headers */
 /***********/
 #include "H5private.h"          /* Generic Functions                        */
-#include "H5Eprivate.h"		/* Error handling			    */
+#include "H5Eprivate.h"         /* Error handling                           */
 #include "H5Iprivate.h"         /* ID Functions                             */
 #include "H5Spkg.h"             /* Dataspace functions                      */
 #include "H5VMprivate.h"        /* Vector functions                         */
@@ -599,7 +599,7 @@ H5S__all_serial_size(const H5S_t H5_ATTR_UNUSED *space)
  PURPOSE
     Serialize the current selection into a user-provided buffer.
  USAGE
-    herr_t H5S_all_serialize(space, p)
+    herr_t H5S__all_serialize(space, p)
         const H5S_t *space;     IN: Dataspace with selection to serialize
         uint8_t **p;            OUT: Pointer to buffer to put serialized
                                 selection.  Will be advanced to end of
@@ -627,8 +627,8 @@ H5S__all_serialize(const H5S_t *space, uint8_t **p)
     HDassert(pp);
 
     /* Store the preamble information */
-    UINT32ENCODE(pp, (uint32_t)H5S_GET_SELECT_TYPE(space));  /* Store the type of selection */
-    UINT32ENCODE(pp, (uint32_t)H5S_ALL_VERSION_1);  /* Store the version number */
+    UINT32ENCODE(pp, (uint32_t)H5S_GET_SELECT_TYPE(space)); /* Store the type of selection */
+    UINT32ENCODE(pp, (uint32_t)H5S_ALL_VERSION_1);          /* Store the version number */
     UINT32ENCODE(pp, (uint32_t)0);  /* Store the un-used padding */
     UINT32ENCODE(pp, (uint32_t)0);  /* Store the additional information length */
 
diff --git a/src/H5Sdbg.c b/src/H5Sdbg.c
index 8171191130f..32f5295bc33 100644
--- a/src/H5Sdbg.c
+++ b/src/H5Sdbg.c
@@ -13,11 +13,12 @@
 
 /*-------------------------------------------------------------------------
  *
- * Created:		H5Sdbg.c
- *			Jul 24 2007
- *			Quincey Koziol <koziol@hdfgroup.org>
+ * Created:         H5Sdbg.c
+ *                  Quincey Koziol
+ *                  Jul 24 2007
+ *                  
  *
- * Purpose:		Dump debugging information about a dataspace
+ * Purpose:         Dump debugging information about a dataspace
  *
  *-------------------------------------------------------------------------
  */
@@ -32,9 +33,9 @@
 /***********/
 /* Headers */
 /***********/
-#include "H5private.h"		/* Generic Functions			*/
-#include "H5Eprivate.h"		/* Error handling		  	*/
-#include "H5Spkg.h"		/* Dataspaces         			*/
+#include "H5private.h"        /* Generic Functions            */
+#include "H5Eprivate.h"        /* Error handling              */
+#include "H5Spkg.h"        /* Dataspaces                     */
 
 
 /****************/
@@ -74,13 +75,13 @@
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5S_debug
+ * Function:    H5S_debug
  *
- * Purpose:	Prints debugging information about a dataspace.
+ * Purpose:     Prints debugging information about a dataspace.
  *
- * Return:	Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:	Robb Matzke
+ * Programmer:  Robb Matzke
  *              Tuesday, July 21, 1998
  *
  *-------------------------------------------------------------------------
@@ -88,7 +89,7 @@
 herr_t
 H5S_debug(H5F_t *f, const void *_mesg, FILE *stream, int indent, int fwidth)
 {
-    const H5S_t	*mesg = (const H5S_t*)_mesg;
+    const H5S_t *mesg = (const H5S_t*)_mesg;
 
     FUNC_ENTER_NOAPI_NOINIT_NOERR
 
diff --git a/src/H5Shyper.c b/src/H5Shyper.c
index b352374e7e8..7d99f39b209 100644
--- a/src/H5Shyper.c
+++ b/src/H5Shyper.c
@@ -15,7 +15,7 @@
  * Programmer:  Quincey Koziol <koziol@ncsa.uiuc.edu>
  *              Thursday, June 18, 1998
  *
- * Purpose:    Hyperslab selection dataspace I/O functions.
+ * Purpose:     Hyperslab selection dataspace I/O functions.
  */
 
 /****************/
@@ -30,8 +30,8 @@
 /***********/
 #include "H5private.h"          /* Generic Functions                        */
 #include "H5CXprivate.h"        /* API Contexts                             */
-#include "H5Eprivate.h"        /* Error handling                */
-#include "H5FLprivate.h"    /* Free Lists                    */
+#include "H5Eprivate.h"         /* Error handling                           */
+#include "H5FLprivate.h"        /* Free Lists                               */
 #include "H5Iprivate.h"         /* ID Functions                             */
 #include "H5MMprivate.h"        /* Memory management                        */
 #include "H5Spkg.h"             /* Dataspace functions                      */
@@ -304,7 +304,7 @@ H5FL_EXTERN(H5S_sel_iter_t);
 static uint64_t H5S_hyper_op_gen_g = 1;
 
 
-/* Uncomment this, to provide the debugging routines for printing selection info */
+/* Uncomment this to provide the debugging routines for printing selection info */
 /* #define H5S_HYPER_DEBUG */
 #ifdef H5S_HYPER_DEBUG
 static herr_t
@@ -385,7 +385,7 @@ H5S__hyper_print_diminfo(FILE *f, const H5S_t *space)
     FUNC_LEAVE_NOAPI(SUCCEED)
 }
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_print_spans_dfs
@@ -531,7 +531,7 @@ H5S__hyper_print_space_dfs(FILE *f, const H5S_t *space)
 } /* end H5S__hyper_print_space_dfs() */
 #endif /* H5S_HYPER_DEBUG */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S__hyper_get_op_gen
  *
@@ -555,15 +555,15 @@ H5S__hyper_get_op_gen(void)
     FUNC_LEAVE_NOAPI(H5S_hyper_op_gen_g++);
 } /* end H5S__hyper_op_gen() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S__hyper_iter_init
  *
- * Purpose:    Initializes iteration information for hyperslab selection.
+ * Purpose:     Initializes iteration information for hyperslab selection.
  *
- * Return:    Non-negative on success, negative on failure.
+ * Return:      Non-negative on success, negative on failure.
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Saturday, February 24, 2001
  *
  * Notes:       If the 'iter->elmt_size' field is set to zero, the regular
@@ -794,16 +794,16 @@ H5S__hyper_iter_init(const H5S_t *space, H5S_sel_iter_t *iter)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_iter_init() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S__hyper_iter_coords
  *
- * Purpose:    Retrieve the current coordinates of iterator for current
+ * Purpose:     Retrieve the current coordinates of iterator for current
  *              selection
  *
- * Return:    Non-negative on success, negative on failure
+ * Return:      Non-negative on success, negative on failure
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Tuesday, April 22, 2003
  *
  *-------------------------------------------------------------------------
@@ -879,16 +879,16 @@ H5S__hyper_iter_coords(const H5S_sel_iter_t *iter, hsize_t *coords)
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5S__hyper_iter_coords() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S__hyper_iter_block
  *
- * Purpose:    Retrieve the current block of iterator for current
+ * Purpose:     Retrieve the current block of iterator for current
  *              selection
  *
- * Return:    Non-negative on success, negative on failure
+ * Return:      Non-negative on success, negative on failure
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Monday, June 2, 2003
  *
  * Notes:       This routine assumes that the iterator is always located at
@@ -916,28 +916,28 @@ H5S__hyper_iter_block(const H5S_sel_iter_t *iter, hsize_t *start, hsize_t *end)
         for(u = 0; u < iter->rank; u++) {
             start[u] = iter->u.hyp.off[u];
             end[u] = (start[u] + iter->u.hyp.diminfo[u].block) - 1;
-        } /* end for */
+        }
     } /* end if */
     else {
         /* Copy the start & end of the block */
         for(u = 0; u < iter->rank; u++) {
             start[u] = iter->u.hyp.span[u]->low;
             end[u] = iter->u.hyp.span[u]->high;
-        } /* end for */
+        }
     } /* end else */
 
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5S__hyper_iter_block() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S__hyper_iter_nelmts
  *
- * Purpose:    Return number of elements left to process in iterator
+ * Purpose:     Return number of elements left to process in iterator
  *
- * Return:    Non-negative number of elements on success, zero on failure
+ * Return:      Non-negative number of elements on success, zero on failure
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Tuesday, June 16, 1998
  *
  *-------------------------------------------------------------------------
@@ -953,7 +953,7 @@ H5S__hyper_iter_nelmts(const H5S_sel_iter_t *iter)
     FUNC_LEAVE_NOAPI(iter->elmt_left)
 } /* end H5S__hyper_iter_nelmts() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_iter_has_next_block
@@ -1009,17 +1009,17 @@ H5S__hyper_iter_has_next_block(const H5S_sel_iter_t *iter)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_iter_has_next_block() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S__hyper_iter_next
  *
- * Purpose:    Moves a hyperslab iterator to the beginning of the next sequence
- *      of elements to read.  Handles walking off the end in all dimensions.
+ * Purpose:     Moves a hyperslab iterator to the beginning of the next sequence
+ *              of elements to read.  Handles walking off the end in all dimensions.
  *
- * Return:    Success:    non-negative
- *        Failure:    negative
+ * Return:      Success:    non-negative
+ *              Failure:    negative
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Friday, September 8, 2000
  *
  *-------------------------------------------------------------------------
@@ -1216,17 +1216,17 @@ H5S__hyper_iter_next(H5S_sel_iter_t *iter, size_t nelem)
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5S__hyper_iter_next() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S__hyper_iter_next_block
  *
- * Purpose:    Moves a hyperslab iterator to the beginning of the next sequence
- *      of elements to read.  Handles walking off the end in all dimensions.
+ * Purpose:     Moves a hyperslab iterator to the beginning of the next sequence
+ *              of elements to read.  Handles walking off the end in all dimensions.
  *
- * Return:    Success:    non-negative
- *        Failure:    negative
+ * Return:      Success:    non-negative
+ *              Failure:    negative
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Tuesday, June 3, 2003
  *
  *-------------------------------------------------------------------------
@@ -1391,7 +1391,7 @@ H5S__hyper_iter_next_block(H5S_sel_iter_t *iter)
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5S__hyper_iter_next_block() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_iter_get_seq_list_gen
@@ -1409,7 +1409,7 @@ H5S__hyper_iter_next_block(H5S_sel_iter_t *iter)
         hsize_t *off;           OUT: Array of offsets
         size_t *len;            OUT: Array of lengths
  RETURNS
-    Non-negative on success/Negative on failure.
+    Non-negative on success/Negative on failure
  DESCRIPTION
     Use the selection in the dataspace to generate a list of byte offsets and
     lengths for the region(s) selected.  Start/Restart from the position in the
@@ -1843,7 +1843,7 @@ H5S__hyper_iter_get_seq_list_gen(H5S_sel_iter_t *iter, size_t maxseq, size_t max
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5S__hyper_iter_get_seq_list_gen() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_iter_get_seq_list_opt
@@ -2287,7 +2287,7 @@ loc += fast_dim_buf_off;
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5S__hyper_iter_get_seq_list_opt() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_iter_get_seq_list_single
@@ -2565,7 +2565,7 @@ H5S__hyper_iter_get_seq_list_single(H5S_sel_iter_t *iter, size_t maxseq, size_t
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5S__hyper_iter_get_seq_list_single() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_iter_get_seq_list
@@ -2727,7 +2727,7 @@ H5S__hyper_iter_get_seq_list(H5S_sel_iter_t *iter, size_t maxseq,
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_iter_get_seq_list() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_iter_release
@@ -2760,7 +2760,7 @@ H5S__hyper_iter_release(H5S_sel_iter_t *iter)
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5S__hyper_iter_release() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_new_span
@@ -2851,7 +2851,7 @@ H5S__hyper_new_span_info(unsigned rank)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_new_span_info() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_copy_span_helper
@@ -2947,7 +2947,7 @@ H5S__hyper_copy_span_helper(H5S_hyper_span_info_t *spans, unsigned rank,
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_copy_span_helper() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_copy_span
@@ -2992,7 +2992,7 @@ H5S__hyper_copy_span(H5S_hyper_span_info_t *spans, unsigned rank)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_copy_span() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_cmp_spans
@@ -3013,8 +3013,7 @@ H5S__hyper_copy_span(H5S_hyper_span_info_t *spans, unsigned rank)
  REVISION LOG
 --------------------------------------------------------------------------*/
 static H5_ATTR_PURE hbool_t
-H5S__hyper_cmp_spans(const H5S_hyper_span_info_t *span_info1,
-    const H5S_hyper_span_info_t *span_info2)
+H5S__hyper_cmp_spans(const H5S_hyper_span_info_t *span_info1, const H5S_hyper_span_info_t *span_info2)
 {
     hbool_t ret_value = TRUE;   /* Return value */
 
@@ -3088,7 +3087,7 @@ H5S__hyper_cmp_spans(const H5S_hyper_span_info_t *span_info1,
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_cmp_spans() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_free_span_info
@@ -3145,7 +3144,7 @@ H5S__hyper_free_span_info(H5S_hyper_span_info_t *span_info)
     FUNC_LEAVE_NOAPI_VOID
 } /* end H5S__hyper_free_span_info() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_free_span
@@ -3183,7 +3182,7 @@ H5S__hyper_free_span(H5S_hyper_span_t *span)
     FUNC_LEAVE_NOAPI_VOID
 } /* end H5S__hyper_free_span() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_copy
@@ -3258,7 +3257,7 @@ H5S__hyper_copy(H5S_t *dst, const H5S_t *src, hbool_t share_selection)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_copy() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_is_valid
@@ -3317,7 +3316,7 @@ H5S__hyper_is_valid(const H5S_t *space)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_is_valid() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_span_nblocks_helper
@@ -3385,7 +3384,7 @@ H5S__hyper_span_nblocks_helper(H5S_hyper_span_info_t *spans, unsigned op_info_i,
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_span_nblocks_helper() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_span_nblocks
@@ -3426,7 +3425,7 @@ H5S__hyper_span_nblocks(H5S_hyper_span_info_t *spans)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_span_nblocks() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__get_select_hyper_nblocks
@@ -3463,7 +3462,7 @@ H5S__get_select_hyper_nblocks(const H5S_t *space, hbool_t app_ref)
         /* Check each dimension */
         for(ret_value = 1, u = 0; u < space->extent.rank; u++)
             ret_value *= (app_ref ? space->select.sel_info.hslab->diminfo.app[u].count :
-                    space->select.sel_info.hslab->diminfo.opt[u].count);
+                                    space->select.sel_info.hslab->diminfo.opt[u].count);
     } /* end if */
     else
         ret_value = H5S__hyper_span_nblocks(space->select.sel_info.hslab->span_lst);
@@ -3471,7 +3470,7 @@ H5S__get_select_hyper_nblocks(const H5S_t *space, hbool_t app_ref)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__get_select_hyper_nblocks() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5Sget_select_hyper_nblocks
@@ -3512,7 +3511,7 @@ H5Sget_select_hyper_nblocks(hid_t spaceid)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Sget_select_hyper_nblocks() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_get_enc_size_real
@@ -3707,13 +3706,13 @@ H5S__hyper_get_version_enc_size(const H5S_t *space, hsize_t block_count, uint32_
         default:
             HGOTO_ERROR(H5E_DATASPACE, H5E_UNSUPPORTED, FAIL, "unknown hyperslab selection version")
             break;
-    } /* end switch */
+    }
 
 done:
     FUNC_LEAVE_NOAPI(ret_value)
 } /* H5S__hyper_get_version_enc_size() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_serial_size
@@ -3738,14 +3737,15 @@ H5S__hyper_serial_size(const H5S_t *space)
 {
     hsize_t block_count = 0;    /* block counter for regular hyperslabs */
     uint32_t version;           /* Version number */
-    uint8_t enc_size;           /* Encoded size of hyerslab selection info */
+    uint8_t enc_size;           /* Encoded size of hyperslab selection info */
     hssize_t ret_value = -1;    /* return value */
 
     FUNC_ENTER_STATIC
 
     HDassert(space);
 
-    if(space->select.sel_info.hslab->unlim_dim < 0)  /* ! H5S_UNLIMITED */
+    /* Determine the number of blocks */
+    if(space->select.sel_info.hslab->unlim_dim < 0) /* ! H5S_UNLIMITED */
         block_count = H5S__get_select_hyper_nblocks(space, FALSE);
 
     /* Determine the version and the encoded size */
@@ -3787,7 +3787,7 @@ H5S__hyper_serial_size(const H5S_t *space)
          */
         HDassert(enc_size == 8);
         ret_value = (hssize_t)17 + ((hssize_t)4 * (hssize_t)8 * (hssize_t)space->extent.rank);
-    } /* end else-if */
+    }
     else {
         HDassert(version == H5S_HYPER_VERSION_1);
         HDassert(enc_size == 4);
@@ -3807,7 +3807,7 @@ H5S__hyper_serial_size(const H5S_t *space)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_serial_size() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_serialize_helper
@@ -3928,14 +3928,14 @@ H5S__hyper_serialize_helper(const H5S_hyper_span_info_t *spans,
     FUNC_LEAVE_NOAPI_VOID
 } /* end H5S__hyper_serialize_helper() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_serialize
  PURPOSE
     Serialize the current selection into a user-provided buffer.
  USAGE
-    herr_t H5S_hyper_serialize(space, p)
+    herr_t H5S__hyper_serialize(space, p)
         const H5S_t *space;     IN: Dataspace with selection to serialize
         uint8_t **p;            OUT: Pointer to buffer to put serialized
                                 selection.  Will be advanced to end of
@@ -3958,7 +3958,7 @@ H5S__hyper_serialize(const H5S_t *space, uint8_t **p)
     hsize_t offset[H5S_MAX_RANK];       /* Offset of element in dataspace */
     hsize_t start[H5S_MAX_RANK];        /* Location of start of hyperslab */
     hsize_t end[H5S_MAX_RANK];          /* Location of end of hyperslab */
-    uint8_t *pp;                        /* Local pointer for decoding */
+    uint8_t *pp;                        /* Local pointer for encoding */
     uint8_t *lenp = NULL;   /* pointer to length location for later storage */
     uint32_t len = 0;       /* number of bytes used */
     uint32_t version;       /* Version number */
@@ -3969,7 +3969,7 @@ H5S__hyper_serialize(const H5S_t *space, uint8_t **p)
     unsigned u;             /* Local counting variable */
     hbool_t complete = FALSE;   /* Whether we are done with the iteration */
     hbool_t is_regular;     /* Whether selection is regular */
-    uint8_t enc_size;
+    uint8_t enc_size;       /* Encoded size */
     herr_t ret_value = SUCCEED; /* return value */
 
     FUNC_ENTER_STATIC
@@ -3984,7 +3984,8 @@ H5S__hyper_serialize(const H5S_t *space, uint8_t **p)
     ndims = space->extent.rank;
     diminfo = space->select.sel_info.hslab->diminfo.opt;
 
-    if(space->select.sel_info.hslab->unlim_dim < 0)  /* ! H5S_UNLIMITED */
+    /* Calculate the # of blocks */
+    if(space->select.sel_info.hslab->unlim_dim < 0) /* ! H5S_UNLIMITED */
         block_count = H5S__get_select_hyper_nblocks(space, FALSE);
 
     /* Determine the version and the encoded size */
@@ -4120,7 +4121,7 @@ H5S__hyper_serialize(const H5S_t *space, uint8_t **p)
                     tmp_count[fast_dim]--;
                 } /* end while */
 
-                 /* Work on other dimensions if necessary */
+                /* Work on other dimensions if necessary */
                 if(fast_dim > 0) {
                     int temp_dim;           /* Temporary rank holder */
 
@@ -4141,7 +4142,7 @@ H5S__hyper_serialize(const H5S_t *space, uint8_t **p)
                         if(temp_dim == 0)
                             complete = TRUE;
 
-                         /* Reset the block count in this dimension */
+                        /* Reset the block count in this dimension */
                         tmp_count[temp_dim] = diminfo[temp_dim].count;
 
                         /* Wrapped a dimension, go up to next dimension */
@@ -4204,7 +4205,7 @@ H5S__hyper_serialize(const H5S_t *space, uint8_t **p)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_serialize() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_deserialize
@@ -4383,7 +4384,7 @@ H5S__hyper_deserialize(H5S_t **space, const uint8_t **p)
         size_t num_elem;        /* Number of elements in selection */
         unsigned v;             /* Local counting variable */
 
-        /* decode the number of blocks */
+        /* Decode the number of blocks */
         switch(enc_size) {
             case H5S_SELECT_INFO_ENC_SIZE_2:
                 UINT16DECODE(pp, num_elem);
@@ -4748,7 +4749,7 @@ H5S__get_select_hyper_blocklist(H5S_t *space, hsize_t startblock,
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__get_select_hyper_blocklist() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5Sget_select_hyper_blocklist
@@ -4761,7 +4762,7 @@ H5S__get_select_hyper_blocklist(H5S_t *space, hsize_t startblock,
         hsize_t numblocks;      IN: Number of hyperslab blocks to get
         hsize_t buf[];          OUT: List of hyperslab blocks selected
  RETURNS
-    Non-negative on success/Negative on failure
+    Non-negative on success, negative on failure
  DESCRIPTION
         Puts a list of the hyperslab blocks into the user's buffer.  The blocks
     start with the 'startblock'th block in the list of blocks and put
@@ -4809,7 +4810,7 @@ H5Sget_select_hyper_blocklist(hid_t spaceid, hsize_t startblock,
     FUNC_LEAVE_API(ret_value)
 } /* end H5Sget_select_hyper_blocklist() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_bounds
@@ -4890,7 +4891,7 @@ H5S__hyper_bounds(const H5S_t *space, hsize_t *start, hsize_t *end)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_bounds() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_offset
@@ -4999,7 +5000,7 @@ H5S__hyper_offset(const H5S_t *space, hsize_t *offset)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_offset() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_unlim_dim
@@ -5026,7 +5027,7 @@ H5S__hyper_unlim_dim(const H5S_t *space)
     FUNC_LEAVE_NOAPI(space->select.sel_info.hslab->unlim_dim);
 } /* end H5S__hyper_unlim_dim() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_num_elem_non_unlim
@@ -5068,7 +5069,7 @@ H5S__hyper_num_elem_non_unlim(const H5S_t *space, hsize_t *num_elem_non_unlim)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_num_elem_non_unlim() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_is_contiguous
@@ -5254,7 +5255,7 @@ H5S__hyper_is_contiguous(const H5S_t *space)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_is_contiguous() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_is_single
@@ -5327,7 +5328,7 @@ H5S__hyper_is_single(const H5S_t *space)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_is_single() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_is_regular
@@ -5372,7 +5373,7 @@ H5S__hyper_is_regular(const H5S_t *space)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_is_regular() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_spans_shape_same_helper
@@ -5724,7 +5725,7 @@ H5S__hyper_shape_same(const H5S_t *space1, const H5S_t *space2)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_shape_same() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_release
@@ -5765,7 +5766,7 @@ H5S__hyper_release(H5S_t *space)
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5S__hyper_release() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_coord_to_span
@@ -5828,7 +5829,7 @@ H5S__hyper_coord_to_span(unsigned rank, const hsize_t *coords)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_coord_to_span() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_add_span_element_helper
@@ -6494,7 +6495,7 @@ H5S__hyper_adjust_u(H5S_t *space, const hsize_t *offset)
         if(0 != offset[u]) {
             non_zero_offset = TRUE;
             break;
-        } /* end if */
+        }
 
     /* Only perform operation if the offset is non-zero */
     if(non_zero_offset) {
@@ -9020,7 +9021,7 @@ H5S__hyper_generate_spans(H5S_t *space)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_generate_spans() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__check_spans_overlap
@@ -9404,11 +9405,11 @@ H5S__fill_in_new_space(H5S_t *space1, H5S_seloper_t op,
 /*-------------------------------------------------------------------------
  * Function:    H5S__generate_hyperlab
  *
- * Purpose:    Generate hyperslab information from H5S_select_hyperslab()
+ * Purpose:     Generate hyperslab information from H5S_select_hyperslab()
  *
- * Return:    Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Tuesday, September 12, 2000
  *
  *-------------------------------------------------------------------------
@@ -9824,11 +9825,11 @@ H5S__hyper_regular_and_single_block(H5S_t *space, const hsize_t start[],
 /*-------------------------------------------------------------------------
  * Function:    H5S_select_hyperslab
  *
- * Purpose:    Internal version of H5Sselect_hyperslab().
+ * Purpose:     Internal version of H5Sselect_hyperslab().
  *
- * Return:    Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Wednesday, January 10, 2001
  *
  *-------------------------------------------------------------------------
@@ -10495,9 +10496,9 @@ hid_t
 H5Scombine_hyperslab(hid_t space_id, H5S_seloper_t op, const hsize_t start[],
     const hsize_t stride[], const hsize_t count[], const hsize_t block[])
 {
-    H5S_t    *space;                 /* Dataspace to modify selection of */
-    H5S_t    *new_space = NULL;      /* New dataspace created */
-    hid_t    ret_value;              /* Return value */
+    H5S_t   *space;                 /* Dataspace to modify selection of */
+    H5S_t   *new_space = NULL;      /* New dataspace created */
+    hid_t   ret_value;              /* Return value */
 
     FUNC_ENTER_API(H5I_INVALID_HID)
     H5TRACE6("i", "iSs*h*h*h*h", space_id, op, start, stride, count, block);
@@ -10529,11 +10530,11 @@ H5Scombine_hyperslab(hid_t space_id, H5S_seloper_t op, const hsize_t start[],
 /*-------------------------------------------------------------------------
  * Function:    H5S__combine_select
  *
- * Purpose:    Internal version of H5Scombine_select().
+ * Purpose:     Internal version of H5Scombine_select().
  *
- * Return:    New dataspace on success/NULL on failure
+ * Return:      New dataspace on success/NULL on failure
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Tuesday, October 30, 2001
  *
  *-------------------------------------------------------------------------
@@ -10668,15 +10669,15 @@ H5Scombine_select(hid_t space1_id, H5S_seloper_t op, hid_t space2_id)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Scombine_select() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S__modify_select
  *
- * Purpose:    Internal version of H5Smodify_select().
+ * Purpose:     Internal version of H5Smodify_select().
  *
- * Return:    New dataspace on success/NULL on failure
+ * Return:      New dataspace on success/NULL on failure
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Tuesday, October 30, 2001
  *
  *-------------------------------------------------------------------------
diff --git a/src/H5Smpio.c b/src/H5Smpio.c
index 33dd49231ce..147fd25da85 100644
--- a/src/H5Smpio.c
+++ b/src/H5Smpio.c
@@ -14,7 +14,7 @@
 /*
  * Programmer:  rky 980813
  *
- * Purpose:	Create MPI data types for HDF5 selections.
+ * Purpose:     Create MPI data types for HDF5 selections.
  *
  */
 
@@ -148,14 +148,14 @@ H5S__mpio_all_type(const H5S_t *space, size_t elmt_size,
         *new_type = MPI_BYTE;
         H5_CHECKED_ASSIGN(*count, int, total_bytes, hsize_t);
         *is_derived_type = FALSE;
-    } /* end if */
+    }
     else {
         /* Create a LARGE derived datatype for this transfer */
         if(H5_mpio_create_large_type(total_bytes, 0, MPI_BYTE, new_type) < 0)
             HGOTO_ERROR(H5E_DATASPACE, H5E_BADTYPE, FAIL, "couldn't create a large datatype from the all selection")
         *count = 1;
         *is_derived_type = TRUE;
-    } /* end else */
+    }
 
 done:
     FUNC_LEAVE_NOAPI(ret_value)
@@ -253,7 +253,7 @@ H5S__mpio_create_point_datatype(size_t elmt_size, hsize_t num_points,
         /* Commit MPI datatype for later use */
         if(MPI_SUCCESS != (mpi_code = MPI_Type_commit(new_type)))
             HMPI_GOTO_ERROR(FAIL, "MPI_Type_commit failed", mpi_code)
-    } /* end if */
+    }
     else {
         /* use LARGE_DATATYPE::
          * We'll create an hindexed_block type for every 2G point count and then combine
@@ -295,7 +295,7 @@ H5S__mpio_create_point_datatype(size_t elmt_size, hsize_t num_points,
 #if MPI_VERSION >= 3
             if(MPI_SUCCESS != (mpi_code = MPI_Type_create_hindexed_block((int)bigio_count,
                     1, &disp[(hsize_t)i*bigio_count], elmt_type, &inner_types[i])))
-                HMPI_GOTO_ERROR(FAIL, "MPI_Type_create_hindexed_block failed", mpi_code)
+                HMPI_GOTO_ERROR(FAIL, "MPI_Type_create_hindexed_block failed", mpi_code);
 #else
             if(MPI_SUCCESS != (mpi_code = MPI_Type_create_hindexed((int)bigio_count,
                     blocks, &disp[i*bigio_count], elmt_type, &inner_types[i])))
@@ -309,7 +309,7 @@ H5S__mpio_create_point_datatype(size_t elmt_size, hsize_t num_points,
 #if MPI_VERSION >= 3
             if(MPI_SUCCESS != (mpi_code = MPI_Type_create_hindexed_block(remaining_points,
                     1, &disp[(hsize_t)num_big_types*bigio_count], elmt_type, &inner_types[num_big_types])))
-                HMPI_GOTO_ERROR(FAIL, "MPI_Type_create_hindexed_block failed", mpi_code)
+                HMPI_GOTO_ERROR(FAIL, "MPI_Type_create_hindexed_block failed", mpi_code);
 #else
             if(MPI_SUCCESS != (mpi_code = MPI_Type_create_hindexed((int)remaining_points,
                     blocks, &disp[num_big_types*bigio_count], elmt_type, &inner_types[num_big_types])))
@@ -317,11 +317,12 @@ H5S__mpio_create_point_datatype(size_t elmt_size, hsize_t num_points,
 #endif
             inner_blocks[num_big_types] = 1;
             inner_disps[num_big_types] = 0;
-        } /* end if */
+        }
 
         if(MPI_SUCCESS != (mpi_code = MPI_Type_create_struct(total_types,
                 inner_blocks, inner_disps, inner_types, new_type)))
-            HMPI_GOTO_ERROR(FAIL, "MPI_Type_create_struct", mpi_code)
+            HMPI_GOTO_ERROR(FAIL, "MPI_Type_create_struct", mpi_code);
+
         for(i = 0; i < total_types; i++)
             MPI_Type_free(&inner_types[i]);
 
@@ -492,7 +493,7 @@ H5S__mpio_point_type(const H5S_t *space, size_t elmt_size, MPI_Datatype *new_typ
  *              selection and so the memory datatype has to be permuted using the
  *              permutation map created by the file selection.
  *
- * Note:	This routine is called from H5_mpio_space_type(), which is
+ * Note:	This routine is called from H5S_mpio_space_type(), which is
  *              called first for the file dataspace and creates
  *
  * Return:	Non-negative on success, negative on failure.
@@ -799,7 +800,7 @@ if(H5DEBUG(S)) {
         /* Use a single MPI datatype that has a 32 bit size */
         if(MPI_SUCCESS != (mpi_code = MPI_Type_contiguous((int)elmt_size, MPI_BYTE, &inner_type)))
             HMPI_GOTO_ERROR(FAIL, "MPI_Type_contiguous failed", mpi_code)
-    } /* end if */
+    }
     else
         /* Create the compound datatype for this operation (> 2GB) */
         if(H5_mpio_create_large_type(elmt_size, 0, MPI_BYTE, &inner_type) < 0)
@@ -836,7 +837,7 @@ if(H5DEBUG(S))
             MPI_Type_free(&inner_type);
             if(mpi_code != MPI_SUCCESS)
                 HMPI_GOTO_ERROR(FAIL, "couldn't create MPI vector type", mpi_code)
-       } /* end if */
+       }
        else {
             /* Things get a bit more complicated and require LARGE_DATATYPE processing
              * There are two MPI datatypes that need to be created:
@@ -858,7 +859,7 @@ if(H5DEBUG(S))
             if(bigio_count < d[i].block) {
                 if(H5_mpio_create_large_type(d[i].block, 0, inner_type, &block_type) < 0)
                     HGOTO_ERROR(H5E_DATASPACE, H5E_BADTYPE, FAIL, "couldn't create a large block datatype in hyper selection")
-            } /* end if */
+            }
             else
                 if(MPI_SUCCESS != (mpi_code = MPI_Type_contiguous((int)d[i].block, inner_type, &block_type)))
                     HMPI_GOTO_ERROR(FAIL, "MPI_Type_contiguous failed", mpi_code)
@@ -879,7 +880,7 @@ if(H5DEBUG(S))
             if(bigio_count < d[i].count) {
                 if(H5_mpio_create_large_type(d[i].count, stride_in_bytes, block_type, &outer_type) < 0)
                     HGOTO_ERROR(H5E_DATASPACE, H5E_BADTYPE, FAIL, "couldn't create a large outer datatype in hyper selection")
-            } /* end if */
+            }
             /* otherwise a regular create_hvector will do */
             else
                 if(MPI_SUCCESS != (mpi_code = MPI_Type_create_hvector((int)d[i].count, /* count */
@@ -891,7 +892,7 @@ if(H5DEBUG(S))
 
             MPI_Type_free(&block_type);
             MPI_Type_free(&inner_type);
-       } /* end else */
+        } /* end else */
 
         /****************************************
          *  Then build the dimension type as (start, vector type, xtent).
@@ -1004,7 +1005,7 @@ H5S__mpio_span_hyper_type(const H5S_t *space, size_t elmt_size,
     if(bigio_count >= elmt_size) {
         if(MPI_SUCCESS != (mpi_code = MPI_Type_contiguous((int)elmt_size, MPI_BYTE, &elmt_type)))
             HMPI_GOTO_ERROR(FAIL, "MPI_Type_contiguous failed", mpi_code)
-    } /* end if */
+    }
     else
         if(H5_mpio_create_large_type(elmt_size, 0, MPI_BYTE, &elmt_type) < 0)
             HGOTO_ERROR(H5E_DATASPACE, H5E_BADTYPE, FAIL, "couldn't create a large element datatype in span_hyper selection")
@@ -1113,7 +1114,6 @@ H5S__obtain_datatype(H5S_hyper_span_info_t *spans, const hsize_t *down,
 {
     H5S_hyper_span_t      *span;                /* Hyperslab span to iterate with */
     hsize_t               bigio_count;          /* Transition point to create derived type */
-
     size_t                alloc_count = 0;      /* Number of span tree nodes allocated at this level */
     size_t                outercount = 0;       /* Number of span tree nodes at this level */
     MPI_Datatype          *inner_type = NULL;
diff --git a/src/H5Snone.c b/src/H5Snone.c
index 630d1d581bf..672302d7159 100644
--- a/src/H5Snone.c
+++ b/src/H5Snone.c
@@ -29,7 +29,7 @@
 /* Headers */
 /***********/
 #include "H5private.h"          /* Generic Functions                        */
-#include "H5Eprivate.h"		/* Error handling			    */
+#include "H5Eprivate.h"         /* Error handling                           */
 #include "H5Iprivate.h"         /* ID Functions                             */
 #include "H5Spkg.h"             /* Dataspace functions                      */
 #include "H5VMprivate.h"        /* Vector functions                         */
@@ -68,8 +68,7 @@ static htri_t H5S__none_intersect_block(const H5S_t *space, const hsize_t *start
 static herr_t H5S__none_adjust_u(H5S_t *space, const hsize_t *offset);
 static herr_t H5S__none_adjust_s(H5S_t *space, const hssize_t *offset);
 static herr_t H5S__none_project_scalar(const H5S_t *space, hsize_t *offset);
-static herr_t H5S__none_project_simple(const H5S_t *space, H5S_t *new_space,
-    hsize_t *offset);
+static herr_t H5S__none_project_simple(const H5S_t *space, H5S_t *new_space, hsize_t *offset);
 static herr_t H5S__none_iter_init(const H5S_t *space, H5S_sel_iter_t *iter);
 
 /* Selection iteration callbacks */
@@ -143,13 +142,13 @@ static const H5S_sel_iter_class_t H5S_sel_iter_none[1] = {{
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5S__none_iter_init
+ * Function:    H5S__none_iter_init
  *
- * Purpose:	Initializes iteration information for "none" selection.
+ * Purpose:     Initializes iteration information for "none" selection.
  *
- * Return:	Non-negative on success, negative on failure.
+ * Return:      Non-negative on success, negative on failure.
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Tuesday, June 16, 1998
  *
  *-------------------------------------------------------------------------
@@ -171,21 +170,20 @@ H5S__none_iter_init(const H5S_t H5_ATTR_UNUSED *space, H5S_sel_iter_t *iter)
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5S__none_iter_coords
+ * Function:    H5S__none_iter_coords
  *
- * Purpose:	Retrieve the current coordinates of iterator for current
+ * Purpose:     Retrieve the current coordinates of iterator for current
  *              selection
  *
- * Return:	Non-negative on success, negative on failure
+ * Return:      Non-negative on success, negative on failure
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Tuesday, April 22, 2003
  *
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5S__none_iter_coords(const H5S_sel_iter_t H5_ATTR_UNUSED *iter,
-    hsize_t H5_ATTR_UNUSED *coords)
+H5S__none_iter_coords(const H5S_sel_iter_t H5_ATTR_UNUSED *iter, hsize_t H5_ATTR_UNUSED *coords)
 {
     FUNC_ENTER_STATIC_NOERR
 
@@ -198,21 +196,20 @@ H5S__none_iter_coords(const H5S_sel_iter_t H5_ATTR_UNUSED *iter,
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5S__none_iter_block
+ * Function:    H5S__none_iter_block
  *
- * Purpose:	Retrieve the current block of iterator for current
+ * Purpose:     Retrieve the current block of iterator for current
  *              selection
  *
- * Return:	Non-negative on success, negative on failure
+ * Return:      Non-negative on success, negative on failure
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Monday, June 2, 2003
  *
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5S__none_iter_block(const H5S_sel_iter_t H5_ATTR_UNUSED *iter,
-    hsize_t H5_ATTR_UNUSED *start, hsize_t H5_ATTR_UNUSED *end)
+H5S__none_iter_block(const H5S_sel_iter_t H5_ATTR_UNUSED *iter, hsize_t H5_ATTR_UNUSED *start, hsize_t H5_ATTR_UNUSED *end)
 {
     FUNC_ENTER_STATIC_NOERR
 
@@ -226,13 +223,13 @@ H5S__none_iter_block(const H5S_sel_iter_t H5_ATTR_UNUSED *iter,
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5S__none_iter_nelmts
+ * Function:    H5S__none_iter_nelmts
  *
- * Purpose:	Return number of elements left to process in iterator
+ * Purpose:     Return number of elements left to process in iterator
  *
- * Return:	Non-negative number of elements on success, zero on failure
+ * Return:      Non-negative number of elements on success, zero on failure
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Tuesday, June 16, 1998
  *
  *-------------------------------------------------------------------------
@@ -472,8 +469,7 @@ H5S__none_release(H5S_t H5_ATTR_UNUSED *space)
  REVISION LOG
 --------------------------------------------------------------------------*/
 static herr_t
-H5S__none_copy(H5S_t *dst, const H5S_t H5_ATTR_UNUSED *src,
-    hbool_t H5_ATTR_UNUSED share_selection)
+H5S__none_copy(H5S_t *dst, const H5S_t H5_ATTR_UNUSED *src, hbool_t H5_ATTR_UNUSED share_selection)
 {
     FUNC_ENTER_STATIC_NOERR
 
@@ -586,8 +582,8 @@ H5S__none_serialize(const H5S_t *space, uint8_t **p)
     HDassert(pp);
 
     /* Store the preamble information */
-    UINT32ENCODE(pp, (uint32_t)H5S_GET_SELECT_TYPE(space));  /* Store the type of selection */
-    UINT32ENCODE(pp, (uint32_t)H5S_NONE_VERSION_1);  /* Store the version number */
+    UINT32ENCODE(pp, (uint32_t)H5S_GET_SELECT_TYPE(space)); /* Store the type of selection */
+    UINT32ENCODE(pp, (uint32_t)H5S_NONE_VERSION_1);         /* Store the version number */
     UINT32ENCODE(pp, (uint32_t)0);  /* Store the un-used padding */
     UINT32ENCODE(pp, (uint32_t)0);  /* Store the additional information length */
 
@@ -698,8 +694,7 @@ H5S__none_deserialize(H5S_t **space, const uint8_t **p)
  REVISION LOG
 --------------------------------------------------------------------------*/
 static herr_t
-H5S__none_bounds(const H5S_t H5_ATTR_UNUSED *space, hsize_t H5_ATTR_UNUSED *start,
-    hsize_t H5_ATTR_UNUSED *end)
+H5S__none_bounds(const H5S_t H5_ATTR_UNUSED *space, hsize_t H5_ATTR_UNUSED *start, hsize_t H5_ATTR_UNUSED *end)
 {
     FUNC_ENTER_STATIC_NOERR
 
@@ -708,7 +703,7 @@ H5S__none_bounds(const H5S_t H5_ATTR_UNUSED *space, hsize_t H5_ATTR_UNUSED *star
     HDassert(end);
 
     FUNC_LEAVE_NOAPI(FAIL)
-} /* end H5Sget_none_bounds() */
+} /* end H5S_none_bounds() */
 
 
 /*--------------------------------------------------------------------------
@@ -991,11 +986,11 @@ H5S__none_adjust_s(H5S_t H5_ATTR_UNUSED *space, const hssize_t H5_ATTR_UNUSED *o
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5S__none_project_scalar
+ * Function:    H5S__none_project_scalar
  *
- * Purpose:	Projects a 'none' selection into a scalar dataspace
+ * Purpose:     Projects a 'none' selection into a scalar dataspace
  *
- * Return:	Non-negative on success, negative on failure.
+ * Return:      Non-negative on success, negative on failure.
  *
  * Programmer:	Quincey Koziol
  *              Sunday, July 18, 2010
@@ -1016,14 +1011,14 @@ H5S__none_project_scalar(const H5S_t H5_ATTR_UNUSED *space, hsize_t H5_ATTR_UNUS
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5S__none_project_simple
+ * Function:    H5S__none_project_simple
  *
- * Purpose:	Projects an 'none' selection onto/into a simple dataspace
+ * Purpose:     Projects an 'none' selection onto/into a simple dataspace
  *              of a different rank
  *
- * Return:	Non-negative on success, negative on failure.
+ * Return:      Non-negative on success, negative on failure.
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Sunday, July 18, 2010
  *
  *-------------------------------------------------------------------------
diff --git a/src/H5Spkg.h b/src/H5Spkg.h
index da2dd4aff8a..e08fedf0d40 100644
--- a/src/H5Spkg.h
+++ b/src/H5Spkg.h
@@ -324,11 +324,9 @@ struct H5S_t {
 
 /* Selection iteration methods */
 /* Method to retrieve the current coordinates of iterator for current selection */
-typedef herr_t (*H5S_sel_iter_coords_func_t)(const H5S_sel_iter_t *iter,
-    hsize_t *coords);
+typedef herr_t (*H5S_sel_iter_coords_func_t)(const H5S_sel_iter_t *iter, hsize_t *coords);
 /* Method to retrieve the current block of iterator for current selection */
-typedef herr_t (*H5S_sel_iter_block_func_t)(const H5S_sel_iter_t *iter,
-    hsize_t *start, hsize_t *end);
+typedef herr_t (*H5S_sel_iter_block_func_t)(const H5S_sel_iter_t *iter, hsize_t *start, hsize_t *end);
 /* Method to determine number of elements left in iterator for current selection */
 typedef hsize_t (*H5S_sel_iter_nelmts_func_t)(const H5S_sel_iter_t *iter);
 /* Method to determine if there are more blocks left in the current selection */
diff --git a/src/H5Spoint.c b/src/H5Spoint.c
index 694812520fb..60e810d2c25 100644
--- a/src/H5Spoint.c
+++ b/src/H5Spoint.c
@@ -15,7 +15,7 @@
  * Programmer:  Quincey Koziol <koziol@ncsa.uiuc.edu>
  *              Tuesday, June 16, 1998
  *
- * Purpose:    Point selection dataspace I/O functions.
+ * Purpose:     Point selection dataspace I/O functions.
  */
 
 /****************/
@@ -30,8 +30,8 @@
 /***********/
 #include "H5private.h"          /* Generic Functions                        */
 #include "H5CXprivate.h"        /* API Contexts                             */
-#include "H5Eprivate.h"        /* Error handling                */
-#include "H5FLprivate.h"    /* Free Lists                    */
+#include "H5Eprivate.h"         /* Error handling                           */
+#include "H5FLprivate.h"        /* Free Lists                               */
 #include "H5Iprivate.h"         /* ID Functions                             */
 #include "H5MMprivate.h"        /* Memory management                        */
 #include "H5Spkg.h"             /* Dataspace functions                      */
@@ -75,21 +75,17 @@ static htri_t H5S__point_is_contiguous(const H5S_t *space);
 static htri_t H5S__point_is_single(const H5S_t *space);
 static htri_t H5S__point_is_regular(const H5S_t *space);
 static htri_t H5S__point_shape_same(const H5S_t *space1, const H5S_t *space2);
-static htri_t H5S__point_intersect_block(const H5S_t *space, const hsize_t *start,
-    const hsize_t *end);
+static htri_t H5S__point_intersect_block(const H5S_t *space, const hsize_t *start, const hsize_t *end);
 static herr_t H5S__point_adjust_u(H5S_t *space, const hsize_t *offset);
 static herr_t H5S__point_adjust_s(H5S_t *space, const hssize_t *offset);
 static herr_t H5S__point_project_scalar(const H5S_t *spasce, hsize_t *offset);
-static herr_t H5S__point_project_simple(const H5S_t *space, H5S_t *new_space,
-    hsize_t *offset);
+static herr_t H5S__point_project_simple(const H5S_t *space, H5S_t *new_space, hsize_t *offset);
 static herr_t H5S__point_iter_init(const H5S_t *space, H5S_sel_iter_t *iter);
-static herr_t H5S__point_get_version_enc_size(const H5S_t *space,
-    uint32_t *version, uint8_t *enc_size);
+static herr_t H5S__point_get_version_enc_size(const H5S_t *space, uint32_t *version, uint8_t *enc_size);
 
 /* Selection iteration callbacks */
 static herr_t H5S__point_iter_coords(const H5S_sel_iter_t *iter, hsize_t *coords);
-static herr_t H5S__point_iter_block(const H5S_sel_iter_t *iter, hsize_t *start,
-    hsize_t *end);
+static herr_t H5S__point_iter_block(const H5S_sel_iter_t *iter, hsize_t *start, hsize_t *end);
 static hsize_t H5S__point_iter_nelmts(const H5S_sel_iter_t *iter);
 static htri_t H5S__point_iter_has_next_block(const H5S_sel_iter_t *iter);
 static herr_t H5S__point_iter_next(H5S_sel_iter_t *sel_iter, size_t nelem);
@@ -169,16 +165,15 @@ H5FL_BARR_DEFINE_STATIC(H5S_pnt_node_t, hcoords_t, H5S_MAX_RANK);
 /* Declare a free list to manage the H5S_pnt_list_t struct */
 H5FL_DEFINE_STATIC(H5S_pnt_list_t);
 
-
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S__point_iter_init
  *
- * Purpose:    Initializes iteration information for point selection.
+ * Purpose:     Initializes iteration information for point selection.
  *
- * Return:    Non-negative on success, negative on failure.
+ * Return:      Non-negative on success, negative on failure.
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Tuesday, June 16, 1998
  *
  *-------------------------------------------------------------------------
@@ -223,16 +218,16 @@ H5S__point_iter_init(const H5S_t *space, H5S_sel_iter_t *iter)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__point_iter_init() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S__point_iter_coords
  *
- * Purpose:    Retrieve the current coordinates of iterator for current
+ * Purpose:     Retrieve the current coordinates of iterator for current
  *              selection
  *
- * Return:    Non-negative on success, negative on failure
+ * Return:      Non-negative on success, negative on failure
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Tuesday, April 22, 2003
  *
  *-------------------------------------------------------------------------
@@ -252,16 +247,16 @@ H5S__point_iter_coords(const H5S_sel_iter_t *iter, hsize_t *coords)
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5S__point_iter_coords() */
 
-
+
 /*-------------------------------------------------------------------------
- * Function:    H5S__point_iter_block
+ * Function:    H5S_point_iter_block
  *
- * Purpose:    Retrieve the current block of iterator for current
+ * Purpose:     Retrieve the current block of iterator for current
  *              selection
  *
- * Return:    Non-negative on success, negative on failure
+ * Return:      Non-negative on success, negative on failure
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Monday, June 2, 2003
  *
  *-------------------------------------------------------------------------
@@ -283,15 +278,15 @@ H5S__point_iter_block(const H5S_sel_iter_t *iter, hsize_t *start, hsize_t *end)
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5S__point_iter_block() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5S__point_iter_nelmts
  *
- * Purpose:    Return number of elements left to process in iterator
+ * Purpose:     Return number of elements left to process in iterator
  *
- * Return:    Non-negative number of elements on success, zero on failure
+ * Return:      Non-negative number of elements on success, zero on failure
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Tuesday, June 16, 1998
  *
  *-------------------------------------------------------------------------
@@ -307,7 +302,7 @@ H5S__point_iter_nelmts(const H5S_sel_iter_t *iter)
     FUNC_LEAVE_NOAPI(iter->elmt_left)
 } /* end H5S__point_iter_nelmts() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__point_iter_has_next_block
@@ -343,7 +338,7 @@ H5S__point_iter_has_next_block(const H5S_sel_iter_t *iter)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__point_iter_has_next_block() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__point_iter_next
@@ -380,7 +375,7 @@ H5S__point_iter_next(H5S_sel_iter_t *iter, size_t nelem)
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5S__point_iter_next() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__point_iter_next_block
@@ -412,7 +407,7 @@ H5S__point_iter_next_block(H5S_sel_iter_t *iter)
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5S__point_iter_next_block() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__point_iter_get_seq_list
@@ -577,7 +572,7 @@ H5S__point_iter_release(H5S_sel_iter_t * iter)
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5S__point_iter_release() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__point_add
@@ -694,7 +689,7 @@ H5S__point_add(H5S_t *space, H5S_seloper_t op, size_t num_elem, const hsize_t *c
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__point_add() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__point_release
@@ -732,7 +727,7 @@ H5S__point_release(H5S_t *space)
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5S__point_release() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S_select_elements
@@ -789,7 +784,7 @@ H5S_select_elements(H5S_t *space, H5S_seloper_t op, size_t num_elem,
         /* Set the bound box to the default value */
         H5VM_array_fill(space->select.sel_info.pnt_lst->low_bounds, &tmp, sizeof(hsize_t), space->extent.rank);
         HDmemset(space->select.sel_info.pnt_lst->high_bounds, 0, sizeof(hsize_t) * space->extent.rank);
-    } /* end if */
+    }
 
     /* Add points to selection */
     if(H5S__point_add(space, op, num_elem, coord) < 0)
@@ -802,7 +797,7 @@ H5S_select_elements(H5S_t *space, H5S_seloper_t op, size_t num_elem,
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_select_elements() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__copy_pnt_list
@@ -960,7 +955,7 @@ H5S__point_copy(H5S_t *dst, const H5S_t *src, hbool_t H5_ATTR_UNUSED share_selec
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__point_copy() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__point_is_valid
@@ -1004,7 +999,7 @@ H5S__point_is_valid(const H5S_t *space)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__point_is_valid() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5Sget_select_elem_npoints
@@ -1050,7 +1045,7 @@ H5Sget_select_elem_npoints(hid_t spaceid)
  PURPOSE
     Determine the version and the size (2, 4 or 8 bytes) to encode point selection info
  USAGE
-    hssize_t H5S__point_set_enc_size(space, version, enc_size)
+    hssize_t H5S__point_get_version_enc_size(space, version, enc_size)
         const H5S_t *space:         IN: Dataspace ID of selection to query
         uint32_t *version:          OUT: The version to use for encoding
         uint8_t *enc_size:          OUT: The size to use for encoding
@@ -1161,7 +1156,7 @@ H5S__point_get_version_enc_size(const H5S_t *space, uint32_t *version, uint8_t *
     FUNC_LEAVE_NOAPI(ret_value)
 } /* H5S__point_get_version_enc_size() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__point_serial_size
@@ -1220,7 +1215,7 @@ H5S__point_serial_size(const H5S_t *space)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__point_serial_size() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__point_serialize
@@ -1246,7 +1241,7 @@ static herr_t
 H5S__point_serialize(const H5S_t *space, uint8_t **p)
 {
     H5S_pnt_node_t *curr;       /* Point information nodes */
-    uint8_t *pp;                /* Local pointer for decoding */
+    uint8_t *pp;                /* Local pointer for encoding */
     uint8_t *lenp = NULL;       /* pointer to length location for later storage */
     uint32_t len=0;             /* number of bytes used */
     unsigned u;                 /* local counting variable */
@@ -1352,8 +1347,7 @@ H5S__point_serialize(const H5S_t *space, uint8_t **p)
     FUNC_LEAVE_NOAPI(ret_value)
 }   /* H5S__point_serialize() */
 
-
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__point_deserialize
@@ -1508,7 +1502,7 @@ H5S__point_deserialize(H5S_t **space, const uint8_t **p)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__point_deserialize() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__get_select_elem_pointlist
@@ -1539,8 +1533,7 @@ H5S__point_deserialize(H5S_t **space, const uint8_t **p)
  REVISION LOG
 --------------------------------------------------------------------------*/
 static herr_t
-H5S__get_select_elem_pointlist(const H5S_t *space, hsize_t startpoint,
-    hsize_t numpoints, hsize_t *buf)
+H5S__get_select_elem_pointlist(const H5S_t *space, hsize_t startpoint, hsize_t numpoints, hsize_t *buf)
 {
     H5S_pnt_node_t *node;       /* Point node */
     unsigned rank;              /* Dataspace rank */
@@ -1573,7 +1566,7 @@ H5S__get_select_elem_pointlist(const H5S_t *space, hsize_t startpoint,
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5S__get_select_elem_pointlist() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5Sget_select_elem_pointlist
@@ -1627,7 +1620,7 @@ H5Sget_select_elem_pointlist(hid_t spaceid, hsize_t startpoint,
     FUNC_LEAVE_API(ret_value)
 } /* end H5Sget_select_elem_pointlist() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__point_bounds
@@ -1685,7 +1678,7 @@ H5S__point_bounds(const H5S_t *space, hsize_t *start, hsize_t *end)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__point_bounds() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__point_offset
@@ -1749,7 +1742,7 @@ H5S__point_offset(const H5S_t *space, hsize_t *offset)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__point_offset() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__point_unlim_dim
@@ -1778,7 +1771,7 @@ H5S__point_unlim_dim(const H5S_t H5_ATTR_UNUSED *space)
     FUNC_LEAVE_NOAPI(-1)
 } /* end H5S__point_unlim_dim() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__point_is_contiguous
@@ -1818,7 +1811,7 @@ H5S__point_is_contiguous(const H5S_t *space)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__point_is_contiguous() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__point_is_single
@@ -1855,7 +1848,7 @@ H5S__point_is_single(const H5S_t *space)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__point_is_single() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__point_is_regular
@@ -1896,7 +1889,7 @@ H5S__point_is_regular(const H5S_t *space)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__point_is_regular() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__point_shape_same
@@ -2061,7 +2054,7 @@ H5S__point_intersect_block(const H5S_t *space, const hsize_t *start,
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__point_intersect_block() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__point_adjust_u
@@ -2098,7 +2091,7 @@ H5S__point_adjust_u(H5S_t *space, const hsize_t *offset)
         if(0 != offset[u]) {
             non_zero_offset = TRUE;
             break;
-        } /* end if */
+        }
 
     /* Only perform operation if the offset is non-zero */
     if(non_zero_offset) {
@@ -2129,7 +2122,7 @@ H5S__point_adjust_u(H5S_t *space, const hsize_t *offset)
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5S__point_adjust_u() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__point_adjust_s
@@ -2199,15 +2192,16 @@ H5S__point_adjust_s(H5S_t *space, const hssize_t *offset)
 } /* end H5S__point_adjust_s() */
 
 
+
 /*-------------------------------------------------------------------------
  * Function:    H5S__point_project_scalar
  *
- * Purpose:    Projects a single element point selection into a scalar
+ * Purpose:     Projects a single element point selection into a scalar
  *              dataspace
  *
- * Return:    Non-negative on success, negative on failure.
+ * Return:      Non-negative on success, negative on failure.
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Sunday, July 18, 2010
  *
  *-------------------------------------------------------------------------
@@ -2238,16 +2232,16 @@ H5S__point_project_scalar(const H5S_t *space, hsize_t *offset)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__point_project_scalar() */
 
-
+
 /*-------------------------------------------------------------------------
- * Function:    H5S__point_project_simple
+ * Function:    H5S_point_project_simple
  *
- * Purpose:    Projects a point selection onto/into a simple dataspace
+ * Purpose:     Projects a point selection onto/into a simple dataspace
  *              of a different rank
  *
- * Return:    Non-negative on success, negative on failure.
+ * Return:      Non-negative on success, negative on failure.
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Sunday, July 18, 2010
  *
  *-------------------------------------------------------------------------
@@ -2374,7 +2368,7 @@ H5S__point_project_simple(const H5S_t *base_space, H5S_t *new_space, hsize_t *of
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__point_project_simple() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5Sselect_elements
diff --git a/src/H5Sprivate.h b/src/H5Sprivate.h
index a61c505fc5e..5100f1c9403 100644
--- a/src/H5Sprivate.h
+++ b/src/H5Sprivate.h
@@ -183,6 +183,7 @@ typedef struct H5S_sel_iter_op_t {
 #define H5S_SELECT_ITER_GET_SEQ_LIST(ITER,MAXSEQ,MAXBYTES,NSEQ,NBYTES,OFF,LEN)  (H5S_select_iter_get_seq_list(ITER,MAXSEQ,MAXBYTES,NSEQ,NBYTES,OFF,LEN))
 #define H5S_SELECT_ITER_RELEASE(ITER)   (H5S_select_iter_release(ITER))
 #endif /* H5S_MODULE */
+
 /* Handle these callbacks in a special way, since they have prologs that need to be executed */
 #define H5S_SELECT_COPY(DST,SRC,SHARE)  (H5S_select_copy(DST,SRC,SHARE))
 #define H5S_SELECT_SHAPE_SAME(S1,S2)    (H5S_select_shape_same(S1,S2))
diff --git a/src/H5Sselect.c b/src/H5Sselect.c
index 1072d7dfacf..901dec1318a 100644
--- a/src/H5Sselect.c
+++ b/src/H5Sselect.c
@@ -32,6 +32,7 @@
 #include "H5Eprivate.h"		/* Error handling		  	*/
 #include "H5FLprivate.h"	/* Free Lists                           */
 #include "H5Iprivate.h"		/* IDs			  		*/
+#include "H5MMprivate.h"        /* Memory management                    */
 #include "H5Spkg.h"		/* Dataspaces 				*/
 #include "H5VMprivate.h"	/* Vector and array functions		*/
 
@@ -144,8 +145,8 @@ H5S_select_offset(H5S_t *space, const hssize_t *offset)
 herr_t
 H5Soffset_simple(hid_t space_id, const hssize_t *offset)
 {
-    H5S_t *space;	        /* Dataspace to query */
-    herr_t ret_value = SUCCEED; /* Return value */
+    H5S_t *space;                   /* Dataspace to modify */
+    herr_t ret_value = SUCCEED;     /* Return value */
 
     FUNC_ENTER_API(FAIL)
     H5TRACE2("e", "i*Hs", space_id, offset);
@@ -582,7 +583,7 @@ H5S_select_deserialize(H5S_t **space, const uint8_t **p)
 
         default:
             break;
-    } /* end switch */
+    }
 
     if(ret_value < 0)
         HGOTO_ERROR(H5E_DATASPACE, H5E_CANTLOAD, FAIL, "can't deserialize selection")

From 07a52ecb2ffa1d8d32f06db23470833899db3deb Mon Sep 17 00:00:00 2001
From: Allen Byrne <byrn@hdfgroup.org>
Date: Thu, 9 Jul 2020 13:03:58 -0500
Subject: [PATCH 25/55] HDFFV-11116 Add option for install location of Fortran
 MOD files

---
 CMakeLists.txt                 | 11 +++++++++++
 config/cmake/cacheinit.cmake   |  3 +++
 fortran/src/CMakeLists.txt     | 20 ++++++++++++++++++++
 hl/fortran/src/CMakeLists.txt  | 21 ++++++++++++++++++++-
 release_docs/INSTALL_CMake.txt |  8 ++++++++
 release_docs/RELEASE.txt       | 31 ++++++++++++++++++++++++++++---
 6 files changed, 90 insertions(+), 4 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index b5594462cfa..ac291fa6b16 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -995,6 +995,17 @@ if (EXISTS "${HDF5_SOURCE_DIR}/fortran" AND IS_DIRECTORY "${HDF5_SOURCE_DIR}/for
       endif ()
     endif ()
 
+    #option (HDF5_INSTALL_MOD_FORTRAN "Copy FORTRAN mod files to include directory (NO SHARED STATIC)" "NO")
+    set (HDF5_INSTALL_MOD_FORTRAN "SHARED" CACHE STRING "Copy FORTRAN mod files to include directory (NO SHARED STATIC)")
+    set_property (CACHE HDF5_INSTALL_MOD_FORTRAN PROPERTY STRINGS NO SHARED STATIC)
+    if (NOT HDF5_INSTALL_MOD_FORTRAN MATCHES "NO")
+      if (NOT BUILD_SHARED_LIBS AND BUILD_STATIC_LIBS)
+        set (HDF5_INSTALL_MOD_FORTRAN "STATIC")
+      elseif (BUILD_SHARED_LIBS AND NOT BUILD_STATIC_LIBS)
+        set (HDF5_INSTALL_MOD_FORTRAN "SHARED")
+      endif ()
+    endif ()
+
     add_subdirectory (fortran)
     if (HDF5_BUILD_HL_LIB)
       if (EXISTS "${HDF5_SOURCE_DIR}/hl/fortran" AND IS_DIRECTORY "${HDF5_SOURCE_DIR}/hl/fortran")
diff --git a/config/cmake/cacheinit.cmake b/config/cmake/cacheinit.cmake
index 48469979b9b..64e8dccf018 100644
--- a/config/cmake/cacheinit.cmake
+++ b/config/cmake/cacheinit.cmake
@@ -23,6 +23,9 @@ set (HDF_PACKAGE_NAMESPACE "hdf5::" CACHE STRING "Name for HDF package namespace
 
 set (HDF5_BUILD_FORTRAN ON CACHE BOOL "Build FORTRAN support" FORCE)
 
+set (HDF5_INSTALL_MOD_FORTRAN "NO" CACHE STRING "Copy FORTRAN mod files to include directory (NO SHARED STATIC)" FORCE)
+set_property (CACHE HDF5_INSTALL_MOD_FORTRAN PROPERTY STRINGS NO SHARED STATIC)
+
 set (HDF5_BUILD_GENERATORS ON CACHE BOOL "Build Test Generators" FORCE)
 
 set (HDF5_ENABLE_Z_LIB_SUPPORT ON CACHE BOOL "Enable Zlib Filters" FORCE)
diff --git a/fortran/src/CMakeLists.txt b/fortran/src/CMakeLists.txt
index bf2fd849a1b..b1add54bc5e 100644
--- a/fortran/src/CMakeLists.txt
+++ b/fortran/src/CMakeLists.txt
@@ -412,6 +412,16 @@ if (NOT ONLY_SHARED_LIBS)
       COMPONENT
           fortheaders
   )
+  if (HDF5_INSTALL_MOD_FORTRAN MATCHES "STATIC")
+    install (
+        FILES
+            ${mod_files}
+        DESTINATION
+            ${HDF5_INSTALL_INCLUDE_DIR}
+        COMPONENT
+            fortheaders
+    )
+  endif ()
 endif ()
 
 if (BUILD_SHARED_LIBS)
@@ -445,6 +455,16 @@ if (BUILD_SHARED_LIBS)
       COMPONENT
           fortheaders
   )
+  if (HDF5_INSTALL_MOD_FORTRAN MATCHES "SHARED")
+    install (
+        FILES
+            ${modsh_files}
+        DESTINATION
+            ${HDF5_INSTALL_INCLUDE_DIR}
+        COMPONENT
+            fortheaders
+    )
+  endif ()
 endif ()
 
 #-----------------------------------------------------------------------------
diff --git a/hl/fortran/src/CMakeLists.txt b/hl/fortran/src/CMakeLists.txt
index 71b9380ea93..d682d5f4830 100644
--- a/hl/fortran/src/CMakeLists.txt
+++ b/hl/fortran/src/CMakeLists.txt
@@ -234,7 +234,6 @@ if (NOT ONLY_SHARED_LIBS)
       ${MOD_BUILD_DIR}/h5lt_const.mod
       ${MOD_BUILD_DIR}/h5im.mod
   )
-
   install (
       FILES
           ${mod_files}
@@ -243,6 +242,16 @@ if (NOT ONLY_SHARED_LIBS)
       COMPONENT
           fortheaders
   )
+  if (HDF5_INSTALL_MOD_FORTRAN MATCHES "STATIC")
+    install (
+        FILES
+            ${mod_files}
+        DESTINATION
+            ${HDF5_INSTALL_INCLUDE_DIR}
+        COMPONENT
+            fortheaders
+    )
+  endif ()
 endif ()
 if (BUILD_SHARED_LIBS)
   set (modsh_files
@@ -261,6 +270,16 @@ if (BUILD_SHARED_LIBS)
       COMPONENT
           fortheaders
   )
+  if (HDF5_INSTALL_MOD_FORTRAN MATCHES "SHARED")
+    install (
+        FILES
+            ${modsh_files}
+        DESTINATION
+            ${HDF5_INSTALL_INCLUDE_DIR}
+        COMPONENT
+            fortheaders
+    )
+  endif ()
 endif ()
 
 #-----------------------------------------------------------------------------
diff --git a/release_docs/INSTALL_CMake.txt b/release_docs/INSTALL_CMake.txt
index 5442f6c30cb..89cd9f8730f 100644
--- a/release_docs/INSTALL_CMake.txt
+++ b/release_docs/INSTALL_CMake.txt
@@ -624,6 +624,7 @@ The config/cmake/cacheinit.cmake file can override the following values.
 
 ---------------- General Build Options ---------------------
 BUILD_SHARED_LIBS  "Build Shared Libraries"    ON
+BUILD_STATIC_LIBS  "Build Static Libraries"    ON
 BUILD_STATIC_EXECS "Build Static Executables"  OFF
 BUILD_TESTING      "Build HDF5 Unit Testing"   ON
 
@@ -636,6 +637,7 @@ HDF5_BUILD_HL_LIB   "Build HIGH Level HDF5 Library"  ON
 HDF5_BUILD_TOOLS    "Build HDF5 Tools"               ON
 
 ---------------- HDF5 Advanced Options ---------------------
+ONLY_SHARED_LIBS               "Only Build Shared Libraries"                                  OFF
 ALLOW_UNSUPPORTED              "Allow unsupported combinations of configure options"          OFF
 HDF5_EXTERNAL_LIB_PREFIX       "Use prefix for custom library naming."                        ""
 HDF5_DISABLE_COMPILER_WARNINGS "Disable compiler warnings"                                    OFF
@@ -676,6 +678,12 @@ if (CMAKE_BUILD_TYPE MATCHES Debug)
     HDF5_ENABLE_INSTRUMENT     "Instrument The library"                      OFF
 if (HDF5_TEST_VFD)
     HDF5_TEST_FHEAP_VFD        "Execute fheap test with different VFDs"      ON
+if (HDF5_BUILD_FORTRAN)
+    HDF5_INSTALL_MOD_FORTRAN "Copy FORTRAN mod files to include directory (NO SHARED STATIC)" "XX"
+    if (BUILD_SHARED_LIBS AND BUILD_STATIC_LIBS) default HDF5_INSTALL_MOD_FORTRAN is SHARED
+    if (BUILD_SHARED_LIBS AND NOT BUILD_STATIC_LIBS) default HDF5_INSTALL_MOD_FORTRAN is SHARED
+    if (NOT BUILD_SHARED_LIBS AND BUILD_STATIC_LIBS) default HDF5_INSTALL_MOD_FORTRAN is STATIC
+    if (NOT BUILD_SHARED_LIBS AND NOT BUILD_STATIC_LIBS) default HDF5_INSTALL_MOD_FORTRAN is SHARED
 
 ---------------- External Library Options ---------------------
 HDF5_ALLOW_EXTERNAL_SUPPORT "Allow External Library Building (NO GIT TGZ)"        "NO"
diff --git a/release_docs/RELEASE.txt b/release_docs/RELEASE.txt
index 665a156152e..56e55692fc8 100644
--- a/release_docs/RELEASE.txt
+++ b/release_docs/RELEASE.txt
@@ -48,6 +48,31 @@ New Features
 
     Configuration:
     -------------
+    - CMake option to link the generated Fortran MOD files into the include
+      directory.
+
+      The Fortran generation of MOD files by a Fortran compile can produce
+      different binary files between SHARED and STATIC compiles with different
+      compilers and/or different platforms. Note that it has been found that
+      different versions of Fortran compilers will produce incompatible MOD
+      files. Currently, CMake will locate these MOD files in subfolders of
+      the include directory and add that path to the Fortran library target
+      in the CMake config file, which can be used by the CMake find library
+      process. For other build systems using the binary from a CMake install,
+      a new CMake configuration can be used to copy the pre-chosen version
+      of the Fortran MOD files into the install include directory.
+
+      The default will depend on the configuration of
+      BUILD_STATIC_LIBS and BUILD_SHARED_LIBS:
+            YES                   YES         Default to SHARED
+            YES                   NO          Default to STATIC
+            NO                    YES         Default to SHARED
+            NO                    NO          Default to SHARED
+      The defaults can be overriden by setting the config option
+         HDF5_INSTALL_MOD_FORTRAN to one of NO, SHARED, or STATIC
+
+      (ADB - 2020/07/9, HDFFV-11116)
+
     - CMake option to use AEC (open source SZip) library instead of SZip
 
       The open source AEC library is a replacement library for SZip. In
@@ -1015,9 +1040,9 @@ Bug Fixes since HDF5-1.10.3 release
     -------
     - Stopped java/test/junit.sh.in installing libs for testing under ${prefix}
 
-      Lib files needed are now copied to a subdirectory in the java/test 
-      directory, and on Macs the loader path for libhdf5.xxxs.so is changed 
-      in the temporary copy of libhdf5_java.dylib. 
+      Lib files needed are now copied to a subdirectory in the java/test
+      directory, and on Macs the loader path for libhdf5.xxxs.so is changed
+      in the temporary copy of libhdf5_java.dylib.
 
       (LRK, 2020/7/2, HDFFV-11063)
 

From 0f3fd8d53d9af7e024668c1cfae0780cb9f424dd Mon Sep 17 00:00:00 2001
From: Larry Knox <lrknox@hdfgroup.org>
Date: Fri, 10 Jul 2020 13:39:59 -0500
Subject: [PATCH 26/55] Remove path to szip header file from AM_CPPFLAGS when
 configure check of libsz fails. Fix for HDFFV-10830.

---
 configure.ac | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/configure.ac b/configure.ac
index d7e3cb5da9f..fb50f94ac8d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1604,7 +1604,10 @@ case "X-$withval" in
 
     if test "x$HAVE_SZLIB" = "xyes" -a "x$HAVE_SZLIB_H" = "xyes"; then
       AC_CHECK_LIB([sz], [SZ_BufftoBuffCompress],,
-                   [LDFLAGS="$saved_LDFLAGS"; AM_LDFLAGS="$saved_AM_LDFLAGS"; unset HAVE_SZLIB])
+                   [CPPFLAGS="$saved_CPPFLAGS"; AM_CPPFLAGS="$saved_AM_CPPFLAGS"; LDFLAGS="$saved_LDFLAGS"; AM_LDFLAGS="$saved_AM_LDFLAGS"; unset HAVE_SZLIB])
+      if test -z "$HAVE_SZLIB"; then
+        AC_MSG_RESULT([Using SZ_BufftoBuffCompress from libsz in $szlib_lib failed.  Szip not enabled.])
+      fi
     fi
 
     if test -z "$HAVE_SZLIB" -a -n "$HDF5_CONFIG_ABORT"; then

From 4305d9677b4bf4c7e21999a32dbd532250b79abd Mon Sep 17 00:00:00 2001
From: Dana Robinson <derobins@hdfgroup.org>
Date: Tue, 14 Jul 2020 05:01:22 -0700
Subject: [PATCH 27/55] Fallback to older time functions in new timer code.

---
 src/H5timer.c | 31 ++++++++-----------------------
 1 file changed, 8 insertions(+), 23 deletions(-)

diff --git a/src/H5timer.c b/src/H5timer.c
index 8f3d30583fc..cef7bf99503 100644
--- a/src/H5timer.c
+++ b/src/H5timer.c
@@ -220,7 +220,8 @@ H5_now_usec(void)
  *
  * Purpose:     Get the current time, as the time of seconds after the UNIX epoch
  *
- * Return:      SUCCEED/FAIL
+ * Return:      Success:    A non-negative time value
+ *              Failure:    -1.0 (in theory, can't currently fail)
  *
  * Programmer:  Quincey Koziol
  *              October 05, 2016
@@ -247,9 +248,9 @@ H5_get_time(void)
         HDgettimeofday(&now_tv, NULL);
         ret_value = (double)now_tv.tv_sec + ((double)now_tv.tv_usec / (double)1000000.0f);
     }
-#else /* H5_HAVE_GETTIMEOFDAY */
+#else
     ret_value = (double)HDtime(NULL);
-#endif /* H5_HAVE_GETTIMEOFDAY */
+#endif
 
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5_get_time() */
@@ -279,9 +280,9 @@ H5__timer_get_timevals(H5_timevals_t *times /*in,out*/)
     /* Windows call handles both system/user and elapsed times */
 #ifdef H5_HAVE_WIN32_API
     if(H5_get_win32_times(times) < 0) {
-        times->elapsed   = -1;
-        times->system    = -1;
-        times->user      = -1;
+        times->elapsed   = -1.0;
+        times->system    = -1.0;
+        times->user      = -1.0;
 
         return -1;
     } /* end if */
@@ -310,24 +311,8 @@ H5__timer_get_timevals(H5_timevals_t *times /*in,out*/)
      * Elapsed time *
      ****************/
 
-    /* NOTE: Not having a way to get elapsed time IS an error, unlike
-     * the system and user times.
-     */
+    times->elapsed = H5_get_time();
 
-#if defined(H5_HAVE_CLOCK_GETTIME)
-{
-    struct timespec ts;
-
-    if(HDclock_gettime(CLOCK_MONOTONIC, &ts) != 0)
-        return -1;
-    times->elapsed = (double)ts.tv_sec + ((double)ts.tv_nsec / (double)1.0E9F);
-}
-#else
-    /* Die here.  We'd like to know about this so we can support some
-     * other time functionality.
-     */
-    HDassert(0);
-#endif
 #endif /* H5_HAVE_WIN32_API */
 
     return 0;

From b8013380792a3503003f0a2bd60d7541656b03c7 Mon Sep 17 00:00:00 2001
From: Dana Robinson <derobins@hdfgroup.org>
Date: Tue, 14 Jul 2020 07:49:00 -0500
Subject: [PATCH 28/55] Removed POSIX #defines from configure on Solaris.

---
 configure.ac | 6 ------
 1 file changed, 6 deletions(-)

diff --git a/configure.ac b/configure.ac
index 670b0eb6317..f79e9e648a2 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1250,12 +1250,6 @@ case "$host_cpu-$host_vendor-$host_os" in
     H5_CPPFLAGS="-D_GNU_SOURCE $H5_CPPFLAGS"
     ;;
 
-  *solaris*)
-    ## Solaris also needs _POSIX_C_SOURCE set correctly to pick up
-    ## clock_gettime().
-    H5_CPPFLAGS="-D_POSIX_C_SOURCE=200112L $H5_CPPFLAGS"
-    H5_CPPFLAGS="-D_GNU_SOURCE $H5_CPPFLAGS"
-    ;;
 esac
 
 ## Need to add the AM_ and H5_ into CFLAGS/CPPFLAGS to make them visible

From 4bc49d8b2bb6b549141a47f50062eb4ddfba4557 Mon Sep 17 00:00:00 2001
From: vchoi <vchoi@jelly.ad.hdfgroup.org>
Date: Tue, 14 Jul 2020 10:56:33 -0500
Subject: [PATCH 29/55] Fix for jira issue HDFFV-11080: (1) Patch up the file
 pointer when reading attribute of variable length datatype (2) Test to verify
 the fix when doing multiple threads

---
 release_docs/RELEASE.txt |  14 ++++
 src/H5Aint.c             |   4 +
 test/Makefile.am         |   2 +-
 test/ttsafe.c            |   1 +
 test/ttsafe.h            |   2 +
 test/ttsafe_attr_vlen.c  | 176 +++++++++++++++++++++++++++++++++++++++
 6 files changed, 198 insertions(+), 1 deletion(-)
 create mode 100644 test/ttsafe_attr_vlen.c

diff --git a/release_docs/RELEASE.txt b/release_docs/RELEASE.txt
index 56e55692fc8..84f339a28f5 100644
--- a/release_docs/RELEASE.txt
+++ b/release_docs/RELEASE.txt
@@ -656,6 +656,20 @@ Bug Fixes since HDF5-1.10.3 release
 
     Library
     -------
+    - Fixed the segmentation fault when reading attributes with multiple threads
+
+      It was reported that the reading of attributes with variable length string
+      datatype will crash with segmentation fault particularly when the number of 
+      threads is high (>16 threads).  The problem was due to the file pointer that
+      was set in the variable length string datatype for the attribute.  That file
+      pointer was already closed when the attribute was accessed.
+
+      The problem was fixed by setting the file pointer to the current opened file pointer
+      when the attribute was accessed.  Similar patch up was done before when reading
+      dataset with variable length string datatype.
+
+      (VC - 2020/07/13, HDFFV-11080)
+
     - Fixed CVE-2020-10810
 
       The tool h5clear produced a segfault during an error recovery in
diff --git a/src/H5Aint.c b/src/H5Aint.c
index 1a74abe69da..cd0ab80936d 100644
--- a/src/H5Aint.c
+++ b/src/H5Aint.c
@@ -616,6 +616,10 @@ H5A__read(const H5A_t *attr, const H5T_t *mem_type, void *buf)
     HDassert(mem_type);
     HDassert(buf);
 
+     /* Patch the top level file pointer in attr->shared->dt->shared->u.vlen.f if needed */
+    if(H5T_patch_vlen_file(attr->shared->dt, H5F_VOL_OBJ(attr->oloc.file)) < 0 )
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTOPENOBJ, FAIL, "can't patch VL datatype file pointer")
+
     /* Create buffer for data to store on disk */
     if((snelmts = H5S_GET_EXTENT_NPOINTS(attr->shared->ds)) < 0)
         HGOTO_ERROR(H5E_ATTR, H5E_CANTCOUNT, FAIL, "dataspace is invalid")
diff --git a/test/Makefile.am b/test/Makefile.am
index e6ce9541786..7ebeae7b8b7 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -146,7 +146,7 @@ LDADD=libh5test.la $(LIBHDF5)
 
 # List the source files for tests that have more than one
 ttsafe_SOURCES=ttsafe.c ttsafe_dcreate.c ttsafe_error.c ttsafe_cancel.c       \
-               ttsafe_acreate.c
+               ttsafe_acreate.c ttsafe_attr_vlen.c
 cache_image_SOURCES=cache_image.c genall5.c
 mirror_vfd_SOURCES=mirror_vfd.c genall5.c
 
diff --git a/test/ttsafe.c b/test/ttsafe.c
index e6edd9a024d..2de460be4dc 100644
--- a/test/ttsafe.c
+++ b/test/ttsafe.c
@@ -111,6 +111,7 @@ int main(int argc, char *argv[])
     AddTest("cancel", tts_cancel, cleanup_cancel, "thread cancellation safety test", NULL);
 #endif /* H5_HAVE_PTHREAD_H */
     AddTest("acreate", tts_acreate, cleanup_acreate, "multi-attribute creation", NULL);
+    AddTest("attr_vlen", tts_attr_vlen, cleanup_attr_vlen, "multi-file-attribute-vlen read", NULL);
 
 #else /* H5_HAVE_THREADSAFE */
 
diff --git a/test/ttsafe.h b/test/ttsafe.h
index c29fadc5b88..f1cbe4dd9f0 100644
--- a/test/ttsafe.h
+++ b/test/ttsafe.h
@@ -35,12 +35,14 @@ void                    tts_dcreate(void);
 void                    tts_error(void);
 void                    tts_cancel(void);
 void                    tts_acreate(void);
+void                    tts_attr_vlen(void);
 
 /* Prototypes for the cleanup routines */
 void                    cleanup_dcreate(void);
 void                    cleanup_error(void);
 void                    cleanup_cancel(void);
 void                    cleanup_acreate(void);
+void                    cleanup_attr_vlen(void);
 
 #endif /* H5_HAVE_THREADSAFE */
 #endif /* TTSAFE_H */
diff --git a/test/ttsafe_attr_vlen.c b/test/ttsafe_attr_vlen.c
new file mode 100644
index 00000000000..b07e36268fb
--- /dev/null
+++ b/test/ttsafe_attr_vlen.c
@@ -0,0 +1,176 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/********************************************************************
+ *
+ * Testing for thread safety in H5A library operations.
+ * ------------------------------------------------------------------
+ *
+ * Purpose: Verify that the segmentation fault described in HDFFV-11080 
+ *          is fixed.
+ *
+ *          This test simulates what the user did to trigger the error:
+ *          --Create an HDF5 file
+ *          --Create an attribute with variable length string datatype
+ *          --Attach the attribute to a group
+ *          --Write data to the attribute
+ *          --Close the file
+ *          --Create NUM_THREADS threads
+ *          --For each thread:
+ *              --Open the test file
+ *              --Open and read the attribute for each opened file
+ *
+ *          The cause of the problem in this jira issue is due to the file pointer 
+ *          that is set in the variable length string datatype for the attribute.  
+ *          That file pointer is already closed and therefore needs to be set to 
+ *          the current opened file pointer when the attribute is accessed.
+ *          Similar patch up was done before when reading dataset in H5D__read()
+ *          in src/H5Aint.c.
+ *          Hopefully this kind of patch can go away when we resolve the 
+ *          shared file pointer issue.
+ *
+ ********************************************************************/
+
+#include "ttsafe.h"
+
+#ifdef H5_HAVE_THREADSAFE
+
+#define FILENAME	"ttsafe_attr_vlen.h5"
+#define ATTR_NAME   "root_attr"
+#define NUM_THREADS	32
+
+void *tts_attr_vlen_thread(void *);
+
+void
+tts_attr_vlen(void)
+{
+    pthread_t threads[NUM_THREADS] = {0};   /* Thread declaration */
+    hid_t fid = H5I_INVALID_HID;            /* File ID */
+    hid_t gid = H5I_INVALID_HID;            /* Group ID */ 
+    hid_t atid = H5I_INVALID_HID;           /* Datatype ID for attribute */
+    hid_t asid = H5I_INVALID_HID;           /* Dataspace ID for attribute */
+    hid_t aid = H5I_INVALID_HID;            /* The attribute ID */
+    char *string_attr = "2.0";              /* The attribute data */
+    int ret;                                /* Return value */
+    int i;                                  /* Local index variable */
+
+    /* Create the HDF5 test file */
+    fid = H5Fcreate(FILENAME, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
+    CHECK(fid, H5I_INVALID_HID, "H5Fcreate");
+
+    /* Create variable length string type for attribute */
+    atid = H5Tcopy(H5T_C_S1);
+    CHECK(atid, H5I_INVALID_HID, "H5Tcopy");
+    H5Tset_size(atid, H5T_VARIABLE);
+
+    /* Create dataspace for attribute */
+    asid = H5Screate(H5S_SCALAR);
+    CHECK(asid, H5I_INVALID_HID, "H5Screate");
+
+    /* Open the root group */
+    gid = H5Gopen2(fid, "/", H5P_DEFAULT);
+    CHECK(gid, H5I_INVALID_HID, "H5Gopen2");
+
+    /* Attach the attribute to the root group */
+    aid = H5Acreate2(gid, ATTR_NAME, atid, asid, H5P_DEFAULT, H5P_DEFAULT);
+    CHECK(aid, H5I_INVALID_HID, "H5Acreate2");
+
+    /* Write data to the attribute */
+    ret = H5Awrite(aid, atid, &string_attr);
+    CHECK(ret, H5I_INVALID_HID, "H5Awrite");
+
+    /* Close IDs */
+    ret = H5Sclose(asid);
+    CHECK(ret, H5I_INVALID_HID, "H5Sclose");
+
+    ret = H5Aclose(aid);
+    CHECK(ret, H5I_INVALID_HID, "H5Aclose");
+
+    ret = H5Gclose(gid);
+    CHECK(ret, H5I_INVALID_HID, "H5Gclose");
+
+    ret = H5Fclose(fid);
+    CHECK(ret, H5I_INVALID_HID, "H5Fclose");
+
+    ret = H5Tclose(atid);
+    CHECK(ret, H5I_INVALID_HID, "H5Tclose");
+
+    /* Start multiple threads and execute tts_attr_vlen_thread() for each thread */
+    for(i = 0; i < NUM_THREADS; i++)
+        pthread_create(&threads[i], NULL, tts_attr_vlen_thread, NULL);
+
+    /* Wait for the threads to end */
+    for(i = 0; i < NUM_THREADS; i++)
+        pthread_join(threads[i], NULL);
+
+} /* end tts_attr_vlen() */
+
+/* Start execution for each thread */
+void *
+tts_attr_vlen_thread(void *client_data)
+{
+    hid_t fid = H5I_INVALID_HID;    /* File ID */
+    hid_t gid = H5I_INVALID_HID;    /* Group ID */
+    hid_t aid = H5I_INVALID_HID;    /* Attribute ID */
+    hid_t atid = H5I_INVALID_HID;   /* Datatype ID for the attribute */
+    char *string_attr_check;        /* The attribute data being read */
+    char *string_attr = "2.0";      /* The expected attribute data */
+    herr_t  ret;                    /* Return value */
+
+    /* Open the test file */
+    fid = H5Fopen(FILENAME, H5F_ACC_RDONLY, H5P_DEFAULT);
+    CHECK(fid, H5I_INVALID_HID, "H5Fopen");
+
+    /* Open the group */
+    gid = H5Gopen2(fid, "/", H5P_DEFAULT);
+    CHECK(gid, H5I_INVALID_HID, "H5Gopen");
+
+    /* Open the attribte */
+    aid = H5Aopen(gid, "root_attr", H5P_DEFAULT);
+    CHECK(aid, H5I_INVALID_HID, "H5Aopen");
+
+    /* Get the attribute datatype */
+    atid = H5Aget_type(aid);
+    CHECK(atid, H5I_INVALID_HID, "H5Aget_type");
+
+    /* Read the attribute */
+    ret = H5Aread(aid, atid, &string_attr_check);
+    CHECK(ret, FAIL, "H5Aclose");
+    
+    /* Verify the attribute data is as expected */
+    VERIFY_STR(string_attr_check, string_attr, "H5Aread");
+  
+    /* Close IDs */
+    ret = H5Aclose(aid);
+    CHECK(ret, FAIL, "H5Aclose");
+
+    ret = H5Gclose(gid);
+    CHECK(ret, FAIL, "H5Aclose");
+
+    ret = H5Fclose(fid);
+    CHECK(ret, FAIL, "H5Aclose");
+
+    ret = H5Tclose(atid);
+    CHECK(ret, FAIL, "H5Aclose");
+
+    return NULL;
+} /* end tts_attr_vlen_thread() */
+
+void
+cleanup_attr_vlen(void)
+{
+    HDunlink(FILENAME);
+}
+
+#endif /*H5_HAVE_THREADSAFE*/
+

From bac0fc6309aaf777d4b6d093cf027dce3ecfb58c Mon Sep 17 00:00:00 2001
From: Allen Byrne <byrn@hdfgroup.org>
Date: Wed, 15 Jul 2020 11:20:16 -0500
Subject: [PATCH 30/55] Tools refactor

Move error_stack setup to tools library
Add structure for h5dump properties
Eliminate duplicated h5diff functions
Use properties structure in place of argument lists.
---
 MANIFEST                                      |    3 +
 config/cmake/HDF5UseFortran.cmake             |    2 +-
 config/cmake_ext_mod/ConfigureChecks.cmake    |    1 -
 hl/tools/gif2h5/hdf2gif.c                     |   61 +-
 hl/tools/h5watch/h5watch.c                    |   76 +-
 tools/lib/h5diff.c                            |  179 +-
 tools/lib/h5diff.h                            |  176 +-
 tools/lib/h5diff_array.c                      | 4456 ++++++-----------
 tools/lib/h5diff_attr.c                       |  164 +-
 tools/lib/h5diff_dset.c                       |  672 ++-
 tools/lib/h5tools.c                           |  140 +-
 tools/lib/h5tools.h                           |   67 +-
 tools/lib/h5tools_dump.c                      |  525 +-
 tools/lib/h5tools_dump.h                      |   80 +-
 tools/lib/h5tools_str.c                       |   74 +-
 tools/lib/h5tools_str.h                       |    5 +-
 tools/lib/io_timer.c                          |    1 -
 tools/src/h5copy/h5copy.c                     |   18 +-
 tools/src/h5diff/h5diff_common.c              |  342 +-
 tools/src/h5diff/h5diff_main.c                |   36 +-
 tools/src/h5dump/h5dump.c                     |  101 +-
 tools/src/h5dump/h5dump.h                     |   39 +-
 tools/src/h5dump/h5dump_ddl.c                 |   70 +-
 tools/src/h5dump/h5dump_extern.h              |   43 +-
 tools/src/h5dump/h5dump_xml.c                 |   30 +-
 tools/src/h5format_convert/h5format_convert.c |  178 +-
 tools/src/h5jam/h5jam.c                       |   82 +-
 tools/src/h5jam/h5unjam.c                     |   20 +-
 tools/src/h5ls/h5ls.c                         |  273 +-
 tools/src/h5repack/h5repack_main.c            |   18 +-
 tools/src/h5stat/h5stat.c                     |   22 +-
 tools/src/misc/h5clear.c                      |    9 +-
 tools/src/misc/h5mkgrp.c                      |   14 +-
 tools/test/h5diff/CMakeTests.cmake            |   19 +-
 tools/test/h5diff/h5diffgentest.c             |  113 +-
 tools/test/h5diff/testfiles/diff_eps1.h5      |  Bin 0 -> 2272 bytes
 tools/test/h5diff/testfiles/diff_eps2.h5      |  Bin 0 -> 2272 bytes
 tools/test/h5diff/testfiles/h5diff_10.txt     |   15 +-
 tools/test/h5diff/testfiles/h5diff_58_ref.txt |   12 +-
 tools/test/h5diff/testfiles/h5diff_600.txt    |   15 +-
 tools/test/h5diff/testfiles/h5diff_603.txt    |   15 +-
 tools/test/h5diff/testfiles/h5diff_606.txt    |   15 +-
 tools/test/h5diff/testfiles/h5diff_612.txt    |   15 +-
 tools/test/h5diff/testfiles/h5diff_615.txt    |   15 +-
 tools/test/h5diff/testfiles/h5diff_621.txt    |   15 +-
 tools/test/h5diff/testfiles/h5diff_622.txt    |   15 +-
 tools/test/h5diff/testfiles/h5diff_623.txt    |   15 +-
 tools/test/h5diff/testfiles/h5diff_624.txt    |   15 +-
 tools/test/h5diff/testfiles/h5diff_70.txt     |   32 +
 tools/test/h5diff/testfiles/h5diff_700.txt    |   32 +
 tools/test/h5diff/testfiles/h5diff_701.txt    |   32 +
 tools/test/h5diff/testfiles/h5diff_702.txt    |   32 +
 tools/test/h5diff/testfiles/h5diff_703.txt    |   32 +
 tools/test/h5diff/testfiles/h5diff_80.txt     |   64 +-
 tools/test/h5diff/testfiles/h5diff_eps.txt    |   17 +
 tools/test/h5diff/testfiles/h5diff_reg.txt    |    9 +-
 tools/test/h5diff/testh5diff.sh.in            |   15 +
 tools/test/h5jam/tellub.c                     |   40 +-
 tools/testfiles/trefer_attrR.ddl              |    6 +-
 tools/testfiles/trefer_extR.ddl               |    6 +-
 60 files changed, 3911 insertions(+), 4677 deletions(-)
 create mode 100644 tools/test/h5diff/testfiles/diff_eps1.h5
 create mode 100644 tools/test/h5diff/testfiles/diff_eps2.h5
 create mode 100644 tools/test/h5diff/testfiles/h5diff_eps.txt

diff --git a/MANIFEST b/MANIFEST
index a20b24822a7..d3e74bbd9f7 100644
--- a/MANIFEST
+++ b/MANIFEST
@@ -2399,6 +2399,8 @@
 
 
 #test files for h5diff
+./tools/test/h5diff/testfiles/diff_eps1.txt
+./tools/test/h5diff/testfiles/diff_eps2.txt
 ./tools/test/h5diff/testfiles/h5diff_10.txt
 ./tools/test/h5diff/testfiles/h5diff_11.txt
 ./tools/test/h5diff/testfiles/h5diff_12.txt
@@ -2634,6 +2636,7 @@
 ./tools/test/h5diff/testfiles/h5diff_dset_zero_dim_size1.h5
 ./tools/test/h5diff/testfiles/h5diff_dset_zero_dim_size2.h5
 ./tools/test/h5diff/testfiles/h5diff_enum_invalid_values.h5
+./tools/test/h5diff/testfiles/h5diff_eps.txt
 ./tools/test/h5diff/testfiles/compounds_array_vlen1.h5
 ./tools/test/h5diff/testfiles/compounds_array_vlen2.h5
 ./tools/test/h5diff/testfiles/non_comparables1.h5
diff --git a/config/cmake/HDF5UseFortran.cmake b/config/cmake/HDF5UseFortran.cmake
index c5d8200a99a..4350b7afa2d 100644
--- a/config/cmake/HDF5UseFortran.cmake
+++ b/config/cmake/HDF5UseFortran.cmake
@@ -435,7 +435,7 @@ set (${HDF_PREFIX}_H5CONFIG_F_RKIND_SIZEOF "INTEGER, DIMENSION(1:num_rkinds) ::
 ENABLE_LANGUAGE (C)
 
 if (NOT CMAKE_VERSION VERSION_LESS "3.14.0")
-include (CheckCSourceRuns)
+  include (CheckCSourceRuns)
 else ()
 #-----------------------------------------------------------------------------
 # The provided CMake C macros don't provide a general compile/run function
diff --git a/config/cmake_ext_mod/ConfigureChecks.cmake b/config/cmake_ext_mod/ConfigureChecks.cmake
index 6f5a8354e76..0ddb6d08822 100644
--- a/config/cmake_ext_mod/ConfigureChecks.cmake
+++ b/config/cmake_ext_mod/ConfigureChecks.cmake
@@ -679,4 +679,3 @@ endif ()
 # the cache value is set in it's config file)
 #
 set (${HDF_PREFIX}_CONVERT_DENORMAL_FLOAT 1)
-
diff --git a/hl/tools/gif2h5/hdf2gif.c b/hl/tools/gif2h5/hdf2gif.c
index 0e2a8984087..1833c9233d6 100644
--- a/hl/tools/gif2h5/hdf2gif.c
+++ b/hl/tools/gif2h5/hdf2gif.c
@@ -18,8 +18,11 @@
 #include "h5tools.h"
 #include "h5tools_utils.h"
 
-#define IMAGE_WIDTH_MAX		65535	/* unsigned 16bits integer */
-#define IMAGE_HEIGHT_MAX	65535	/* unsigned 16bits integer */
+/* Name of tool */
+#define PROGRAMNAME "hdf2gif"
+
+#define IMAGE_WIDTH_MAX        65535    /* unsigned 16bits integer */
+#define IMAGE_HEIGHT_MAX       65535    /* unsigned 16bits integer */
 
 
 int EndianOrder;
@@ -42,12 +45,17 @@ usage(void)
 
 }
 
+static void
+leave(int ret)
+{
+   h5tools_close();
+   HDexit(ret);
+}
+
 FILE *fpGif = NULL;
 int main(int argc , char **argv)
 {
     GIFBYTE *Image;
-    void *edata;
-    H5E_auto2_t func;
 
     /* compression structs */
     GIFCHAR *HDFName = NULL;
@@ -73,9 +81,8 @@ int main(int argc , char **argv)
     char *image_name = NULL;
     int idx;
 
-    /* Disable error reporting */
-    H5Eget_auto2(H5E_DEFAULT, &func, &edata);
-    H5Eset_auto2(H5E_DEFAULT, NULL, NULL);
+    h5tools_setprogname(PROGRAMNAME);
+    h5tools_setstatus(EXIT_SUCCESS);
 
     /* Initialize h5tools lib */
     h5tools_init();
@@ -83,8 +90,7 @@ int main(int argc , char **argv)
     if ( argv[1] && (strcmp("-V",argv[1])==0) )
     {
         print_version("gif2h5");
-        exit(EXIT_SUCCESS);
-
+        h5tools_setstatus(EXIT_SUCCESS);
     }
 
 
@@ -92,7 +98,7 @@ int main(int argc , char **argv)
     {
         /* they didn't supply at least one image -- bail */
         usage();
-        return EXIT_FAILURE;
+        h5tools_setstatus(EXIT_FAILURE);
     }
 
     HDFName = argv[1];
@@ -156,18 +162,18 @@ int main(int argc , char **argv)
             goto out;
         }
 
-    	if (width > IMAGE_WIDTH_MAX || height > IMAGE_HEIGHT_MAX)
+        if (width > IMAGE_WIDTH_MAX || height > IMAGE_HEIGHT_MAX)
         {
-	        fprintf(stderr, "HDF5 image is too large. Limit is %d by %d.\n", IMAGE_WIDTH_MAX, IMAGE_HEIGHT_MAX);
-	        goto out;
-	    }
+            fprintf(stderr, "HDF5 image is too large. Limit is %d by %d.\n", IMAGE_WIDTH_MAX, IMAGE_HEIGHT_MAX);
+            goto out;
+        }
 
-	    /* tool can handle single plane images only. */
-	    if (planes > 1)
+        /* tool can handle single plane images only. */
+        if (planes > 1)
         {
-	        fprintf(stderr, "Cannot handle multiple planes image\n");
-	        goto out;
-	    }
+            fprintf(stderr, "Cannot handle multiple planes image\n");
+            goto out;
+        }
 
         Image = (GIFBYTE*) malloc( (size_t) width * (size_t) height );
 
@@ -222,9 +228,9 @@ int main(int argc , char **argv)
             numcols = 256;
             for (i = 0 ; i < numcols ; i++)
             {
-	      Red[i] = (GIFBYTE)(255 - i);
-	      Green[i] = (GIFBYTE)(255 - i);
-	      Blue[i] = (GIFBYTE)(255 - i);
+                Red[i] = (GIFBYTE)(255 - i);
+                Green[i] = (GIFBYTE)(255 - i);
+                Blue[i] = (GIFBYTE)(255 - i);
             }
         }
         else
@@ -257,7 +263,7 @@ int main(int argc , char **argv)
             if (j==i)
             {
                 /* wasn't found */
-	            pc2nc[i] = (GIFBYTE)nc;
+                pc2nc[i] = (GIFBYTE)nc;
                 r1[nc] = Red[i];
                 g1[nc] = Green[i];
                 b1[nc] = Blue[i];
@@ -345,9 +351,7 @@ int main(int argc , char **argv)
     if (image_name != NULL)
         free(image_name);
 
-    H5Eset_auto2(H5E_DEFAULT, func, edata);
-
-    return EXIT_SUCCESS;
+    leave(h5tools_getstatus());
 
 
 out:
@@ -357,7 +361,6 @@ int main(int argc , char **argv)
     if (image_name != NULL)
         free(image_name);
 
-    H5Eset_auto2(H5E_DEFAULT, func, edata);
-
-    return EXIT_FAILURE;
+    h5tools_setstatus(EXIT_FAILURE);
+    leave(h5tools_getstatus());
 }
diff --git a/hl/tools/h5watch/h5watch.c b/hl/tools/h5watch/h5watch.c
index ff9a0783b9b..a05c63bdc24 100644
--- a/hl/tools/h5watch/h5watch.c
+++ b/hl/tools/h5watch/h5watch.c
@@ -821,10 +821,6 @@ main(int argc, const char *argv[])
     char        drivername[50];     /* VFD name */
     char        *fname = NULL;      /* File name */
     char        *dname = NULL;      /* Dataset name */
-    void        *edata;             /* Error reporting */
-    void        *tools_edata;       /* Error reporting */
-    H5E_auto2_t func;               /* Error reporting */
-    H5E_auto2_t tools_func;         /* Error reporting */
     char        *x;                 /* Temporary string pointer */
     hid_t       fid = -1;           /* File ID */
     hid_t       fapl = -1;          /* File access property list */
@@ -833,17 +829,9 @@ main(int argc, const char *argv[])
     h5tools_setprogname(PROGRAMNAME);
     h5tools_setstatus(EXIT_SUCCESS);
 
-    /* Disable error reporting */
-    H5Eget_auto2(H5E_DEFAULT, &func, &edata);
-    H5Eset_auto2(H5E_DEFAULT, NULL, NULL);
-
     /* Initialize h5tools lib */
     h5tools_init();
 
-    /* Disable tools error reporting */
-    H5Eget_auto2(H5tools_ERR_STACK_g, &tools_func, &tools_edata);
-    H5Eset_auto2(H5tools_ERR_STACK_g, NULL, NULL);
-
     /* To exit from h5watch for SIGTERM signal */
     if(HDsignal(SIGTERM, catch_signal) == SIG_ERR) {
         error_msg("An error occurred while setting a signal handler.\n");
@@ -865,6 +853,9 @@ main(int argc, const char *argv[])
         leave(EXIT_FAILURE);
     }
 
+    /* enable error reporting if command line option */
+    h5tools_error_report();
+
     /* Mostly copied from tools/h5ls coding & modified accordingly */
     /*
      * [OBJECT] is specified as
@@ -881,18 +872,22 @@ main(int argc, const char *argv[])
      * doesn't exist).
      */
     if((fname = HDstrdup(argv[opt_ind])) == NULL) {
-        error_msg("memory allocation failed (file %s:line %d)\n",
-                   __FILE__, __LINE__);
+        error_msg("memory allocation failed (file %s:line %d)\n", __FILE__, __LINE__);
         h5tools_setstatus(EXIT_FAILURE);
+        goto done;
     }
 
     /* Create a copy of file access property list */
-    if((fapl = H5Pcreate(H5P_FILE_ACCESS)) < 0)
-        return -1;
+    if((fapl = H5Pcreate(H5P_FILE_ACCESS)) < 0) {
+        h5tools_setstatus(EXIT_FAILURE);
+        goto done;
+    }
 
     /* Set to use the latest library format */
-    if(H5Pset_libver_bounds(fapl, H5F_LIBVER_LATEST, H5F_LIBVER_LATEST) < 0)
-        return -1;
+    if(H5Pset_libver_bounds(fapl, H5F_LIBVER_LATEST, H5F_LIBVER_LATEST) < 0) {
+        h5tools_setstatus(EXIT_FAILURE);
+        goto done;
+    }
 
     do {
         while(fname && *fname) {
@@ -917,30 +912,37 @@ main(int argc, const char *argv[])
 
     if(fid < 0) {
         error_msg("unable to open file \"%s\"\n", fname);
-        if(fname) HDfree(fname);
-        if(fapl >= 0) H5Pclose(fapl);
-        leave(EXIT_FAILURE);
+        h5tools_setstatus(EXIT_FAILURE);
+        goto done;
     }
 
     if(!dname) {
         error_msg("no dataset specified\n");
         h5tools_setstatus(EXIT_FAILURE);
-    } else {
+        goto done;
+    }
+    else {
         *dname = '/';
         x = dname;
         if((dname = HDstrdup(dname)) == NULL) {
-            error_msg("memory allocation failed (file %s:line %d)\n",
-                       __FILE__, __LINE__);
+            error_msg("memory allocation failed (file %s:line %d)\n", __FILE__, __LINE__);
             h5tools_setstatus(EXIT_FAILURE);
-        } else {
+            goto done;
+        }
+        else {
             *x = '\0';
             /* Validate dataset */
-            if(check_dataset(fid, dname) < 0)
+            if(check_dataset(fid, dname) < 0) {
                 h5tools_setstatus(EXIT_FAILURE);
+                goto done;
+            }
             /* Validate input "fields" */
-            else if(g_list_of_fields && *g_list_of_fields)
-                if(process_cmpd_fields(fid, dname) < 0)
+            else if(g_list_of_fields && *g_list_of_fields) {
+                if(process_cmpd_fields(fid, dname) < 0) {
                     h5tools_setstatus(EXIT_FAILURE);
+                    goto done;
+                }
+            }
         }
     }
 
@@ -949,15 +951,20 @@ main(int argc, const char *argv[])
         if(monitor_dataset(fid, dname) < 0)
             h5tools_setstatus(EXIT_FAILURE);
 
+done:
     /* Free spaces */
-    if(fname) HDfree(fname);
-    if(dname) HDfree(dname);
-    if(g_list_of_fields) HDfree(g_list_of_fields);
+    if(fname)
+        HDfree(fname);
+    if(dname)
+        HDfree(dname);
+    if(g_list_of_fields)
+        HDfree(g_list_of_fields);
     if(g_listv) {
         H5LD_clean_vector(g_listv);
         HDfree(g_listv);
     }
-    if(g_dup_fields) HDfree(g_dup_fields);
+    if(g_dup_fields)
+        HDfree(g_dup_fields);
 
     /* Close the file access property list */
     if(fapl >= 0 && H5Pclose(fapl) < 0) {
@@ -966,14 +973,11 @@ main(int argc, const char *argv[])
     }
 
     /* Close the file */
-    if(H5Fclose(fid) < 0) {
+    if(fid >= 0 && H5Fclose(fid) < 0) {
         error_msg("unable to close file\n");
         h5tools_setstatus(EXIT_FAILURE);
     }
 
-    H5Eset_auto2(H5E_DEFAULT, func, edata);
-    H5Eset_auto2(H5tools_ERR_STACK_g, tools_func, tools_edata);
-
     /* exit */
     leave(h5tools_getstatus());
 } /* main() */
diff --git a/tools/lib/h5diff.c b/tools/lib/h5diff.c
index 8b6ace903d8..96c2d320200 100644
--- a/tools/lib/h5diff.c
+++ b/tools/lib/h5diff.c
@@ -29,7 +29,7 @@
 H5_ATTR_PURE int
 print_objname (diff_opt_t * opts, hsize_t nfound)
 {
-    return ((opts->m_verbose || nfound) && !opts->m_quiet) ? 1 : 0;
+    return ((opts->mode_verbose || nfound) && !opts->mode_quiet) ? 1 : 0;
 }
 
 /*-------------------------------------------------------------------------
@@ -45,7 +45,7 @@ do_print_objname (const char *OBJ, const char *path1, const char *path2, diff_op
      * displaying any object or symbolic links. This improves
      * readability of the output.
      */
-    if (opts->m_verbose_level >= 1)
+    if (opts->mode_verbose_level >= 1)
         parallel_print("\n");
     parallel_print("%-7s: <%s> and <%s>\n", OBJ, path1, path2);
 }
@@ -74,7 +74,7 @@ do_print_attrname (const char *attr, const char *path1, const char *path2)
 static int
 print_warn(diff_opt_t *opts)
 {
-    return ((opts->m_verbose)) ? 1: 0;
+    return ((opts->mode_verbose)) ? 1: 0;
 }
 
 
@@ -141,7 +141,7 @@ is_valid_options(diff_opt_t *opts)
 
     /*-----------------------------------------------
      * no -q(quiet) with -v (verbose) or -r (report) */
-    if(opts->m_quiet && (opts->m_verbose || opts->m_report)) {
+    if(opts->mode_quiet && (opts->mode_verbose || opts->mode_report)) {
         parallel_print("Error: -q (quiet mode) cannot be added to verbose or report modes\n");
         opts->err_stat = H5DIFF_ERR;
         H5TOOLS_GOTO_DONE(0);
@@ -169,9 +169,9 @@ is_valid_options(diff_opt_t *opts)
  *           0 - not excluded path
  *------------------------------------------------------------------------*/
 static int
-is_exclude_path (char * path, h5trav_type_t type, diff_opt_t *opts)
+is_exclude_path (char *path, h5trav_type_t type, diff_opt_t *opts)
 {
-    struct exclude_path_list * exclude_path_ptr;
+    struct exclude_path_list *exclude_path_ptr;
     int   ret_cmp;
     int   ret_value = 0;
 
@@ -210,7 +210,7 @@ is_exclude_path (char * path, h5trav_type_t type, diff_opt_t *opts)
             if (ret_cmp == 0) {  /* found matching object */
                 /* excluded non-group object */
                 ret_value = 1;
-                /* remember the type of this maching object.
+                /* remember the type of this matching object.
                  * if it's group, it can be used for excluding its member
                  * objects in this while() loop */
                 exclude_path_ptr->obj_type = type;
@@ -224,6 +224,71 @@ is_exclude_path (char * path, h5trav_type_t type, diff_opt_t *opts)
     return  ret_value;
 }
 
+/*-------------------------------------------------------------------------
+ * Function: is_exclude_attr
+ *
+ * Purpose:  check if 'paths' are part of exclude path list
+ *
+ * Return:
+ *           1 - excluded path
+ *           0 - not excluded path
+ *------------------------------------------------------------------------*/
+static int
+is_exclude_attr (char *path, h5trav_type_t type, diff_opt_t *opts)
+{
+    struct exclude_path_list *exclude_ptr;
+    int   ret_cmp;
+    int   ret_value = 0;
+
+    /* check if exclude attr option is given */
+    if (!opts->exclude_attr_path)
+        H5TOOLS_GOTO_DONE(0);
+
+    /* assign to local exclude list pointer */
+    exclude_ptr = opts->exclude_attr;
+
+    /* search objects in exclude list */
+    while (NULL != exclude_ptr) {
+        /* if exclude path is is group, exclude its members as well */
+        if (exclude_ptr->obj_type == H5TRAV_TYPE_GROUP) {
+            ret_cmp = HDstrncmp(exclude_ptr->obj_path, path,
+                                HDstrlen(exclude_ptr->obj_path));
+            if (ret_cmp == 0) {  /* found matching members */
+                size_t len_grp;
+
+                /* check if given path belong to an excluding group, if so
+                 * exclude it as well.
+                 * This verifies if “/grp1/dset1” is only under “/grp1”, but
+                 * not under “/grp1xxx/” group.
+                 */
+                len_grp = HDstrlen(exclude_ptr->obj_path);
+                if (path[len_grp] == '/') {
+                    /* belong to excluded group! */
+                    ret_value = 1;
+                    break;  /* while */
+                }
+            }
+        }
+        /* exclude target is not group, just exclude the object */
+        else {
+            ret_cmp = HDstrcmp(exclude_ptr->obj_path, path);
+            if (ret_cmp == 0) {  /* found matching object */
+                /* excluded non-group object */
+                ret_value = 1;
+                /* remember the type of this matching object.
+                 * if it's group, it can be used for excluding its member
+                 * objects in this while() loop */
+                exclude_ptr->obj_type = type;
+                break; /* while */
+            }
+        }
+        exclude_ptr = exclude_ptr->next;
+    }
+
+done:
+    return  ret_value;
+}
+
 
 /*-------------------------------------------------------------------------
  * Function: free_exclude_path_list
@@ -243,6 +308,25 @@ free_exclude_path_list(diff_opt_t *opts)
     }
 }
 
+
+/*-------------------------------------------------------------------------
+ * Function: free_exclude_attr_list
+ *
+ * Purpose:  free exclude object attribute list from diff options
+ *------------------------------------------------------------------------*/
+static void
+free_exclude_attr_list(diff_opt_t *opts)
+{
+    struct exclude_path_list *curr = opts->exclude_attr;
+    struct exclude_path_list *next;
+
+    while (NULL != curr) {
+        next = curr->next;
+        HDfree(curr);
+        curr = next;
+    }
+}
+
 /*-------------------------------------------------------------------------
  * Function: build_match_list
  *
@@ -288,6 +372,7 @@ build_match_list (const char *objname1, trav_info_t *info1, const char *objname2
      * All the objects belong to given groups are the candidates.
      * So prepare to compare paths without the group names.
      */
+    H5TOOLS_DEBUG("objname1 = %s objname2 = %s ", objname1, objname2);
 
     /* if obj1 is not root */
     if (HDstrcmp (objname1,"/") != 0)
@@ -572,8 +657,8 @@ h5diff(const char *fname1, const char *fname2, const char *objname1, const char
     *-------------------------------------------------------------------------
     */
     /* open file 1 */
-    if (opts->custom_vol_1) {
-        if((fapl1_id = h5tools_get_fapl(H5P_DEFAULT, &(opts->vol_info_1), NULL)) < 0 ) {
+    if (opts->custom_vol[0]) {
+        if((fapl1_id = h5tools_get_fapl(H5P_DEFAULT, &(opts->vol_info[0]), NULL)) < 0 ) {
             parallel_print("h5diff: unable to create fapl for input file\n");
             H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "unable to create input fapl\n");
         }
@@ -587,8 +672,8 @@ h5diff(const char *fname1, const char *fname2, const char *objname1, const char
 
     /* open file 2 */
 
-    if (opts->custom_vol_2) {
-        if((fapl2_id = h5tools_get_fapl(H5P_DEFAULT, &(opts->vol_info_2), NULL)) < 0 ) {
+    if (opts->custom_vol[1]) {
+        if((fapl2_id = h5tools_get_fapl(H5P_DEFAULT, &(opts->vol_info[1]), NULL)) < 0 ) {
             parallel_print("h5diff: unable to create fapl for output file\n");
             H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "unable to create output fapl\n");
         }
@@ -627,6 +712,7 @@ h5diff(const char *fname1, const char *fname2, const char *objname1, const char
         }
         else
             obj1fullname = HDstrdup(objname1);
+        H5TOOLS_DEBUG("obj1fullname = %s", obj1fullname);
 
         /* make the given object2 fullpath, start with "/" */
         if (HDstrncmp(objname2, "/", 1)) {
@@ -644,6 +730,7 @@ h5diff(const char *fname1, const char *fname2, const char *objname1, const char
         }
         else
             obj2fullname = HDstrdup(objname2);
+        H5TOOLS_DEBUG("obj2fullname = %s", obj2fullname);
 
         /*----------------------------------------------------------
          * check if obj1 is root, group, single object or symlink
@@ -777,12 +864,12 @@ h5diff(const char *fname1, const char *fname2, const char *objname1, const char
             H5TOOLS_DEBUG("h5diff ... dangling link");
             if (opts->no_dangle_links) {
                 /* treat dangling link as error */
-                if(opts->m_verbose)
+                if(opts->mode_verbose)
                     parallel_print("Warning: <%s> is a dangling link.\n", obj1fullname);
                 H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "treat dangling link as error");
             }
             else {
-                if(opts->m_verbose)
+                if(opts->mode_verbose)
                     parallel_print("obj1 <%s> is a dangling link.\n", obj1fullname);
                 if (l_ret1 != 0 ||  l_ret2 != 0) {
                     nfound++;
@@ -818,12 +905,12 @@ h5diff(const char *fname1, const char *fname2, const char *objname1, const char
             H5TOOLS_DEBUG("h5diff ... dangling link");
             if (opts->no_dangle_links) {
                 /* treat dangling link as error */
-                if(opts->m_verbose)
+                if(opts->mode_verbose)
                     parallel_print("Warning: <%s> is a dangling link.\n", obj2fullname);
                 H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "treat dangling link as error");
             }
             else {
-                if(opts->m_verbose)
+                if(opts->mode_verbose)
                     parallel_print("obj2 <%s> is a dangling link.\n", obj2fullname);
                 if (l_ret1 != 0 || l_ret2 != 0) {
                     nfound++;
@@ -857,8 +944,8 @@ h5diff(const char *fname1, const char *fname2, const char *objname1, const char
     * comparing details of same objects.
     */
 
-    if(!(opts->m_verbose || opts->m_report)) {
-        H5TOOLS_DEBUG("h5diff NOT (opts->m_verbose || opts->m_report)");
+    if(!(opts->mode_verbose || opts->mode_report)) {
+        H5TOOLS_DEBUG("h5diff NOT (opts->mode_verbose || opts->mode_report)");
         /* if no danglink links */
         if (l_ret1 > 0 && l_ret2 > 0)
             if (h5tools_is_obj_same(file1_id, obj1fullname, file2_id, obj2fullname) != 0)
@@ -924,9 +1011,14 @@ h5diff(const char *fname1, const char *fname2, const char *objname1, const char
         /*------------------------------------------------------
          * print the list
          */
-         if(opts->m_verbose) {
+         if(opts->mode_verbose) {
              unsigned u;
 
+             if(opts->mode_verbose_level > 2) {
+                parallel_print("file1: %s\n", fname1);
+                parallel_print("file2: %s\n", fname2);
+             }
+
              parallel_print("\n");
              /* if given objects is group under root */
              if (HDstrcmp (obj1fullname,"/") || HDstrcmp (obj2fullname,"/"))
@@ -947,6 +1039,7 @@ h5diff(const char *fname1, const char *fname2, const char *objname1, const char
     nfound = diff_match(file1_id, obj1fullname, info1_lp,
                         file2_id, obj2fullname, info2_lp,
                         match_list, opts);
+    H5TOOLS_DEBUG("diff_match nfound: %d - errstat:%d", nfound, opts->err_stat);
 
 done:
     opts->err_stat = opts->err_stat | ret_value;
@@ -1047,12 +1140,14 @@ diff_match(hid_t file1_id, const char *grp1, trav_info_t *info1,
      *-------------------------------------------------------------------------
      */
 
+    H5TOOLS_DEBUG("exclude_path opts->contents:%d", opts->contents);
     /* not valid compare used when --exclude-path option is used */
     if (!opts->exclude_path) {
         /* number of different objects */
         if (info1->nused != info2->nused) {
             opts->contents = 0;
         }
+        H5TOOLS_DEBUG("opts->exclude_path opts->contents:%d", opts->contents);
     }
 
     /* objects in one file and not the other */
@@ -1061,6 +1156,7 @@ diff_match(hid_t file1_id, const char *grp1, trav_info_t *info1,
             opts->contents = 0;
             break;
         }
+        H5TOOLS_DEBUG("table->nobjs[%d] opts->contents:%d", i, opts->contents);
     }
 
     /*-------------------------------------------------------------------------
@@ -1133,9 +1229,7 @@ diff_match(hid_t file1_id, const char *grp1, trav_info_t *info1,
             opts->cmn_objs = 1;
             if(!g_Parallel) {
                 H5TOOLS_DEBUG("diff paths - errstat:%d", opts->err_stat);
-                nfound += diff(file1_id, obj1_fullpath,
-                               file2_id, obj2_fullpath,
-                            opts, &argdata);
+                nfound += diff(file1_id, obj1_fullpath, file2_id, obj2_fullpath, opts, &argdata);
             } /* end if */
 #ifdef H5_HAVE_PARALLEL
             else {
@@ -1380,6 +1474,8 @@ diff_match(hid_t file1_id, const char *grp1, trav_info_t *info1,
 
     opts->err_stat = opts->err_stat | ret_value;
 
+    free_exclude_attr_list (opts);
+
     /* free table */
     if (table)
         trav_table_free(table);
@@ -1404,7 +1500,7 @@ diff_match(hid_t file1_id, const char *grp1, trav_info_t *info1,
  *-------------------------------------------------------------------------
  */
 hsize_t
-diff(hid_t file1_id, const char *path1, hid_t file2_id, const char *path2, diff_opt_t * opts, diff_args_t *argdata)
+diff(hid_t file1_id, const char *path1, hid_t file2_id, const char *path2, diff_opt_t *opts, diff_args_t *argdata)
 {
     int           status = -1;
     hid_t         dset1_id = H5I_INVALID_HID;
@@ -1453,7 +1549,7 @@ diff(hid_t file1_id, const char *path1, hid_t file2_id, const char *path2, diff_
         if (status == 0) {
             if (opts->no_dangle_links) {
                 /* dangling link is error */
-                if(opts->m_verbose)
+                if(opts->mode_verbose)
                     parallel_print("Warning: <%s> is a dangling link.\n", path1);
                 H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "dangling link is error");
             }
@@ -1468,7 +1564,7 @@ diff(hid_t file1_id, const char *path1, hid_t file2_id, const char *path2, diff_
         if (status == 0) {
             if (opts->no_dangle_links) {
                 /* dangling link is error */
-                if(opts->m_verbose)
+                if(opts->mode_verbose)
                     parallel_print("Warning: <%s> is a dangling link.\n", path2);
                 H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "dangling link is error");
             }
@@ -1494,11 +1590,11 @@ diff(hid_t file1_id, const char *path1, hid_t file2_id, const char *path2, diff_
     /* if objects are not the same type */
     if (argdata->type[0] != argdata->type[1]) {
         H5TOOLS_DEBUG("diff objects are not the same");
-        if (opts->m_verbose||opts->m_list_not_cmp) {
+        if (opts->mode_verbose||opts->mode_list_not_cmp) {
             parallel_print("Not comparable: <%s> is of type %s and <%s> is of type %s\n",
-            path1, get_type(argdata->type[0]),
-            path2, get_type(argdata->type[1]));
+                    path1, get_type(argdata->type[0]), path2, get_type(argdata->type[1]));
         }
+
         opts->not_cmp = 1;
         /* TODO: will need to update non-comparable is different
          * opts->contents = 0;
@@ -1523,7 +1619,7 @@ diff(hid_t file1_id, const char *path1, hid_t file2_id, const char *path2, diff_
                         object_type == H5TRAV_TYPE_GROUP);
         if (opts->follow_links || is_hard_link) {
             /* print information is only verbose option is used */
-            if(opts->m_verbose || opts->m_report) {
+            if(opts->mode_verbose || opts->mode_report) {
                 switch(object_type) {
                     case H5TRAV_TYPE_DATASET:
                         do_print_objname("dataset", path1, path2, opts);
@@ -1552,7 +1648,7 @@ diff(hid_t file1_id, const char *path1, hid_t file2_id, const char *path2, diff_
                 } /* switch(type)*/
 
                 print_found(nfound);
-            } /* if(opts->m_verbose || opts->m_report) */
+            } /* if(opts->mode_verbose || opts->mode_report) */
 
             /* exact same, so comparison is done */
             H5TOOLS_GOTO_DONE(H5DIFF_NO_ERR);
@@ -1570,15 +1666,16 @@ diff(hid_t file1_id, const char *path1, hid_t file2_id, const char *path2, diff_
                 H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Dopen2 failed");
             if((dset2_id = H5Dopen2(file2_id, path2, H5P_DEFAULT)) < 0)
                 H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Dopen2 failed");
+            H5TOOLS_DEBUG("paths: %s - %s", path1, path2);
             /* verbose (-v) and report (-r) mode */
-            if(opts->m_verbose || opts->m_report) {
+            if(opts->mode_verbose || opts->mode_report) {
                 do_print_objname("dataset", path1, path2, opts);
                 H5TOOLS_DEBUG("call diff_dataset 1:%s  2:%s ", path1, path2);
                 nfound = diff_dataset(file1_id, file2_id, path1, path2, opts);
                 print_found(nfound);
             }
             /* quiet mode (-q), just count differences */
-            else if(opts->m_quiet) {
+            else if(opts->mode_quiet) {
                 nfound = diff_dataset(file1_id, file2_id, path1, path2, opts);
             }
             /* the rest (-c, none, ...) */
@@ -1598,7 +1695,7 @@ diff(hid_t file1_id, const char *path1, hid_t file2_id, const char *path2, diff_
              * referenced object
              *---------------------------------------------------------
              */
-            if(path1) {
+            if(path1 && !is_exclude_attr(path1, object_type, opts)) {
                 H5TOOLS_DEBUG( "call diff_attr 1:%s  2:%s ", path1, path2);
                 nfound += diff_attr(dset1_id, dset2_id, path1, path2, opts);
             }
@@ -1630,7 +1727,7 @@ diff(hid_t file1_id, const char *path1, hid_t file2_id, const char *path2, diff_
                 do_print_objname("datatype", path1, path2, opts);
 
             /* always print the number of differences found in verbose mode */
-            if(opts->m_verbose)
+            if(opts->mode_verbose)
                 print_found(nfound);
 
             /*-----------------------------------------------------------------
@@ -1639,7 +1736,7 @@ diff(hid_t file1_id, const char *path1, hid_t file2_id, const char *path2, diff_
              * referenced object
              *-----------------------------------------------------------------
              */
-            if(path1) {
+            if(path1 && !is_exclude_attr(path1, object_type, opts)) {
                 H5TOOLS_DEBUG("call diff_attr 1:%s  2:%s ", path1, path2);
                 nfound += diff_attr(type1_id, type2_id, path1, path2, opts);
             }
@@ -1660,7 +1757,7 @@ diff(hid_t file1_id, const char *path1, hid_t file2_id, const char *path2, diff_
                 do_print_objname("group", path1, path2, opts);
 
             /* always print the number of differences found in verbose mode */
-            if(opts->m_verbose)
+            if(opts->mode_verbose)
                 print_found(nfound);
 
             if((grp1_id = H5Gopen2(file1_id, path1, H5P_DEFAULT)) < 0)
@@ -1674,7 +1771,7 @@ diff(hid_t file1_id, const char *path1, hid_t file2_id, const char *path2, diff_
              * referenced object
              *-----------------------------------------------------------------
              */
-            if(path1) {
+            if(path1 && !is_exclude_attr(path1, object_type, opts)) {
                 H5TOOLS_DEBUG("call diff_attr 1:%s  2:%s ", path1, path2);
                 nfound += diff_attr(grp1_id, grp2_id, path1, path2, opts);
             }
@@ -1702,7 +1799,7 @@ diff(hid_t file1_id, const char *path1, hid_t file2_id, const char *path2, diff_
                     do_print_objname("link", path1, path2, opts);
 
                 /* always print the number of differences found in verbose mode */
-                if(opts->m_verbose)
+                if(opts->mode_verbose)
                     print_found(nfound);
                 }
             break;
@@ -1752,14 +1849,14 @@ diff(hid_t file1_id, const char *path1, hid_t file2_id, const char *path2, diff_
                 } /* end else */
 
                 /* always print the number of differences found in verbose mode */
-                if(opts->m_verbose)
+                if(opts->mode_verbose)
                     print_found(nfound);
             }
             break;
 
         case H5TRAV_TYPE_UNKNOWN:
         default:
-            if(opts->m_verbose)
+            if(opts->mode_verbose)
                 parallel_print("Comparison not supported: <%s> and <%s> are of type %s\n",
                     path1, path2, get_type(object_type) );
             opts->not_cmp = 1;
@@ -1781,7 +1878,7 @@ diff(hid_t file1_id, const char *path1, hid_t file2_id, const char *path2, diff_
     }
     /* path1 is dangling link */
     else if (is_dangle_link1) {
-        if(opts->m_verbose)
+        if(opts->mode_verbose)
            parallel_print("obj1 <%s> is a dangling link.\n", path1);
         nfound++;
         if(print_objname(opts, nfound))
@@ -1789,7 +1886,7 @@ diff(hid_t file1_id, const char *path1, hid_t file2_id, const char *path2, diff_
     }
     /* path2 is dangling link */
     else if (is_dangle_link2) {
-        if(opts->m_verbose)
+        if(opts->mode_verbose)
             parallel_print("obj2 <%s> is a dangling link.\n", path2);
         nfound++;
         if(print_objname(opts, nfound))
diff --git a/tools/lib/h5diff.h b/tools/lib/h5diff.h
index 37eb7758d37..c3c111f1d44 100644
--- a/tools/lib/h5diff.h
+++ b/tools/lib/h5diff.h
@@ -18,23 +18,6 @@
 #include "h5tools.h"
 #include "h5trav.h"
 
-/*
- * Debug printf macros. The prefix allows output filtering by test scripts.
- */
-#ifdef H5DIFF_DEBUG
-#define h5difftrace(x) HDfprintf(stderr, "h5diff debug: " x)
-#define h5diffdebug2(x1, x2) HDfprintf(stderr, "h5diff debug: " x1, x2)
-#define h5diffdebug3(x1, x2, x3) HDfprintf(stderr, "h5diff debug: " x1, x2, x3)
-#define h5diffdebug4(x1, x2, x3, x4) HDfprintf(stderr, "h5diff debug: " x1, x2, x3, x4)
-#define h5diffdebug5(x1, x2, x3, x4, x5) HDfprintf(stderr, "h5diff debug: " x1, x2, x3, x4, x5)
-#else
-#define h5difftrace(x)
-#define h5diffdebug2(x1, x2)
-#define h5diffdebug3(x1, x2, x3)
-#define h5diffdebug4(x1, x2, x3, x4)
-#define h5diffdebug5(x1, x2, x3, x4, x5)
-#endif
-
 #define MAX_FILENAME 1024
 
 /*-------------------------------------------------------------------------
@@ -58,6 +41,7 @@ struct exclude_path_list {
     struct exclude_path_list   *next;
 };
 
+
 /* Enumeration value for keeping track of whether an error occurred or differences were found */
 typedef enum {
     H5DIFF_NO_ERR,   /* No error occurred */
@@ -66,31 +50,46 @@ typedef enum {
 } diff_err_t;
 
 typedef struct {
-    int        m_quiet;               /* quiet mode: no output at all */
-    int        m_report;              /* report mode: print the data */
-    int        m_verbose;             /* verbose mode: print the data, list of objcets, warnings */
-    int        m_verbose_level;       /* control verbose details */
-    int        d;                     /* delta, absolute value to compare */
-    double     delta;                 /* delta value */
-    int        p;                     /* relative error to compare*/
-    int        use_system_epsilon;    /* flag to use system epsilon (1 or 0) */
-    double     percent;               /* relative error value */
-    int        n;                     /* count, compare up to count */
-    hsize_t    count;                 /* count value */
-    hbool_t    follow_links;          /* follow symbolic links */
-    int        no_dangle_links;       /* return error when find dangling link */
-    diff_err_t err_stat;              /* an error ocurred (2, error, 1, differences, 0, no error) */
-    int        cmn_objs;              /* do we have common objects */
-    int        not_cmp;               /* are the objects comparable */
-    int        contents;              /* equal contents */
-    int        do_nans;               /* consider Nans while diffing floats */
-    int        m_list_not_cmp;        /* list not comparable messages */
-    int        exclude_path;          /* exclude path to an object */
-    struct     exclude_path_list * exclude; /* keep exclude path list */
-    h5tools_vol_info_t  vol_info_1;   /* VOL information for input file */
-    h5tools_vol_info_t  vol_info_2;   /* VOL information for output file */
-    hbool_t    custom_vol_1;          /* Using a custom input VOL? */
-    hbool_t    custom_vol_2;          /* Using a custom output VOL? */
+    int        mode_quiet;                 /* quiet mode: no output at all */
+    int        mode_report;                /* report mode: print the data */
+    int        mode_verbose;               /* verbose mode: print the data, list of objcets, warnings */
+    int        mode_verbose_level;         /* control verbose details */
+    int        mode_list_not_cmp;          /* list not comparable messages */
+    int        print_header;               /* print header */
+    int        print_percentage;           /* print percentage */
+    int        delta_bool;                 /* delta, absolute value to compare */
+    double     delta;                      /* delta value */
+    int        use_system_epsilon;         /* flag to use system epsilon (1 or 0) */
+    int        percent_bool;               /* relative error to compare*/
+    double     percent;                    /* relative error value */
+    hbool_t    follow_links;               /* follow symbolic links */
+    int        no_dangle_links;            /* return error when find dangling link */
+    int        cmn_objs;                   /* do we have common objects */
+    int        not_cmp;                    /* are the objects comparable */
+    int        contents;                   /* equal contents */
+    int        do_nans;                    /* consider Nans while diffing floats */
+    int        exclude_path;               /* exclude path to an object */
+    int        exclude_attr_path;          /* exclude path to an object */
+    struct     exclude_path_list *exclude; /* keep exclude path list */
+    struct     exclude_path_list *exclude_attr; /* keep exclude attribute list */
+    int        count_bool;                 /* count, compare up to count */
+    hsize_t    count;                      /* count value */
+    diff_err_t err_stat;                   /* an error ocurred (2, error, 1, differences, 0, no error) */
+    hsize_t    nelmts;                     /* total number of elements */
+    hsize_t    hs_nelmts;                  /* number of elements to read at a time*/
+    int        rank;                       /* dimensionality */
+    size_t     m_size;                     /* m_size for diff */
+    hid_t      m_tid;                      /* m_tid for diff */
+    hsize_t    dims[H5S_MAX_RANK];         /* dimensions of object */
+    hsize_t    p_min_idx[H5S_MAX_RANK];    /* min selected index */
+    hsize_t    p_max_idx[H5S_MAX_RANK];    /* max selected index */
+    hsize_t    acc[H5S_MAX_RANK];          /* accumulator position */
+    hsize_t    pos[H5S_MAX_RANK];          /* matrix position */
+    hsize_t    sm_pos[H5S_MAX_RANK];       /* stripmine position */
+    char       *obj_name[2];               /* name for object */
+    struct     subset_t *sset[2];          /* subsetting parameters */
+    h5tools_vol_info_t  vol_info[2];       /* VOL information for input file, output file */
+    hbool_t    custom_vol[2];              /* Using a custom input, output VOL? */
 } diff_opt_t;
 
 
@@ -103,18 +102,9 @@ typedef struct {
 extern "C" {
 #endif
 
-H5TOOLS_DLL hsize_t  h5diff(const char *fname1,
-                const char *fname2,
-                const char *objname1,
-                const char *objname2,
-                diff_opt_t *opts);
+H5TOOLS_DLL hsize_t h5diff(const char *fname1, const char *fname2, const char *objname1, const char *objname2, diff_opt_t *opts);
 
-H5TOOLS_DLL hsize_t diff( hid_t      file1_id,
-              const char *path1,
-              hid_t      file2_id,
-              const char *path2,
-              diff_opt_t *opts,
-              diff_args_t *argdata);
+H5TOOLS_DLL hsize_t diff(hid_t file1_id, const char *path1, hid_t file2_id, const char *path2, diff_opt_t *opts, diff_args_t *argdata);
 
 #ifdef H5_HAVE_PARALLEL
 H5TOOLS_DLL void phdiff_dismiss_workers(void);
@@ -133,63 +123,29 @@ H5TOOLS_DLL void print_manager_output(void);
  */
 
 
-hsize_t diff_dataset( hid_t file1_id,
-                      hid_t file2_id,
-                      const char *obj1_name,
-                      const char *obj2_name,
-                      diff_opt_t *opts);
-
-hsize_t diff_datasetid( hid_t dset1_id,
-                        hid_t dset2_id,
-                        const char *obj1_name,
-                        const char *obj2_name,
-                        diff_opt_t *opts);
-
-
-hsize_t diff_match( hid_t file1_id, const char *grp1, trav_info_t *info1,
-                    hid_t file2_id, const char *grp2, trav_info_t *info2,
-                    trav_table_t *table, diff_opt_t *opts );
-
-hsize_t diff_array( void *_mem1,
-                    void *_mem2,
-                    hsize_t nelmts,
-                    hsize_t hyper_start,
-                    int rank,
-                    hsize_t *dims,
-                    diff_opt_t *opts,
-                    const char *name1,
-                    const char *name2,
-                    hid_t m_type,
-                    hid_t container1_id,
-                    hid_t container2_id); /* dataset where the reference came from*/
-
-
-int diff_can_type( hid_t       f_type1, /* file data type */
-                   hid_t       f_type2, /* file data type */
-                   int         rank1,
-                   int         rank2,
-                   hsize_t     *dims1,
-                   hsize_t     *dims2,
-                   hsize_t     *maxdim1,
-                   hsize_t     *maxdim2,
-                   const char  *obj1_name,
-                   const char  *obj2_name,
-                   diff_opt_t  *opts,
-                   int         is_compound);
-
-hsize_t diff_attr_data(hid_t attr1_id,
-                  hid_t attr2_id,
-                  const char *attr1_name,
-                  const char *attr2_name,
-                  const char *path1,
-                  const char *path2,
-                  diff_opt_t *opts);
-
-hsize_t diff_attr(hid_t loc1_id,
-                  hid_t loc2_id,
-                  const char *path1,
-                  const char *path2,
-                  diff_opt_t *opts);
+hsize_t diff_dataset(hid_t file1_id, hid_t file2_id,
+                     const char *obj1_name, const char *obj2_name, diff_opt_t *opts);
+
+hsize_t diff_datasetid(hid_t dset1_id, hid_t dset2_id,
+                       const char *obj1_name, const char *obj2_name, diff_opt_t *opts);
+
+
+hsize_t diff_match(hid_t file1_id, const char *grp1, trav_info_t *info1,
+                   hid_t file2_id, const char *grp2, trav_info_t *info2,
+                   trav_table_t *table, diff_opt_t *opts);
+
+hsize_t diff_array(void *_mem1, void *_mem2,
+                   diff_opt_t *opts, hid_t container1_id, hid_t container2_id);
+
+int diff_can_type(hid_t f_type1, hid_t f_type2, int rank1, int rank2,
+                  hsize_t *dims1, hsize_t *dims2, hsize_t *maxdim1, hsize_t *maxdim2,
+                  diff_opt_t *opts, int is_compound);
+
+hsize_t diff_attr_data(hid_t attr1_id, hid_t attr2_id, const char *name1, const char *name2,
+                    const char *path1, const char *path2, diff_opt_t *opts);
+
+hsize_t diff_attr(hid_t loc1_id, hid_t loc2_id,
+                  const char *path1, const char *path2, diff_opt_t *opts);
 
 
 /*-------------------------------------------------------------------------
diff --git a/tools/lib/h5diff_array.c b/tools/lib/h5diff_array.c
index 52bae512ce7..9b680ece330 100644
--- a/tools/lib/h5diff_array.c
+++ b/tools/lib/h5diff_array.c
@@ -132,97 +132,39 @@ typedef struct mcomp_t {
  * local prototypes
  *-------------------------------------------------------------------------
  */
-static hsize_t diff_region(hid_t obj1_id, hid_t obj2_id, hid_t region1_id,
-        hid_t region2_id, diff_opt_t *opts);
 static hbool_t all_zero(const void *_mem, size_t size);
 static int ull2float(unsigned long long ull_value, float *f_value);
-static hsize_t character_compare(char *mem1, char *mem2, hsize_t i, size_t u,
-        int rank, hsize_t *dims, hsize_t *acc, hsize_t *pos,
-        diff_opt_t *opts, const char *obj1, const char *obj2, int *ph);
-static hsize_t character_compare_opt(unsigned char *mem1, unsigned char *mem2,
-        hsize_t i, int rank, hsize_t *dims, hsize_t *acc, hsize_t *pos,
-        diff_opt_t *opts, const char *obj1, const char *obj2, int *ph);
+static hsize_t character_compare(char *mem1, char *mem2, hsize_t elemtno, ssize_t u, diff_opt_t *opts);
+static hsize_t character_compare_opt(unsigned char *mem1, unsigned char *mem2, hsize_t elemtno, diff_opt_t *opts);
 static hbool_t equal_float(float value, float expected, diff_opt_t *opts);
 static hbool_t equal_double(double value, double expected, diff_opt_t *opts);
 #if H5_SIZEOF_LONG_DOUBLE !=0
 static hbool_t equal_ldouble(long double value, long double expected, diff_opt_t *opts);
 #endif
+
 static int print_data(diff_opt_t *opts);
-static void print_pos(int *ph, int pp, hsize_t curr_pos, hsize_t *acc,
-        hsize_t *pos, int rank, hsize_t *dims, const char *obj1,
-        const char *obj2);
-static void print_char_pos(int *ph, int pp, hsize_t curr_pos, size_t u,
-        hsize_t *acc, hsize_t *pos, int rank, hsize_t *dims, const char *obj1,
-        const char *obj2);
+static void print_pos(diff_opt_t *opts, hsize_t elemtno, ssize_t u);
 static void h5diff_print_char(char ch);
-static hsize_t diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx,
-        int rank, hsize_t *dims, hsize_t *acc, hsize_t *pos,
-        diff_opt_t *opts, const char *obj1, const char *obj2,
-        hid_t container1_id, hid_t container2_id, /*where the reference came from*/
-        int *ph, /*print header */
-        mcomp_t *members); /*compound members */
-static hsize_t diff_float(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims,
-        hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1,
-        const char *obj2, int *ph);
-static hsize_t diff_double(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims,
-        hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1,
-        const char *obj2, int *ph);
+
+static hsize_t diff_region(hid_t obj1_id, hid_t obj2_id, hid_t region1_id, hid_t region2_id, diff_opt_t *opts);
+static hsize_t diff_datum(void *_mem1, void *_mem2, hsize_t elemtno, diff_opt_t *opts,
+        hid_t container1_id, hid_t container2_id, mcomp_t *members);
+/* element diffs */
+static hsize_t diff_float_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts);
+static hsize_t diff_double_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts);
 #if H5_SIZEOF_LONG_DOUBLE !=0
-static hsize_t diff_ldouble(unsigned char *mem1,
-        unsigned char *mem2,
-        hsize_t nelmts,
-        hsize_t hyper_start,
-        int rank,
-        hsize_t *dims,
-        hsize_t *acc,
-        hsize_t *pos,
-        diff_opt_t *opts,
-        const char *obj1,
-        const char *obj2,
-        int *ph);
+static hsize_t diff_ldouble_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts);
 #endif
-static hsize_t diff_schar(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims,
-        hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1,
-        const char *obj2, int *ph);
-static hsize_t diff_uchar(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims,
-        hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1,
-        const char *obj2, int *ph);
-static hsize_t diff_short(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims,
-        hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1,
-        const char *obj2, int *ph);
-static hsize_t diff_ushort(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims,
-        hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1,
-        const char *obj2, int *ph);
-static hsize_t diff_int(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims,
-        hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1,
-        const char *obj2, int *ph);
-static hsize_t diff_uint(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims,
-        hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1,
-        const char *obj2, int *ph);
-static hsize_t diff_long(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims,
-        hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1,
-        const char *obj2, int *ph);
-static hsize_t diff_ulong(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims,
-        hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1,
-        const char *obj2, int *ph);
-static hsize_t diff_llong(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims,
-        hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1,
-        const char *obj2, int *ph);
-static hsize_t diff_ullong(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims,
-        hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1,
-        const char *obj2, int *ph);
+static hsize_t diff_schar_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts);
+static hsize_t diff_uchar_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts);
+static hsize_t diff_short_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts);
+static hsize_t diff_ushort_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts);
+static hsize_t diff_int_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts);
+static hsize_t diff_uint_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts);
+static hsize_t diff_long_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts);
+static hsize_t diff_ulong_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts);
+static hsize_t diff_llong_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts);
+static hsize_t diff_ullong_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts);
 
 /*-------------------------------------------------------------------------
  * NaN detection
@@ -260,26 +202,24 @@ static void close_member_types(mcomp_t *members);
  *-------------------------------------------------------------------------
  */
 
-hsize_t diff_array(void *_mem1, void *_mem2, hsize_t nelmts, hsize_t hyper_start,
-        int rank, hsize_t *dims, diff_opt_t *opts, const char *name1, const char *name2,
-        hid_t m_type, hid_t container1_id, hid_t container2_id)
+hsize_t
+diff_array(void *_mem1, void *_mem2, diff_opt_t *opts, hid_t container1_id, hid_t container2_id)
 {
     hsize_t         nfound = 0; /* number of differences found */
     size_t          size; /* size of datum */
     unsigned char  *mem1 = (unsigned char*) _mem1;
     unsigned char  *mem2 = (unsigned char*) _mem2;
-    hsize_t         acc[32]; /* accumulator position */
-    hsize_t         pos[32]; /* matrix position */
-    int             ph = 1; /* print header  */
     hsize_t         i;
     int             j;
     mcomp_t         members;
     H5T_class_t     type_class;
 
-    H5TOOLS_START_DEBUG(" - errstat:%d", opts->err_stat);
+    H5TOOLS_START_DEBUG(" - rank:%d hs_nelmts:%ld errstat:%d", opts->rank, opts->hs_nelmts, opts->err_stat);
+    opts->print_header = 1; /* enable print header  */
+
     /* get the size. */
-    size = H5Tget_size(m_type);
-    type_class = H5Tget_class(m_type);
+    size = H5Tget_size(opts->m_tid);
+    type_class = H5Tget_class(opts->m_tid);
 
     /* Fast comparison first for atomic type by memcmp().
      * It is OK not to list non-atomic type here because it will not be caught
@@ -289,24 +229,18 @@ hsize_t diff_array(void *_mem1, void *_mem2, hsize_t nelmts, hsize_t hyper_start
             type_class != H5T_COMPOUND &&
             type_class != H5T_STRING &&
             type_class != H5T_VLEN &&
-            HDmemcmp(mem1, mem2, size*nelmts) == 0)
+            HDmemcmp(mem1, mem2, size * opts->hs_nelmts) == 0) {
+        H5TOOLS_ENDDEBUG(":Fast comparison - errstat:%d", opts->err_stat);
         return 0;
-
-    if (rank > 0) {
-        acc[rank - 1] = 1;
-        for (j = (rank - 2); j >= 0; j--) {
-            acc[j] = acc[j + 1] * dims[j + 1];
-        }
-        for (j = 0; j < rank; j++)
-            pos[j] = 0;
     }
 
-    H5TOOLS_DEBUG("diff_array type_class:%d", type_class);
+    H5TOOLS_DEBUG("type_class:%d", type_class);
     switch (type_class) {
     case H5T_NO_CLASS:
     case H5T_TIME:
     case H5T_NCLASSES:
     default:
+        H5TOOLS_DEBUG("type_class:INVALID");
         HDassert(0);
         break;
 
@@ -315,37 +249,142 @@ hsize_t diff_array(void *_mem1, void *_mem2, hsize_t nelmts, hsize_t hyper_start
      *-------------------------------------------------------------------------
      */
     case H5T_FLOAT:
-        if (H5Tequal(m_type, H5T_NATIVE_FLOAT))
-            nfound = diff_float(mem1, mem2, nelmts, hyper_start, rank, dims, acc, pos, opts, name1, name2, &ph);
-        else if (H5Tequal(m_type, H5T_NATIVE_DOUBLE))
-            nfound = diff_double(mem1, mem2, nelmts, hyper_start, rank, dims, acc, pos, opts, name1, name2, &ph);
+        H5TOOLS_DEBUG("type_class:H5T_FLOAT");
+        if (H5Tequal(opts->m_tid, H5T_NATIVE_FLOAT)) {
+            for (i = 0; i < opts->hs_nelmts; i++) {
+                nfound += diff_float_element(mem1, mem2, i, opts);
+
+                mem1 += sizeof(float);
+                mem2 += sizeof(float);
+                if (opts->count_bool && nfound >= opts->count)
+                    return nfound;
+            } /* nelmts */
+        }
+        else if (H5Tequal(opts->m_tid, H5T_NATIVE_DOUBLE)){
+            for (i = 0; i < opts->hs_nelmts; i++) {
+                nfound += diff_double_element(mem1, mem2, i, opts);
+
+                mem1 += sizeof(double);
+                mem2 += sizeof(double);
+                if (opts->count_bool && nfound >= opts->count)
+                    return nfound;
+            } /* nelmts */
+        }
 #if H5_SIZEOF_LONG_DOUBLE != 0
-        else if (H5Tequal(m_type, H5T_NATIVE_LDOUBLE))
-        nfound = diff_ldouble(mem1, mem2, nelmts, hyper_start, rank, dims, acc, pos, opts, name1, name2, &ph);
+        else if (H5Tequal(opts->m_tid, H5T_NATIVE_LDOUBLE)) {
+            for ( i = 0; i < opts->hs_nelmts; i++) {
+                nfound += diff_ldouble_element(mem1, mem2, i, opts);
+
+                mem1 += sizeof(long double);
+                mem2 += sizeof(long double);
+                if (opts->count_bool && nfound >= opts->count)
+                    return nfound;
+            } /* nelmts */
+        }
 #endif
         break;
 
     case H5T_INTEGER:
-        if (H5Tequal(m_type, H5T_NATIVE_SCHAR))
-            nfound = diff_schar(mem1, mem2, nelmts, hyper_start, rank, dims, acc, pos, opts, name1, name2, &ph);
-        else if (H5Tequal(m_type, H5T_NATIVE_UCHAR))
-            nfound = diff_uchar(mem1, mem2, nelmts, hyper_start, rank, dims, acc, pos, opts, name1, name2, &ph);
-        else if (H5Tequal(m_type, H5T_NATIVE_SHORT))
-            nfound = diff_short(mem1, mem2, nelmts, hyper_start, rank, dims, acc, pos, opts, name1, name2, &ph);
-        else if (H5Tequal(m_type, H5T_NATIVE_USHORT))
-            nfound = diff_ushort(mem1, mem2, nelmts, hyper_start, rank, dims, acc, pos, opts, name1, name2, &ph);
-        else if (H5Tequal(m_type, H5T_NATIVE_INT))
-            nfound = diff_int(mem1, mem2, nelmts, hyper_start, rank, dims, acc, pos, opts, name1, name2, &ph);
-        else if (H5Tequal(m_type, H5T_NATIVE_UINT))
-            nfound = diff_uint(mem1, mem2, nelmts, hyper_start, rank, dims, acc, pos, opts, name1, name2, &ph);
-        else if (H5Tequal(m_type, H5T_NATIVE_LONG))
-            nfound = diff_long(mem1, mem2, nelmts, hyper_start, rank, dims, acc, pos, opts, name1, name2, &ph);
-        else if (H5Tequal(m_type, H5T_NATIVE_ULONG))
-            nfound = diff_ulong(mem1, mem2, nelmts, hyper_start, rank, dims, acc, pos, opts, name1, name2, &ph);
-        else if (H5Tequal(m_type, H5T_NATIVE_LLONG))
-            nfound = diff_llong(mem1, mem2, nelmts, hyper_start, rank, dims, acc, pos, opts, name1, name2, &ph);
-        else if (H5Tequal(m_type, H5T_NATIVE_ULLONG))
-            nfound = diff_ullong(mem1, mem2, nelmts, hyper_start, rank, dims, acc, pos, opts, name1, name2, &ph);
+        H5TOOLS_DEBUG("type_class:H5T_INTEGER");
+        if (H5Tequal(opts->m_tid, H5T_NATIVE_SCHAR)) {
+            for (i = 0; i < opts->hs_nelmts; i++) {
+                nfound += diff_schar_element(mem1, mem2, i, opts);
+                mem1 += sizeof(char);
+                mem2 += sizeof(char);
+                if (opts->count_bool && nfound >= opts->count)
+                    return nfound;
+            } /* nelmts */
+        }
+        else if (H5Tequal(opts->m_tid, H5T_NATIVE_UCHAR)) {
+            for (i = 0; i < opts->hs_nelmts; i++) {
+                nfound += diff_uchar_element(mem1, mem2, i, opts);
+
+                mem1 += sizeof(unsigned char);
+                mem2 += sizeof(unsigned char);
+                if (opts->count_bool && nfound >= opts->count)
+                    return nfound;
+            } /* nelmts */
+        }
+        else if (H5Tequal(opts->m_tid, H5T_NATIVE_SHORT)) {
+            for (i = 0; i < opts->hs_nelmts; i++) {
+                nfound += diff_short_element(mem1, mem2, i, opts);
+
+                mem1 += sizeof(short);
+                mem2 += sizeof(short);
+                if (opts->count_bool && nfound >= opts->count)
+                    return nfound;
+            } /* nelmts */
+        }
+        else if (H5Tequal(opts->m_tid, H5T_NATIVE_USHORT)) {
+            for (i = 0; i < opts->hs_nelmts; i++) {
+                nfound += diff_ushort_element(mem1, mem2, i, opts);
+
+                mem1 += sizeof(unsigned short);
+                mem2 += sizeof(unsigned short);
+                if (opts->count_bool && nfound >= opts->count)
+                    return nfound;
+            } /* nelmts */
+        }
+        else if (H5Tequal(opts->m_tid, H5T_NATIVE_INT)) {
+            for (i = 0; i < opts->hs_nelmts; i++) {
+                nfound += diff_int_element(mem1, mem2, i, opts);
+
+                mem1 += sizeof(int);
+                mem2 += sizeof(int);
+                if (opts->count_bool && nfound >= opts->count)
+                    return nfound;
+            } /* nelmts */
+        }
+        else if (H5Tequal(opts->m_tid, H5T_NATIVE_UINT)) {
+            for (i = 0; i < opts->hs_nelmts; i++) {
+                nfound += diff_int_element(mem1, mem2, i, opts);
+
+                mem1 += sizeof(unsigned int);
+                mem2 += sizeof(unsigned int);
+                if (opts->count_bool && nfound >= opts->count)
+                    return nfound;
+            } /* nelmts */
+        }
+        else if (H5Tequal(opts->m_tid, H5T_NATIVE_LONG)) {
+            for (i = 0; i < opts->hs_nelmts; i++) {
+                nfound += diff_long_element(mem1, mem2, i, opts);
+
+                mem1 += sizeof(long);
+                mem2 += sizeof(long);
+                if (opts->count_bool && nfound >= opts->count)
+                    return nfound;
+            } /* nelmts */
+        }
+        else if (H5Tequal(opts->m_tid, H5T_NATIVE_ULONG)) {
+            for (i = 0; i < opts->hs_nelmts; i++) {
+                nfound += diff_ulong_element(mem1, mem2, i, opts);
+
+                mem1 += sizeof(unsigned long);
+                mem2 += sizeof(unsigned long);
+                if (opts->count_bool && nfound >= opts->count)
+                    return nfound;
+            } /* nelmts */
+        }
+        else if (H5Tequal(opts->m_tid, H5T_NATIVE_LLONG)) {
+            for (i = 0; i < opts->hs_nelmts; i++) {
+                nfound += diff_llong_element(mem1, mem2, i, opts);
+
+                mem1 += sizeof(long long);
+                mem2 += sizeof(long long);
+                if (opts->count_bool && nfound >= opts->count)
+                    return nfound;
+            } /* nelmts */
+        }
+        else if (H5Tequal(opts->m_tid, H5T_NATIVE_ULLONG)) {
+            for (i = 0; i < opts->hs_nelmts; i++) {
+                nfound += diff_ullong_element(mem1, mem2, i, opts);
+
+                mem1 += sizeof(unsigned long long);
+                mem2 += sizeof(unsigned long long);
+                if (opts->count_bool && nfound >= opts->count)
+                    return nfound;
+            } /* nelmts */
+        }
         break;
 
     /*-------------------------------------------------------------------------
@@ -360,13 +399,13 @@ hsize_t diff_array(void *_mem1, void *_mem2, hsize_t nelmts, hsize_t hyper_start
     case H5T_ARRAY:
     case H5T_VLEN:
     case H5T_REFERENCE:
+        H5TOOLS_DEBUG("type_class:OTHER");
         HDmemset(&members, 0, sizeof(mcomp_t));
-        get_member_types(m_type, &members);
-        H5TOOLS_DEBUG("call diff_datum nelmts:%d - errstat:%d", nelmts, opts->err_stat);
-        for (i = 0; i < nelmts; i++) {
-            nfound += diff_datum(mem1 + i * size, mem2 + i * size, m_type, i, rank, dims, acc, pos, opts,
-                    name1, name2, container1_id, container2_id, &ph, &members);
-            if (opts->n && nfound >= opts->count)
+        get_member_types(opts->m_tid, &members);
+        for (i = 0; i < opts->hs_nelmts; i++) {
+            H5TOOLS_DEBUG("opts->pos[%ld]:%ld - nelmts:%ld", i, opts->pos[i], opts->hs_nelmts);
+            nfound += diff_datum(mem1 + i * size, mem2 + i * size, i, opts, container1_id, container2_id, &members);
+            if (opts->count_bool && nfound >= opts->count)
                 break;
         } /* i */
         close_member_types(&members);
@@ -409,12 +448,7 @@ hsize_t diff_array(void *_mem1, void *_mem2, hsize_t nelmts, hsize_t hyper_start
  *-------------------------------------------------------------------------
  */
 static hsize_t
-diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
-    hsize_t *dims, hsize_t *acc, hsize_t *pos, diff_opt_t *opts,
-    const char *obj1, const char *obj2,
-    hid_t container1_id, hid_t container2_id,
-        int *ph,             /*print header */
-        mcomp_t *members)    /*compound members */
+diff_datum(void *_mem1, void *_mem2, hsize_t elemtno, diff_opt_t *opts, hid_t container1_id, hid_t container2_id, mcomp_t *members)
 {
     unsigned char  *mem1 = (unsigned char*) _mem1;
     unsigned char  *mem2 = (unsigned char*) _mem2;
@@ -425,7 +459,6 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
     size_t          offset;
     unsigned        nmembs;
     unsigned        j;
-    hsize_t         nelmts;
     size_t          size = 0;
     hbool_t         iszero1;
     hbool_t         iszero2;
@@ -434,10 +467,10 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
     hbool_t         both_zero;
     diff_err_t      ret_value = opts->err_stat;
 
-    H5TOOLS_START_DEBUG(" - errstat:%d", opts->err_stat);
+    H5TOOLS_START_DEBUG("ph:%d elemtno:%d - errstat:%d", opts->print_header, elemtno, opts->err_stat);
 
-    type_size = H5Tget_size(m_type);
-    type_class = H5Tget_class(m_type);
+    type_size = H5Tget_size(opts->m_tid);
+    type_class = H5Tget_class(opts->m_tid);
 
     /* Fast comparison first for atomic type by memcmp().
      * It is OK not to list non-atomic type here because it will not be caught
@@ -450,7 +483,7 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
             HDmemcmp(mem1, mem2, type_size) == 0)
         H5TOOLS_GOTO_DONE(opts->err_stat);
 
-    switch (H5Tget_class(m_type)) {
+    switch (H5Tget_class(opts->m_tid)) {
     case H5T_NO_CLASS:
     case H5T_TIME:
     case H5T_NCLASSES:
@@ -463,18 +496,22 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
      *-------------------------------------------------------------------------
      */
     case H5T_COMPOUND:
-        H5TOOLS_DEBUG("diff_datum H5T_COMPOUND");
+        H5TOOLS_DEBUG("H5T_COMPOUND");
         {
-            hid_t memb_type = H5I_INVALID_HID;
+            diff_opt_t cmpd_opts;
+
+            cmpd_opts = *opts;
             nmembs = members->n;
 
             for (j = 0; j < nmembs; j++) {
                 offset = members->offsets[j];
-                memb_type = members->ids[j];
+                cmpd_opts.m_tid = members->ids[j];
 
-                nfound += diff_datum(mem1 + offset, mem2 + offset, memb_type, idx,
-                        rank, dims, acc, pos, opts, obj1, obj2, container1_id, container2_id, ph, members->m[j]);
+                nfound += diff_datum(mem1 + offset, mem2 + offset, elemtno, &cmpd_opts, container1_id, container2_id, members->m[j]);
             }
+            opts->err_stat =  opts->err_stat | cmpd_opts.err_stat;
+            opts->print_header = cmpd_opts.print_header;
+            opts->not_cmp = cmpd_opts.not_cmp;
         }
         break;
 
@@ -483,7 +520,7 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
      *-------------------------------------------------------------------------
      */
     case H5T_STRING:
-        H5TOOLS_DEBUG("diff_datum H5T_STRING");
+        H5TOOLS_DEBUG("H5T_STRING");
         {
             char *s = NULL;
             char *sx = NULL;
@@ -492,12 +529,12 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
             size_t size1;
             size_t size2;
             size_t sizex;
-            size_t size_mtype = H5Tget_size(m_type);
-            H5T_str_t pad = H5Tget_strpad(m_type);
+            size_t size_mtype = H5Tget_size(opts->m_tid);
+            H5T_str_t pad = H5Tget_strpad(opts->m_tid);
 
             /* if variable length string */
-            if (H5Tis_variable_str(m_type)) {
-                H5TOOLS_DEBUG("diff_datum H5T_STRING variable");
+            if (H5Tis_variable_str(opts->m_tid)) {
+                H5TOOLS_DEBUG("H5T_STRING variable");
                 /* Get pointer to first string */
                 s1 = *(char **)((void *)mem1);
                 if (s1)
@@ -513,7 +550,7 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
                     size2 = 0;
             }
             else if (H5T_STR_NULLTERM == pad) {
-                H5TOOLS_DEBUG("diff_datum H5T_STRING null term");
+                H5TOOLS_DEBUG("H5T_STRING null term");
                 /* Get pointer to first string */
                 s1 = (char*) mem1;
                 if (s1)
@@ -550,10 +587,10 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
              *       of length of strings.
              *       For now mimic the previous way.
              */
-            H5TOOLS_DEBUG("diff_datum string size:%d", size1);
-            H5TOOLS_DEBUG("diff_datum string size:%d", size2);
+            H5TOOLS_DEBUG("string size:%d", size1);
+            H5TOOLS_DEBUG("string size:%d", size2);
             if (size1 != size2) {
-                H5TOOLS_DEBUG("diff_datum string sizes difference");
+                H5TOOLS_DEBUG("string sizes difference");
                 nfound++;
             }
             if (size1 < size2) {
@@ -572,15 +609,13 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
             /* check for NULL pointer for string */
             if (s != NULL) {
                 /* try fast compare first */
-                if (HDmemcmp(s, sx, size) == 0) {
-                    if (size1 != size2)
-                        if (print_data(opts))
-                            for (u = size; u < sizex; u++)
-                                character_compare(s + u, sx + u, idx, u, rank, dims, acc, pos, opts, obj1, obj2, ph);
+                if ((HDmemcmp(s, sx, size) == 0) && (size1 != size2)) {
+                    for (u = size; u < sizex; u++)
+                        character_compare(s + u, sx + u, elemtno, u, opts);
                 }
                 else
                     for (u = 0; u < size; u++)
-                        nfound += character_compare(s + u, sx + u, idx, u, rank, dims, acc, pos, opts, obj1, obj2, ph);
+                        nfound += character_compare(s + u, sx + u, elemtno, u, opts);
             } /* end check for NULL pointer for string */
         }
         break;
@@ -590,10 +625,10 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
      *-------------------------------------------------------------------------
      */
     case H5T_BITFIELD:
-        H5TOOLS_DEBUG("diff_datum H5T_BITFIELD");
+        H5TOOLS_DEBUG("H5T_BITFIELD");
         /* byte-by-byte comparison */
         for (u = 0; u < type_size; u++)
-            nfound += character_compare_opt(mem1 + u, mem2 + u, idx, rank, dims, acc, pos, opts, obj1, obj2, ph);
+            nfound += character_compare_opt(mem1 + u, mem2 + u, elemtno, opts);
         break;
 
     /*-------------------------------------------------------------------------
@@ -601,10 +636,10 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
      *-------------------------------------------------------------------------
      */
     case H5T_OPAQUE:
-        H5TOOLS_DEBUG("diff_datum H5T_OPAQUE");
+        H5TOOLS_DEBUG("H5T_OPAQUE");
         /* byte-by-byte comparison */
         for (u = 0; u < type_size; u++)
-            nfound += character_compare_opt(mem1 + u, mem2 + u, idx, rank, dims, acc, pos, opts, obj1, obj2, ph);
+            nfound += character_compare_opt(mem1 + u, mem2 + u, elemtno, opts);
         break;
 
     /*-------------------------------------------------------------------------
@@ -617,7 +652,7 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
          * compared, we convert both bit patterns to their corresponding
          * enumeration constant and do a string comparison
          */
-        H5TOOLS_DEBUG("diff_datum H5T_ENUM");
+        H5TOOLS_DEBUG("H5T_ENUM");
         {
             char enum_name1[1024];
             char enum_name2[1024];
@@ -629,11 +664,11 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
                 /* If the enum value cannot be converted to a string
                  * it is set to an error string for later output.
                  */
-                err1 = H5Tenum_nameof(m_type, mem1, enum_name1, sizeof enum_name1);
+                err1 = H5Tenum_nameof(opts->m_tid, mem1, enum_name1, sizeof enum_name1);
                 if (err1 < 0)
                     HDsnprintf(enum_name1, sizeof(enum_name1), "**INVALID VALUE**");
 
-                err2 = H5Tenum_nameof(m_type, mem2, enum_name2, sizeof enum_name2);
+                err2 = H5Tenum_nameof(opts->m_tid, mem2, enum_name2, sizeof enum_name2);
                 if (err2 < 0)
                     HDsnprintf(enum_name2, sizeof(enum_name2), "**INVALID VALUE**");
 
@@ -644,9 +679,9 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
                      * don't attempt to convert them - just report errors.
                      */
                     nfound += 1;
+                    opts->print_percentage = 0;
+                    print_pos(opts, elemtno, -1);
                     if (print_data(opts)) {
-                        print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
                         parallel_print(S_FORMAT, enum_name1, enum_name2);
                     }
                 }
@@ -654,15 +689,15 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
                     /* Both enum values were valid */
                     if (HDstrcmp(enum_name1, enum_name2) != 0) {
                         nfound = 1;
+                        opts->print_percentage = 0;
+                        print_pos(opts, elemtno, -1);
                         if (print_data(opts)) {
-                            print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                            parallel_print(SPACES);
                             parallel_print(S_FORMAT, enum_name1, enum_name2);
                         }
                     }
                     else {
                         for (u = 0; u < type_size; u++)
-                            nfound += character_compare_opt(mem1 + u, mem2 + u, idx, rank, dims, acc, pos, opts, obj1, obj2, ph);
+                            nfound += character_compare_opt(mem1 + u, mem2 + u, elemtno, opts);
                     }
                 }
                 /* enable error reporting */
@@ -676,26 +711,32 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
      */
     case H5T_ARRAY:
         {
-            hid_t   memb_type = H5I_INVALID_HID;
             hsize_t adims[H5S_MAX_RANK];
             int     ndims;
+            diff_opt_t arr_opts;
+
+            H5TOOLS_DEBUG("H5T_ARRAY ph=%d", opts->print_header);
 
-            H5TOOLS_DEBUG("diff_datum H5T_ARRAY");
+            arr_opts = *opts;
+            H5TOOLS_DEBUG("Check opts: hs_nelmts:%ld to %ld rank:%d to %ld", opts->hs_nelmts, arr_opts.hs_nelmts, opts->rank, arr_opts.rank);
             /* get the array's base datatype for each element */
-            memb_type = H5Tget_super(m_type);
-            size = H5Tget_size(memb_type);
-            ndims = H5Tget_array_ndims(m_type);
-            H5Tget_array_dims2(m_type, adims);
+            arr_opts.m_tid = H5Tget_super(opts->m_tid);
+            size = H5Tget_size(arr_opts.m_tid);
+            ndims = H5Tget_array_ndims(opts->m_tid);
+            H5Tget_array_dims2(opts->m_tid, adims);
             HDassert(ndims >= 1 && ndims <= H5S_MAX_RANK);
+            H5TOOLS_DEBUG("attr ph=%d", arr_opts.print_header);
 
             /* calculate the number of array elements */
-            for (u = 0, nelmts = 1; u < (unsigned) ndims; u++)
-                nelmts *= adims[u];
-            for (u = 0; u < nelmts; u++) {
-                nfound += diff_datum(mem1 + u * size, mem2 + u * size, memb_type, idx,
-                        rank, dims, acc, pos, opts, obj1, obj2, container1_id, container2_id, ph, members);
-            }
-            H5Tclose(memb_type);
+            for (u = 0, arr_opts.hs_nelmts = 1; u < (unsigned) ndims; u++)
+                arr_opts.hs_nelmts *= adims[u];
+            for (u = 0; u < arr_opts.hs_nelmts; u++) {
+                nfound += diff_datum(mem1 + u * size, mem2 + u * size, elemtno, &arr_opts, container1_id, container2_id, members);
+            }
+            opts->err_stat =  opts->err_stat | arr_opts.err_stat;
+            opts->print_header = arr_opts.print_header;
+            opts->not_cmp = arr_opts.not_cmp;
+            H5Tclose(arr_opts.m_tid);
         }
         break;
 
@@ -704,9 +745,9 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
      *-------------------------------------------------------------------------
      */
     case H5T_REFERENCE:
-        H5TOOLS_DEBUG("diff_datum H5T_REFERENCE");
-        iszero1 = all_zero(_mem1, H5Tget_size(m_type));
-        iszero2 = all_zero(_mem2, H5Tget_size(m_type));
+        H5TOOLS_DEBUG("H5T_REFERENCE");
+        iszero1 = all_zero(_mem1, H5Tget_size(opts->m_tid));
+        iszero2 = all_zero(_mem2, H5Tget_size(opts->m_tid));
         if (iszero1 != iszero2) {
             nfound++;
             H5TOOLS_GOTO_DONE(opts->err_stat);
@@ -714,13 +755,17 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
         else if (!iszero1 && !iszero2) {
             hid_t obj1_id = H5I_INVALID_HID;
             hid_t obj2_id = H5I_INVALID_HID;
+            diff_opt_t ref_opts;
 
             /*-------------------------------------------------------------------------
              * H5T_STD_REF
              * Reference
              *-------------------------------------------------------------------------
              */
-            if (H5Tequal(m_type, H5T_STD_REF)) {
+            ref_opts = *opts;
+            ref_opts.obj_name[0] = NULL;
+            ref_opts.obj_name[1] = NULL;
+            if (H5Tequal(ref_opts.m_tid, H5T_STD_REF)) {
                 /* if (type_size == H5R_STD_REF_SIZE) */
                 hid_t region1_id = H5I_INVALID_HID;
                 hid_t region2_id = H5I_INVALID_HID;
@@ -730,66 +775,67 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
                 H5O_type_t obj2_type = -1;   /* Object type */
                 H5R_type_t ref_type;   /* Reference type */
 
-                H5TOOLS_DEBUG("diff_datum H5T_REFERENCE - H5T_STD_REF");
+                H5TOOLS_DEBUG("H5T_REFERENCE - H5T_STD_REF");
                 ref_type = H5Rget_type(ref1_buf);
                 switch (ref_type) {
                     case H5R_OBJECT1:
                         H5TOOLS_DEBUG("ref_type is H5R_OBJECT1");
-                        if (H5Rget_obj_type3(ref1_buf, H5P_DEFAULT, &obj1_type) < 0) {
-                            opts->err_stat = H5DIFF_ERR;
-                            H5TOOLS_INFO("H5Rget_obj_type3 object 1 failed");
-                        }
-                        if (H5Rget_obj_type3(ref2_buf, H5P_DEFAULT, &obj2_type) < 0) {
-                            opts->err_stat = H5DIFF_ERR;
-                            H5TOOLS_INFO("H5Rget_obj_type3 object 2 failed");
-                        }
-
-                        /* check object type */
-                        if (obj1_type != obj2_type) {
-                            parallel_print("Different object types referenced: <%s> and <%s>", obj1, obj2);
-                            opts->not_cmp = 1;
-                            H5TOOLS_GOTO_DONE(opts->err_stat);
-                        }
-
-                        if((obj1_id = H5Ropen_object(ref1_buf, H5P_DEFAULT, H5P_DEFAULT)) < 0) {
-                            opts->err_stat = H5DIFF_ERR;
-                            H5TOOLS_INFO("H5Ropen_object object 1 failed");
-                        }
-                        if((obj2_id = H5Ropen_object(ref2_buf, H5P_DEFAULT, H5P_DEFAULT)) < 0) {
-                            opts->err_stat = H5DIFF_ERR;
-                            H5TOOLS_INFO("H5Ropen_object object 2 failed");
-                        }
-
-                        switch (obj1_type) {
-                            case H5O_TYPE_DATASET:
-                                nfound = diff_datasetid(obj1_id, obj2_id, NULL, NULL, opts);
-                                break;
-
-                            case H5O_TYPE_GROUP:
-                            case H5O_TYPE_NAMED_DATATYPE:
-                            case H5O_TYPE_MAP:
-                            case H5O_TYPE_UNKNOWN:
-                            case H5O_TYPE_NTYPES:
-                            default:
-                                if (opts->m_verbose)
-                                    parallel_print("Warning: Comparison not possible of object types referenced: <%s> and <%s>\n", obj1, obj2);
-                                opts->not_cmp = 1;
-                                break;
-                        } /* end switch */
-                        if(obj1_id >= 0)
-                            if(H5Oclose(obj1_id) < 0) {
-                                opts->err_stat = H5DIFF_ERR;
-                                H5TOOLS_INFO("H5Oclose H5R_OBJECT1 failed");
+                        if (H5Rget_obj_type3(ref1_buf, H5P_DEFAULT, &obj1_type) >= 0) {
+                            if (H5Rget_obj_type3(ref2_buf, H5P_DEFAULT, &obj2_type) >= 0) {
+                                /* check object type */
+                                if (obj1_type == obj2_type) {
+                                    switch (obj1_type) {
+                                        case H5O_TYPE_DATASET:
+                                            if((obj1_id = H5Ropen_object(ref1_buf, H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
+                                                if((obj2_id = H5Ropen_object(ref2_buf, H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
+                                                    nfound = diff_datasetid(obj1_id, obj2_id, opts->obj_name[0], opts->obj_name[1], &ref_opts);
+                                                    if(H5Dclose(obj2_id) < 0) {
+                                                        ref_opts.err_stat = H5DIFF_ERR;
+                                                        H5TOOLS_INFO("H5Dclose H5R_OBJECT1 failed");
+                                                    }
+                                                }
+                                                else {
+                                                    ref_opts.err_stat = H5DIFF_ERR;
+                                                    H5TOOLS_INFO("H5Ropen_object object 2 failed");
+                                                }
+                                                if(H5Dclose(obj1_id) < 0) {
+                                                    ref_opts.err_stat = H5DIFF_ERR;
+                                                    H5TOOLS_INFO("H5Dclose H5R_OBJECT1 failed");
+                                                }
+                                            }
+                                            else {
+                                                ref_opts.err_stat = H5DIFF_ERR;
+                                                H5TOOLS_INFO("H5Ropen_object object 1 failed");
+                                            }
+                                            break;
+
+                                        case H5O_TYPE_GROUP:
+                                        case H5O_TYPE_NAMED_DATATYPE:
+                                        case H5O_TYPE_MAP:
+                                        case H5O_TYPE_UNKNOWN:
+                                        case H5O_TYPE_NTYPES:
+                                        default:
+                                            if (ref_opts.mode_verbose)
+                                                parallel_print("Warning: Comparison not possible of object types referenced: <%s> and <%s>\n", opts->obj_name[0], opts->obj_name[1]);
+                                            ref_opts.not_cmp = 1;
+                                            break;
+                                    } /* end switch */
+                                }
+                                else {
+                                    parallel_print("Different object types referenced: <%s> and <%s>", opts->obj_name[0], opts->obj_name[1]);
+                                    ref_opts.not_cmp = 1;
+                                    ref_opts.err_stat = H5DIFF_ERR;
+                                }
                             }
-                        if(obj2_id >= 0)
-                            if(H5Oclose(obj2_id) < 0) {
-                                opts->err_stat = H5DIFF_ERR;
-                                H5TOOLS_INFO("H5Oclose H5R_OBJECT1 failed");
+                            else {
+                                ref_opts.err_stat = H5DIFF_ERR;
+                                H5TOOLS_INFO("H5Rget_obj_type3 object 2 failed");
                             }
-                        if(H5Rdestroy(ref2_buf) < 0)
-                            H5TOOLS_ERROR(H5DIFF_ERR, "H5Rdestroy H5R_OBJECT1 failed");
-                        if(H5Rdestroy(ref1_buf) < 0)
-                            H5TOOLS_ERROR(H5DIFF_ERR, "H5Rdestroy H5R_OBJECT1 failed");
+                        }
+                        else {
+                            ref_opts.err_stat = H5DIFF_ERR;
+                            H5TOOLS_INFO("H5Rget_obj_type3 object 1 failed");
+                        }
                         break;
                     case H5R_DATASET_REGION1:
                         H5TOOLS_DEBUG("ref_type is H5R_DATASET_REGION1");
@@ -797,149 +843,143 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
                             if((obj2_id = H5Ropen_object(ref2_buf, H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
                                 if((region1_id = H5Ropen_region(ref1_buf, H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
                                     if((region2_id = H5Ropen_region(ref2_buf, H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
-                                        nfound = diff_region(obj1_id, obj2_id, region1_id, region2_id, opts);
+                                        nfound = diff_region(obj1_id, obj2_id, region1_id, region2_id, &ref_opts);
                                         if(H5Sclose(region2_id) < 0)
-                                            H5TOOLS_ERROR(H5DIFF_ERR, "H5Sclose H5R_DATASET_REGION1 failed");
+                                            H5TOOLS_INFO("H5Sclose H5R_DATASET_REGION1 failed");
                                     }
                                     if(H5Sclose(region1_id) < 0)
-                                        H5TOOLS_ERROR(H5DIFF_ERR, "H5Sclose H5R_DATASET_REGION1 failed");
+                                        H5TOOLS_INFO("H5Sclose H5R_DATASET_REGION1 failed");
                                 }
-                                if(H5Oclose(obj2_id) < 0)
-                                    H5TOOLS_ERROR(H5DIFF_ERR, "H5Oclose H5R_DATASET_REGION1 failed");
+                                if(H5Dclose(obj2_id) < 0)
+                                    H5TOOLS_INFO("H5Oclose H5R_DATASET_REGION1 failed");
                             }
                             else {
-                                H5TOOLS_ERROR(H5DIFF_ERR, "H5Ropen_object H5R_DATASET_REGION1 failed");
+                                H5TOOLS_INFO("H5Ropen_object H5R_DATASET_REGION1 failed");
                             }
-                            if(H5Oclose(obj1_id) < 0)
-                                H5TOOLS_ERROR(H5DIFF_ERR, "H5Oclose H5R_DATASET_REGION1 failed");
+                            if(H5Dclose(obj1_id) < 0)
+                                H5TOOLS_INFO("H5Oclose H5R_DATASET_REGION1 failed");
                         }
                         else {
-                            H5TOOLS_ERROR(H5DIFF_ERR, "H5Ropen_object H5R_DATASET_REGION1 failed");
+                            H5TOOLS_INFO("H5Ropen_object H5R_DATASET_REGION1 failed");
                         }
-                        if(H5Rdestroy(ref2_buf) < 0)
-                            H5TOOLS_ERROR(H5DIFF_ERR, "H5Rdestroy H5R_DATASET_REGION1 failed");
-                        if(H5Rdestroy(ref1_buf) < 0)
-                            H5TOOLS_ERROR(H5DIFF_ERR, "H5Rdestroy H5R_DATASET_REGION1 failed");
                         break;
                     case H5R_OBJECT2:
                         H5TOOLS_DEBUG("ref_type is H5R_OBJECT2");
-                        if (H5Rget_obj_type3(ref1_buf, H5P_DEFAULT, &obj1_type) < 0) {
-                            opts->err_stat = H5DIFF_ERR;
-                            H5TOOLS_INFO("H5Rget_obj_type3 object 1 failed");
-                        }
-                        if (H5Rget_obj_type3(ref2_buf, H5P_DEFAULT, &obj2_type) < 0) {
-                            opts->err_stat = H5DIFF_ERR;
-                            H5TOOLS_INFO("H5Rget_obj_type3 object 2 failed");
-                        }
-
-                        /* check object type */
-                        if (obj1_type != obj2_type) {
-                            parallel_print("Different object types referenced: <%s> and <%s>", obj1, obj2);
-                            opts->not_cmp = 1;
-                            H5TOOLS_GOTO_DONE(opts->err_stat);
-                        }
-
-                        if((obj1_id = H5Ropen_object(ref1_buf, H5P_DEFAULT, H5P_DEFAULT)) < 0) {
-                            opts->err_stat = H5DIFF_ERR;
-                            H5TOOLS_INFO("H5Ropen_object object 1 failed");
-                        }
-                        if((obj2_id = H5Ropen_object(ref2_buf, H5P_DEFAULT, H5P_DEFAULT)) < 0) {
-                            opts->err_stat = H5DIFF_ERR;
-                            H5TOOLS_INFO("H5Ropen_object object 2 failed");
-                        }
-
-                        switch (obj1_type) {
-                            case H5O_TYPE_DATASET:
-                                H5TOOLS_DEBUG("ref_type is H5R_OBJECT2 : DATASET");
-                                nfound = diff_datasetid(obj1_id, obj2_id, NULL, NULL, opts);
-                                break;
-
-                            case H5O_TYPE_GROUP:
-                                H5TOOLS_DEBUG("ref_type is H5R_OBJECT2 : GROUP");
-                                if (opts->m_verbose)
-                                    parallel_print("Warning: Comparison not possible of group object types referenced: <%s> and <%s>\n", obj1, obj2);
-                                opts->not_cmp = 1;
-                                break;
-
-                            case H5O_TYPE_NAMED_DATATYPE:
-                                H5TOOLS_DEBUG("ref_type is H5R_OBJECT2 : NAMED");
-                                if (opts->m_verbose)
-                                    parallel_print("Warning: Comparison not possible of named datatypes object types referenced: <%s> and <%s>\n", obj1, obj2);
-                                opts->not_cmp = 1;
-                                break;
-
-                            case H5O_TYPE_MAP:
-                            case H5O_TYPE_UNKNOWN:
-                            case H5O_TYPE_NTYPES:
-                            default:
-                                if (opts->m_verbose)
-                                    parallel_print("Warning: Comparison not possible of object types referenced: <%s> and <%s>\n", obj1, obj2);
-                                opts->not_cmp = 1;
-                                break;
-                        } /* end switch */
-                        if(obj1_id >= 0)
-                            if(H5Oclose(obj1_id) < 0) {
-                                opts->err_stat = H5DIFF_ERR;
-                                H5TOOLS_INFO("H5Oclose H5R_OBJECT2 failed");
+                        if (H5Rget_obj_type3(ref1_buf, H5P_DEFAULT, &obj1_type) >= 0) {
+                            if (H5Rget_obj_type3(ref2_buf, H5P_DEFAULT, &obj2_type) >= 0) {
+                                /* check object type */
+                                if (obj1_type == obj2_type) {
+                                    if((obj1_id = H5Ropen_object(ref1_buf, H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
+                                        if((obj2_id = H5Ropen_object(ref2_buf, H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
+                                            switch (obj1_type) {
+                                                case H5O_TYPE_DATASET:
+                                                    H5TOOLS_DEBUG("ref_type is H5R_OBJECT2 : DATASET");
+                                                    nfound = diff_datasetid(obj1_id, obj2_id, opts->obj_name[0], opts->obj_name[1], &ref_opts);
+                                                    break;
+
+                                                case H5O_TYPE_GROUP:
+                                                    H5TOOLS_DEBUG("ref_type is H5R_OBJECT2 : GROUP");
+                                                    if (ref_opts.mode_verbose)
+                                                        parallel_print("Warning: Comparison not possible of group object types referenced: <%s> and <%s>\n", opts->obj_name[0], opts->obj_name[1]);
+                                                    ref_opts.not_cmp = 1;
+                                                    break;
+
+                                                case H5O_TYPE_NAMED_DATATYPE:
+                                                    H5TOOLS_DEBUG("ref_type is H5R_OBJECT2 : NAMED");
+                                                    if (ref_opts.mode_verbose)
+                                                        parallel_print("Warning: Comparison not possible of named datatypes object types referenced: <%s> and <%s>\n", opts->obj_name[0], opts->obj_name[1]);
+                                                    ref_opts.not_cmp = 1;
+                                                    break;
+
+                                                case H5O_TYPE_MAP:
+                                                case H5O_TYPE_UNKNOWN:
+                                                case H5O_TYPE_NTYPES:
+                                                default:
+                                                    if (ref_opts.mode_verbose)
+                                                        parallel_print("Warning: Comparison not possible of object types referenced: <%s> and <%s>\n", opts->obj_name[0], opts->obj_name[1]);
+                                                    ref_opts.not_cmp = 1;
+                                                    break;
+                                            } /* end switch */
+                                            if(H5Oclose(obj2_id) < 0) {
+                                                ref_opts.err_stat = H5DIFF_ERR;
+                                                H5TOOLS_INFO("H5Oclose H5R_OBJECT2 failed");
+                                            }
+                                        }
+                                        else {
+                                            ref_opts.err_stat = H5DIFF_ERR;
+                                            H5TOOLS_INFO("H5Ropen_object object 2 failed");
+                                        }
+                                        if(H5Oclose(obj1_id) < 0) {
+                                            ref_opts.err_stat = H5DIFF_ERR;
+                                            H5TOOLS_INFO("H5Oclose H5R_OBJECT2 failed");
+                                        }
+                                    }
+                                    else {
+                                        ref_opts.err_stat = H5DIFF_ERR;
+                                        H5TOOLS_INFO("H5Ropen_object object 1 failed");
+                                    }
+                                }
+                                else {
+                                    parallel_print("Different object types referenced: <%s> and <%s>", opts->obj_name[0], opts->obj_name[1]);
+                                    ref_opts.not_cmp = 1;
+                                    ref_opts.err_stat = H5DIFF_ERR;
+                                }
                             }
-                        if(obj2_id >= 0)
-                            if(H5Oclose(obj2_id) < 0) {
-                                opts->err_stat = H5DIFF_ERR;
-                                H5TOOLS_INFO("H5Oclose H5R_OBJECT2 failed");
+                            else {
+                                ref_opts.err_stat = H5DIFF_ERR;
+                                H5TOOLS_INFO("H5Rget_obj_type3 object 2 failed");
                             }
-                        if(H5Rdestroy(ref2_buf) < 0)
-                            H5TOOLS_ERROR(H5DIFF_ERR, "H5Rdestroy H5R_OBJECT2 failed");
-                        if(H5Rdestroy(ref1_buf) < 0)
-                            H5TOOLS_ERROR(H5DIFF_ERR, "H5Rdestroy H5R_OBJECT2 failed");
+                        }
+                        else {
+                            ref_opts.err_stat = H5DIFF_ERR;
+                            H5TOOLS_INFO("H5Rget_obj_type3 object 1 failed");
+                        }
                         break;
                     case H5R_DATASET_REGION2:
                         H5TOOLS_DEBUG("ref_type is H5R_DATASET_REGION2");
 
                         /* if (obj_id < 0) - could mean that no reference was written do not throw failure */
-                        obj1_id = H5Ropen_object(ref1_buf, H5P_DEFAULT, H5P_DEFAULT);
-                        obj2_id = H5Ropen_object(ref2_buf, H5P_DEFAULT, H5P_DEFAULT);
-                        if((obj1_id  < 0) || (obj2_id  < 0)) {
-                            H5TOOLS_INFO("H5Ropen_object H5R_DATASET_REGION2 failed");
+                        if((obj1_id = H5Ropen_object(ref1_buf, H5P_DEFAULT, H5P_DEFAULT)) < 0) {
+                            H5TOOLS_INFO("H5Ropen_object H5R_DATASET_REGION2 object 1 failed");
                         }
                         else {
-                            H5TOOLS_DEBUG("open_region - H5R_DATASET_REGION2");
-                            if((region1_id = H5Ropen_region(ref1_buf, H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
-                                if (h5tools_is_zero(ref1_buf, H5Tget_size(H5T_STD_REF))) {
-                                    H5TOOLS_DEBUG("NULL H5R_DATASET_REGION2");
-                                }
-                                else {
-                                    if((region2_id = H5Ropen_region(ref2_buf, H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
-                                        if (h5tools_is_zero(ref2_buf, H5Tget_size(H5T_STD_REF))) {
-                                            H5TOOLS_DEBUG("NULL H5R_DATASET_REGION2");
-                                        }
-                                        else {
-                                            nfound = diff_region(obj1_id, obj2_id, region1_id, region2_id, opts);
-                                        }
-                                        if(H5Sclose(region2_id) < 0)
-                                            H5TOOLS_ERROR(H5DIFF_ERR, "H5Sclose H5R_DATASET_REGION2 failed");
+                            if((obj2_id = H5Ropen_object(ref2_buf, H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
+                                H5TOOLS_DEBUG("open_region - H5R_DATASET_REGION2");
+                                if((region1_id = H5Ropen_region(ref1_buf, H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
+                                    if (h5tools_is_zero(ref1_buf, H5Tget_size(H5T_STD_REF))) {
+                                        H5TOOLS_DEBUG("NULL H5R_DATASET_REGION2");
                                     }
-                                    else
-                                        H5TOOLS_ERROR(H5DIFF_ERR, "H5Ropen_region H5R_DATASET_REGION2 failed");
-                                } /* end else to if (h5tools_is_zero(... */
-                                if(H5Sclose(region1_id) < 0)
-                                    H5TOOLS_ERROR(H5DIFF_ERR, "H5Sclose H5R_DATASET_REGION2 failed");
-                            }
-                            else
-                                H5TOOLS_ERROR(H5DIFF_ERR, "H5Ropen_region H5R_DATASET_REGION2 failed");
-                            if (obj1_id >= 0)
-                                if(H5Dclose(obj1_id) < 0) {
-                                    opts->err_stat = H5DIFF_ERR;
-                                    H5TOOLS_INFO("H5Dclose H5R_DATASET_REGION2 failed");
+                                    else {
+                                        if((region2_id = H5Ropen_region(ref2_buf, H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
+                                            if (h5tools_is_zero(ref2_buf, H5Tget_size(H5T_STD_REF))) {
+                                                H5TOOLS_DEBUG("NULL H5R_DATASET_REGION2");
+                                            }
+                                            else {
+                                                nfound = diff_region(obj1_id, obj2_id, region1_id, region2_id, &ref_opts);
+                                            }
+                                            if(H5Sclose(region2_id) < 0)
+                                                H5TOOLS_INFO("H5Sclose H5R_DATASET_REGION2 failed");
+                                        }
+                                        else
+                                            H5TOOLS_INFO("H5Ropen_region H5R_DATASET_REGION2 failed");
+                                    } /* end else to if (h5tools_is_zero(... */
+                                    if(H5Sclose(region1_id) < 0)
+                                        H5TOOLS_INFO("H5Sclose H5R_DATASET_REGION2 failed");
                                 }
-                            if (obj2_id >= 0)
+                                else
+                                    H5TOOLS_ERROR(H5DIFF_ERR, "H5Ropen_region H5R_DATASET_REGION2 failed");
                                 if(H5Dclose(obj2_id) < 0) {
-                                    opts->err_stat = H5DIFF_ERR;
+                                    ref_opts.err_stat = H5DIFF_ERR;
                                     H5TOOLS_INFO("H5Dclose H5R_DATASET_REGION2 failed");
                                 }
-                            if(H5Rdestroy(ref1_buf) < 0)
-                                H5TOOLS_ERROR(H5DIFF_ERR, "H5Rdestroy H5R_DATASET_REGION2 failed");
-                            if(H5Rdestroy(ref2_buf) < 0)
-                                H5TOOLS_ERROR(H5DIFF_ERR, "H5Rdestroy H5R_DATASET_REGION2 failed");
+                            }
+                            else {
+                                H5TOOLS_INFO("H5Ropen_object H5R_DATASET_REGION2 object 2 failed");
+                            }
+                            if(H5Dclose(obj1_id) < 0) {
+                                ref_opts.err_stat = H5DIFF_ERR;
+                                H5TOOLS_INFO("H5Dclose H5R_DATASET_REGION2 failed");
+                            }
                         }
                         break;
                     case H5R_ATTR:
@@ -948,44 +988,42 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
                             char       name2[ATTR_NAME_MAX];
 
                             H5TOOLS_DEBUG("ref_type is H5R_ATTR");
-                            if((obj1_id = H5Ropen_attr(ref1_buf, H5P_DEFAULT, H5P_DEFAULT)) < 0) {
-                                parallel_print("Warning: Cannot open referenced attribute: attribute 1\n");
-                                H5TOOLS_INFO("H5Ropen_attr object 1 failed");
-                            }
-                            if((obj2_id = H5Ropen_attr(ref2_buf, H5P_DEFAULT, H5P_DEFAULT)) < 0) {
-                                parallel_print("Warning: Cannot open referenced attribute: attribute 2\n");
-                                H5TOOLS_INFO("H5Ropen_attr object 2 failed");
-                            }
-
-                            if((obj1_id < 0) || (obj2_id < 0)) {
-                                H5TOOLS_INFO("H5Ropen_attr H5R_ATTR failed");
-                            }
-                            else {
-                                /* get name */
-                                if(H5Aget_name(obj1_id, (size_t)ATTR_NAME_MAX, name1) < 0)
-                                    H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Aget_name first attribute failed");
-                                /* get name */
-                                if(H5Aget_name(obj2_id, (size_t)ATTR_NAME_MAX, name2) < 0)
-                                    H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Aget_name second attribute failed");
-
-                                H5TOOLS_DEBUG("H5R_ATTR diff_attr_data - name1=%s, name2=%s", name1, name2);
-                                nfound = diff_attr_data(obj1_id, obj2_id, name1, name2, NULL, NULL, opts);
-                            }
+                            if((obj1_id = H5Ropen_attr(ref1_buf, H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
+                                if((obj2_id = H5Ropen_attr(ref2_buf, H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
+                                    /* get name */
+                                    if(H5Aget_name(obj1_id, (size_t)ATTR_NAME_MAX, name1) >= 0) {
+                                        /* get name */
+                                        if(H5Aget_name(obj2_id, (size_t)ATTR_NAME_MAX, name2) >= 0) {
+                                            H5TOOLS_DEBUG("H5R_ATTR diff_attr_data - name1=%s, name2=%s", name1, name2);
+                                            nfound = diff_attr_data(obj1_id, obj2_id, name1, name2, opts->obj_name[0], opts->obj_name[1], &ref_opts);
+                                        }
+                                        else {
+                                            ref_opts.err_stat = H5DIFF_ERR;
+                                            H5TOOLS_INFO("H5Aget_name second attribute failed");
+                                        }
+                                    }
+                                    else {
+                                        ref_opts.err_stat = H5DIFF_ERR;
+                                        H5TOOLS_INFO("H5Aget_name first attribute failed");
+                                    }
 
-                            if(obj1_id >= 0)
-                                if(H5Aclose(obj1_id) < 0) {
-                                    opts->err_stat = H5DIFF_ERR;
-                                    H5TOOLS_INFO("H5Aclose H5R_ATTR failed");
+                                    if(H5Aclose(obj2_id) < 0) {
+                                        ref_opts.err_stat = H5DIFF_ERR;
+                                        H5TOOLS_INFO("H5Aclose H5R_ATTR failed");
+                                    }
+                                }
+                                else {
+                                    parallel_print("Warning: Cannot open referenced attribute2\n");
+                                    H5TOOLS_INFO("H5Ropen_attr object 2 failed");
                                 }
-                            if(obj2_id >= 0)
-                                if(H5Aclose(obj2_id) < 0) {
-                                    opts->err_stat = H5DIFF_ERR;
+                                if(H5Aclose(obj1_id) < 0) {
                                     H5TOOLS_INFO("H5Aclose H5R_ATTR failed");
                                 }
-                            if(H5Rdestroy(ref2_buf) < 0)
-                                H5TOOLS_ERROR(H5DIFF_ERR, "H5Rdestroy H5R_ATTR failed");
-                            if(H5Rdestroy(ref1_buf) < 0)
-                                H5TOOLS_ERROR(H5DIFF_ERR, "H5Rdestroy H5R_ATTR failed");
+                            }
+                            else {
+                                parallel_print("Warning: Cannot open referenced attribute1\n");
+                                H5TOOLS_INFO("H5Ropen_attr object 1 failed");
+                            }
                         }
                         break;
                     case H5R_BADTYPE:
@@ -993,43 +1031,20 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
                     default:
                         break;
                 } /* end switch */
-                H5TOOLS_DEBUG("diff_datum H5T_REFERENCE - H5T_STD_REF complete nfound:%d - errstat:%d", nfound, opts->err_stat);
+                if(H5Rdestroy(ref2_buf) < 0)
+                    H5TOOLS_INFO("H5Rdestroy H5R_OBJECT1 failed");
+                if(H5Rdestroy(ref1_buf) < 0)
+                    H5TOOLS_INFO("H5Rdestroy H5R_OBJECT1 failed");
+                H5TOOLS_DEBUG("H5T_REFERENCE - H5T_STD_REF complete nfound:%d - errstat:%d", nfound, ref_opts.err_stat);
             }
             /*-------------------------------------------------------------------------
              * H5T_STD_REF_DSETREG
              * Dataset region reference
              *-------------------------------------------------------------------------
              */
-            else if (H5Tequal(m_type, H5T_STD_REF_DSETREG)) {
+            else if (H5Tequal(ref_opts.m_tid, H5T_STD_REF_DSETREG)) {
                 /* if (type_size == H5R_DSET_REG_REF_BUF_SIZE) */
-                hid_t region1_id = H5I_INVALID_HID;
-                hid_t region2_id = H5I_INVALID_HID;
-
-                H5TOOLS_INFO("H5T_STD_REF_DSETREG reference type");
-
-                if ((obj1_id = H5Rdereference2(container1_id, H5P_DEFAULT, H5R_DATASET_REGION, _mem1)) < 0) {
-                    opts->err_stat = H5DIFF_ERR;
-                    H5TOOLS_INFO("H5Rdereference2 object 1 failed");
-                }
-                if ((obj2_id = H5Rdereference2(container2_id, H5P_DEFAULT, H5R_DATASET_REGION, _mem2)) < 0) {
-                    opts->err_stat = H5DIFF_ERR;
-                    H5TOOLS_INFO("H5Rdereference2 object 2 failed");
-                }
-                if ((region1_id = H5Rget_region(container1_id, H5R_DATASET_REGION, _mem1)) < 0) {
-                    opts->err_stat = H5DIFF_ERR;
-                    H5TOOLS_INFO("H5Rget_region object 1 failed");
-                }
-                if ((region2_id = H5Rget_region(container2_id, H5R_DATASET_REGION, _mem2)) < 0) {
-                    opts->err_stat = H5DIFF_ERR;
-                    H5TOOLS_INFO("H5Rget_region object 2 failed");
-                }
-
-                nfound = diff_region(obj1_id, obj2_id, region1_id, region2_id, opts);
-
-                H5Oclose(obj1_id);
-                H5Oclose(obj2_id);
-                H5Sclose(region1_id);
-                H5Sclose(region2_id);
+                H5TOOLS_DEBUG("H5T_STD_REF_DSETREG");
             }/*dataset reference*/
 
             /*-------------------------------------------------------------------------
@@ -1037,52 +1052,15 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
              * Object references. get the type and OID of the referenced object
              *-------------------------------------------------------------------------
              */
-            else if (H5Tequal(m_type, H5T_STD_REF_OBJ)) {
+            else if (H5Tequal(ref_opts.m_tid, H5T_STD_REF_OBJ)) {
                 /* if (type_size == H5R_OBJ_REF_BUF_SIZE) */
-                H5O_type_t obj1_type;
-                H5O_type_t obj2_type;
-
-                H5TOOLS_INFO("H5T_STD_REF_OBJ reference type");
-
-                if (H5Rget_obj_type2(container1_id, H5R_OBJECT, _mem1, &obj1_type) < 0) {
-                    opts->err_stat = H5DIFF_ERR;
-                    H5TOOLS_INFO("H5Rget_obj_type2 object 1 failed");
-                }
-                if (H5Rget_obj_type2(container2_id, H5R_OBJECT, _mem2, &obj2_type) < 0) {
-                    opts->err_stat = H5DIFF_ERR;
-                    H5TOOLS_INFO("H5Rget_obj_type2 object 2 failed");
-                }
-
-                /* check object type */
-                if (obj1_type != obj2_type) {
-                    parallel_print("Different object types referenced: <%s> and <%s>", obj1, obj2);
-                    opts->not_cmp = 1;
-                    H5TOOLS_GOTO_DONE(opts->err_stat);
-                }
-
-                if ((obj1_id = H5Rdereference2(container1_id, H5P_DEFAULT, H5R_OBJECT, _mem1)) < 0) {
-                    opts->err_stat = H5DIFF_ERR;
-                    H5TOOLS_INFO("H5Rdereference2 object 1 failed");
-                }
-                if ((obj2_id = H5Rdereference2(container2_id, H5P_DEFAULT, H5R_OBJECT, _mem2)) < 0) {
-                    opts->err_stat = H5DIFF_ERR;
-                    H5TOOLS_INFO("H5Rdereference2 object 2 failed");
-                }
-
-                /* compare */
-                if (obj1_type == H5O_TYPE_DATASET)
-                    nfound = diff_datasetid(obj1_id, obj2_id, NULL, NULL, opts);
-                else {
-                    if (opts->m_verbose)
-                        parallel_print("Warning: Comparison not possible of object types referenced: <%s> and <%s>\n", obj1, obj2);
-                    opts->not_cmp = 1;
-                }
-
-                H5Oclose(obj1_id);
-                H5Oclose(obj2_id);
+                H5TOOLS_DEBUG("H5T_STD_REF_OBJ");
             }/*object reference*/
+            opts->print_header = ref_opts.print_header;
+            opts->not_cmp = ref_opts.not_cmp;
+            opts->err_stat = ref_opts.err_stat | ret_value;
         }/*is zero*/
-        H5TOOLS_DEBUG("diff_datum H5T_REFERENCE complete");
+        H5TOOLS_DEBUG("H5T_REFERENCE complete");
         break;
 
     /*-------------------------------------------------------------------------
@@ -1091,21 +1069,26 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
      */
     case H5T_VLEN:
         {
-            hid_t memb_type = H5I_INVALID_HID;
+            diff_opt_t vl_opts;
 
-            H5TOOLS_DEBUG("diff_datum H5T_VLEN");
+            H5TOOLS_DEBUG("H5T_VLEN");
+
+            vl_opts = *opts;
             /* get the VL sequences's base datatype for each element */
-            memb_type = H5Tget_super(m_type);
-            size = H5Tget_size(memb_type);
+            vl_opts.m_tid = H5Tget_super(opts->m_tid);
+            size = H5Tget_size(vl_opts.m_tid);
 
             /* get the number of sequence elements */
-            nelmts = ((hvl_t *)((void *)mem1))->len;
+            vl_opts.hs_nelmts = ((hvl_t *)((void *)mem1))->len;
 
-            for (j = 0; j < nelmts; j++)
-                nfound += diff_datum(((char *) (((hvl_t *)((void *)mem1))->p)) + j * size, ((char *) (((hvl_t *)((void *)mem2))->p)) + j * size, memb_type, idx,      /* Extra (void *) cast to quiet "cast to create alignment" warning - 2019/07/05, QAK */
-                        rank, dims, acc, pos, opts, obj1, obj2, container1_id, container2_id, ph, members);
+            for (j = 0; j < vl_opts.hs_nelmts; j++)
+                nfound += diff_datum(((char *) (((hvl_t *)((void *)mem1))->p)) + j * size, ((char *) (((hvl_t *)((void *)mem2))->p)) + j * size, elemtno,      /* Extra (void *) cast to quiet "cast to create alignment" warning - 2019/07/05, QAK */
+                        &vl_opts, container1_id, container2_id, members);
+            opts->print_header = vl_opts.print_header;
+            opts->not_cmp = vl_opts.not_cmp;
+            opts->err_stat =  opts->err_stat | vl_opts.err_stat;
 
-            H5Tclose(memb_type);
+            H5Tclose(vl_opts.m_tid);
         }
         break;
 
@@ -1114,81 +1097,16 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
      *-------------------------------------------------------------------------
      */
     case H5T_INTEGER:
-        H5TOOLS_DEBUG("diff_datum H5T_INTEGER");
-        type_sign = H5Tget_sign(m_type);
+        H5TOOLS_DEBUG("H5T_INTEGER");
+        type_sign = H5Tget_sign(opts->m_tid);
         /*-------------------------------------------------------------------------
          * H5T_NATIVE_SCHAR
          *-------------------------------------------------------------------------
          */
         if (type_size == 1 && type_sign != H5T_SGN_NONE) {
-            char temp1_char;
-            char temp2_char;
-
             if(type_size != sizeof(char))
                 H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "Type size is not char size");
-            HDmemcpy(&temp1_char, mem1, sizeof(char));
-            HDmemcpy(&temp2_char, mem2, sizeof(char));
-            /* -d and !-p */
-            if (opts->d && !opts->p) {
-                if (ABS(temp1_char-temp2_char) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT, temp1_char, temp2_char, ABS(temp1_char - temp2_char));
-                    }
-                    nfound++;
-                }
-            }
-            /* !-d and -p */
-            else if (!opts->d && opts->p) {
-                PER(temp1_char, temp2_char);
-
-                if (not_comparable && !both_zero) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT_P_NOTCOMP, temp1_char, temp2_char, ABS(temp1_char - temp2_char));
-                    }
-                    nfound++;
-                }
-                else if (per > opts->percent) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT_P, temp1_char, temp2_char, ABS(temp1_char - temp2_char), per);
-                    }
-                    nfound++;
-                }
-            }
-            /* -d and -p */
-            else if (opts->d && opts->p) {
-                PER(temp1_char, temp2_char);
-
-                if (not_comparable && !both_zero) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT_P_NOTCOMP, temp1_char, temp2_char, ABS(temp1_char - temp2_char));
-                    }
-                    nfound++;
-                }
-                else if (per > opts->percent && ABS(temp1_char - temp2_char) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT_P, temp1_char, temp2_char, ABS(temp1_char - temp2_char), per);
-                    }
-                    nfound++;
-                }
-            }
-            else if (temp1_char != temp2_char) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT, temp1_char, temp2_char, ABS(temp1_char - temp2_char));
-                }
-                nfound++;
-            }
+            nfound += diff_schar_element(mem1, mem2, elemtno, opts);
         } /*H5T_NATIVE_SCHAR*/
 
         /*-------------------------------------------------------------------------
@@ -1196,75 +1114,9 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
          *-------------------------------------------------------------------------
          */
         else if (type_size == 1 && type_sign == H5T_SGN_NONE) {
-            unsigned char temp1_uchar;
-            unsigned char temp2_uchar;
-
             if(type_size != sizeof(unsigned char))
                 H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "Type size is not unsigned char size");
-
-            HDmemcpy(&temp1_uchar, mem1, sizeof(unsigned char));
-            HDmemcpy(&temp2_uchar, mem2, sizeof(unsigned char));
-            /* -d and !-p */
-            if (opts->d && !opts->p) {
-                if (PDIFF(temp1_uchar, temp2_uchar) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar));
-                    }
-                    nfound++;
-                }
-            }
-            /* !-d and -p */
-            else if (!opts->d && opts->p) {
-                PER_UNSIGN(signed char, temp1_uchar, temp2_uchar);
-
-                if (not_comparable && !both_zero) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT_P_NOTCOMP, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar));
-                    }
-                    nfound++;
-                }
-                else if (per > opts->percent) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT_P, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar), per);
-                    }
-                    nfound++;
-                }
-            }
-            /* -d and -p */
-            else if (opts->d && opts->p) {
-                PER_UNSIGN(signed char, temp1_uchar, temp2_uchar);
-
-                if (not_comparable && !both_zero) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT_P_NOTCOMP, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar));
-                    }
-                    nfound++;
-                }
-                else if (per > opts->percent && PDIFF(temp1_uchar, temp2_uchar) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT_P, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar), per);
-                    }
-                    nfound++;
-                }
-            }
-            else if (temp1_uchar != temp2_uchar) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar));
-                }
-                nfound++;
-            }
+            nfound += diff_uchar_element(mem1, mem2, elemtno, opts);
         } /*H5T_NATIVE_UCHAR*/
 
         /*-------------------------------------------------------------------------
@@ -1272,75 +1124,9 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
          *-------------------------------------------------------------------------
          */
         else if (type_size == 2 && type_sign != H5T_SGN_NONE) {
-            short temp1_short;
-            short temp2_short;
-
             if(type_size != sizeof(short))
                 H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "Type size is not short size");
-
-            HDmemcpy(&temp1_short, mem1, sizeof(short));
-            HDmemcpy(&temp2_short, mem2, sizeof(short));
-            /* -d and !-p */
-            if (opts->d && !opts->p) {
-                if (ABS(temp1_short - temp2_short) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT, temp1_short, temp2_short, ABS(temp1_short - temp2_short));
-                    }
-                    nfound++;
-                }
-            }
-            /* !-d and -p */
-            else if (!opts->d && opts->p) {
-                PER(temp1_short, temp2_short);
-
-                if (not_comparable && !both_zero) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT_P_NOTCOMP, temp1_short, temp2_short, ABS(temp1_short - temp2_short));
-                    }
-                    nfound++;
-                }
-                else if (per > opts->percent) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT_P, temp1_short, temp2_short, ABS(temp1_short - temp2_short), per);
-                    }
-                    nfound++;
-                }
-            }
-            /* -d and -p */
-            else if (opts->d && opts->p) {
-                PER(temp1_short, temp2_short);
-
-                if (not_comparable && !both_zero) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT_P_NOTCOMP, temp1_short, temp2_short, ABS(temp1_short - temp2_short));
-                    }
-                    nfound++;
-                }
-                else if (per > opts->percent && ABS(temp1_short - temp2_short) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT_P, temp1_short, temp2_short, ABS(temp1_short - temp2_short), per);
-                    }
-                    nfound++;
-                }
-            }
-            else if (temp1_short != temp2_short) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT, temp1_short, temp2_short, ABS(temp1_short - temp2_short));
-                }
-                nfound++;
-            }
+            nfound += diff_short_element(mem1, mem2, elemtno, opts);
         } /*H5T_NATIVE_SHORT*/
 
         /*-------------------------------------------------------------------------
@@ -1348,227 +1134,29 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
          *-------------------------------------------------------------------------
          */
         else if (type_size == 2 && type_sign == H5T_SGN_NONE) {
-            unsigned short temp1_ushort;
-            unsigned short temp2_ushort;
-
             if(type_size != sizeof(unsigned short))
                 H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "Type size is not unsigned short size");
+            nfound += diff_ushort_element(mem1, mem2, elemtno, opts);
+        } /*H5T_NATIVE_USHORT*/
 
-            HDmemcpy(&temp1_ushort, mem1, sizeof(unsigned short));
-            HDmemcpy(&temp2_ushort, mem2, sizeof(unsigned short));
-            /* -d and !-p */
-            if (opts->d && !opts->p) {
-                if (PDIFF(temp1_ushort, temp2_ushort) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort));
-                    }
-                    nfound++;
-                }
-            }
-            /* !-d and -p */
-            else if (!opts->d && opts->p) {
-                PER_UNSIGN(signed short, temp1_ushort, temp2_ushort);
-
-                if (not_comparable && !both_zero) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT_P_NOTCOMP, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort));
-                    }
-                    nfound++;
-                }
-                else if (per > opts->percent) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT_P, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort), per);
-                    }
-                    nfound++;
-                }
-            }
-            /* -d and -p */
-            else if (opts->d && opts->p) {
-                PER_UNSIGN(signed short, temp1_ushort, temp2_ushort);
-
-                if (not_comparable && !both_zero) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT_P_NOTCOMP, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort));
-                    }
-                    nfound++;
-                }
-                else if (per > opts->percent && PDIFF(temp1_ushort, temp2_ushort) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT_P, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort), per);
-                    }
-                    nfound++;
-                }
-            }
-            else if (temp1_ushort != temp2_ushort) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort));
-                }
-                nfound++;
-            }
-        } /*H5T_NATIVE_USHORT*/
-
-        /*-------------------------------------------------------------------------
-         * H5T_NATIVE_INT
-         *-------------------------------------------------------------------------
-         */
-        else if (type_size == 4 && type_sign != H5T_SGN_NONE) {
-            int temp1_int;
-            int temp2_int;
-
-            if(type_size != sizeof(int))
-                H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "Type size is not int size");
-
-            HDmemcpy(&temp1_int, mem1, sizeof(int));
-            HDmemcpy(&temp2_int, mem2, sizeof(int));
-            /* -d and !-p */
-            if (opts->d && !opts->p) {
-                if (ABS(temp1_int-temp2_int) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT, temp1_int, temp2_int, ABS(temp1_int - temp2_int));
-                    }
-                    nfound++;
-                }
-            }
-            /* !-d and -p */
-            else if (!opts->d && opts->p) {
-                PER(temp1_int, temp2_int);
-
-                if (not_comparable && !both_zero) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT_P_NOTCOMP, temp1_int, temp2_int, ABS(temp1_int - temp2_int));
-                    }
-                    nfound++;
-                }
-                else if (per > opts->percent) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT_P, temp1_int, temp2_int, ABS(temp1_int - temp2_int), per);
-                    }
-                    nfound++;
-                }
-            }
-            /* -d and -p */
-            else if (opts->d && opts->p) {
-                PER(temp1_int, temp2_int);
-
-                if (not_comparable && !both_zero) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT_P_NOTCOMP, temp1_int, temp2_int, ABS(temp1_int - temp2_int));
-                    }
-                    nfound++;
-                }
-                else if (per > opts->percent && ABS(temp1_int - temp2_int) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(I_FORMAT_P, temp1_int, temp2_int, ABS(temp1_int - temp2_int), per);
-                    }
-                    nfound++;
-                }
-            }
-            else if (temp1_int != temp2_int) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT, temp1_int, temp2_int, ABS(temp1_int - temp2_int));
-                }
-                nfound++;
-            }
-        } /*H5T_NATIVE_INT*/
+        /*-------------------------------------------------------------------------
+         * H5T_NATIVE_INT
+         *-------------------------------------------------------------------------
+         */
+        else if (type_size == 4 && type_sign != H5T_SGN_NONE) {
+            if(type_size != sizeof(int))
+                H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "Type size is not int size");
+            nfound += diff_int_element(mem1, mem2, elemtno, opts);
+        } /*H5T_NATIVE_INT*/
 
         /*-------------------------------------------------------------------------
          * H5T_NATIVE_UINT
          *-------------------------------------------------------------------------
          */
         else if (type_size == 4 && type_sign == H5T_SGN_NONE) {
-            unsigned int temp1_uint;
-            unsigned int temp2_uint;
-
             if(type_size != sizeof(unsigned int))
                 H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "Type size is not unsigned int size");
-
-            HDmemcpy(&temp1_uint, mem1, sizeof(unsigned int));
-            HDmemcpy(&temp2_uint, mem2, sizeof(unsigned int));
-            /* -d and !-p */
-            if (opts->d && !opts->p) {
-                if (PDIFF(temp1_uint, temp2_uint) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(UI_FORMAT, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint));
-                    }
-                    nfound++;
-                }
-            }
-            /* !-d and -p */
-            else if (!opts->d && opts->p) {
-                PER_UNSIGN(signed int, temp1_uint, temp2_uint);
-
-                if (not_comparable && !both_zero) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(UI_FORMAT_P_NOTCOMP, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint));
-                    }
-                    nfound++;
-                }
-                else if (per > opts->percent) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(UI_FORMAT_P, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint), per);
-                    }
-                    nfound++;
-                }
-            }
-            /* -d and -p */
-            else if (opts->d && opts->p) {
-                PER_UNSIGN(signed int, temp1_uint, temp2_uint);
-
-                if (not_comparable && !both_zero) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(UI_FORMAT_P_NOTCOMP, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint));
-                    }
-                    nfound++;
-                }
-                else if (per > opts->percent && PDIFF(temp1_uint,temp2_uint) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(UI_FORMAT_P, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint), per);
-                    }
-                    nfound++;
-                }
-            }
-            else if (temp1_uint != temp2_uint) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(UI_FORMAT, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint));
-                }
-                nfound++;
-            }
+            nfound += diff_uint_element(mem1, mem2, elemtno, opts);
         } /*H5T_NATIVE_UINT*/
 
         /*-------------------------------------------------------------------------
@@ -1576,75 +1164,9 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
          *-------------------------------------------------------------------------
          */
         else if (type_size == 8 && type_sign != H5T_SGN_NONE) {
-            long temp1_long;
-            long temp2_long;
-
             if(type_size != sizeof(long))
                 H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "Type size is not long size");
-
-            HDmemcpy(&temp1_long, mem1, sizeof(long));
-            HDmemcpy(&temp2_long, mem2, sizeof(long));
-            /* -d and !-p */
-            if (opts->d && !opts->p) {
-                if (ABS(temp1_long-temp2_long) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(LI_FORMAT, temp1_long, temp2_long, ABS(temp1_long - temp2_long));
-                    }
-                    nfound++;
-                }
-            }
-            /* !-d and -p */
-            else if (!opts->d && opts->p) {
-                PER(temp1_long, temp2_long);
-
-                if (not_comparable && !both_zero) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(LI_FORMAT_P_NOTCOMP, temp1_long, temp2_long, ABS(temp1_long - temp2_long));
-                    }
-                    nfound++;
-                }
-                else if (per > opts->percent) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(LI_FORMAT_P, temp1_long, temp2_long, ABS(temp1_long - temp2_long), per);
-                    }
-                    nfound++;
-                }
-            }
-            /* -d and -p */
-            else if (opts->d && opts->p) {
-                PER(temp1_long, temp2_long);
-
-                if (not_comparable && !both_zero) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(LI_FORMAT_P_NOTCOMP, temp1_long, temp2_long, ABS(temp1_long - temp2_long));
-                    }
-                    nfound++;
-                }
-                else if (per > opts->percent && ABS(temp1_long-temp2_long) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(LI_FORMAT_P, temp1_long, temp2_long, ABS(temp1_long - temp2_long), per);
-                    }
-                    nfound++;
-                }
-            }
-            else if (temp1_long != temp2_long) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(LI_FORMAT, temp1_long, temp2_long, ABS(temp1_long - temp2_long));
-                }
-                nfound++;
-            }
+            nfound += diff_long_element(mem1, mem2, elemtno, opts);
         } /*H5T_NATIVE_LONG*/
 
         /*-------------------------------------------------------------------------
@@ -1652,76 +1174,30 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
          *-------------------------------------------------------------------------
          */
         else if (type_size == 8 && type_sign == H5T_SGN_NONE) {
-            unsigned long temp1_ulong;
-            unsigned long temp2_ulong;
-
             if(type_size != sizeof(unsigned long))
                 H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "Type size is not unsigned long size");
+            nfound += diff_ulong_element(mem1, mem2, elemtno, opts);
+        } /*H5T_NATIVE_ULONG*/
 
-            HDmemcpy(&temp1_ulong, mem1, sizeof(unsigned long));
-            HDmemcpy(&temp2_ulong, mem2, sizeof(unsigned long));
-            /* -d and !-p */
-            if (opts->d && !opts->p) {
-                if (PDIFF(temp1_ulong, temp2_ulong) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(ULI_FORMAT, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong));
-                    }
-                    nfound++;
-                }
-            }
-            /* !-d and -p */
-            else if (!opts->d && opts->p) {
-                PER_UNSIGN(signed long, temp1_ulong, temp2_ulong);
-
-                if (not_comparable && !both_zero) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(ULI_FORMAT_P_NOTCOMP, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong));
-                    }
-                    nfound++;
-                }
-                else if (per > opts->percent) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(ULI_FORMAT_P, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong), per);
-                    }
-                    nfound++;
-                }
-            }
-            /* -d and -p */
-            else if (opts->d && opts->p) {
-                PER_UNSIGN(signed long, temp1_ulong, temp2_ulong);
+        /*-------------------------------------------------------------------------
+         * H5T_NATIVE_LLONG
+         *-------------------------------------------------------------------------
+         */
+        else if (type_size == 16 && type_sign != H5T_SGN_NONE) {
+            if(type_size != sizeof(long long))
+                H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "Type size is not long long size");
+            nfound += diff_llong_element(mem1, mem2, elemtno, opts);
+        } /*H5T_NATIVE_LLONG*/
 
-                if (not_comparable && !both_zero) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(ULI_FORMAT_P_NOTCOMP, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong));
-                    }
-                    nfound++;
-                }
-                else if (per > opts->percent && PDIFF(temp1_ulong,temp2_ulong) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(ULI_FORMAT_P, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong), per);
-                    }
-                    nfound++;
-                }
-            }
-            else if (temp1_ulong != temp2_ulong) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(ULI_FORMAT, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong));
-                }
-                nfound++;
-            }
-        } /*H5T_NATIVE_ULONG*/
+        /*-------------------------------------------------------------------------
+         * H5T_NATIVE_ULLONG
+         *-------------------------------------------------------------------------
+         */
+        else if (type_size == 16 && type_sign == H5T_SGN_NONE) {
+            if(type_size != sizeof(unsigned long long))
+                H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "Type size is not unsigned long long size");
+            nfound += diff_ullong_element(mem1, mem2, elemtno, opts);
+        } /*H5T_NATIVE_ULLONG*/
         break; /* H5T_INTEGER class */
 
     /*-------------------------------------------------------------------------
@@ -1733,319 +1209,21 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
          * H5T_NATIVE_FLOAT
          *-------------------------------------------------------------------------
          */
-        H5TOOLS_DEBUG("diff_datum H5T_FLOAT");
+        H5TOOLS_DEBUG("H5T_FLOAT");
         if (type_size == 4) {
-            float temp1_float;
-            float temp2_float;
-            hbool_t isnan1 = FALSE;
-            hbool_t isnan2 = FALSE;
-
             if(type_size != sizeof(float))
                 H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "Type size is not float size");
-
-            HDmemcpy(&temp1_float, mem1, sizeof(float));
-            HDmemcpy(&temp2_float, mem2, sizeof(float));
-
-            /* logic for detecting NaNs is different with opts -d, -p and no opts */
-
-            /*-------------------------------------------------------------------------
-             * -d and !-p
-             *-------------------------------------------------------------------------
-             */
-            if (opts->d && !opts->p) {
-                /*-------------------------------------------------------------------------
-                 * detect NaNs
-                 *-------------------------------------------------------------------------
-                 */
-                if (opts->do_nans) {
-                    isnan1 = HDisnan(temp1_float);
-                    isnan2 = HDisnan(temp2_float);
-                }
-
-                /* both not NaN, do the comparison */
-                if (!isnan1 && !isnan2) {
-                    if (ABS(temp1_float-temp2_float) > (float) opts->delta) {
-                        if (print_data(opts)) {
-                            print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                            parallel_print(SPACES);
-                            parallel_print(F_FORMAT, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
-                        }
-                        nfound++;
-                    }
-                }
-                /* only one is NaN, assume difference */
-                else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
-                    }
-                    nfound++;
-                }
-            }
-            /*-------------------------------------------------------------------------
-             * !-d and -p
-             *-------------------------------------------------------------------------
-             */
-            else if (!opts->d && opts->p) {
-                /*-------------------------------------------------------------------------
-                 * detect NaNs
-                 *-------------------------------------------------------------------------
-                 */
-                if (opts->do_nans) {
-                    isnan1 = HDisnan(temp1_float);
-                    isnan2 = HDisnan(temp2_float);
-                }
-
-                /* both not NaN, do the comparison */
-                if (!isnan1 && !isnan2) {
-                    PER(temp1_float, temp2_float);
-
-                    if (not_comparable && !both_zero) {
-                        if (print_data(opts)) {
-                            print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                            parallel_print(SPACES);
-                            parallel_print(F_FORMAT_P_NOTCOMP, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
-                        }
-                        nfound++;
-                    }
-                    else if (per > opts->percent && (double) ABS(temp1_float - temp2_float) > opts->delta) {
-                        if (print_data(opts)) {
-                            print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                            parallel_print(SPACES);
-                            parallel_print(F_FORMAT_P, (double) temp1_float, (double) temp2_float,
-                                    (double) ABS(temp1_float - temp2_float), (double) ABS(1 - temp2_float / temp1_float));
-                        }
-                        nfound++;
-                    }
-                }
-                /* only one is NaN, assume difference */
-                else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
-                    }
-                    nfound++;
-                }
-            }
-            /*-------------------------------------------------------------------------
-             * -d and -p
-             *-------------------------------------------------------------------------
-             */
-            else if (opts->d && opts->p) {
-                /*-------------------------------------------------------------------------
-                 * detect NaNs
-                 *-------------------------------------------------------------------------
-                 */
-                if (opts->do_nans) {
-                    isnan1 = HDisnan(temp1_float);
-                    isnan2 = HDisnan(temp2_float);
-                }
-
-                /* both not NaN, do the comparison */
-                if (!isnan1 && !isnan2) {
-                    PER(temp1_float, temp2_float);
-
-                    if (not_comparable && !both_zero) {
-                        if (print_data(opts)) {
-                            print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                            parallel_print(SPACES);
-                            parallel_print(F_FORMAT_P_NOTCOMP, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
-                        }
-                        nfound++;
-                    }
-                    else if (per > opts->percent) {
-                        if (print_data(opts)) {
-                            print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                            parallel_print(SPACES);
-                            parallel_print(F_FORMAT_P, (double) temp1_float, (double) temp2_float,
-                                    (double) ABS(temp1_float - temp2_float), (double) ABS(1 - temp2_float / temp1_float));
-                        }
-                        nfound++;
-                    }
-                }
-                /* only one is NaN, assume difference */
-                else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
-                    }
-                    nfound++;
-                }
-            }
-            /*-------------------------------------------------------------------------
-             * no -d and -p
-             *-------------------------------------------------------------------------
-             */
-            else if (equal_float(temp1_float, temp2_float, opts) == FALSE) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(F_FORMAT, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
-                }
-                nfound++;
-            }
-        } /*H5T_NATIVE_FLOAT*/
-
+            nfound += diff_float_element(mem1, mem2, elemtno, opts);
+        }
         /*-------------------------------------------------------------------------
          * H5T_NATIVE_DOUBLE
          *-------------------------------------------------------------------------
          */
         else if (type_size == 8) {
-            double temp1_double;
-            double temp2_double;
-            hbool_t isnan1 = FALSE;
-            hbool_t isnan2 = FALSE;
-
             if(type_size != sizeof(double))
                 H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "Type size is not double size");
-
-            HDmemcpy(&temp1_double, mem1, sizeof(double));
-            HDmemcpy(&temp2_double, mem2, sizeof(double));
-
-            /* logic for detecting NaNs is different with opts -d, -p and no opts */
-            /*-------------------------------------------------------------------------
-             * -d and !-p
-             *-------------------------------------------------------------------------
-             */
-            if (opts->d && !opts->p) {
-                /*-------------------------------------------------------------------------
-                 * detect NaNs
-                 *-------------------------------------------------------------------------
-                 */
-                if (opts->do_nans) {
-                    isnan1 = HDisnan(temp1_double);
-                    isnan2 = HDisnan(temp2_double);
-                }
-
-                /* both not NaN, do the comparison */
-                if (!isnan1 && !isnan2) {
-                    if (ABS(temp1_double-temp2_double) > opts->delta) {
-                        if (print_data(opts)) {
-                            print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                            parallel_print(SPACES);
-                            parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
-                        }
-                        nfound++;
-                    }
-                }
-                /* only one is NaN, assume difference */
-                else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
-                    }
-                    nfound++;
-                }
-            } /* opts->d && !opts->p */
-            /*-------------------------------------------------------------------------
-             * !-d and -p
-             *-------------------------------------------------------------------------
-             */
-            else if (!opts->d && opts->p) {
-                /*-------------------------------------------------------------------------
-                 * detect NaNs
-                 *-------------------------------------------------------------------------
-                 */
-                if (opts->do_nans) {
-                    isnan1 = HDisnan(temp1_double);
-                    isnan2 = HDisnan(temp2_double);
-                }
-
-                /* both not NaN, do the comparison */
-                if (!isnan1 && !isnan2) {
-                    PER(temp1_double, temp2_double);
-
-                    if (not_comparable && !both_zero) {
-                        if (print_data(opts)) {
-                            print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                            parallel_print(SPACES);
-                            parallel_print(F_FORMAT_P_NOTCOMP, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
-                        }
-                        nfound++;
-                    }
-                    else if (per > opts->percent) {
-                        if (print_data(opts)) {
-                            print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                            parallel_print(SPACES);
-                            parallel_print(F_FORMAT_P, temp1_double, temp2_double, ABS(temp1_double - temp2_double), ABS(1 - temp2_double / temp1_double));
-                        }
-                        nfound++;
-                    }
-                }
-                /* only one is NaN, assume difference */
-                else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
-                    }
-                    nfound++;
-                }
-            }
-            /*-------------------------------------------------------------------------
-             * -d and -p
-             *-------------------------------------------------------------------------
-             */
-            else if (opts->d && opts->p) {
-                /*-------------------------------------------------------------------------
-                * detect NaNs
-                *-------------------------------------------------------------------------
-                */
-                if (opts->do_nans) {
-                    isnan1 = HDisnan(temp1_double);
-                    isnan2 = HDisnan(temp2_double);
-                }
-
-                /* both not NaN, do the comparison */
-                if (!isnan1 && !isnan2) {
-                    PER(temp1_double, temp2_double);
-
-                    if (not_comparable && !both_zero) {
-                        if (print_data(opts)) {
-                            print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                            parallel_print(SPACES);
-                            parallel_print(F_FORMAT_P_NOTCOMP, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
-                        }
-                        nfound++;
-                    }
-                    else if (per > opts->percent &&
-                    ABS(temp1_double-temp2_double) > opts->delta) {
-                        if (print_data(opts)) {
-                            print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                            parallel_print(SPACES);
-                            parallel_print(F_FORMAT_P, temp1_double, temp2_double, ABS(temp1_double - temp2_double), ABS(1 - temp2_double / temp1_double));
-                        }
-                        nfound++;
-                    }
-                }
-                /* only one is NaN, assume difference */
-                else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
-                    }
-                    nfound++;
-                }
-            }
-            /*-------------------------------------------------------------------------
-             * no -d and -p
-             *-------------------------------------------------------------------------
-             */
-            else if (equal_double(temp1_double, temp2_double, opts) == FALSE) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
-                }
-                nfound++;
-            }
-        } /*H5T_NATIVE_DOUBLE*/
-
+            nfound += diff_double_element(mem1, mem2, elemtno, opts);
+        }
 #if H5_SIZEOF_LONG_DOUBLE != H5_SIZEOF_DOUBLE
 
         /*-------------------------------------------------------------------------
@@ -2053,157 +1231,10 @@ diff_datum(void *_mem1, void *_mem2, hid_t m_type, hsize_t idx, int rank,
          *-------------------------------------------------------------------------
          */
         else if (type_size == H5_SIZEOF_LONG_DOUBLE) {
-            long double temp1_double;
-            long double temp2_double;
-            hbool_t     isnan1 = FALSE;
-            hbool_t     isnan2 = FALSE;
-
             if(type_size != sizeof(long double)) {
                 H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "Type size is not long double size");
             }
-
-            HDmemcpy(&temp1_double, mem1, sizeof(long double));
-            HDmemcpy(&temp2_double, mem2, sizeof(long double));
-
-            /* logic for detecting NaNs is different with options -d, -p and no options */
-
-            /*-------------------------------------------------------------------------
-             * -d and !-p
-             *-------------------------------------------------------------------------
-             */
-            if (opts->d && !opts->p) {
-                /*-------------------------------------------------------------------------
-                 * detect NaNs
-                 *-------------------------------------------------------------------------
-                 */
-                if (opts->do_nans) {
-                    isnan1 = HDisnan(temp1_double);
-                    isnan2 = HDisnan(temp2_double);
-                }
-
-                /* both not NaN, do the comparison */
-                if (!isnan1 && !isnan2) {
-                    if (ABS(temp1_double-temp2_double) > opts->delta) {
-                        if (print_data(opts)) {
-                            print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                            parallel_print(SPACES);
-                            parallel_print(LD_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
-                        }
-                        nfound++;
-                    }
-                } /* NaN */
-                /* only one is NaN, assume difference */
-                else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
-                    }
-                    nfound++;
-                }
-            }
-            /*-------------------------------------------------------------------------
-             * !-d and -p
-             *-------------------------------------------------------------------------
-             */
-            else if (!opts->d && opts->p) {
-                /*-------------------------------------------------------------------------
-                 * detect NaNs
-                 *-------------------------------------------------------------------------
-                 */
-                if (opts->do_nans) {
-                    isnan1 = HDisnan(temp1_double);
-                    isnan2 = HDisnan(temp2_double);
-                }
-
-                /* both not NaN, do the comparison */
-                if (!isnan1 && !isnan2) {
-                    PER(temp1_double,temp2_double);
-
-                    if (not_comparable && !both_zero) {
-                        if (print_data(opts)) {
-                            print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                            parallel_print(SPACES);
-                            parallel_print(LD_FORMAT_P_NOTCOMP, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
-                        }
-                        nfound++;
-                    }
-                    else if (per > opts->percent) {
-                        if (print_data(opts)) {
-                            print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                            parallel_print(SPACES);
-                            parallel_print(LD_FORMAT_P, temp1_double, temp2_double, ABS(temp1_double - temp2_double), ABS(1 - temp2_double / temp1_double));
-                        }
-                        nfound++;
-                    }
-                } /* NaN */
-                /* only one is NaN, assume difference */
-                else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
-                    }
-                    nfound++;
-                }
-            }
-            /*-------------------------------------------------------------------------
-             * -d and -p
-             *-------------------------------------------------------------------------
-             */
-            else if (opts->d && opts->p) {
-                /*-------------------------------------------------------------------------
-                 * detect NaNs
-                 *-------------------------------------------------------------------------
-                 */
-                if (opts->do_nans) {
-                    isnan1 = HDisnan(temp1_double);
-                    isnan2 = HDisnan(temp2_double);
-                }
-
-                /* both not NaN, do the comparison */
-                if (!isnan1 && !isnan2) {
-                    PER(temp1_double,temp2_double);
-
-                    if (not_comparable && !both_zero) {
-                        if (print_data(opts)) {
-                            print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                            parallel_print(SPACES);
-                            parallel_print(LD_FORMAT_P_NOTCOMP, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
-                        }
-                        nfound++;
-                    }
-                    else if (per > opts->percent && ABS(temp1_double-temp2_double) > opts->delta) {
-                        if (print_data(opts)) {
-                            print_pos(ph, 1, idx, acc, pos, rank, dims, obj1, obj2);
-                            parallel_print(SPACES);
-                            parallel_print(LD_FORMAT_P, temp1_double, temp2_double, ABS(temp1_double - temp2_double), ABS(1 - temp2_double / temp1_double));
-                        }
-                        nfound++;
-                    }
-                } /* NaN */
-                /* only one is NaN, assume difference */
-                else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
-                    }
-                    nfound++;
-                }
-            }
-            /*-------------------------------------------------------------------------
-             * no -d and -p
-             *-------------------------------------------------------------------------
-             */
-            else if (equal_ldouble(temp1_double, temp2_double, opts) == FALSE) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, idx, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(LD_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
-                }
-                nfound++;
-            }
+            nfound += diff_ldouble_element(mem1, mem2, elemtno, opts);
         } /*H5T_NATIVE_LDOUBLE*/
 #endif  /* H5_SIZEOF_LONG_DOUBLE */
 
@@ -2320,8 +1351,8 @@ static hsize_t diff_region(hid_t obj1_id, hid_t obj2_id, hid_t region1_id, hid_t
         npoints1 = H5Sget_select_elem_npoints(region1_id);
         npoints2 = H5Sget_select_elem_npoints(region2_id);
     } H5E_END_TRY;
-    H5TOOLS_DEBUG("diff_region blocks: 1=%ld-2=%ld", nblocks1, nblocks2);
-    H5TOOLS_DEBUG("diff_region points: 1=%ld-2=%ld", npoints1, npoints2);
+    H5TOOLS_DEBUG("blocks: 1=%ld-2=%ld", nblocks1, nblocks2);
+    H5TOOLS_DEBUG("points: 1=%ld-2=%ld", npoints1, npoints2);
 
     if (nblocks1 != nblocks2 || npoints1 != npoints2 || ndims1 != ndims2) {
         opts->not_cmp = 1;
@@ -2369,7 +1400,7 @@ static hsize_t diff_region(hid_t obj1_id, hid_t obj2_id, hid_t region1_id, hid_t
                 }
 
                 /* print differences if found */
-                if (nfound_b && opts->m_verbose) {
+                if (nfound_b && opts->mode_verbose) {
                     H5O_info2_t oi1, oi2;
                     char *obj1_str = NULL, *obj2_str = NULL;
 
@@ -2437,7 +1468,7 @@ static hsize_t diff_region(hid_t obj1_id, hid_t obj2_id, hid_t region1_id, hid_t
                     }
                 }
 
-                if (nfound_p && opts->m_verbose) {
+                if (nfound_p && opts->mode_verbose) {
                     parallel_print("Region points\n");
                     for (i = 0; i < npoints1; i++) {
                         hsize_t pt1, pt2;
@@ -2497,8 +1528,7 @@ static hsize_t diff_region(hid_t obj1_id, hid_t obj2_id, hid_t region1_id, hid_t
  *-------------------------------------------------------------------------
  */
 
-static hsize_t character_compare(char *mem1, char *mem2, hsize_t i, size_t u,
-        int rank, hsize_t *dims, hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1, const char *obj2, int *ph)
+static hsize_t character_compare(char *mem1, char *mem2, hsize_t elemtno, ssize_t u, diff_opt_t *opts)
 {
     hsize_t nfound = 0; /* differences found */
     char    temp1_uchar;
@@ -2506,12 +1536,13 @@ static hsize_t character_compare(char *mem1, char *mem2, hsize_t i, size_t u,
 
     HDmemcpy(&temp1_uchar, mem1, sizeof(unsigned char));
     HDmemcpy(&temp2_uchar, mem2, sizeof(unsigned char));
-    H5TOOLS_START_DEBUG(" %d=%d",temp1_uchar,temp2_uchar);
+    H5TOOLS_START_DEBUG(" %d=%d", temp1_uchar, temp2_uchar);
 
     if (temp1_uchar != temp2_uchar) {
         if (print_data(opts)) {
-            print_char_pos(ph, 0, i, u, acc, pos, rank, dims, obj1, obj2);
-            parallel_print("            ");
+            opts->print_percentage = 0;
+            print_pos(opts, elemtno, u);
+            parallel_print("  ");
             h5diff_print_char(temp1_uchar);
             parallel_print("            ");
             h5diff_print_char(temp2_uchar);
@@ -2532,1953 +1563,1455 @@ static hsize_t character_compare(char *mem1, char *mem2, hsize_t i, size_t u,
  *-------------------------------------------------------------------------
  */
 
-static hsize_t character_compare_opt(unsigned char *mem1, unsigned char *mem2,
-        hsize_t i, int rank, hsize_t *dims, hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1, const char *obj2, int *ph)
+static hsize_t character_compare_opt(unsigned char *mem1, unsigned char *mem2, hsize_t elemtno, diff_opt_t *opts)
 {
     hsize_t       nfound = 0; /* differences found */
     unsigned char temp1_uchar;
     unsigned char temp2_uchar;
+    hbool_t       both_zero = FALSE;
     double        per;
-    hbool_t       both_zero;
 
     HDmemcpy(&temp1_uchar, mem1, sizeof(unsigned char));
     HDmemcpy(&temp2_uchar, mem2, sizeof(unsigned char));
+    H5TOOLS_START_DEBUG(" %d=%d", temp1_uchar, temp2_uchar);
 
     /* -d and !-p */
 
-    if (opts->d && !opts->p) {
+    if (opts->delta_bool && !opts->percent_bool) {
         if (PDIFF(temp1_uchar,temp2_uchar) > opts->delta) {
+            opts->print_percentage = 0;
+            print_pos(opts, elemtno, -1);
             if (print_data(opts)) {
-                print_pos(ph, 0, i, acc, pos, rank, dims, obj1, obj2);
-                parallel_print(SPACES);
                 parallel_print(I_FORMAT, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar));
             }
             nfound++;
         }
     }
     /* !-d and -p */
-    else if (!opts->d && opts->p) {
+    else if (!opts->delta_bool && opts->percent_bool) {
         PER_UNSIGN(signed char, temp1_uchar, temp2_uchar);
         if (per > opts->percent) {
+            opts->print_percentage = 1;
+            print_pos(opts, elemtno, -1);
             if (print_data(opts)) {
-                print_pos(ph, 1, i, acc, pos, rank, dims, obj1, obj2);
-                parallel_print(SPACES);
                 parallel_print(I_FORMAT_P, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar), per);
             }
             nfound++;
         }
     }
     /* -d and -p */
-    else if (opts->d && opts->p) {
+    else if (opts->delta_bool && opts->percent_bool) {
         PER_UNSIGN(signed char, temp1_uchar, temp2_uchar);
         if (per > opts->percent && PDIFF(temp1_uchar,temp2_uchar) > opts->delta) {
+            opts->print_percentage = 1;
+            print_pos(opts, elemtno, -1);
             if (print_data(opts)) {
-                print_pos(ph, 1, i, acc, pos, rank, dims, obj1, obj2);
-                parallel_print(SPACES);
                 parallel_print(I_FORMAT_P, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar), per);
             }
             nfound++;
         }
     }
     else if (temp1_uchar != temp2_uchar) {
+        opts->print_percentage = 0;
+        print_pos(opts, elemtno, -1);
         if (print_data(opts)) {
-            print_pos(ph, 0, i, acc, pos, rank, dims, obj1, obj2);
-            parallel_print(SPACES);
             parallel_print(I_FORMAT, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar));
         }
         nfound++;
     }
 
+    H5TOOLS_ENDDEBUG(": %d zero:%d", nfound, both_zero);
     return nfound;
 }
 
 /*-------------------------------------------------------------------------
- * Function: diff_float
+ * Function: diff_float_element
  *
- * Purpose:  diff a H5T_NATIVE_FLOAT type
+ * Purpose:  diff a single H5T_NATIVE_FLOAT type
  *
  * Return:   number of differences found
 *
  *-------------------------------------------------------------------------
  */
-static hsize_t diff_float(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims, hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1,
-        const char *obj2, int *ph)
-
+static hsize_t diff_float_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts)
 {
     hsize_t nfound = 0; /* number of differences found */
     float   temp1_float;
     float   temp2_float;
-    hsize_t i;
     double  per;
-    hbool_t both_zero;
+    hbool_t both_zero = FALSE;
     hbool_t isnan1 = FALSE;
     hbool_t isnan2 = FALSE;
 
+    H5TOOLS_START_DEBUG("delta_bool:%d - percent_bool:%d", opts->delta_bool, opts->percent_bool);
+
+    HDmemcpy(&temp1_float, mem1, sizeof(float));
+    HDmemcpy(&temp2_float, mem2, sizeof(float));
+
+    /* logic for detecting NaNs is different with opts -d, -p and no opts */
+
     /*-------------------------------------------------------------------------
      * -d and !-p
      *-------------------------------------------------------------------------
      */
+    if (opts->delta_bool && !opts->percent_bool) {
+        /*-------------------------------------------------------------------------
+         * detect NaNs
+         *-------------------------------------------------------------------------
+         */
+        if (opts->do_nans) {
+            isnan1 = HDisnan(temp1_float);
+            isnan2 = HDisnan(temp2_float);
+        }
 
-    if (opts->d && !opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_float, mem1, sizeof(float));
-            HDmemcpy(&temp2_float, mem2, sizeof(float));
-
-            /*-------------------------------------------------------------------------
-             * detect NaNs
-             *-------------------------------------------------------------------------
-             */
-            if (opts->do_nans) {
-                isnan1 = HDisnan(temp1_float);
-                isnan2 = HDisnan(temp2_float);
-            }
-
-            /* both not NaN, do the comparison */
-            if (!isnan1 && !isnan2) {
-                if ((double) ABS(temp1_float - temp2_float) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
-                    }
-                    nfound++;
-                }
-            }
-            /* only one is NaN, assume difference */
-            else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
+        /* both not NaN, do the comparison */
+        if (!isnan1 && !isnan2) {
+            if ((double) ABS(temp1_float - temp2_float) > opts->delta) {
+                opts->print_percentage = 0;
+                print_pos(opts, elem_idx, -1);
                 if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
                     parallel_print(F_FORMAT, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
                 }
                 nfound++;
-
             }
-            mem1 += sizeof(float);
-            mem2 += sizeof(float);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
-        } /* i */
+        }
+        /* only one is NaN, assume difference */
+        else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
+            opts->print_percentage = 0;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(F_FORMAT, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
+            }
+            nfound++;
+        }
     }
     /*-------------------------------------------------------------------------
-     * !-d and -p
-     *-------------------------------------------------------------------------
-     */
-    else if (!opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_float, mem1, sizeof(float));
-            HDmemcpy(&temp2_float, mem2, sizeof(float));
-
-            /*-------------------------------------------------------------------------
-             * detect NaNs
-             *-------------------------------------------------------------------------
-             */
-            if (opts->do_nans) {
-                isnan1 = HDisnan(temp1_float);
-                isnan2 = HDisnan(temp2_float);
-            }
-            /* both not NaN, do the comparison */
-            if ((!isnan1 && !isnan2)) {
-                PER(temp1_float, temp2_float);
+    * !-d and -p
+    *-------------------------------------------------------------------------
+    */
+    else if (!opts->delta_bool && opts->percent_bool) {
+        /*-------------------------------------------------------------------------
+         * detect NaNs
+         *-------------------------------------------------------------------------
+         */
+        if (opts->do_nans) {
+            isnan1 = HDisnan(temp1_float);
+            isnan2 = HDisnan(temp2_float);
+        }
+        /* both not NaN, do the comparison */
+        if ((!isnan1 && !isnan2)) {
+            PER(temp1_float, temp2_float);
 
-                if (not_comparable && !both_zero) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT_P_NOTCOMP, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
-                    }
-                    nfound++;
-                }
-                else if (per > opts->percent) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT_P, (double) temp1_float, (double) temp2_float,
-                                (double) ABS(temp1_float - temp2_float), (double) ABS(1 - temp2_float / temp1_float));
-                    }
-                    nfound++;
+            if (not_comparable && !both_zero) {
+                opts->print_percentage = 1;
+                print_pos(opts, elem_idx, -1);
+                if (print_data(opts)) {
+                    parallel_print(F_FORMAT_P_NOTCOMP, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
                 }
+                nfound++;
             }
-            /* only one is NaN, assume difference */
-            else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
+            else if (per > opts->percent) {
+                opts->print_percentage = 1;
+                print_pos(opts, elem_idx, -1);
                 if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(F_FORMAT, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
+                    parallel_print(F_FORMAT_P, (double) temp1_float, (double) temp2_float,
+                            (double) ABS(temp1_float - temp2_float), (double) ABS(1 - temp2_float / temp1_float));
                 }
                 nfound++;
-
             }
-            mem1 += sizeof(float);
-            mem2 += sizeof(float);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
-        } /* i */
+        }
+        /* only one is NaN, assume difference */
+        else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
+            opts->print_percentage = 0;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(F_FORMAT, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
+            }
+            nfound++;
+        }
     }
     /*-------------------------------------------------------------------------
-     * -d and -p
-     *-------------------------------------------------------------------------
-     */
-    else if (opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_float, mem1, sizeof(float));
-            HDmemcpy(&temp2_float, mem2, sizeof(float));
-
-            /*-------------------------------------------------------------------------
-             * detect NaNs
-             *-------------------------------------------------------------------------
-             */
-            if (opts->do_nans) {
-                isnan1 = HDisnan(temp1_float);
-                isnan2 = HDisnan(temp2_float);
-            }
+    * -d and -p
+    *-------------------------------------------------------------------------
+    */
+    else if (opts->delta_bool && opts->percent_bool) {
+        /*-------------------------------------------------------------------------
+         * detect NaNs
+         *-------------------------------------------------------------------------
+         */
+        if (opts->do_nans) {
+            isnan1 = HDisnan(temp1_float);
+            isnan2 = HDisnan(temp2_float);
+        }
 
-            /* both not NaN, do the comparison */
-            if (!isnan1 && !isnan2) {
-                PER(temp1_float, temp2_float);
+        /* both not NaN, do the comparison */
+        if (!isnan1 && !isnan2) {
+            PER(temp1_float, temp2_float);
 
-                if (not_comparable && !both_zero) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT_P_NOTCOMP, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
-                    }
-                    nfound++;
-                }
-                else if (per > opts->percent && (double) ABS(temp1_float - temp2_float) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT_P, (double) temp1_float, (double) temp2_float,
-                                (double) ABS(temp1_float - temp2_float), (double) ABS(1 - temp2_float / temp1_float));
-                    }
-                    nfound++;
+            if (not_comparable && !both_zero) {
+                opts->print_percentage = 1;
+                print_pos(opts, elem_idx, -1);
+                if (print_data(opts)) {
+                    parallel_print(F_FORMAT_P_NOTCOMP, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
                 }
-
+                nfound++;
             }
-            /* only one is NaN, assume difference */
-            else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
+            else if (per > opts->percent && (double) ABS(temp1_float - temp2_float) > opts->delta) {
+                opts->print_percentage = 1;
+                print_pos(opts, elem_idx, -1);
                 if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(F_FORMAT, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
+                    parallel_print(F_FORMAT_P, (double) temp1_float, (double) temp2_float,
+                            (double) ABS(temp1_float - temp2_float), (double) ABS(1 - temp2_float / temp1_float));
                 }
                 nfound++;
-
             }
-            mem1 += sizeof(float);
-            mem2 += sizeof(float);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
-        } /* i */
+        }
+        /* only one is NaN, assume difference */
+        else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
+            opts->print_percentage = 0;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(F_FORMAT, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
+            }
+            nfound++;
+        }
     }
-
     /*-------------------------------------------------------------------------
-     * no -d and -p
-     *-------------------------------------------------------------------------
-     */
+    * no -d and -p
+    *-------------------------------------------------------------------------
+    */
     else {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_float, mem1, sizeof(float));
-            HDmemcpy(&temp2_float, mem2, sizeof(float));
-
-            if (equal_float(temp1_float, temp2_float, opts) == FALSE) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(F_FORMAT, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
-                }
-                nfound++;
+        if (equal_float(temp1_float, temp2_float, opts) == FALSE) {
+            opts->print_percentage = 0;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(F_FORMAT, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
             }
-
-            mem1 += sizeof(float);
-            mem2 += sizeof(float);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
-        } /* nelmts */
+            nfound++;
+        }
     }
 
+    H5TOOLS_ENDDEBUG(": %d zero:%d", nfound, both_zero);
     return nfound;
 }
 
 /*-------------------------------------------------------------------------
- * Function: diff_double
+ * Function: diff_double_element
  *
- * Purpose:  diff a H5T_NATIVE_DOUBLE type
+ * Purpose:  diff a single H5T_NATIVE_DOUBLE type
  *
  * Return:   number of differences found
  *-------------------------------------------------------------------------
  */
-static hsize_t diff_double(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims,
-        hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1,
-        const char *obj2, int *ph)
-
+static hsize_t diff_double_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts)
 {
     hsize_t nfound = 0; /* number of differences found */
     double  temp1_double;
     double  temp2_double;
-    hsize_t i;
     double  per;
-    hbool_t both_zero;
+    hbool_t both_zero = FALSE;
     hbool_t isnan1 = FALSE;
     hbool_t isnan2 = FALSE;
 
-    /*-------------------------------------------------------------------------
-     * -d and !-p
-     *-------------------------------------------------------------------------
-     */
+    H5TOOLS_START_DEBUG("delta_bool:%d - percent_bool:%d", opts->delta_bool, opts->percent_bool);
 
-    if (opts->d && !opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_double, mem1, sizeof(double));
-            HDmemcpy(&temp2_double, mem2, sizeof(double));
+    HDmemcpy(&temp1_double, mem1, sizeof(double));
+    HDmemcpy(&temp2_double, mem2, sizeof(double));
 
-            /*-------------------------------------------------------------------------
-             * detect NaNs
-             *-------------------------------------------------------------------------
-             */
-            if (opts->do_nans) {
-                isnan1 = HDisnan(temp1_double);
-                isnan2 = HDisnan(temp2_double);
-            }
+    /*-------------------------------------------------------------------------
+    * -d and !-p
+    *-------------------------------------------------------------------------
+    */
+    if (opts->delta_bool && !opts->percent_bool) {
+        /*-------------------------------------------------------------------------
+        * detect NaNs
+        *-------------------------------------------------------------------------
+        */
+        if (opts->do_nans) {
+            isnan1 = HDisnan(temp1_double);
+            isnan2 = HDisnan(temp2_double);
+        }
 
-            /* both not NaN, do the comparison */
-            if (!isnan1 && !isnan2) {
-                if (ABS(temp1_double-temp2_double) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
-                    }
-                    nfound++;
-                }
-            }
-            /* only one is NaN, assume difference */
-            else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
+        /* both not NaN, do the comparison */
+        if (!isnan1 && !isnan2) {
+            if (ABS(temp1_double-temp2_double) > opts->delta) {
+                opts->print_percentage = 0;
+                print_pos(opts, elem_idx, -1);
                 if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
                     parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
                 }
                 nfound++;
-
             }
-            mem1 += sizeof(double);
-            mem2 += sizeof(double);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
-        } /* i */
+        }
+        /* only one is NaN, assume difference */
+        else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
+            opts->print_percentage = 0;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
+            }
+            nfound++;
+        }
     }
 
     /*-------------------------------------------------------------------------
-     * !-d and -p
-     *-------------------------------------------------------------------------
-     */
-    else if (!opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_double, mem1, sizeof(double));
-            HDmemcpy(&temp2_double, mem2, sizeof(double));
-
-            /*-------------------------------------------------------------------------
-             * detect NaNs
-             *-------------------------------------------------------------------------
-             */
-            if (opts->do_nans) {
-                isnan1 = HDisnan(temp1_double);
-                isnan2 = HDisnan(temp2_double);
-            }
-            /* both not NaN, do the comparison */
-            if (!isnan1 && !isnan2) {
-                PER(temp1_double, temp2_double);
+    * !-d and -p
+    *-------------------------------------------------------------------------
+    */
+    else if (!opts->delta_bool && opts->percent_bool) {
+        /*-------------------------------------------------------------------------
+        * detect NaNs
+        *-------------------------------------------------------------------------
+        */
+        if (opts->do_nans) {
+            isnan1 = HDisnan(temp1_double);
+            isnan2 = HDisnan(temp2_double);
+        }
+        /* both not NaN, do the comparison */
+        if (!isnan1 && !isnan2) {
+            PER(temp1_double, temp2_double);
 
-                if (not_comparable && !both_zero) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT_P_NOTCOMP, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
-                    }
-                    nfound++;
-                }
-                else if (per > opts->percent) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT_P, temp1_double, temp2_double,
-                                ABS(temp1_double - temp2_double), ABS(1 - temp2_double / temp1_double));
-                    }
-                    nfound++;
+            if (not_comparable && !both_zero) {
+                opts->print_percentage = 1;
+                print_pos(opts, elem_idx, -1);
+                if (print_data(opts)) {
+                    parallel_print(F_FORMAT_P_NOTCOMP, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
                 }
+                nfound++;
             }
-            /* only one is NaN, assume difference */
-            else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
+            else if (per > opts->percent) {
+                opts->print_percentage = 1;
+                print_pos(opts, elem_idx, -1);
                 if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
+                    parallel_print(F_FORMAT_P, temp1_double, temp2_double,
+                            ABS(temp1_double - temp2_double), ABS(1 - temp2_double / temp1_double));
                 }
                 nfound++;
-
             }
-            mem1 += sizeof(double);
-            mem2 += sizeof(double);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
-        } /* i */
+        }
+        /* only one is NaN, assume difference */
+        else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
+            opts->print_percentage = 0;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
+            }
+            nfound++;
+        }
     }
     /*-------------------------------------------------------------------------
-     * -d and -p
-     *-------------------------------------------------------------------------
-     */
-    else if (opts->d && opts->p) {
-
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_double, mem1, sizeof(double));
-            HDmemcpy(&temp2_double, mem2, sizeof(double));
-
-            /*-------------------------------------------------------------------------
-             * detect NaNs
-             *-------------------------------------------------------------------------
-             */
-            if (opts->do_nans) {
-                isnan1 = HDisnan(temp1_double);
-                isnan2 = HDisnan(temp2_double);
-            }
+    * -d and -p
+    *-------------------------------------------------------------------------
+    */
+    else if (opts->delta_bool && opts->percent_bool) {
+        /*-------------------------------------------------------------------------
+        * detect NaNs
+        *-------------------------------------------------------------------------
+        */
+        if (opts->do_nans) {
+            isnan1 = HDisnan(temp1_double);
+            isnan2 = HDisnan(temp2_double);
+        }
 
-            /* both not NaN, do the comparison */
-            if (!isnan1 && !isnan2) {
-                PER(temp1_double, temp2_double);
+        /* both not NaN, do the comparison */
+        if (!isnan1 && !isnan2) {
+            PER(temp1_double, temp2_double);
 
-                if (not_comparable && !both_zero)  {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT_P_NOTCOMP, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
-                    }
-                    nfound++;
-                }
-                else if (per > opts->percent && ABS(temp1_double-temp2_double) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT_P, temp1_double, temp2_double,
-                                ABS(temp1_double - temp2_double), ABS(1 - temp2_double / temp1_double));
-                    }
-                    nfound++;
+            if (not_comparable && !both_zero)  {
+                opts->print_percentage = 1;
+                print_pos(opts, elem_idx, -1);
+                if (print_data(opts)) {
+                    parallel_print(F_FORMAT_P_NOTCOMP, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
                 }
+                nfound++;
             }
-            /* only one is NaN, assume difference */
-            else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
+            else if (per > opts->percent && ABS(temp1_double-temp2_double) > opts->delta) {
+                opts->print_percentage = 1;
+                print_pos(opts, elem_idx, -1);
                 if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
+                    parallel_print(F_FORMAT_P, temp1_double, temp2_double,
+                            ABS(temp1_double - temp2_double), ABS(1 - temp2_double / temp1_double));
                 }
                 nfound++;
             }
-            mem1 += sizeof(double);
-            mem2 += sizeof(double);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
-        } /* i */
+        }
+        /* only one is NaN, assume difference */
+        else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
+            opts->print_percentage = 0;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
+            }
+            nfound++;
+        }
     }
     /*-------------------------------------------------------------------------
-     * no -d and -p
-     *-------------------------------------------------------------------------
-     */
+    * no -d and -p
+    *-------------------------------------------------------------------------
+    */
     else {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_double, mem1, sizeof(double));
-            HDmemcpy(&temp2_double, mem2, sizeof(double));
-
-            if (equal_double(temp1_double, temp2_double, opts) == FALSE) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
-                }
-                nfound++;
+        if (equal_double(temp1_double, temp2_double, opts) == FALSE) {
+            opts->print_percentage = 0;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
             }
-
-            mem1 += sizeof(double);
-            mem2 += sizeof(double);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
-        } /* nelmts */
+            nfound++;
+        }
     }
+    H5TOOLS_ENDDEBUG(":%d - errstat:%d", nfound, opts->err_stat);
 
     return nfound;
 }
 
 /*-------------------------------------------------------------------------
- * Function: diff_ldouble
+ * Function: diff_ldouble_element
  *
- * Purpose:  diff a H5T_NATIVE_LDOUBLE type
+ * Purpose:  diff a single H5T_NATIVE_LDOUBLE type
  *
  * Return:   number of differences found
  *-------------------------------------------------------------------------
  */
 #if H5_SIZEOF_LONG_DOUBLE !=0
 
-static hsize_t diff_ldouble(unsigned char *mem1,
-        unsigned char *mem2,
-        hsize_t nelmts,
-        hsize_t hyper_start,
-        int rank,
-        hsize_t *dims,
-        hsize_t *acc,
-        hsize_t *pos,
-        diff_opt_t *opts,
-        const char *obj1,
-        const char *obj2,
-        int *ph)
-
+static hsize_t diff_ldouble_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts)
 {
     hsize_t     nfound = 0; /* number of differences found */
     long double temp1_double;
     long double temp2_double;
-    hsize_t     i;
     double      per;
-    hbool_t     both_zero;
+    hbool_t     both_zero = FALSE;
     hbool_t     isnan1 = FALSE;
     hbool_t     isnan2 = FALSE;
 
+    H5TOOLS_START_DEBUG("delta_bool:%d - percent_bool:%d", opts->delta_bool, opts->percent_bool);
+
+    HDmemcpy(&temp1_double, mem1, sizeof(long double));
+    HDmemcpy(&temp2_double, mem2, sizeof(long double));
+
+    /* logic for detecting NaNs is different with options -d, -p and no options */
+
     /*-------------------------------------------------------------------------
      * -d and !-p
      *-------------------------------------------------------------------------
      */
+    if (opts->delta_bool && !opts->percent_bool) {
+        /*-------------------------------------------------------------------------
+         * detect NaNs
+         *-------------------------------------------------------------------------
+         */
+        if (opts->do_nans) {
+            isnan1 = HDisnan(temp1_double);
+            isnan2 = HDisnan(temp2_double);
+        }
 
-    if (opts->d && !opts->p) {
-        for ( i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_double, mem1, sizeof(long double));
-            HDmemcpy(&temp2_double, mem2, sizeof(long double));
-
-            /*-------------------------------------------------------------------------
-             * detect NaNs
-             *-------------------------------------------------------------------------
-             */
-            if (opts->do_nans) {
-                isnan1 = HDisnan(temp1_double);
-                isnan2 = HDisnan(temp2_double);
-            }
-
-            /* both not NaN, do the comparison */
-            if (!isnan1 && !isnan2) {
-                if (ABS(temp1_double-temp2_double) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
-                    }
-                    nfound++;
-                }
-            }
-            /* only one is NaN, assume difference */
-            else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
+        /* both not NaN, do the comparison */
+        if (!isnan1 && !isnan2) {
+            if (ABS(temp1_double-temp2_double) > opts->delta) {
+                opts->print_percentage = 0;
+                print_pos(opts, elem_idx, -1);
                 if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
+                    parallel_print(LD_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
                 }
                 nfound++;
-
             }
-            mem1 += sizeof(long double);
-            mem2 += sizeof(long double);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
-        } /* i */
+        } /* NaN */
+        /* only one is NaN, assume difference */
+        else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
+            opts->print_percentage = 0;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
+            }
+            nfound++;
+        }
     }
-
     /*-------------------------------------------------------------------------
      * !-d and -p
      *-------------------------------------------------------------------------
      */
-    else if (!opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_double, mem1, sizeof(long double));
-            HDmemcpy(&temp2_double, mem2, sizeof(long double));
+    else if (!opts->delta_bool && opts->percent_bool) {
+        /*-------------------------------------------------------------------------
+         * detect NaNs
+         *-------------------------------------------------------------------------
+         */
+        if (opts->do_nans) {
+            isnan1 = HDisnan(temp1_double);
+            isnan2 = HDisnan(temp2_double);
+        }
 
-            /*-------------------------------------------------------------------------
-             * detect NaNs
-             *-------------------------------------------------------------------------
-             */
-            if (opts->do_nans) {
-                isnan1 = HDisnan(temp1_double);
-                isnan2 = HDisnan(temp2_double);
-            }
-            /* both not NaN, do the comparison */
-            if (!isnan1 && !isnan2) {
-                PER(temp1_double, temp2_double);
+        /* both not NaN, do the comparison */
+        if (!isnan1 && !isnan2) {
+            PER(temp1_double,temp2_double);
 
-                if (not_comparable && !both_zero) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT_P_NOTCOMP, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
-                    }
-                    nfound++;
-                }
-                else if (per > opts->percent) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT_P, temp1_double, temp2_double,
-                                ABS(temp1_double - temp2_double), ABS(1-temp2_double / temp1_double));
-                    }
-                    nfound++;
+            if (not_comparable && !both_zero) {
+                opts->print_percentage = 1;
+                print_pos(opts, elem_idx, -1);
+                if (print_data(opts)) {
+                    parallel_print(LD_FORMAT_P_NOTCOMP, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
                 }
+                nfound++;
             }
-            /* only one is NaN, assume difference */
-            else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
+            else if (per > opts->percent) {
+                opts->print_percentage = 1;
+                print_pos(opts, elem_idx, -1);
                 if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start+i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
+                    parallel_print(LD_FORMAT_P, temp1_double, temp2_double, ABS(temp1_double - temp2_double), ABS(1 - temp2_double / temp1_double));
                 }
                 nfound++;
             }
-            mem1 += sizeof(long double);
-            mem2 += sizeof(long double);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
-        } /* i */
+        } /* NaN */
+        /* only one is NaN, assume difference */
+        else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
+            opts->print_percentage = 0;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
+            }
+            nfound++;
+        }
     }
     /*-------------------------------------------------------------------------
      * -d and -p
      *-------------------------------------------------------------------------
      */
-    else if (opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_double, mem1, sizeof(long double));
-            HDmemcpy(&temp2_double, mem2, sizeof(long double));
-
-            /*-------------------------------------------------------------------------
-             * detect NaNs
-             *-------------------------------------------------------------------------
-             */
-            if (opts->do_nans) {
-                isnan1 = HDisnan(temp1_double);
-                isnan2 = HDisnan(temp2_double);
-            }
+    else if (opts->delta_bool && opts->percent_bool) {
+        /*-------------------------------------------------------------------------
+         * detect NaNs
+         *-------------------------------------------------------------------------
+         */
+        if (opts->do_nans) {
+            isnan1 = HDisnan(temp1_double);
+            isnan2 = HDisnan(temp2_double);
+        }
 
-            /* both not NaN, do the comparison */
-            if (!isnan1 && !isnan2) {
-                PER(temp1_double, temp2_double);
+        /* both not NaN, do the comparison */
+        if (!isnan1 && !isnan2) {
+            PER(temp1_double,temp2_double);
 
-                if (not_comparable && !both_zero) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT_P_NOTCOMP, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
-                    }
-                    nfound++;
-                }
-                else if (per > opts->percent && ABS(temp1_double - temp2_double) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(F_FORMAT_P, temp1_double, temp2_double, ABS(temp1_double - temp2_double), ABS(1-temp2_double / temp1_double));
-                    }
-                    nfound++;
+            if (not_comparable && !both_zero) {
+                opts->print_percentage = 1;
+                print_pos(opts, elem_idx, -1);
+                if (print_data(opts)) {
+                    parallel_print(LD_FORMAT_P_NOTCOMP, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
                 }
+                nfound++;
             }
-            /* only one is NaN, assume difference */
-            else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
-                if (print_data(opts))  {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
+            else if (per > opts->percent && ABS(temp1_double-temp2_double) > opts->delta) {
+                opts->print_percentage = 1;
+                print_pos(opts, elem_idx, -1);
+                if (print_data(opts)) {
+                    parallel_print(LD_FORMAT_P, temp1_double, temp2_double, ABS(temp1_double - temp2_double), ABS(1 - temp2_double / temp1_double));
                 }
                 nfound++;
             }
-            mem1 += sizeof(long double);
-            mem2 += sizeof(long double);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
-        } /* i */
+        } /* NaN */
+        /* only one is NaN, assume difference */
+        else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
+            opts->print_percentage = 0;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
+            }
+            nfound++;
+        }
     }
     /*-------------------------------------------------------------------------
      * no -d and -p
      *-------------------------------------------------------------------------
      */
-    else {
-        for (i = 0; i < nelmts; i++)  {
-            HDmemcpy(&temp1_double, mem1, sizeof(long double));
-            HDmemcpy(&temp2_double, mem2, sizeof(long double));
-
-            if (equal_ldouble(temp1_double, temp2_double, opts) == FALSE) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
-                }
-                nfound++;
-            }
-            mem1 += sizeof(long double);
-            mem2 += sizeof(long double);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
-        } /* nelmts */
+    else if (equal_ldouble(temp1_double, temp2_double, opts) == FALSE) {
+        opts->print_percentage = 0;
+        print_pos(opts, elem_idx, -1);
+        if (print_data(opts)) {
+            parallel_print(LD_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
+        }
+        nfound++;
     }
 
+    H5TOOLS_ENDDEBUG(":%d - errstat:%d", nfound, opts->err_stat);
+
     return nfound;
 }
 #endif /* H5_SIZEOF_LONG_DOUBLE */
 
 /*-------------------------------------------------------------------------
- * Function: diff_schar
+ * Function: diff_schar_element
  *
- * Purpose:  diff a H5T_NATIVE_SCHAR type
+ * Purpose:  diff a single H5T_NATIVE_SCHAR type
  *
  * Return:   number of differences found
  *-------------------------------------------------------------------------
  */
-static hsize_t diff_schar(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims,
-        hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1,
-        const char *obj2, int *ph)
-
+static hsize_t diff_schar_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts)
 {
     hsize_t nfound = 0; /* number of differences found */
     char    temp1_char;
     char    temp2_char;
-    hsize_t i;
     double  per;
-    hbool_t both_zero;
+    hbool_t both_zero = FALSE;
 
-    /* -d and !-p */
-    if (opts->d && !opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_char, mem1, sizeof(char));
-            HDmemcpy(&temp2_char, mem2, sizeof(char));
+    H5TOOLS_START_DEBUG("delta_bool:%d - percent_bool:%d", opts->delta_bool, opts->percent_bool);
+    HDmemcpy(&temp1_char, mem1, sizeof(char));
+    HDmemcpy(&temp2_char, mem2, sizeof(char));
 
-            if (ABS(temp1_char-temp2_char) > opts->delta) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT, temp1_char, temp2_char, ABS(temp1_char - temp2_char));
-                }
-                nfound++;
+    /* -d and !-p */
+    if (opts->delta_bool && !opts->percent_bool) {
+        if (ABS(temp1_char-temp2_char) > opts->delta) {
+            opts->print_percentage = 0;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT, temp1_char, temp2_char, ABS(temp1_char - temp2_char));
             }
-            mem1 += sizeof(char);
-            mem2 += sizeof(char);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
     /* !-d and -p */
-    else if (!opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_char, mem1, sizeof(char));
-            HDmemcpy(&temp2_char, mem2, sizeof(char));
-
-            PER(temp1_char, temp2_char);
+    else if (!opts->delta_bool && opts->percent_bool) {
+        PER(temp1_char, temp2_char);
 
-            if (not_comparable && !both_zero) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P_NOTCOMP, temp1_char, temp2_char, ABS(temp1_char - temp2_char));
-                }
-                nfound++;
+        if (not_comparable && !both_zero) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT_P_NOTCOMP, temp1_char, temp2_char, ABS(temp1_char - temp2_char));
             }
-            else if (per > opts->percent) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P, temp1_char, temp2_char, ABS(temp1_char - temp2_char), per);
-                }
-                nfound++;
+            nfound++;
+        }
+        else if (per > opts->percent) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT_P, temp1_char, temp2_char, ABS(temp1_char - temp2_char), per);
             }
-            mem1 += sizeof(char);
-            mem2 += sizeof(char);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
     /* -d and -p */
-    else if (opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_char, mem1, sizeof(char));
-            HDmemcpy(&temp2_char, mem2, sizeof(char));
+    else if (opts->delta_bool && opts->percent_bool) {
+        PER(temp1_char, temp2_char);
 
-            PER(temp1_char, temp2_char);
-
-            if (not_comparable && !both_zero) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P_NOTCOMP, temp1_char, temp2_char, ABS(temp1_char - temp2_char));
-                }
-                nfound++;
+        if (not_comparable && !both_zero) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT_P_NOTCOMP, temp1_char, temp2_char, ABS(temp1_char - temp2_char));
             }
-            else if (per > opts->percent && ABS(temp1_char-temp2_char) > opts->delta) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P, temp1_char, temp2_char, ABS(temp1_char - temp2_char), per);
-                }
-                nfound++;
+            nfound++;
+        }
+        else if (per > opts->percent && ABS(temp1_char - temp2_char) > opts->delta) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT_P, temp1_char, temp2_char, ABS(temp1_char - temp2_char), per);
             }
-            mem1 += sizeof(char);
-            mem2 += sizeof(char);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
-    else {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_char, mem1, sizeof(char));
-            HDmemcpy(&temp2_char, mem2, sizeof(char));
-
-            if (temp1_char != temp2_char) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT, temp1_char, temp2_char, ABS(temp1_char - temp2_char));
-                }
-                nfound++;
-            }
-
-            mem1 += sizeof(char);
-            mem2 += sizeof(char);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
-        } /* nelmts */
+    else if (temp1_char != temp2_char) {
+        opts->print_percentage = 0;
+        print_pos(opts, elem_idx, -1);
+        if (print_data(opts)) {
+            parallel_print(I_FORMAT, temp1_char, temp2_char, ABS(temp1_char - temp2_char));
+        }
+        nfound++;
     }
 
+    H5TOOLS_ENDDEBUG(":%d - errstat:%d", nfound, opts->err_stat);
+
     return nfound;
 }
 
 /*-------------------------------------------------------------------------
- * Function: diff_uchar
+ * Function: diff_uchar_element
  *
- * Purpose:  diff a H5T_NATIVE_UCHAR type
+ * Purpose:  diff a single H5T_NATIVE_UCHAR type
  *
  * Return:   number of differences found
  *-------------------------------------------------------------------------
  */
-static hsize_t diff_uchar(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims,
-        hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1,
-        const char *obj2, int *ph)
+static hsize_t diff_uchar_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts)
 {
     hsize_t       nfound = 0; /* number of differences found */
     unsigned char temp1_uchar;
     unsigned char temp2_uchar;
-    hsize_t       i;
     double        per;
-    hbool_t       both_zero;
+    hbool_t       both_zero = FALSE;
 
-    /* -d and !-p */
-    if (opts->d && !opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_uchar, mem1, sizeof(unsigned char));
-            HDmemcpy(&temp2_uchar, mem2, sizeof(unsigned char));
+    H5TOOLS_START_DEBUG("delta_bool:%d - percent_bool:%d", opts->delta_bool, opts->percent_bool);
 
-            if (PDIFF(temp1_uchar,temp2_uchar) > opts->delta) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar));
-                }
-                nfound++;
+    HDmemcpy(&temp1_uchar, mem1, sizeof(unsigned char));
+    HDmemcpy(&temp2_uchar, mem2, sizeof(unsigned char));
+    /* -d and !-p */
+    if (opts->delta_bool && !opts->percent_bool) {
+        if (PDIFF(temp1_uchar, temp2_uchar) > opts->delta) {
+            opts->print_percentage = 0;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar));
             }
-            mem1 += sizeof(unsigned char);
-            mem2 += sizeof(unsigned char);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
     /* !-d and -p */
-    else if (!opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_uchar, mem1, sizeof(unsigned char));
-            HDmemcpy(&temp2_uchar, mem2, sizeof(unsigned char));
-
-            PER_UNSIGN(signed char, temp1_uchar, temp2_uchar);
+    else if (!opts->delta_bool && opts->percent_bool) {
+        PER_UNSIGN(signed char, temp1_uchar, temp2_uchar);
 
-            if (not_comparable && !both_zero) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P_NOTCOMP, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar));
-                }
-                nfound++;
+        if (not_comparable && !both_zero) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT_P_NOTCOMP, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar));
             }
-            else if (per > opts->percent) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar), per);
-                }
-                nfound++;
+            nfound++;
+        }
+        else if (per > opts->percent) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT_P, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar), per);
             }
-            mem1 += sizeof(unsigned char);
-            mem2 += sizeof(unsigned char);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
     /* -d and -p */
-    else if (opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_uchar, mem1, sizeof(unsigned char));
-            HDmemcpy(&temp2_uchar, mem2, sizeof(unsigned char));
-
-            PER_UNSIGN(signed char, temp1_uchar, temp2_uchar);
+    else if (opts->delta_bool && opts->percent_bool) {
+        PER_UNSIGN(signed char, temp1_uchar, temp2_uchar);
 
-            if (not_comparable && !both_zero) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P_NOTCOMP, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar));
-                }
-                nfound++;
+        if (not_comparable && !both_zero) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT_P_NOTCOMP, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar));
             }
-            else if (per > opts->percent && PDIFF(temp1_uchar,temp2_uchar) > opts->delta) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar), per);
-                }
-                nfound++;
+            nfound++;
+        }
+        else if (per > opts->percent && PDIFF(temp1_uchar, temp2_uchar) > opts->delta) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT_P, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar), per);
             }
-            mem1 += sizeof(unsigned char);
-            mem2 += sizeof(unsigned char);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
-    else {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_uchar, mem1, sizeof(unsigned char));
-            HDmemcpy(&temp2_uchar, mem2, sizeof(unsigned char));
-
-            if (temp1_uchar != temp2_uchar) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar));
-                }
-                nfound++;
-            }
-
-            mem1 += sizeof(unsigned char);
-            mem2 += sizeof(unsigned char);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
-        } /* nelmts */
+    else if (temp1_uchar != temp2_uchar) {
+        opts->print_percentage = 0;
+        print_pos(opts, elem_idx, -1);
+        if (print_data(opts)) {
+            parallel_print(I_FORMAT, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar));
+        }
+        nfound++;
     }
 
+    H5TOOLS_ENDDEBUG(":%d - errstat:%d", nfound, opts->err_stat);
+
     return nfound;
 }
 
 /*-------------------------------------------------------------------------
- * Function: diff_short
+ * Function: diff_short_element
  *
  * Purpose:  diff a H5T_NATIVE_SHORT type
  *
  * Return:   number of differences found
  *-------------------------------------------------------------------------
  */
-static hsize_t diff_short(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims,
-        hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1,
-        const char *obj2, int *ph)
+static hsize_t diff_short_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts)
 {
     hsize_t nfound = 0; /* number of differences found */
     short   temp1_short;
     short   temp2_short;
-    hsize_t i;
     double  per;
-    hbool_t both_zero;
+    hbool_t both_zero = FALSE;
 
-    /* -d and !-p */
-    if (opts->d && !opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_short, mem1, sizeof(short));
-            HDmemcpy(&temp2_short, mem2, sizeof(short));
+    H5TOOLS_START_DEBUG("delta_bool:%d - percent_bool:%d", opts->delta_bool, opts->percent_bool);
 
-            if (ABS(temp1_short-temp2_short) > opts->delta) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT, temp1_short, temp2_short, ABS(temp1_short - temp2_short));
-                }
-                nfound++;
+    HDmemcpy(&temp1_short, mem1, sizeof(short));
+    HDmemcpy(&temp2_short, mem2, sizeof(short));
+    /* -d and !-p */
+    if (opts->delta_bool && !opts->percent_bool) {
+        if (ABS(temp1_short - temp2_short) > opts->delta) {
+            opts->print_percentage = 0;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT, temp1_short, temp2_short, ABS(temp1_short - temp2_short));
             }
-            mem1 += sizeof(short);
-            mem2 += sizeof(short);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
     /* !-d and -p */
-    else if (!opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_short, mem1, sizeof(short));
-            HDmemcpy(&temp2_short, mem2, sizeof(short));
+    else if (!opts->delta_bool && opts->percent_bool) {
+        PER(temp1_short, temp2_short);
 
-            PER(temp1_short, temp2_short);
-
-            if (not_comparable && !both_zero) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P_NOTCOMP, temp1_short, temp2_short, ABS(temp1_short - temp2_short));
-                }
-                nfound++;
+        if (not_comparable && !both_zero) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT_P_NOTCOMP, temp1_short, temp2_short, ABS(temp1_short - temp2_short));
             }
-            else if (per > opts->percent) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P, temp1_short, temp2_short, ABS(temp1_short - temp2_short), per);
-                }
-                nfound++;
+            nfound++;
+        }
+        else if (per > opts->percent) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT_P, temp1_short, temp2_short, ABS(temp1_short - temp2_short), per);
             }
-            mem1 += sizeof(short);
-            mem2 += sizeof(short);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
     /* -d and -p */
-    else if (opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_short, mem1, sizeof(short));
-            HDmemcpy(&temp2_short, mem2, sizeof(short));
-
-            PER(temp1_short, temp2_short);
+    else if (opts->delta_bool && opts->percent_bool) {
+        PER(temp1_short, temp2_short);
 
-            if (not_comparable && !both_zero) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P_NOTCOMP, temp1_short, temp2_short, ABS(temp1_short - temp2_short));
-                }
-                nfound++;
+        if (not_comparable && !both_zero) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT_P_NOTCOMP, temp1_short, temp2_short, ABS(temp1_short - temp2_short));
             }
-            else if (per > opts->percent && ABS(temp1_short-temp2_short) > opts->delta) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P, temp1_short, temp2_short, ABS(temp1_short - temp2_short), per);
-                }
-                nfound++;
+            nfound++;
+        }
+        else if (per > opts->percent && ABS(temp1_short - temp2_short) > opts->delta) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT_P, temp1_short, temp2_short, ABS(temp1_short - temp2_short), per);
             }
-            mem1 += sizeof(short);
-            mem2 += sizeof(short);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
-    else {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_short, mem1, sizeof(short));
-            HDmemcpy(&temp2_short, mem2, sizeof(short));
-
-            if (temp1_short != temp2_short) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT, temp1_short, temp2_short, ABS(temp1_short - temp2_short));
-                }
-                nfound++;
-            }
-
-            mem1 += sizeof(short);
-            mem2 += sizeof(short);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
-        } /* nelmts */
+    else if (temp1_short != temp2_short) {
+        opts->print_percentage = 0;
+        print_pos(opts, elem_idx, -1);
+        if (print_data(opts)) {
+            parallel_print(I_FORMAT, temp1_short, temp2_short, ABS(temp1_short - temp2_short));
+        }
+        nfound++;
     }
 
+    H5TOOLS_ENDDEBUG(":%d - errstat:%d", nfound, opts->err_stat);
+
     return nfound;
 }
 
 /*-------------------------------------------------------------------------
- * Function: diff_ushort
+ * Function: diff_ushort_element
  *
- * Purpose:  diff a H5T_NATIVE_USHORT type
+ * Purpose:  diff a single H5T_NATIVE_USHORT type
  *
  * Return:   number of differences found
  *-------------------------------------------------------------------------
  */
-static hsize_t diff_ushort(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims,
-        hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1,
-        const char *obj2, int *ph)
-
+static hsize_t diff_ushort_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts)
 {
     hsize_t        nfound = 0; /* number of differences found */
     unsigned short temp1_ushort;
     unsigned short temp2_ushort;
-    hsize_t        i;
     double         per;
-    hbool_t        both_zero;
+    hbool_t        both_zero = FALSE;
 
-    /* -d and !-p */
-    if (opts->d && !opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_ushort, mem1, sizeof(unsigned short));
-            HDmemcpy(&temp2_ushort, mem2, sizeof(unsigned short));
+    H5TOOLS_START_DEBUG("delta_bool:%d - percent_bool:%d", opts->delta_bool, opts->percent_bool);
 
-            if (PDIFF(temp1_ushort,temp2_ushort) > opts->delta) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort));
-                }
-                nfound++;
+    HDmemcpy(&temp1_ushort, mem1, sizeof(unsigned short));
+    HDmemcpy(&temp2_ushort, mem2, sizeof(unsigned short));
+    /* -d and !-p */
+    if (opts->delta_bool && !opts->percent_bool) {
+        if (PDIFF(temp1_ushort, temp2_ushort) > opts->delta) {
+            opts->print_percentage = 0;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort));
             }
-            mem1 += sizeof(unsigned short);
-            mem2 += sizeof(unsigned short);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
     /* !-d and -p */
-    else if (!opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_ushort, mem1, sizeof(unsigned short));
-            HDmemcpy(&temp2_ushort, mem2, sizeof(unsigned short));
+    else if (!opts->delta_bool && opts->percent_bool) {
+        PER_UNSIGN(signed short, temp1_ushort, temp2_ushort);
 
-            PER_UNSIGN(signed short, temp1_ushort, temp2_ushort);
-
-            if (not_comparable && !both_zero)  {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P_NOTCOMP, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort));
-                }
-                nfound++;
+        if (not_comparable && !both_zero) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT_P_NOTCOMP, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort));
             }
-            else if (per > opts->percent) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort), per);
-                }
-                nfound++;
+            nfound++;
+        }
+        else if (per > opts->percent) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT_P, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort), per);
             }
-            mem1 += sizeof(unsigned short);
-            mem2 += sizeof(unsigned short);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
     /* -d and -p */
-    else if (opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_ushort, mem1, sizeof(unsigned short));
-            HDmemcpy(&temp2_ushort, mem2, sizeof(unsigned short));
-
-            PER_UNSIGN(signed short, temp1_ushort, temp2_ushort);
+    else if (opts->delta_bool && opts->percent_bool) {
+        PER_UNSIGN(signed short, temp1_ushort, temp2_ushort);
 
-            if (not_comparable && !both_zero) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P_NOTCOMP, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort));
-                }
-                nfound++;
+        if (not_comparable && !both_zero) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT_P_NOTCOMP, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort));
             }
-            else if (per > opts->percent && PDIFF(temp1_ushort,temp2_ushort) > opts->delta) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort), per);
-                }
-                nfound++;
+            nfound++;
+        }
+        else if (per > opts->percent && PDIFF(temp1_ushort, temp2_ushort) > opts->delta) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT_P, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort), per);
             }
-            mem1 += sizeof(unsigned short);
-            mem2 += sizeof(unsigned short);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
-    else {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_ushort, mem1, sizeof(unsigned short));
-            HDmemcpy(&temp2_ushort, mem2, sizeof(unsigned short));
-
-            if (temp1_ushort != temp2_ushort) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort));
-                }
-                nfound++;
-            }
-
-            mem1 += sizeof(unsigned short);
-            mem2 += sizeof(unsigned short);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
-        } /* nelmts */
+    else if (temp1_ushort != temp2_ushort) {
+        opts->print_percentage = 0;
+        print_pos(opts, elem_idx, -1);
+        if (print_data(opts)) {
+            parallel_print(I_FORMAT, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort));
+        }
+        nfound++;
     }
 
+    H5TOOLS_ENDDEBUG(":%d - errstat:%d", nfound, opts->err_stat);
+
     return nfound;
 }
 
 /*-------------------------------------------------------------------------
- * Function:  diff_int
+ * Function:  diff_int_element
  *
- * Purpose:   diff a H5T_NATIVE_INT type
+ * Purpose:   diff a single H5T_NATIVE_INT type
  *
  * Return:    number of differences found
   *-------------------------------------------------------------------------
  */
-static hsize_t diff_int(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims,
-        hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1,
-        const char *obj2, int *ph)
+static hsize_t diff_int_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts)
 {
     hsize_t nfound = 0; /* number of differences found */
     int     temp1_int;
     int     temp2_int;
-    hsize_t i;
     double  per;
-    hbool_t both_zero;
+    hbool_t both_zero = FALSE;
 
-    /* -d and !-p */
-    if (opts->d && !opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_int, mem1, sizeof(int));
-            HDmemcpy(&temp2_int, mem2, sizeof(int));
+    H5TOOLS_START_DEBUG("delta_bool:%d - percent_bool:%d", opts->delta_bool, opts->percent_bool);
 
-            if (ABS(temp1_int-temp2_int) > opts->delta) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT, temp1_int, temp2_int, ABS(temp1_int - temp2_int));
-                }
-                nfound++;
+    HDmemcpy(&temp1_int, mem1, sizeof(int));
+    HDmemcpy(&temp2_int, mem2, sizeof(int));
+    /* -d and !-p */
+    if (opts->delta_bool && !opts->percent_bool) {
+        if (ABS(temp1_int-temp2_int) > opts->delta) {
+            opts->print_percentage = 0;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT, temp1_int, temp2_int, ABS(temp1_int - temp2_int));
             }
-            mem1 += sizeof(int);
-            mem2 += sizeof(int);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
     /* !-d and -p */
-    else if (!opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_int, mem1, sizeof(int));
-            HDmemcpy(&temp2_int, mem2, sizeof(int));
-
-            PER(temp1_int, temp2_int);
+    else if (!opts->delta_bool && opts->percent_bool) {
+        PER(temp1_int, temp2_int);
 
-            if (not_comparable && !both_zero) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P_NOTCOMP, temp1_int, temp2_int, ABS(temp1_int - temp2_int));
-                }
-                nfound++;
+        if (not_comparable && !both_zero) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT_P_NOTCOMP, temp1_int, temp2_int, ABS(temp1_int - temp2_int));
             }
-            else if (per > opts->percent) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P, temp1_int, temp2_int, ABS(temp1_int - temp2_int), per);
-                }
-                nfound++;
+            nfound++;
+        }
+        else if (per > opts->percent) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT_P, temp1_int, temp2_int, ABS(temp1_int - temp2_int), per);
             }
-            mem1 += sizeof(int);
-            mem2 += sizeof(int);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
     /* -d and -p */
-    else if (opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_int, mem1, sizeof(int));
-            HDmemcpy(&temp2_int, mem2, sizeof(int));
+    else if (opts->delta_bool && opts->percent_bool) {
+        PER(temp1_int, temp2_int);
 
-            PER(temp1_int, temp2_int);
-
-            if (not_comparable && !both_zero) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P_NOTCOMP, temp1_int, temp2_int, ABS(temp1_int - temp2_int));
-                }
-                nfound++;
+        if (not_comparable && !both_zero) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT_P_NOTCOMP, temp1_int, temp2_int, ABS(temp1_int - temp2_int));
             }
-            else if (per > opts->percent && ABS(temp1_int-temp2_int) > opts->delta) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P, temp1_int, temp2_int, ABS(temp1_int - temp2_int), per);
-                }
-                nfound++;
+            nfound++;
+        }
+        else if (per > opts->percent && ABS(temp1_int - temp2_int) > opts->delta) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(I_FORMAT_P, temp1_int, temp2_int, ABS(temp1_int - temp2_int), per);
             }
-            mem1 += sizeof(int);
-            mem2 += sizeof(int);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
-    else {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_int, mem1, sizeof(int));
-            HDmemcpy(&temp2_int, mem2, sizeof(int));
-
-            if (temp1_int != temp2_int) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT, temp1_int, temp2_int, ABS(temp1_int - temp2_int));
-                }
-                nfound++;
-            }
+    else if (temp1_int != temp2_int) {
+        opts->print_percentage = 0;
+        print_pos(opts, elem_idx, -1);
+        if (print_data(opts)) {
+            parallel_print(I_FORMAT, temp1_int, temp2_int, ABS(temp1_int - temp2_int));
+        }
+        nfound++;
+    }
 
-            mem1 += sizeof(int);
-            mem2 += sizeof(int);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
-        } /* nelmts */
+    H5TOOLS_ENDDEBUG(":%d - errstat:%d", nfound, opts->err_stat);
 
-    }
     return nfound;
 }
 
 /*-------------------------------------------------------------------------
- * Function: diff_uint
+ * Function: diff_uint_element
  *
- * Purpose:  diff a H5T_NATIVE_UINT type
+ * Purpose:  diff a single H5T_NATIVE_UINT type
  *
  * Return:  number of differences found
  *-------------------------------------------------------------------------
  */
-static hsize_t diff_uint(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims,
-        hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1,
-        const char *obj2, int *ph)
+static hsize_t diff_uint_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts)
 {
     hsize_t nfound = 0; /* number of differences found */
     unsigned int temp1_uint;
     unsigned int temp2_uint;
-    hsize_t i;
     double per;
-    hbool_t both_zero;
-
-    /* -d and !-p */
-    if (opts->d && !opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_uint, mem1, sizeof(unsigned int));
-            HDmemcpy(&temp2_uint, mem2, sizeof(unsigned int));
+    hbool_t both_zero = FALSE;
 
-            if (PDIFF(temp1_uint,temp2_uint) > opts->delta) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint));
-                }
-                nfound++;
+    H5TOOLS_START_DEBUG("delta_bool:%d - percent_bool:%d", opts->delta_bool, opts->percent_bool);
+
+    HDmemcpy(&temp1_uint, mem1, sizeof(unsigned int));
+    HDmemcpy(&temp2_uint, mem2, sizeof(unsigned int));
+    /* -d and !-p */
+    if (opts->delta_bool && !opts->percent_bool) {
+        if (PDIFF(temp1_uint, temp2_uint) > opts->delta) {
+            opts->print_percentage = 0;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(UI_FORMAT, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint));
             }
-            mem1 += sizeof(unsigned int);
-            mem2 += sizeof(unsigned int);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
     /* !-d and -p */
-    else if (!opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_uint, mem1, sizeof(unsigned int));
-            HDmemcpy(&temp2_uint, mem2, sizeof(unsigned int));
+    else if (!opts->delta_bool && opts->percent_bool) {
+        PER_UNSIGN(signed int, temp1_uint, temp2_uint);
 
-            PER_UNSIGN(signed int, temp1_uint, temp2_uint);
-
-            if (not_comparable && !both_zero) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P_NOTCOMP, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint));
-                }
-                nfound++;
+        if (not_comparable && !both_zero) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(UI_FORMAT_P_NOTCOMP, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint));
             }
-            else if (per > opts->percent) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint), per);
-                }
-                nfound++;
+            nfound++;
+        }
+        else if (per > opts->percent) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(UI_FORMAT_P, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint), per);
             }
-            mem1 += sizeof(unsigned int);
-            mem2 += sizeof(unsigned int);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
     /* -d and -p */
-    else if (opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_uint, mem1, sizeof(unsigned int));
-            HDmemcpy(&temp2_uint, mem2, sizeof(unsigned int));
-
-            PER_UNSIGN(signed int, temp1_uint, temp2_uint);
+    else if (opts->delta_bool && opts->percent_bool) {
+        PER_UNSIGN(signed int, temp1_uint, temp2_uint);
 
-            if (not_comparable && !both_zero) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P_NOTCOMP, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint));
-                }
-                nfound++;
+        if (not_comparable && !both_zero) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(UI_FORMAT_P_NOTCOMP, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint));
             }
-            else if (per > opts->percent
-                    && PDIFF(temp1_uint,temp2_uint) > opts->delta) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT_P, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint), per);
-                }
-                nfound++;
+            nfound++;
+        }
+        else if (per > opts->percent && PDIFF(temp1_uint,temp2_uint) > opts->delta) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(UI_FORMAT_P, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint), per);
             }
-            mem1 += sizeof(unsigned int);
-            mem2 += sizeof(unsigned int);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
-    else {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_uint, mem1, sizeof(unsigned int));
-            HDmemcpy(&temp2_uint, mem2, sizeof(unsigned int));
-
-            if (temp1_uint != temp2_uint) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(I_FORMAT, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint));
-                }
-                nfound++;
-            }
-
-            mem1 += sizeof(unsigned int);
-            mem2 += sizeof(unsigned int);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
-        } /* nelmts */
+    else if (temp1_uint != temp2_uint) {
+        opts->print_percentage = 0;
+        print_pos(opts, elem_idx, -1);
+        if (print_data(opts)) {
+            parallel_print(UI_FORMAT, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint));
+        }
+        nfound++;
     }
 
+    H5TOOLS_ENDDEBUG(":%d - errstat:%d", nfound, opts->err_stat);
+
     return nfound;
 }
 
 /*-------------------------------------------------------------------------
- * Function: diff_long
+ * Function: diff_long_element
  *
- * Purpose:  diff a H5T_NATIVE_LONG type
+ * Purpose:  diff a single H5T_NATIVE_LONG type
  *
  * Return:   number of differences found
  *-------------------------------------------------------------------------
  */
-static hsize_t diff_long(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims,
-        hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1,
-        const char *obj2, int *ph)
+static hsize_t diff_long_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts)
 {
     hsize_t nfound = 0; /* number of differences found */
     long temp1_long;
     long temp2_long;
-    hsize_t i;
     double per;
-    hbool_t both_zero;
+    hbool_t both_zero = FALSE;
 
-    /* -d and !-p */
-    if (opts->d && !opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            for (i = 0; i < nelmts; i++) {
-                HDmemcpy(&temp1_long, mem1, sizeof(long));
-                HDmemcpy(&temp2_long, mem2, sizeof(long));
+    H5TOOLS_START_DEBUG("delta_bool:%d - percent_bool:%d", opts->delta_bool, opts->percent_bool);
 
-                if (ABS(temp1_long-temp2_long) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(LI_FORMAT, temp1_long, temp2_long, ABS(temp1_long - temp2_long));
-                    }
-                    nfound++;
-                }
-                mem1 += sizeof(long);
-                mem2 += sizeof(long);
-                if (opts->n && nfound >= opts->count)
-                    return nfound;
+    HDmemcpy(&temp1_long, mem1, sizeof(long));
+    HDmemcpy(&temp2_long, mem2, sizeof(long));
+    /* -d and !-p */
+    if (opts->delta_bool && !opts->percent_bool) {
+        if (ABS(temp1_long-temp2_long) > opts->delta) {
+            opts->print_percentage = 0;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(LI_FORMAT, temp1_long, temp2_long, ABS(temp1_long - temp2_long));
             }
+            nfound++;
         }
     }
     /* !-d and -p */
-    else if (!opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_long, mem1, sizeof(long));
-            HDmemcpy(&temp2_long, mem2, sizeof(long));
+    else if (!opts->delta_bool && opts->percent_bool) {
+        PER(temp1_long, temp2_long);
 
-            PER(temp1_long, temp2_long);
-
-            if (not_comparable && !both_zero) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(LI_FORMAT_P_NOTCOMP, temp1_long, temp2_long, ABS(temp1_long - temp2_long));
-                }
-                nfound++;
+        if (not_comparable && !both_zero) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(LI_FORMAT_P_NOTCOMP, temp1_long, temp2_long, ABS(temp1_long - temp2_long));
             }
-            else if (per > opts->percent) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(LI_FORMAT_P, temp1_long, temp2_long, ABS(temp1_long - temp2_long), per);
-                }
-                nfound++;
+            nfound++;
+        }
+        else if (per > opts->percent) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(LI_FORMAT_P, temp1_long, temp2_long, ABS(temp1_long - temp2_long), per);
             }
-            mem1 += sizeof(long);
-            mem2 += sizeof(long);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
     /* -d and -p */
-    else if (opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_long, mem1, sizeof(long));
-            HDmemcpy(&temp2_long, mem2, sizeof(long));
-
-            PER(temp1_long, temp2_long);
+    else if (opts->delta_bool && opts->percent_bool) {
+        PER(temp1_long, temp2_long);
 
-            if (not_comparable && !both_zero) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(LI_FORMAT_P_NOTCOMP, temp1_long, temp2_long, ABS(temp1_long - temp2_long));
-                }
-                nfound++;
+        if (not_comparable && !both_zero) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(LI_FORMAT_P_NOTCOMP, temp1_long, temp2_long, ABS(temp1_long - temp2_long));
             }
-            else if (per > opts->percent && ABS(temp1_long-temp2_long) > opts->delta) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(LI_FORMAT_P, temp1_long, temp2_long, ABS(temp1_long - temp2_long), per);
-                }
-                nfound++;
+            nfound++;
+        }
+        else if (per > opts->percent && ABS(temp1_long-temp2_long) > opts->delta) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(LI_FORMAT_P, temp1_long, temp2_long, ABS(temp1_long - temp2_long), per);
             }
-            mem1 += sizeof(long);
-            mem2 += sizeof(long);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
-    else {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_long, mem1, sizeof(long));
-            HDmemcpy(&temp2_long, mem2, sizeof(long));
-
-            if (temp1_long != temp2_long) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(LI_FORMAT, temp1_long, temp2_long, ABS(temp1_long - temp2_long));
-                }
-                nfound++;
-            }
-
-            mem1 += sizeof(long);
-            mem2 += sizeof(long);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
-        } /* nelmts */
+    else if (temp1_long != temp2_long) {
+        opts->print_percentage = 0;
+        print_pos(opts, elem_idx, -1);
+        if (print_data(opts)) {
+            parallel_print(LI_FORMAT, temp1_long, temp2_long, ABS(temp1_long - temp2_long));
+        }
+        nfound++;
     }
 
+    H5TOOLS_ENDDEBUG(":%d - errstat:%d", nfound, opts->err_stat);
+
     return nfound;
 }
 
 /*-------------------------------------------------------------------------
- * Function: diff_ulong
+ * Function: diff_ulong_element
  *
- * Purpose:  diff a H5T_NATIVE_ULONG type
+ * Purpose:  diff a single H5T_NATIVE_ULONG type
  *
  * Return:   number of differences found
  *-------------------------------------------------------------------------
  */
-static hsize_t diff_ulong(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims,
-        hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1,
-        const char *obj2, int *ph)
+static hsize_t diff_ulong_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts)
 {
     hsize_t       nfound = 0; /* number of differences found */
     unsigned long temp1_ulong;
     unsigned long temp2_ulong;
-    hsize_t       i;
     double        per;
-    hbool_t       both_zero;
+    hbool_t       both_zero = FALSE;
 
-    /* -d and !-p */
-    if (opts->d && !opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            for (i = 0; i < nelmts; i++) {
-                HDmemcpy(&temp1_ulong, mem1, sizeof(unsigned long));
-                HDmemcpy(&temp2_ulong, mem2, sizeof(unsigned long));
+    H5TOOLS_START_DEBUG("delta_bool:%d - percent_bool:%d", opts->delta_bool, opts->percent_bool);
 
-                if (PDIFF(temp1_ulong,temp2_ulong) > opts->delta) {
-                    if (print_data(opts)) {
-                        print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                        parallel_print(SPACES);
-                        parallel_print(LI_FORMAT, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong));
-                    }
-                    nfound++;
-                }
-                mem1 += sizeof(unsigned long);
-                mem2 += sizeof(unsigned long);
-                if (opts->n && nfound >= opts->count)
-                    return nfound;
+    HDmemcpy(&temp1_ulong, mem1, sizeof(unsigned long));
+    HDmemcpy(&temp2_ulong, mem2, sizeof(unsigned long));
+    /* -d and !-p */
+    if (opts->delta_bool && !opts->percent_bool) {
+        if (PDIFF(temp1_ulong, temp2_ulong) > opts->delta) {
+            opts->print_percentage = 0;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(ULI_FORMAT, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong));
             }
+            nfound++;
         }
     }
     /* !-d and -p */
-    else if (!opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_ulong, mem1, sizeof(unsigned long));
-            HDmemcpy(&temp2_ulong, mem2, sizeof(unsigned long));
+    else if (!opts->delta_bool && opts->percent_bool) {
+        PER_UNSIGN(signed long, temp1_ulong, temp2_ulong);
 
-            PER_UNSIGN(signed long, temp1_ulong, temp2_ulong);
-
-            if (not_comparable && !both_zero) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(ULI_FORMAT_P_NOTCOMP, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong));
-                }
-                nfound++;
+        if (not_comparable && !both_zero) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(ULI_FORMAT_P_NOTCOMP, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong));
             }
-            else if (per > opts->percent) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(LI_FORMAT_P, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong), per);
-                }
-                nfound++;
+            nfound++;
+        }
+        else if (per > opts->percent) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(ULI_FORMAT_P, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong), per);
             }
-            mem1 += sizeof(unsigned long);
-            mem2 += sizeof(unsigned long);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
     /* -d and -p */
-    else if (opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_ulong, mem1, sizeof(unsigned long));
-            HDmemcpy(&temp2_ulong, mem2, sizeof(unsigned long));
-
-            PER_UNSIGN(signed long, temp1_ulong, temp2_ulong);
+    else if (opts->delta_bool && opts->percent_bool) {
+        PER_UNSIGN(signed long, temp1_ulong, temp2_ulong);
 
-            if (not_comparable && !both_zero) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(ULI_FORMAT_P_NOTCOMP, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong));
-                }
-                nfound++;
+        if (not_comparable && !both_zero) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(ULI_FORMAT_P_NOTCOMP, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong));
             }
-            else if (per > opts->percent
-                    && PDIFF(temp1_ulong,temp2_ulong) > opts->delta) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(LI_FORMAT_P, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong), per);
-                }
-                nfound++;
+            nfound++;
+        }
+        else if (per > opts->percent && PDIFF(temp1_ulong,temp2_ulong) > opts->delta) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(ULI_FORMAT_P, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong), per);
             }
-            mem1 += sizeof(unsigned long);
-            mem2 += sizeof(unsigned long);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
-    else {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_ulong, mem1, sizeof(unsigned long));
-            HDmemcpy(&temp2_ulong, mem2, sizeof(unsigned long));
-
-            if (temp1_ulong != temp2_ulong) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(LI_FORMAT, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong));
-                }
-                nfound++;
-            }
-
-            mem1 += sizeof(unsigned long);
-            mem2 += sizeof(unsigned long);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
-        } /* nelmts */
+    else if (temp1_ulong != temp2_ulong) {
+        opts->print_percentage = 0;
+        print_pos(opts, elem_idx, -1);
+        if (print_data(opts)) {
+            parallel_print(ULI_FORMAT, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong));
+        }
+        nfound++;
     }
 
+    H5TOOLS_ENDDEBUG(":%d - errstat:%d", nfound, opts->err_stat);
+
     return nfound;
 }
 
 /*-------------------------------------------------------------------------
- * Function: diff_llong
+ * Function: diff_llong_element
  *
- * Purpose:  diff a H5T_NATIVE_LLONG type
+ * Purpose:  diff a single H5T_NATIVE_LLONG type
  *
  * Return:   number of differences found
  *-------------------------------------------------------------------------
  */
-static hsize_t diff_llong(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims,
-        hsize_t *acc, hsize_t *pos, diff_opt_t *opts, const char *obj1,
-        const char *obj2, int *ph)
+static hsize_t diff_llong_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts)
 {
     hsize_t   nfound = 0; /* number of differences found */
     long long temp1_llong;
     long long temp2_llong;
-    hsize_t   i;
     double    per;
-    hbool_t   both_zero;
+    hbool_t   both_zero = FALSE;
 
-    /* -d and !-p */
-    if (opts->d && !opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_llong, mem1, sizeof(long long));
-            HDmemcpy(&temp2_llong, mem2, sizeof(long long));
+    H5TOOLS_START_DEBUG("delta_bool:%d - percent_bool:%d", opts->delta_bool, opts->percent_bool);
 
-            if (ABS( temp1_llong-temp2_llong) > opts->delta) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(LLI_FORMAT, temp1_llong, temp2_llong, ABS(temp1_llong - temp2_llong));
-                }
-                nfound++;
+    HDmemcpy(&temp1_llong, mem1, sizeof(long long));
+    HDmemcpy(&temp2_llong, mem2, sizeof(long long));
+
+    /* -d and !-p */
+    if (opts->delta_bool && !opts->percent_bool) {
+        if (ABS( temp1_llong-temp2_llong) > opts->delta) {
+            opts->print_percentage = 0;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(LLI_FORMAT, temp1_llong, temp2_llong, ABS(temp1_llong - temp2_llong));
             }
-            mem1 += sizeof(long long);
-            mem2 += sizeof(long long);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
     /* !-d and -p */
-    else if (!opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_llong, mem1, sizeof(long long));
-            HDmemcpy(&temp2_llong, mem2, sizeof(long long));
+    else if (!opts->delta_bool && opts->percent_bool) {
+        PER(temp1_llong, temp2_llong);
 
-            PER(temp1_llong, temp2_llong);
-
-            if (not_comparable && !both_zero) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
+        if (not_comparable && !both_zero) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
                 parallel_print(LLI_FORMAT_P_NOTCOMP, temp1_llong, temp2_llong, ABS(temp1_llong - temp2_llong));
             }
             nfound++;
         }
         else if (per > opts->percent) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
             if (print_data(opts)) {
-                print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                parallel_print(SPACES);
                 parallel_print(LLI_FORMAT_P, temp1_llong, temp2_llong, ABS(temp1_llong - temp2_llong),per);
             }
             nfound++;
         }
-        mem1 += sizeof(long long);
-        mem2 += sizeof(long long);
-        if (opts->n && nfound >= opts->count)
-            return nfound;
-        }
     }
     /* -d and -p */
-    else if (opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_llong, mem1, sizeof(long long));
-            HDmemcpy(&temp2_llong, mem2, sizeof(long long));
-
-            PER(temp1_llong, temp2_llong);
+    else if (opts->delta_bool && opts->percent_bool) {
+        PER(temp1_llong, temp2_llong);
 
-            if (not_comparable && !both_zero) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(LLI_FORMAT_P_NOTCOMP, temp1_llong, temp2_llong, ABS(temp1_llong - temp2_llong));
-                }
-                nfound++;
+        if (not_comparable && !both_zero) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(LLI_FORMAT_P_NOTCOMP, temp1_llong, temp2_llong, ABS(temp1_llong - temp2_llong));
             }
-            else if (per > opts->percent
-                    && ABS(temp1_llong-temp2_llong) > opts->delta) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(LLI_FORMAT_P, temp1_llong, temp2_llong, ABS(temp1_llong - temp2_llong),per);
-                }
-                nfound++;
+            nfound++;
+        }
+        else if (per > opts->percent && ABS(temp1_llong-temp2_llong) > opts->delta) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(LLI_FORMAT_P, temp1_llong, temp2_llong, ABS(temp1_llong - temp2_llong),per);
             }
-            mem1 += sizeof(long long);
-            mem2 += sizeof(long long);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
     else {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_llong, mem1, sizeof(long long));
-            HDmemcpy(&temp2_llong, mem2, sizeof(long long));
-
-            if (temp1_llong != temp2_llong) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(LLI_FORMAT, temp1_llong, temp2_llong, ABS(temp1_llong - temp2_llong));
-                }
-                nfound++;
+        if (temp1_llong != temp2_llong) {
+            opts->print_percentage = 0;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(LLI_FORMAT, temp1_llong, temp2_llong, ABS(temp1_llong - temp2_llong));
             }
-
-            mem1 += sizeof(long long);
-            mem2 += sizeof(long long);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
-        } /* nelmts */
+            nfound++;
+        }
     }
 
+    H5TOOLS_ENDDEBUG(":%d - errstat:%d", nfound, opts->err_stat);
+
     return nfound;
 }
 
 /*-------------------------------------------------------------------------
- * Function: diff_ullong
+ * Function: diff_ullong_element
  *
- * Purpose:  diff a H5T_NATIVE_ULLONG type
+ * Purpose:  diff a single H5T_NATIVE_ULLONG type
  *
  * Return:   number of differences found
  *-------------------------------------------------------------------------
  */
-static hsize_t diff_ullong(unsigned char *mem1, unsigned char *mem2,
-        hsize_t nelmts, hsize_t hyper_start, int rank, hsize_t *dims, hsize_t *acc,
-        hsize_t *pos, diff_opt_t *opts, const char *obj1, const char *obj2, int *ph)
-
+static hsize_t diff_ullong_element(unsigned char *mem1, unsigned char *mem2, hsize_t elem_idx, diff_opt_t *opts)
 {
     hsize_t            nfound = 0; /* number of differences found */
     unsigned long long temp1_ullong;
     unsigned long long temp2_ullong;
-    hsize_t            i;
     float              f1, f2;
     double             per;
-    hbool_t            both_zero;
+    hbool_t            both_zero = FALSE;
 
-    /* -d and !-p */
-    if (opts->d && !opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_ullong, mem1, sizeof(unsigned long long));
-            HDmemcpy(&temp2_ullong, mem2, sizeof(unsigned long long));
+    H5TOOLS_START_DEBUG("delta_bool:%d - percent_bool:%d", opts->delta_bool, opts->percent_bool);
 
-            if (PDIFF(temp1_ullong,temp2_ullong) > (unsigned long long) opts->delta) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(ULLI_FORMAT,temp1_ullong,temp2_ullong,PDIFF(temp1_ullong,temp2_ullong));
-                }
-                nfound++;
+    HDmemcpy(&temp1_ullong, mem1, sizeof(unsigned long long));
+    HDmemcpy(&temp2_ullong, mem2, sizeof(unsigned long long));
+
+    /* -d and !-p */
+    if (opts->delta_bool && !opts->percent_bool) {
+        if (PDIFF(temp1_ullong,temp2_ullong) > (unsigned long long) opts->delta) {
+            opts->print_percentage = 0;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(ULLI_FORMAT, temp1_ullong, temp2_ullong, PDIFF(temp1_ullong, temp2_ullong));
             }
-            mem1 += sizeof(unsigned long long);
-            mem2 += sizeof(unsigned long long);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
     /* !-d and -p */
-    else if (!opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_ullong, mem1, sizeof(unsigned long long));
-            HDmemcpy(&temp2_ullong, mem2, sizeof(unsigned long long));
-
-            ull2float(temp1_ullong, &f1);
-            ull2float(temp2_ullong, &f2);
-            PER(f1, f2);
-
-            if (not_comparable && !both_zero) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(ULLI_FORMAT_P_NOTCOMP,temp1_ullong,temp2_ullong,PDIFF(temp1_ullong,temp2_ullong));
-                }
-                nfound++;
+    else if (!opts->delta_bool && opts->percent_bool) {
+        ull2float(temp1_ullong, &f1);
+        ull2float(temp2_ullong, &f2);
+        PER(f1, f2);
+
+        if (not_comparable && !both_zero) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(ULLI_FORMAT_P_NOTCOMP, temp1_ullong, temp2_ullong, PDIFF(temp1_ullong, temp2_ullong));
             }
-            else if (per > opts->percent) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(ULLI_FORMAT_P,temp1_ullong,temp2_ullong,PDIFF(temp1_ullong,temp2_ullong),per);
-                }
-                nfound++;
+            nfound++;
+        }
+        else if (per > opts->percent) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(ULLI_FORMAT_P, temp1_ullong, temp2_ullong, PDIFF(temp1_ullong,temp2_ullong), per);
             }
-            mem1 += sizeof(unsigned long long);
-            mem2 += sizeof(unsigned long long);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
     /* -d and -p */
-    else if (opts->d && opts->p) {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_ullong, mem1, sizeof(unsigned long long));
-            HDmemcpy(&temp2_ullong, mem2, sizeof(unsigned long long));
-
-            ull2float(temp1_ullong, &f1);
-            ull2float(temp2_ullong, &f2);
-            PER(f1, f2);
-
-            if (not_comparable && !both_zero) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(ULLI_FORMAT_P_NOTCOMP,temp1_ullong,temp2_ullong,PDIFF(temp1_ullong,temp2_ullong));
-                }
-                nfound++;
+    else if (opts->delta_bool && opts->percent_bool) {
+        ull2float(temp1_ullong, &f1);
+        ull2float(temp2_ullong, &f2);
+        PER(f1, f2);
+
+        if (not_comparable && !both_zero) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(ULLI_FORMAT_P_NOTCOMP, temp1_ullong, temp2_ullong, PDIFF(temp1_ullong, temp2_ullong));
             }
-            else if (per > opts->percent
-                    && PDIFF(temp1_ullong,temp2_ullong) > (unsigned long long) opts->delta) {
-                if (print_data(opts)) {
-                    print_pos(ph, 1, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(ULLI_FORMAT_P,temp1_ullong,temp2_ullong,PDIFF(temp1_ullong,temp2_ullong),per);
-                }
-                nfound++;
+            nfound++;
+        }
+        else if (per > opts->percent && PDIFF(temp1_ullong,temp2_ullong) > (unsigned long long) opts->delta) {
+            opts->print_percentage = 1;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(ULLI_FORMAT_P, temp1_ullong, temp2_ullong, PDIFF(temp1_ullong, temp2_ullong), per);
             }
-            mem1 += sizeof(unsigned long long);
-            mem2 += sizeof(unsigned long long);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
+            nfound++;
         }
     }
     else {
-        for (i = 0; i < nelmts; i++) {
-            HDmemcpy(&temp1_ullong, mem1, sizeof(unsigned long long));
-            HDmemcpy(&temp2_ullong, mem2, sizeof(unsigned long long));
-
-            if (temp1_ullong != temp2_ullong) {
-                if (print_data(opts)) {
-                    print_pos(ph, 0, hyper_start + i, acc, pos, rank, dims, obj1, obj2);
-                    parallel_print(SPACES);
-                    parallel_print(ULLI_FORMAT,temp1_ullong,temp2_ullong,PDIFF(temp1_ullong,temp2_ullong));
-                }
-                nfound++;
+        if (temp1_ullong != temp2_ullong) {
+            opts->print_percentage = 0;
+            print_pos(opts, elem_idx, -1);
+            if (print_data(opts)) {
+                parallel_print(ULLI_FORMAT, temp1_ullong, temp2_ullong, PDIFF(temp1_ullong, temp2_ullong));
             }
-
-            mem1 += sizeof(unsigned long long);
-            mem2 += sizeof(unsigned long long);
-            if (opts->n && nfound >= opts->count)
-                return nfound;
-        } /* nelmts */
+            nfound++;
+        }
     }
 
+    H5TOOLS_ENDDEBUG(": %d zero:%d", nfound, both_zero);
     return nfound;
 }
 
@@ -4681,7 +3214,7 @@ static hbool_t equal_float(float value, float expected, diff_opt_t *opts) {
 static
 int print_data(diff_opt_t *opts)
 {
-    return ((opts->m_report || opts->m_verbose) && !opts->m_quiet) ? 1 : 0;
+    return ((opts->mode_report || opts->mode_verbose) && !opts->mode_quiet) ? 1 : 0;
 }
 
 /*-------------------------------------------------------------------------
@@ -4691,25 +3224,24 @@ int print_data(diff_opt_t *opts)
  *-------------------------------------------------------------------------
  */
 static
-void print_header(int pp, /* print percentage */
-        int rank, hsize_t *dims, const char *obj1, const char *obj2)
+void print_header(diff_opt_t *opts)
 {
     /* print header */
     parallel_print("%-16s", "size:");
-    print_dimensions(rank, dims);
+    print_dimensions(opts->rank, opts->dims);
     parallel_print("%-11s", "");
-    print_dimensions(rank, dims);
+    print_dimensions(opts->rank, opts->dims);
     parallel_print("\n");
 
-    if (pp) {
+    if (opts->print_percentage) {
         parallel_print("%-15s %-15s %-15s %-15s %-15s\n", "position",
-                (obj1 != NULL) ? obj1 : " ", (obj2 != NULL) ? obj2 : " ", "difference", "relative");
+                opts->obj_name[0], opts->obj_name[1], "difference", "relative");
         parallel_print(
                 "------------------------------------------------------------------------\n");
     }
     else {
         parallel_print("%-15s %-15s %-15s %-20s\n", "position",
-                (obj1 != NULL) ? obj1 : " ", (obj2 != NULL) ? obj2 : " ", "difference");
+                opts->obj_name[0], opts->obj_name[1], "difference");
         parallel_print(
                 "------------------------------------------------------------\n");
     }
@@ -4722,77 +3254,93 @@ void print_header(int pp, /* print percentage */
  *-------------------------------------------------------------------------
  */
 static
-void print_pos(int *ph, /* print header */
-        int pp, /* print percentage */
-        hsize_t curr_pos, hsize_t *acc, hsize_t *pos, int rank, hsize_t *dims,
-        const char *obj1, const char *obj2)
+void print_pos(diff_opt_t *opts, hsize_t idx, ssize_t u)
 {
-    int i;
-
-    /* print header */
-    if (*ph == 1) {
-        *ph = 0;
-
-        print_header(pp, rank, dims, obj1, obj2);
-    } /* end print header */
-
-    for (i = 0; i < rank; i++) {
-        pos[i] = curr_pos / acc[i];
-        curr_pos -= acc[i] * pos[i];
-    }
-    HDassert(curr_pos == 0);
+    int i,j;
+
+    H5TOOLS_START_DEBUG(" -- idx:%ld", idx);
+
+    if (print_data(opts)) {
+        /* print header */
+        if (opts->print_header == 1) {
+            opts->print_header = 0;
+
+            print_header(opts);
+        } /* end print header */
+
+        H5TOOLS_DEBUG("rank=%d", opts->rank);
+        if(opts->rank > 0) {
+            hsize_t curr_pos = idx;
+
+            parallel_print("[ ");
+            H5TOOLS_DEBUG("do calc_acc_pos[%ld] nelmts:%d - errstat:%d", i, opts->hs_nelmts, opts->err_stat);
+
+            if (opts->sset[0] != NULL) {
+                /* Subsetting is used - calculate total position */
+                hsize_t elmnt_cnt = 1;
+                hsize_t dim_cnt = 0; /* previous dim size */
+                hsize_t str_cnt = 0; /* previous dim stride */
+                hsize_t curr_idx = idx; /* calculated running position */
+                hsize_t str_idx = 0;
+                hsize_t blk_idx = 0;
+                hsize_t cnt_idx = 0;
+                hsize_t hs_idx = 0;
+                j = opts->rank-1;
+                do {
+                    cnt_idx = opts->sset[0]->count.data[j]; /* Count value for current dim */
+                    H5TOOLS_DEBUG("... sset loop:%d with curr_pos:%ld (curr_idx:%ld) - count:%ld", j, curr_pos, curr_idx, cnt_idx);
+                    blk_idx = opts->sset[0]->block.data[j]; /* Block value for current dim */
+                    H5TOOLS_DEBUG("... sset loop:%d with curr_pos:%ld (curr_idx:%ld) - block:%ld", j, curr_pos, curr_idx, blk_idx);
+                    hs_idx = cnt_idx * blk_idx; /* hyperslab area value for current dim */
+                    H5TOOLS_DEBUG("... sset loop:%d with curr_pos:%ld (curr_idx:%ld) - hs:%ld", j, curr_pos, curr_idx, hs_idx);
+                    str_idx = opts->sset[0]->stride.data[j]; /* Stride value for current dim */
+                    H5TOOLS_DEBUG("... sset loop:%d with curr_pos:%ld (curr_idx:%ld) - stride:%ld", j, curr_pos, curr_idx, str_idx);
+                    elmnt_cnt *= opts->dims[j]; /* Total number of elements in dimension */
+                    H5TOOLS_DEBUG("... sset loop:%d with elmnt_cnt:%ld", j, elmnt_cnt);
+                    if (str_idx > blk_idx)
+                        curr_idx += dim_cnt * (str_idx - blk_idx); /* */
+                    else if (curr_idx >= hs_idx)
+                        curr_idx += dim_cnt * str_cnt;
+                    H5TOOLS_DEBUG("... sset loop:%d with idx:%ld (curr_idx:%ld) - stride:%ld", j, idx, curr_idx, str_idx);
+                    dim_cnt = elmnt_cnt; /* */
+                    if (str_idx > blk_idx)
+                        str_cnt = str_idx - blk_idx; /* */
+                    else
+                        str_cnt = str_idx; /* */
+                    H5TOOLS_DEBUG("... sset loop:%d with dim_cnt:%ld - str_cnt:%ld", j, dim_cnt, str_cnt);
+                    j--;
+                } while (curr_idx >= elmnt_cnt && j >= 0);
+                curr_pos = curr_idx; /* New current position */
+                H5TOOLS_DEBUG("pos loop:%d,%d with  elmnt_cnt:%ld - curr_pos:%ld", i, j, elmnt_cnt, curr_pos);
+            } /* if (opts->sset[0] != NULL) */
+            /*
+             * Calculate the number of elements represented by a unit change in a
+             * certain index position.
+             */
+            calc_acc_pos(opts->rank, curr_pos, opts->acc, opts->pos);
 
-    if (rank > 0) {
-        parallel_print("[ ");
-        for (i = 0; i < rank; i++) {
-            parallel_print(HSIZE_T_FORMAT, (unsigned long long)pos[i]);
-            parallel_print(" ");
+            for (i = 0; i < opts->rank; i++) {
+                H5TOOLS_DEBUG("pos loop:%d with opts->pos=%ld opts->sm_pos=%ld", i, opts->pos[i], opts->sm_pos[i]);
+                opts->pos[i] += (unsigned long) opts->sm_pos[i];
+                H5TOOLS_DEBUG("pos loop:%d with opts->pos=%ld", i, opts->pos[i]);
+                parallel_print(HSIZE_T_FORMAT, (unsigned long long)opts->pos[i]);
+                parallel_print(" ");
+            }
+            parallel_print("]");
         }
-        parallel_print("]");
-    }
-    else
-        parallel_print("      ");
-}
-
-/*-------------------------------------------------------------------------
- * Function: print_char_pos
- *
- * Purpose:  print character position in string
- *-------------------------------------------------------------------------
- */
-static
-void print_char_pos(int *ph, /* print header */
-        int pp, /* print percentage */
-        hsize_t curr_pos, size_t u, hsize_t *acc, hsize_t *pos, int rank, hsize_t *dims,
-        const char *obj1, const char *obj2)
-{
-    int i;
-
-    /* print header */
-    if (*ph == 1) {
-        *ph = 0;
-
-        print_header(pp, rank, dims, obj1, obj2);
-    } /* end print header */
-
-    for (i = 0; i < rank; i++) {
-        pos[i] = curr_pos / acc[i];
-        curr_pos -= acc[i] * pos[i];
-    }
-    HDassert(curr_pos == 0);
-
-    parallel_print("[ ");
-    if (rank > 0) {
-        for (i = 0; i < rank; i++) {
-            parallel_print(HSIZE_T_FORMAT, (unsigned long long)pos[i]);
-            parallel_print(" ");
+        else {
+            if (u >= 0) {
+                parallel_print("[ ");
+                parallel_print("%zu", u);
+                parallel_print("]");
+            }
+            else
+                parallel_print("      ");
         }
-
+        parallel_print(SPACES);
     }
-    else
-        parallel_print("%zu", u);
 
-    parallel_print("]");
+    H5TOOLS_ENDDEBUG("");
 }
 
 /*-------------------------------------------------------------------------
diff --git a/tools/lib/h5diff_attr.c b/tools/lib/h5diff_attr.c
index 5ad29fcdc1f..774859b5ddd 100644
--- a/tools/lib/h5diff_attr.c
+++ b/tools/lib/h5diff_attr.c
@@ -137,7 +137,7 @@ static void table_attr_mark_exist(unsigned *exist, char *name, table_attrs_t *ta
  * Parameter:
  *  table_out [OUT] : return the list
  *------------------------------------------------------------------------*/
-static herr_t build_match_list_attrs(hid_t loc1_id, hid_t loc2_id, table_attrs_t ** table_out,  diff_opt_t *opts)
+static herr_t build_match_list_attrs(hid_t loc1_id, hid_t loc2_id, table_attrs_t ** table_out, diff_opt_t *opts)
 {
     table_attrs_t *table_lp = NULL;
     H5O_info2_t    oinfo1, oinfo2;    /* Object info */
@@ -171,8 +171,8 @@ static herr_t build_match_list_attrs(hid_t loc1_id, hid_t loc2_id, table_attrs_t
      * build the list
      */
     while(curr1 < oinfo1.num_attrs && curr2 < oinfo2.num_attrs) {
-        H5TOOLS_DEBUG("build_match_list_attrs 1: %ld - %ld", curr1, oinfo1.num_attrs);
-        H5TOOLS_DEBUG("build_match_list_attrs 2: %ld - %ld", curr2, oinfo2.num_attrs);
+        H5TOOLS_DEBUG("list_attrs 1: %ld - %ld", curr1, oinfo1.num_attrs);
+        H5TOOLS_DEBUG("list_attrs 2: %ld - %ld", curr2, oinfo2.num_attrs);
 
         /*------------------
         * open attribute1 */
@@ -226,7 +226,7 @@ static herr_t build_match_list_attrs(hid_t loc1_id, hid_t loc2_id, table_attrs_t
     infile[0] = 1;
     infile[1] = 0;
     while(curr1 < oinfo1.num_attrs) {
-        H5TOOLS_DEBUG("build_match_list_attrs 1: %ld - %ld", curr1, oinfo1.num_attrs);
+        H5TOOLS_DEBUG("list_attrs 1: %ld - %ld", curr1, oinfo1.num_attrs);
 
         /*------------------
         * open attribute1 */
@@ -235,7 +235,7 @@ static herr_t build_match_list_attrs(hid_t loc1_id, hid_t loc2_id, table_attrs_t
         /* get name */
         if(H5Aget_name(attr1_id, (size_t)ATTR_NAME_MAX, name1) < 0)
             H5TOOLS_GOTO_ERROR(FAIL, "H5Aget_name first attribute failed");
-        H5TOOLS_DEBUG("build_match_list_attrs #1 name - %s", name1);
+        H5TOOLS_DEBUG("list_attrs 1 name - %s", name1);
 
         table_attr_mark_exist(infile, name1, table_lp);
         table_lp->nattrs_only1++;
@@ -250,7 +250,7 @@ static herr_t build_match_list_attrs(hid_t loc1_id, hid_t loc2_id, table_attrs_t
     infile[0] = 0;
     infile[1] = 1;
     while(curr2 < oinfo2.num_attrs) {
-        H5TOOLS_DEBUG("build_match_list_attrs 2: %ld - %ld", curr2, oinfo2.num_attrs);
+        H5TOOLS_DEBUG("list_attrs 2: %ld - %ld", curr2, oinfo2.num_attrs);
         /*------------------
         * open attribute2 */
         if((attr2_id = H5Aopen_by_idx(loc2_id, ".", H5_INDEX_NAME, H5_ITER_INC, (hsize_t)curr2, H5P_DEFAULT, H5P_DEFAULT)) < 0)
@@ -258,7 +258,7 @@ static herr_t build_match_list_attrs(hid_t loc1_id, hid_t loc2_id, table_attrs_t
         /* get name */
         if(H5Aget_name(attr2_id, (size_t)ATTR_NAME_MAX, name2) < 0)
             H5TOOLS_GOTO_ERROR(FAIL, "H5Aget_name second attribute failed");
-        H5TOOLS_DEBUG("build_match_list_attrs #2 name - %s", name2);
+        H5TOOLS_DEBUG("list_attrs 2 name - %s", name2);
 
         table_attr_mark_exist(infile, name2, table_lp);
         table_lp->nattrs_only2++;
@@ -272,7 +272,7 @@ static herr_t build_match_list_attrs(hid_t loc1_id, hid_t loc2_id, table_attrs_t
     /*------------------------------------------------------
      * print the list
      */
-    if(opts->m_verbose_level == 2) {
+    if(opts->mode_verbose_level == 2) {
         /* if '-v2' is detected */
         parallel_print("   obj1   obj2\n");
         parallel_print(" --------------------------------------\n");
@@ -284,7 +284,7 @@ static herr_t build_match_list_attrs(hid_t loc1_id, hid_t loc2_id, table_attrs_t
         } /* end for */
     }
 
-    if(opts->m_verbose_level >= 1)
+    if(opts->mode_verbose_level >= 1)
         parallel_print("Attributes status:  %d common, %d only in obj1, %d only in obj2\n",
                 table_lp->nattrs - table_lp->nattrs_only1 - table_lp->nattrs_only2,
                 table_lp->nattrs_only1, table_lp->nattrs_only2);
@@ -313,7 +313,8 @@ static herr_t build_match_list_attrs(hid_t loc1_id, hid_t loc2_id, table_attrs_t
  *-------------------------------------------------------------------------
  */
 
-hsize_t diff_attr_data(hid_t attr1_id, hid_t attr2_id, const char *name1, const char *name2, const char *path1, const char *path2, diff_opt_t *opts)
+hsize_t diff_attr_data(hid_t attr1_id, hid_t attr2_id,
+        const char *name1, const char *name2, const char *path1, const char *path2, diff_opt_t *opts)
 {
     hid_t      space1_id = H5I_INVALID_HID;    /* space ID */
     hid_t      space2_id = H5I_INVALID_HID;    /* space ID */
@@ -327,19 +328,15 @@ hsize_t diff_attr_data(hid_t attr1_id, hid_t attr2_id, const char *name1, const
     void      *buf2 = NULL;       /* data buffer */
     hbool_t    buf1hasdata = FALSE;    /* buffer has data */
     hbool_t    buf2hasdata = FALSE;    /* buffer has data */
-    hsize_t    nelmts1;           /* number of elements in dataset */
     int        rank1;             /* rank of dataset */
     int        rank2;             /* rank of dataset */
     hsize_t    dims1[H5S_MAX_RANK];    /* dimensions of dataset */
     hsize_t    dims2[H5S_MAX_RANK];    /* dimensions of dataset */
-    char       np1[512];
-    char       np2[512];
     hsize_t    nfound = 0;
     int        j;
     diff_err_t ret_value = opts->err_stat;
 
     H5TOOLS_START_DEBUG(" - errstat:%d", opts->err_stat);
-
     /* get the datatypes  */
     if((ftype1_id = H5Aget_type(attr1_id)) < 0)
         H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Aget_type first attribute failed");
@@ -383,11 +380,32 @@ hsize_t diff_attr_data(hid_t attr1_id, hid_t attr2_id, const char *name1, const
     * check for comparable TYPE and SPACE
     *----------------------------------------------------------------------
     */
-    H5TOOLS_DEBUG("diff_attr_data check for comparable TYPE and SPACE");
+    H5TOOLS_DEBUG("Check for comparable TYPE and SPACE");
+
+    H5TOOLS_DEBUG("attr_names: %s - %s", name1, name2);
+    if (name1) {
+        j = (int)HDstrlen(name1);
+        H5TOOLS_DEBUG("attr1_name: %s - %d", name1, j);
+        if (j > 0) {
+            opts->obj_name[0] = (char *)HDcalloc((size_t)j + 1, sizeof(char));
+            HDstrncpy(opts->obj_name[0], name1, (size_t)j);
+            opts->obj_name[0][j] = '\0';
+        }
+    }
+    if (name2) {
+        j = (int)HDstrlen(name2);
+        H5TOOLS_DEBUG("attr2_name: %s - %d", name2, j);
+        if (j > 0) {
+            opts->obj_name[1] = (char *)HDcalloc((size_t)j + 1, sizeof(char));
+            HDstrncpy(opts->obj_name[1], name2, (size_t)j);
+            opts->obj_name[1][j] = '\0';
+        }
+    }
+    H5TOOLS_DEBUG("attr_names: %s - %s", opts->obj_name[0], opts->obj_name[1]);
 
     /* pass dims1 and dims2 for maxdims as well since attribute's maxdims
     * are always same */
-    if(diff_can_type(ftype1_id, ftype2_id, rank1, rank2, dims1, dims2, dims1, dims2, name1, name2, opts, 0) == 1) {
+    if(diff_can_type(ftype1_id, ftype2_id, rank1, rank2, dims1, dims2, dims1, dims2, opts, 0) == 1) {
         /*-----------------------------------------------------------------
         * "upgrade" the smaller memory size
         *------------------------------------------------------------------
@@ -395,17 +413,26 @@ hsize_t diff_attr_data(hid_t attr1_id, hid_t attr2_id, const char *name1, const
         if(FAIL == match_up_memsize(ftype1_id, ftype2_id, &mtype1_id, &mtype2_id, &msize1, &msize2))
             H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "match_up_memsize failed");
 
-        H5TOOLS_DEBUG("diff_attr_data read");
+        H5TOOLS_DEBUG("initialize read");
         /*---------------------------------------------------------------------
-        * read
+        * initialize diff_opt_t structure for dimensions
         *----------------------------------------------------------------------
         */
-        nelmts1 = 1;
-        for(j = 0; j < rank1; j++)
-            nelmts1 *= dims1[j];
+        opts->nelmts = 1;
+        for(j = 0; j < rank1; j++) {
+            opts->dims[j] = dims1[j];
+            opts->nelmts *= dims1[j];
+        }
+        opts->rank = rank1;
+        init_acc_pos(opts->rank, opts->dims, opts->acc, opts->pos, opts->p_min_idx);
 
-        buf1 = (void *)HDcalloc((size_t)(nelmts1), msize1);
-        buf2 = (void *)HDcalloc((size_t)(nelmts1), msize2);
+        /*---------------------------------------------------------------------
+        * read
+        *----------------------------------------------------------------------
+        */
+        buf1 = (void *)HDcalloc((size_t)(opts->nelmts), msize1);
+        buf2 = (void *)HDcalloc((size_t)(opts->nelmts), msize2);
+        H5TOOLS_DEBUG("attr buffer size %ld * %ld", opts->nelmts, msize1);
         if(buf1 == NULL || buf2 == NULL) {
             parallel_print("cannot read into memory\n");
             H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "buffer allocation failed");
@@ -416,6 +443,7 @@ hsize_t diff_attr_data(hid_t attr1_id, hid_t attr2_id, const char *name1, const
         }
         else
             buf1hasdata = TRUE;
+        H5TOOLS_DEBUG("attr H5Aread 1");
 
         if(H5Aread(attr2_id, mtype2_id, buf2) < 0) {
             parallel_print("Failed reading attribute2 %s\n", name2);
@@ -423,49 +451,84 @@ hsize_t diff_attr_data(hid_t attr1_id, hid_t attr2_id, const char *name1, const
         }
         else
             buf2hasdata = TRUE;
+        H5TOOLS_DEBUG("attr H5Aread 2");
 
         /* format output string */
-        HDsnprintf(np1, sizeof(np1), "%s of <%s>", name1, path1);
-        HDsnprintf(np2, sizeof(np1), "%s of <%s>", name2, path2);
+        if (opts->obj_name[0] != NULL)
+             HDfree(opts->obj_name[0]);
+        opts->obj_name[0] = NULL;
+        if (opts->obj_name[1] != NULL)
+             HDfree(opts->obj_name[1]);
+        opts->obj_name[1] = NULL;
+
+        H5TOOLS_DEBUG("attr_names: %s - %s : %s - %s", name1, name2, path1, path2);
+        if (name1) {
+            j = (int)HDstrlen(name1) + (int)HDstrlen(path1) + 7;
+            H5TOOLS_DEBUG("attr1_name: %s - %d", name1, j);
+            if (j > 0) {
+                opts->obj_name[0] = (char *)HDcalloc((size_t)j + 1, sizeof(char));
+                HDsnprintf(opts->obj_name[0], j, "%s of <%s>", name1, path1);
+                opts->obj_name[0][j] = '\0';
+            }
+        }
+        if (name2) {
+            j = (int)HDstrlen(name2) + (int)HDstrlen(path2) + 7;
+            H5TOOLS_DEBUG("attr2_name: %s - %d", name2, j);
+            if (j > 0) {
+                opts->obj_name[1] = (char *)HDcalloc((size_t)j + 1, sizeof(char));
+                HDsnprintf(opts->obj_name[1], j, "%s of <%s>", name2, path2);
+                opts->obj_name[1][j] = '\0';
+            }
+        }
 
         /*---------------------------------------------------------------------
         * array compare
         *----------------------------------------------------------------------
         */
-        H5TOOLS_DEBUG("diff_attr_data array compare %s - %s", name1, name1);
+        H5TOOLS_DEBUG("array compare %s - %s", opts->obj_name[0], opts->obj_name[1]);
+
+        opts->hs_nelmts = opts->nelmts;
+        opts->m_tid = mtype1_id;
+
+        /* initialize the current stripmine position; this is necessary to print the array indices */
+        for (j = 0; j < opts->rank; j++)
+            opts->sm_pos[j] = (hsize_t)0;
 
         /* always print name */
         /* verbose (-v) and report (-r) mode */
-        if(opts->m_verbose || opts->m_report) {
-            do_print_attrname("attribute", np1, np2);
+        if(opts->mode_verbose || opts->mode_report) {
+            do_print_attrname("attribute", opts->obj_name[0], opts->obj_name[1]);
 
-            nfound = diff_array(buf1, buf2, nelmts1, (hsize_t) 0, rank1,
-                    dims1, opts, np1, np2, mtype1_id, attr1_id, attr2_id);
+            nfound = diff_array(buf1, buf2, opts, attr1_id, attr2_id);
             print_found(nfound);
         }
         /* quiet mode (-q), just count differences */
-        else if(opts->m_quiet) {
-            nfound = diff_array(buf1, buf2, nelmts1, (hsize_t) 0, rank1,
-                    dims1, opts, np1, np2, mtype1_id, attr1_id, attr2_id);
+        else if(opts->mode_quiet) {
+            nfound = diff_array(buf1, buf2, opts, attr1_id, attr2_id);
         }
         /* the rest (-c, none, ...) */
         else {
-            nfound = diff_array(buf1, buf2, nelmts1, (hsize_t) 0, rank1,
-                    dims1, opts, np1, np2, mtype1_id, attr1_id, attr2_id);
+            nfound = diff_array(buf1, buf2, opts, attr1_id, attr2_id);
 
             /* print info if compatible and difference found */
             if (nfound) {
-                do_print_attrname("attribute", np1, np2);
+                do_print_attrname("attribute", opts->obj_name[0], opts->obj_name[1]);
                 print_found(nfound);
             } /* end if */
         } /* end else */
     }
-    H5TOOLS_DEBUG("diff_attr_data check for comparable TYPE and SPACE complete nfound:%d - errstat:%d", nfound, opts->err_stat);
+    H5TOOLS_DEBUG("check for comparable TYPE and SPACE complete nfound:%d - errstat:%d", nfound, opts->err_stat);
 
     /*----------------------------------------------------------------------
     * close
     *----------------------------------------------------------------------
     */
+   if (opts->obj_name[0] != NULL)
+        HDfree(opts->obj_name[0]);
+   opts->obj_name[0] = NULL;
+   if (opts->obj_name[1] != NULL)
+        HDfree(opts->obj_name[1]);
+   opts->obj_name[1] = NULL;
 
     /* Free buf1 and buf2, check both VLEN-data VLEN-string to reclaim any
     * VLEN memory first */
@@ -543,28 +606,32 @@ hsize_t diff_attr(hid_t loc1_id, hid_t loc2_id, const char *path1, const char *p
     unsigned       u;                 /* Local index variable */
     hsize_t        nfound = 0;
     hsize_t        nfound_total = 0;
+    diff_opt_t attr_opts;
     diff_err_t     ret_value = opts->err_stat;
 
     H5TOOLS_START_DEBUG(" - errstat:%d", opts->err_stat);
+    attr_opts = *opts;
+    attr_opts.obj_name[0] = NULL;
+    attr_opts.obj_name[1] = NULL;
 
-    if(build_match_list_attrs(loc1_id, loc2_id, &match_list_attrs, opts) < 0) {
+    if(build_match_list_attrs(loc1_id, loc2_id, &match_list_attrs, &attr_opts) < 0) {
         H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "build_match_list_attrs failed");
     }
-    H5TOOLS_DEBUG("build_match_list_attrs - errstat:%d", opts->err_stat);
+    H5TOOLS_DEBUG("check match_list_attrs - opts->contents:%d - errstat:%d", attr_opts.contents, attr_opts.err_stat);
 
     /* if detect any unique extra attr */
     if(match_list_attrs->nattrs_only1 || match_list_attrs->nattrs_only2) {
-        H5TOOLS_DEBUG("diff_attr attributes only in one file");
+        H5TOOLS_DEBUG("attributes only in one file");
         /* exit will be 1 */
-        opts->contents = 0;
+        attr_opts.contents = 0;
     }
-    H5TOOLS_DEBUG("match_list_attrs info - errstat:%d", opts->err_stat);
+    H5TOOLS_DEBUG("match_list_attrs info - opts->contents:%d", attr_opts.contents);
 
     for(u = 0; u < (unsigned)match_list_attrs->nattrs; u++) {
-        H5TOOLS_DEBUG("match_list_attrs loop[%d] - errstat:%d", u, opts->err_stat);
+        H5TOOLS_DEBUG("match_list_attrs loop[%d] - errstat:%d", u, attr_opts.err_stat);
         if((match_list_attrs->attrs[u].exist[0]) && (match_list_attrs->attrs[u].exist[1])) {
             name1 = name2 = match_list_attrs->attrs[u].name;
-            H5TOOLS_DEBUG("diff_attr name - %s", name1);
+            H5TOOLS_DEBUG("name - %s", name1);
 
             /*--------------
             * attribute 1 */
@@ -576,8 +643,8 @@ hsize_t diff_attr(hid_t loc1_id, hid_t loc2_id, const char *path1, const char *p
             if((attr2_id = H5Aopen(loc2_id, name2, H5P_DEFAULT)) < 0)
                 H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Aopen second attribute failed");
 
-            H5TOOLS_DEBUG("diff_attr got attributes");
-            nfound = diff_attr_data(attr1_id, attr2_id, name1, name2, path1, path2, opts);
+            H5TOOLS_DEBUG("got attributes");
+            nfound = diff_attr_data(attr1_id, attr2_id, name1, name2, path1, path2, &attr_opts);
             if(H5Aclose(attr1_id) < 0)
                 H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Aget_type first attribute failed");
             if(H5Aclose(attr2_id) < 0)
@@ -588,7 +655,10 @@ hsize_t diff_attr(hid_t loc1_id, hid_t loc2_id, const char *path1, const char *p
     } /* u */
 
 done:
-    opts->err_stat = opts->err_stat | ret_value;
+    opts->print_header = attr_opts.print_header;
+    opts->contents = attr_opts.contents;
+    opts->not_cmp = attr_opts.not_cmp;
+    opts->err_stat = attr_opts.err_stat | ret_value;
 
     H5E_BEGIN_TRY {
         table_attrs_free(match_list_attrs);
diff --git a/tools/lib/h5diff_dset.c b/tools/lib/h5diff_dset.c
index cea20a82de3..602255e9ff6 100644
--- a/tools/lib/h5diff_dset.c
+++ b/tools/lib/h5diff_dset.c
@@ -27,7 +27,8 @@
  * Return: Number of differences found
  *-------------------------------------------------------------------------
  */
-hsize_t diff_dataset(hid_t file1_id, hid_t file2_id, const char *obj1_name, const char *obj2_name, diff_opt_t *opts)
+hsize_t
+diff_dataset(hid_t file1_id, hid_t file2_id, const char *obj1_name, const char *obj2_name, diff_opt_t *opts)
 {
     int        status = -1;
     hid_t      did1 = H5I_INVALID_HID;
@@ -35,9 +36,15 @@ hsize_t diff_dataset(hid_t file1_id, hid_t file2_id, const char *obj1_name, cons
     hid_t      dcpl1 = H5I_INVALID_HID;
     hid_t      dcpl2 = H5I_INVALID_HID;
     hsize_t    nfound = 0;
+    diff_opt_t diff_opts;
     diff_err_t ret_value = opts->err_stat;
 
     H5TOOLS_START_DEBUG(" - errstat:%d", opts->err_stat);
+    diff_opts = *opts;
+    diff_opts.obj_name[0] = NULL;
+    diff_opts.obj_name[1] = NULL;
+
+    H5TOOLS_DEBUG("obj_names: %s - %s", obj1_name, obj2_name);
     /*-------------------------------------------------------------------------
      * open the handles
      *-------------------------------------------------------------------------
@@ -64,20 +71,22 @@ hsize_t diff_dataset(hid_t file1_id, hid_t file2_id, const char *obj1_name, cons
      * 2) the internal filters might be turned off
      *-------------------------------------------------------------------------
      */
-    H5TOOLS_DEBUG("diff_dataset h5tools_canreadf then diff_datasetid");
-    if ((status = h5tools_canreadf((opts->m_verbose ? obj1_name : NULL), dcpl1) == 1) &&
-            (status = h5tools_canreadf((opts->m_verbose ? obj2_name : NULL), dcpl2) == 1))
-        nfound = diff_datasetid(did1, did2, obj1_name, obj2_name, opts);
+    H5TOOLS_DEBUG("h5tools_canreadf then diff_datasetid");
+    if ((status = h5tools_canreadf((opts->mode_verbose ? obj1_name : NULL), dcpl1) == 1) &&
+            (status = h5tools_canreadf((opts->mode_verbose ? obj2_name : NULL), dcpl2) == 1))
+        nfound = diff_datasetid(did1, did2, obj1_name, obj2_name, &diff_opts);
     else if (status < 0) {
         H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "h5tools_canreadf failed");
     }
     else {
         ret_value = 1;
-        opts->not_cmp = 1;
+        diff_opts.not_cmp = 1;
     }
 
 done:
-    opts->err_stat = opts->err_stat | ret_value;
+    opts->print_header = diff_opts.print_header;
+    opts->not_cmp = diff_opts.not_cmp;
+    opts->err_stat = diff_opts.err_stat | ret_value;
 
     /* disable error reporting */
     H5E_BEGIN_TRY {
@@ -143,36 +152,31 @@ hsize_t diff_dataset(hid_t file1_id, hid_t file2_id, const char *obj1_name, cons
  *
  *-------------------------------------------------------------------------
  */
-hsize_t diff_datasetid(hid_t did1, hid_t did2, const char *obj1_name, const char *obj2_name, diff_opt_t *opts)
+hsize_t
+diff_datasetid(hid_t did1, hid_t did2, const char *obj1_name, const char *obj2_name, diff_opt_t *opts)
 {
     hid_t      sid1 = H5I_INVALID_HID;
     hid_t      sid2 = H5I_INVALID_HID;
     hid_t      f_tid1 = H5I_INVALID_HID;
     hid_t      f_tid2 = H5I_INVALID_HID;
-    hid_t      dam_tid = H5I_INVALID_HID;             /* m_tid for diff_array function */
     hid_t      m_tid1 = H5I_INVALID_HID;
     hid_t      m_tid2 = H5I_INVALID_HID;
     hid_t      dcpl1 = H5I_INVALID_HID;
     hid_t      dcpl2 = H5I_INVALID_HID;
     H5D_layout_t     stl1 = -1;
     H5D_layout_t     stl2 = -1;
-    size_t     dam_size;                /* m_size for diff_array function */
     size_t     m_size1;
     size_t     m_size2;
     H5T_sign_t sign1;
     H5T_sign_t sign2;
     int        rank1;
     int        rank2;
-    hsize_t    danelmts;                /* nelmts for diff_array function */
     hsize_t    nelmts1;
     hsize_t    nelmts2;
-    hsize_t    *dadims;                 /* dims for diff_array function */
     hsize_t    dims1[H5S_MAX_RANK];
     hsize_t    dims2[H5S_MAX_RANK];
     hsize_t    maxdim1[H5S_MAX_RANK];
     hsize_t    maxdim2[H5S_MAX_RANK];
-    const char *name1 = NULL;           /* relative names */
-    const char *name2 = NULL;
     hsize_t    storage_size1;
     hsize_t    storage_size2;
     hsize_t    nfound = 0;              /* number of differences found */
@@ -181,9 +185,10 @@ hsize_t diff_datasetid(hid_t did1, hid_t did2, const char *obj1_name, const char
     void       *buf2 = NULL;
     void       *sm_buf1 = NULL;
     void       *sm_buf2 = NULL;
-    hid_t      sm_space = H5I_INVALID_HID;           /*stripmine data space */
+    hid_t      sm_space1 = H5I_INVALID_HID;           /*stripmine data space */
+    hid_t      sm_space2 = H5I_INVALID_HID;           /*stripmine data space */
     size_t     need;                    /* bytes needed for malloc */
-    int        i;
+    int        i, j;
     unsigned int  vl_data1 = 0;          /*contains VL datatypes */
     unsigned int  vl_data2 = 0;          /*contains VL datatypes */
     diff_err_t    ret_value = opts->err_stat;
@@ -233,13 +238,15 @@ hsize_t diff_datasetid(hid_t did1, hid_t did2, const char *obj1_name, const char
      */
     if((dcpl1 = H5Dget_create_plist(did1)) < 0)
         H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Dget_create_plist failed");
-    if((dcpl2 = H5Dget_create_plist(did2)) < 0)
-        H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Dget_create_plist failed");
-
     if((stl1 = H5Pget_layout(dcpl1)) < 0)
         H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Pget_layout failed");
+    H5Pclose(dcpl1);
+
+    if((dcpl2 = H5Dget_create_plist(did2)) < 0)
+        H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Dget_create_plist failed");
     if((stl2 = H5Pget_layout(dcpl2)) < 0)
         H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Pget_layout failed");
+    H5Pclose(dcpl2);
 
     /*-------------------------------------------------------------------------
      * check for empty datasets
@@ -253,27 +260,48 @@ hsize_t diff_datasetid(hid_t did1, hid_t did2, const char *obj1_name, const char
 
     if(storage_size1 == 0 || storage_size2 == 0) {
         if(stl1 == H5D_VIRTUAL || stl2 == H5D_VIRTUAL) {
-            if((opts->m_verbose||opts->m_list_not_cmp) && obj1_name && obj2_name)
+            if((opts->mode_verbose||opts->mode_list_not_cmp) && obj1_name && obj2_name)
                 parallel_print("Warning: <%s> or <%s> is a virtual dataset\n", obj1_name, obj2_name);
         }
         else {
-            if((opts->m_verbose || opts->m_list_not_cmp) && obj1_name && obj2_name)
+            if((opts->mode_verbose || opts->mode_list_not_cmp) && obj1_name && obj2_name)
                 parallel_print("Not comparable: <%s> or <%s> is an empty dataset\n", obj1_name, obj2_name);
             can_compare = 0;
             opts->not_cmp = 1;
         }
     }
 
+    H5TOOLS_DEBUG("obj_names: %s - %s", obj1_name, obj2_name);
+    opts->obj_name[0] = NULL;
+    if (obj1_name) {
+        j = (int)HDstrlen(obj1_name);
+        H5TOOLS_DEBUG("obj1_name: %s - %d", obj1_name, j);
+        if (j > 0) {
+            opts->obj_name[0] = (char *)HDcalloc((size_t)j + 1, sizeof(char));
+            HDstrncpy(opts->obj_name[0], obj1_name, (size_t)j );
+            opts->obj_name[0][j] = '\0';
+        }
+    }
+
+
+    opts->obj_name[1] = NULL;
+    if (obj2_name) {
+        j = (int)HDstrlen(obj2_name);
+        H5TOOLS_DEBUG("obj2_name: %s - %d", obj2_name, j);
+        if (j > 0) {
+            opts->obj_name[1] = (char *)HDcalloc((size_t)j + 1, sizeof(char));
+            HDstrncpy(opts->obj_name[1], obj2_name, (size_t)j);
+            opts->obj_name[1][j] = '\0';
+        }
+    }
+
     /*-------------------------------------------------------------------------
      * check for comparable TYPE and SPACE
      *-------------------------------------------------------------------------
      */
-    if (diff_can_type(f_tid1, f_tid2, rank1, rank2,
-            dims1, dims2, maxdim1, maxdim2,
-            obj1_name, obj2_name,
-            opts, 0) != 1)
+    if (diff_can_type(f_tid1, f_tid2, rank1, rank2, dims1, dims2, maxdim1, maxdim2, opts, 0) != 1)
         can_compare = 0;
-    H5TOOLS_DEBUG("diff_can_type - errstat:%d", opts->err_stat);
+    H5TOOLS_DEBUG("diff_can_type returned errstat:%d", opts->err_stat);
 
     /*-------------------------------------------------------------------------
      * memory type and sizes
@@ -312,7 +340,7 @@ hsize_t diff_datasetid(hid_t did1, hid_t did2, const char *obj1_name, const char
         sign2 = H5Tget_sign(m_tid2);
         if(sign1 != sign2) {
             H5TOOLS_DEBUG("sign1 != sign2");
-            if((opts->m_verbose || opts->m_list_not_cmp) && obj1_name && obj2_name) {
+            if((opts->mode_verbose || opts->mode_list_not_cmp) && obj1_name && obj2_name) {
                 parallel_print("Not comparable: <%s> has sign %s ", obj1_name, get_sign(sign1));
                 parallel_print("and <%s> has sign %s\n", obj2_name, get_sign(sign2));
             }
@@ -360,41 +388,56 @@ hsize_t diff_datasetid(hid_t did1, hid_t did2, const char *obj1_name, const char
              *------------------------------------------------------------------
              */
             H5TOOLS_DEBUG("NOT H5T_ARRAY, upgrade the smaller memory size?");
-            if (FAIL == match_up_memsize (f_tid1, f_tid2,
-                                        &m_tid1, &m_tid2,
-                                        &m_size1, &m_size2))
+            if (FAIL == match_up_memsize (f_tid1, f_tid2, &m_tid1, &m_tid2, &m_size1, &m_size2))
                 H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "match_up_memsize failed");
             H5TOOLS_DEBUG("m_size: %ld - %ld", m_size1, m_size2);
-            dadims = dims1;
-            dam_size = m_size1;
-            dam_tid = m_tid1;
-            danelmts = nelmts1;
+            opts->rank = rank1;
+            for(i = 0; i < rank1; i++)
+                opts->dims[i] = dims1[i];
+            opts->m_size = m_size1;
+            opts->m_tid = m_tid1;
+            opts->nelmts = nelmts1;
             need = (size_t)(nelmts1 * m_size1);  /* bytes needed */
         }
         else {
             H5TOOLS_DEBUG("Array dims: %d - %d", dims1[0], dims2[0]);
             /* Compare the smallest array, but create the largest buffer */
             if(m_size1 <= m_size2) {
-                dadims = dims1;
-                dam_size = m_size1;
-                dam_tid = m_tid1;
-                danelmts = nelmts1;
+                opts->rank = rank1;
+                for(i = 0; i < rank1; i++)
+                    opts->dims[i] = dims1[i];
+                opts->m_size = m_size1;
+                opts->m_tid = m_tid1;
+                opts->nelmts = nelmts1;
                 need = (size_t)(nelmts2 * m_size2);  /* bytes needed */
             }
             else {
-                dadims = dims2;
-                dam_size = m_size2;
-                dam_tid = m_tid2;
-                danelmts = nelmts2;
+                opts->rank = rank2;
+                for(i = 0; i < rank2; i++)
+                    opts->dims[i] = dims2[i];
+                opts->m_size = m_size2;
+                opts->m_tid = m_tid2;
+                opts->nelmts = nelmts2;
                 need = (size_t)(nelmts1 * m_size1);  /* bytes needed */
             }
         }
+        opts->hs_nelmts = opts->nelmts;
+        H5TOOLS_DEBUG("need: %ld", need);
         /* print names */
+        H5TOOLS_DEBUG("obj_names: %s - %s", obj1_name, obj2_name);
+
+        if (opts->obj_name[0] != NULL)
+             HDfree(opts->obj_name[0]);
+        opts->obj_name[0] = NULL;
+        if (opts->obj_name[1] != NULL)
+             HDfree(opts->obj_name[1]);
+        opts->obj_name[1] = NULL;
+
         if(obj1_name)
-            name1 = diff_basename(obj1_name);
+            opts->obj_name[0] = HDstrdup(diff_basename(obj1_name));
         if(obj2_name)
-            name2 = diff_basename(obj2_name);
-        H5TOOLS_DEBUG("obj_names: %s - %s", name1, name2);
+            opts->obj_name[1] = HDstrdup(diff_basename(obj2_name));
+        H5TOOLS_DEBUG("obj_names: %s - %s", opts->obj_name[0], opts->obj_name[1]);
 
 
         H5TOOLS_DEBUG("read/compare");
@@ -407,7 +450,14 @@ hsize_t diff_datasetid(hid_t did1, hid_t did2, const char *obj1_name, const char
             buf2 = HDmalloc(need);
         } /* end if */
 
-        if(buf1 != NULL && buf2 != NULL) {
+        /* Assume entire data space to be printed */
+        init_acc_pos(opts->rank, opts->dims, opts->acc, opts->pos, opts->p_min_idx);
+
+        for(i = 0; i < opts->rank; i++) {
+            opts->p_max_idx[i] = opts->dims[i];
+        }
+
+        if(buf1 != NULL && buf2 != NULL && opts->sset[0] == NULL && opts->sset[1] == NULL) {
             H5TOOLS_DEBUG("buf1 != NULL && buf2 != NULL");
             H5TOOLS_DEBUG("H5Dread did1");
             if(H5Dread(did1, m_tid1, H5S_ALL, H5S_ALL, H5P_DEFAULT, buf1) < 0)
@@ -416,10 +466,13 @@ hsize_t diff_datasetid(hid_t did1, hid_t did2, const char *obj1_name, const char
             if(H5Dread(did2, m_tid2, H5S_ALL, H5S_ALL, H5P_DEFAULT, buf2) < 0)
                 H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Dread failed");
 
+            /* initialize the current stripmine position; this is necessary to print the array indices */
+            for (j = 0; j < opts->rank; j++)
+                opts->sm_pos[j] = (hsize_t)0;
+
             /* array diff */
-            nfound = diff_array(buf1, buf2, danelmts, (hsize_t)0, rank1, dadims,
-                opts, name1, name2, dam_tid, did1, did2);
-            H5TOOLS_DEBUG("diff_array nfound:%d - errstat:%d", nfound, opts->err_stat);
+            nfound = diff_array(buf1, buf2, opts, did1, did2);
+            H5TOOLS_DEBUG("diff_array ret nfound:%d - errstat:%d", nfound, opts->err_stat);
 
             /* reclaim any VL memory, if necessary */
             H5TOOLS_DEBUG("check vl_data1:%d", vl_data1);
@@ -438,111 +491,369 @@ hsize_t diff_datasetid(hid_t did1, hid_t did2, const char *obj1_name, const char
             }
         } /* end if */
         else { /* possibly not enough memory, read/compare by hyperslabs */
-            size_t        p_type_nbytes = dam_size; /*size of memory type */
-            hsize_t       p_nelmts = danelmts;      /*total selected elmts */
-            hsize_t       elmtno;                  /*counter  */
-            int           carry;                   /*counter carry value */
+            hsize_t       elmtno;                   /* counter  */
+            int           carry;                    /* counter carry value */
 
             /* stripmine info */
-            hsize_t       sm_size[H5S_MAX_RANK];   /*stripmine size */
-            hsize_t       sm_nbytes;               /*bytes per stripmine */
-            hsize_t       sm_nelmts;               /*elements per stripmine*/
+            hsize_t       sm_size[H5S_MAX_RANK];    /* stripmine size */
+            hsize_t       sm_block[H5S_MAX_RANK];   /* stripmine block size  */
+            hsize_t       sm_nbytes;                /* bytes per stripmine */
+            hsize_t       sm_nelmts1;               /* elements per stripmine */
+            hsize_t       sm_nelmts2;               /* elements per stripmine */
+            hssize_t      ssm_nelmts;               /* elements temp */
 
             /* hyperslab info */
-            hsize_t       hs_offset[H5S_MAX_RANK]; /*starting offset */
-            hsize_t       hs_size[H5S_MAX_RANK];   /*size this pass */
-            hsize_t       hs_nelmts;               /*elements in request */
-            hsize_t       zero[8];                 /*vector of zeros */
+            hsize_t       hs_offset1[H5S_MAX_RANK]; /* starting offset */
+            hsize_t       hs_count1[H5S_MAX_RANK];  /* number of blocks */
+            hsize_t       hs_block1[H5S_MAX_RANK];  /* size of blocks */
+            hsize_t       hs_stride1[H5S_MAX_RANK]; /* stride */
+            hsize_t       hs_size1[H5S_MAX_RANK];   /* size this pass */
+            hsize_t       hs_offset2[H5S_MAX_RANK]; /* starting offset */
+            hsize_t       hs_count2[H5S_MAX_RANK];  /* number of blocks */
+            hsize_t       hs_block2[H5S_MAX_RANK];  /* size of blocks */
+            hsize_t       hs_stride2[H5S_MAX_RANK]; /* stride */
+            hsize_t       hs_size2[H5S_MAX_RANK];   /* size this pass */
+            hsize_t       hs_nelmts1 = 0;           /* elements in request */
+            hsize_t       hs_nelmts2 = 0;           /* elements in request */
+            hsize_t       zero[8];                  /* vector of zeros */
+            hsize_t       low[H5S_MAX_RANK];        /* low bound of hyperslab */
+            hsize_t       high[H5S_MAX_RANK];       /* higher bound of hyperslab */
+
+            H5TOOLS_DEBUG("reclaim any VL memory and free unused buffers");
+            if(buf1 != NULL) {
+                /* reclaim any VL memory, if necessary */
+                if(vl_data1)
+                    H5Treclaim(m_tid1, sid1, H5P_DEFAULT, buf1);
+                HDfree(buf1);
+                buf1 = NULL;
+            }
+            if(buf2 != NULL) {
+                /* reclaim any VL memory, if necessary */
+                if(vl_data2)
+                    H5Treclaim(m_tid2, sid2, H5P_DEFAULT, buf2);
+                HDfree(buf2);
+                buf2 = NULL;
+            }
+
+            /* the stripmine loop */
+            HDmemset(hs_offset1, 0, sizeof hs_offset1);
+            HDmemset(hs_stride1, 0, sizeof hs_stride1);
+            HDmemset(hs_count1, 0, sizeof hs_count1);
+            HDmemset(hs_block1, 0, sizeof hs_block1);
+            HDmemset(hs_size1, 0, sizeof hs_size1);
+            HDmemset(hs_offset2, 0, sizeof hs_offset2);
+            HDmemset(hs_stride2, 0, sizeof hs_stride2);
+            HDmemset(hs_count2, 0, sizeof hs_count2);
+            HDmemset(hs_block2, 0, sizeof hs_block2);
+            HDmemset(hs_size2, 0, sizeof hs_size2);
+            HDmemset(zero, 0, sizeof zero);
+
+            /* if subsetting was requested - initialize the subsetting variables */
+            H5TOOLS_DEBUG("compare by hyperslabs: opts->nelmts=%ld - opts->m_size=%ld", opts->nelmts, opts->m_size);
+            if (opts->sset[0] != NULL) {
+                H5TOOLS_DEBUG("opts->sset[0] != NULL");
+
+                /* Check for valid settings - default if not specified */
+                if(!opts->sset[0]->start.data || !opts->sset[0]->stride.data || !opts->sset[0]->count.data || !opts->sset[0]->block.data) {
+                    /* they didn't specify a ``stride'' or ``block''. default to 1 in all
+                     * dimensions */
+                    if(!opts->sset[0]->start.data) {
+                        /* default to (0, 0, ...) for the start coord */
+                        opts->sset[0]->start.data = (hsize_t *)HDcalloc((size_t)rank1, sizeof(hsize_t));
+                        opts->sset[0]->start.len = (unsigned)rank1;
+                    }
+
+                    if(!opts->sset[0]->stride.data) {
+                        opts->sset[0]->stride.data = (hsize_t *)HDcalloc((size_t)rank1, sizeof(hsize_t));
+                        opts->sset[0]->stride.len = (unsigned)rank1;
+                        for (i = 0; i < rank1; i++)
+                            opts->sset[0]->stride.data[i] = 1;
+                    }
+
+                    if(!opts->sset[0]->count.data) {
+                        opts->sset[0]->count.data = (hsize_t *)HDcalloc((size_t)rank1, sizeof(hsize_t));
+                        opts->sset[0]->count.len = (unsigned)rank1;
+                        for (i = 0; i < rank1; i++)
+                            opts->sset[0]->count.data[i] = 1;
+                    }
+
+                    if(!opts->sset[0]->block.data) {
+                        opts->sset[0]->block.data = (hsize_t *)HDcalloc((size_t)rank1, sizeof(hsize_t));
+                        opts->sset[0]->block.len = (unsigned)rank1;
+                        for (i = 0; i < rank1; i++)
+                            opts->sset[0]->block.data[i] = 1;
+                    }
+
+                    /*-------------------------------------------------------------------------
+                     * check for block overlap
+                     *-------------------------------------------------------------------------
+                     */
+                    for(i = 0; i < rank1; i++) {
+                        if(opts->sset[0]->count.data[i] > 1) {
+                            if(opts->sset[0]->stride.data[i] < opts->sset[0]->block.data[i]) {
+                                H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "wrong subset selection[0]; blocks overlap");
+                            } /* end if */
+                        } /* end if */
+                    } /* end for */
+                }
+
+                /* Reset the total number of elements to the subset from the command */
+                opts->nelmts = 1;
+                for (i = 0; i < rank1; i++) {
+                    hs_offset1[i] = opts->sset[0]->start.data[i];
+                    hs_stride1[i] = opts->sset[0]->stride.data[i];
+                    hs_count1[i] = opts->sset[0]->count.data[i];
+                    hs_block1[i] = opts->sset[0]->block.data[i];
+                    opts->nelmts *= hs_count1[i] * hs_block1[i];
+                    hs_size1[i] = 0;
+                    H5TOOLS_DEBUG("[%d]hs_offset1:%ld, hs_stride1:%ld, hs_count1:%ld, hs_block1:%ld", i, hs_offset1[i], hs_stride1[i], hs_count1[i], hs_block1[i]);
+                }
+            }
+            if (opts->sset[1] != NULL) {
+                H5TOOLS_DEBUG("opts->sset[1] != NULL");
+
+                /* Check for valid settings - default if not specified */
+                if(!opts->sset[1]->start.data || !opts->sset[1]->stride.data || !opts->sset[1]->count.data || !opts->sset[1]->block.data) {
+                    /* they didn't specify a ``stride'' or ``block''. default to 1 in all
+                     * dimensions */
+                    if(!opts->sset[1]->start.data) {
+                        /* default to (0, 0, ...) for the start coord */
+                        opts->sset[1]->start.data = (hsize_t *)HDcalloc((size_t)rank2, sizeof(hsize_t));
+                        opts->sset[1]->start.len = (unsigned)rank2;
+                    }
+
+                    if(!opts->sset[1]->stride.data) {
+                        opts->sset[1]->stride.data = (hsize_t *)HDcalloc((size_t)rank2, sizeof(hsize_t));
+                        opts->sset[1]->stride.len = (unsigned)rank2;
+                        for (i = 0; i < rank2; i++)
+                            opts->sset[1]->stride.data[i] = 1;
+                    }
+
+                    if(!opts->sset[1]->count.data) {
+                        opts->sset[1]->count.data = (hsize_t *)HDcalloc((size_t)rank2, sizeof(hsize_t));
+                        opts->sset[1]->count.len = (unsigned)rank2;
+                        for (i = 0; i < rank2; i++)
+                            opts->sset[1]->count.data[i] = 1;
+                    }
+
+                    if(!opts->sset[1]->block.data) {
+                        opts->sset[1]->block.data = (hsize_t *)HDcalloc((size_t)rank2, sizeof(hsize_t));
+                        opts->sset[1]->block.len = (unsigned)rank2;
+                        for (i = 0; i < rank2; i++)
+                            opts->sset[1]->block.data[i] = 1;
+                    }
+
+                    /*-------------------------------------------------------------------------
+                     * check for block overlap
+                     *-------------------------------------------------------------------------
+                     */
+                    for(i = 0; i < rank2; i++) {
+                        if(opts->sset[1]->count.data[i] > 1) {
+                            if(opts->sset[1]->stride.data[i] < opts->sset[1]->block.data[i]) {
+                                H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "wrong subset selection[1]; blocks overlap");
+                            } /* end if */
+                        } /* end if */
+                    } /* end for */
+                }
+
+                for (i = 0; i < rank2; i++) {
+                    hs_offset2[i] = opts->sset[1]->start.data[i];
+                    hs_stride2[i] = opts->sset[1]->stride.data[i];
+                    hs_count2[i] = opts->sset[1]->count.data[i];
+                    hs_block2[i] = opts->sset[1]->block.data[i];
+                    hs_size2[i] = 0;
+                    H5TOOLS_DEBUG("[%d]hs_offset2:%ld, hs_stride2:%ld, hs_count2:%ld, hs_block2:%ld", i, hs_offset2[i], hs_stride2[i], hs_count2[i], hs_block2[i]);
+                }
+            }
 
             /*
              * determine the strip mine size and allocate a buffer. The strip mine is
              * a hyperslab whose size is manageable.
              */
-            sm_nbytes = p_type_nbytes;
-
-            for(i = rank1; i > 0; --i) {
-                hsize_t size = H5TOOLS_BUFSIZE / sm_nbytes;
-
-                if(size == 0) /* datum size > H5TOOLS_BUFSIZE */
-                    size = 1;
-                sm_size[i - 1] = MIN(dadims[i - 1], size);
-                sm_nbytes *= sm_size[i - 1];
-                H5TOOLS_DEBUG("sm_nbytes: %ld", sm_nbytes);
-            } /* end for */
-
-            /* malloc return code should be verified.
-             * If fail, need to handle the error.
-             * This else branch should be recoded as a separate function.
-             * Note that there are many "goto error" within this branch
-             * that fails to address freeing other objects created here.
-             * E.g., sm_space.
-             */
-            if((sm_buf1 = HDmalloc((size_t)sm_nbytes)) == NULL)
-                H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "HDmalloc failed");
-            if((sm_buf2 = HDmalloc((size_t)sm_nbytes)) == NULL)
-                H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "HDmalloc failed");
+            sm_nbytes = opts->m_size;
+            if(opts->rank > 0) {
+                for (i = opts->rank; i > 0; --i) {
+                    hsize_t size = H5TOOLS_BUFSIZE / sm_nbytes;
+                    if (size == 0) /* datum size > H5TOOLS_BUFSIZE */
+                        size = 1;
+                    H5TOOLS_DEBUG("opts->dims[%d]: %ld - size: %ld", i - 1, opts->dims[i - 1], size);
+                    if (opts->sset[1] != NULL) {
+                        sm_size[i - 1] = MIN(hs_block1[i - 1] * hs_count1[i - 1], size);
+                        sm_block[i - 1] = MIN(hs_block1[i - 1], sm_size[i - 1]);
+                    }
+                    else {
+                        sm_size[i - 1] = MIN(opts->dims[i - 1], size);
+                        sm_block[i - 1] = sm_size[i - 1];
+                    }
+                    H5TOOLS_DEBUG("sm_size[%d]: %ld - sm_block:%ld", i - 1, sm_size[i - 1], sm_block[i - 1]);
+                    sm_nbytes *= sm_size[i - 1];
+                    H5TOOLS_DEBUG("sm_nbytes: %ld", sm_nbytes);
+                }
+            }
 
-            sm_nelmts = sm_nbytes / p_type_nbytes;
-            sm_space = H5Screate_simple(1, &sm_nelmts, NULL);
+            H5TOOLS_DEBUG("opts->nelmts: %ld", opts->nelmts);
+            for(elmtno = 0; elmtno < opts->nelmts; elmtno += opts->hs_nelmts) {
+                H5TOOLS_DEBUG("elmtno: %ld - hs_nelmts1: %ld", elmtno, hs_nelmts1);
 
-            /* the stripmine loop */
-            HDmemset(hs_offset, 0, sizeof hs_offset);
-            HDmemset(zero, 0, sizeof zero);
+                if(NULL == (sm_buf1 = (unsigned char *)HDmalloc((size_t) sm_nbytes)))
+                    H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "Could not allocate buffer for strip-mine");
+                if(NULL == (sm_buf2 = (unsigned char *)HDmalloc((size_t) sm_nbytes)))
+                    H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "Could not allocate buffer for strip-mine");
 
-            for(elmtno = 0; elmtno < p_nelmts; elmtno += hs_nelmts) {
                 /* calculate the hyperslab size */
-                if(rank1 > 0) {
-                    for(i = 0, hs_nelmts = 1; i < rank1; i++) {
-                        hs_size[i] = MIN(dadims[i] - hs_offset[i], sm_size[i]);
-                        hs_nelmts *= hs_size[i];
-                    } /* end for */
-                    if(H5Sselect_hyperslab(sid1, H5S_SELECT_SET, hs_offset, NULL, hs_size, NULL) < 0)
-                        H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Sselect_hyperslab failed");
-                    if(H5Sselect_hyperslab(sid2, H5S_SELECT_SET, hs_offset, NULL, hs_size, NULL) < 0)
+                /* initialize subset */
+                if(opts->rank > 0) {
+                    if (opts->sset[0] != NULL) {
+                        H5TOOLS_DEBUG("sset1 has data");
+                        /* calculate the potential number of elements */
+                        for(i = 0; i < rank1; i++) {
+                            H5TOOLS_DEBUG("[%d]opts->dims: %ld - hs_offset1: %ld - sm_block: %ld", i, opts->dims[i], hs_offset1[i], sm_block[i]);
+                            hs_size1[i] = MIN(opts->dims[i] - hs_offset1[i], sm_block[i]);
+                            H5TOOLS_DEBUG("hs_size1[%d]: %ld", i, hs_size1[i]);
+                        }
+                        if(H5Sselect_hyperslab(sid1, H5S_SELECT_SET, hs_offset1, hs_stride1, hs_count1, hs_size1) < 0)
+                            H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Sselect_hyperslab sid1 failed");
+                    }
+                    else {
+                        for(i = 0, hs_nelmts1 = 1; i < rank1; i++) {
+                            H5TOOLS_DEBUG("[%d]opts->dims: %ld - hs_offset1: %ld - sm_block: %ld", i, opts->dims[i], hs_offset1[i], sm_block[i]);
+                            hs_size1[i] = MIN(opts->dims[i] - hs_offset1[i], sm_block[i]);
+                            H5TOOLS_DEBUG("hs_size1[%d]: %ld", i, hs_size1[i]);
+                            hs_nelmts1 *= hs_size1[i];
+                            H5TOOLS_DEBUG("hs_nelmts1:%ld *= hs_size1[%d]: %ld", hs_nelmts1, i, hs_size1[i]);
+                        }
+                        if(H5Sselect_hyperslab(sid1, H5S_SELECT_SET, hs_offset1, NULL, hs_size1, NULL) < 0)
+                            H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Sselect_hyperslab sid1 failed");
+                    }
+
+                    if((ssm_nelmts = H5Sget_select_npoints(sid1)) < 0)
+                        H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Sget_select_npoints failed");
+                    sm_nelmts1 = (hsize_t)ssm_nelmts;
+                    H5TOOLS_DEBUG("sm_nelmts1: %ld", sm_nelmts1);
+                    hs_nelmts1 = sm_nelmts1;
+
+                    if((sm_space1 = H5Screate_simple(1, &sm_nelmts1, NULL)) < 0)
+                        H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Screate_simple failed");
+
+                    if(H5Sselect_hyperslab(sm_space1, H5S_SELECT_SET, zero, NULL, &sm_nelmts1, NULL) < 0)
                         H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Sselect_hyperslab failed");
-                    if(H5Sselect_hyperslab(sm_space, H5S_SELECT_SET, zero, NULL, &hs_nelmts, NULL) < 0)
+
+                    if (opts->sset[1] != NULL) {
+                        H5TOOLS_DEBUG("sset2 has data");
+                        for(i = 0; i < rank2; i++) {
+                            H5TOOLS_DEBUG("[%d]opts->dims: %ld - hs_offset2: %ld - sm_block: %ld", i, opts->dims[i], hs_offset2[i], sm_block[i]);
+                            hs_size2[i] = MIN(opts->dims[i] - hs_offset2[i], sm_block[i]);
+                            H5TOOLS_DEBUG("hs_size2[%d]: %ld", i, hs_size2[i]);
+                        }
+                        if(H5Sselect_hyperslab(sid2, H5S_SELECT_SET, hs_offset2, hs_stride2, hs_count2, hs_size2) < 0)
+                            H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Sselect_hyperslab sid2 failed");
+                    }
+                    else {
+                        for(i = 0, hs_nelmts2 = 1; i < rank2; i++) {
+                            H5TOOLS_DEBUG("[%d]opts->dims: %ld - hs_offset2: %ld - sm_block: %ld", i, opts->dims[i], hs_offset2[i], sm_block[i]);
+                            hs_size2[i] = MIN(opts->dims[i] - hs_offset2[i], sm_block[i]);
+                            H5TOOLS_DEBUG("hs_size2[%d]: %ld", i, hs_size2[i]);
+                            hs_nelmts2 *= hs_size2[i];
+                            H5TOOLS_DEBUG("hs_nelmts2:%ld *= hs_size2[%d]: %ld", hs_nelmts2, i, hs_size2[i]);
+                        }
+                        if(H5Sselect_hyperslab(sid2, H5S_SELECT_SET, hs_offset2, NULL, hs_size2, NULL) < 0)
+                            H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Sselect_hyperslab sid2 failed");
+                    }
+
+                    if((ssm_nelmts = H5Sget_select_npoints(sid2)) < 0)
+                        H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Sget_select_npoints failed");
+                    sm_nelmts2 = (hsize_t)ssm_nelmts;
+                    H5TOOLS_DEBUG("sm_nelmts2: %ld", sm_nelmts2);
+                    hs_nelmts2 = sm_nelmts2;
+
+                    if((sm_space2 = H5Screate_simple(1, &sm_nelmts2, NULL)) < 0)
+                        H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Screate_simple failed");
+
+                    if(H5Sselect_hyperslab(sm_space2, H5S_SELECT_SET, zero, NULL, &sm_nelmts2, NULL) < 0)
                         H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Sselect_hyperslab failed");
-                } /* end if */
+                }
                 else
-                    hs_nelmts = 1;
+                    hs_nelmts1 = 1;
+                opts->hs_nelmts = hs_nelmts1;
+                H5TOOLS_DEBUG("hs_nelmts: %ld", opts->hs_nelmts);
 
-                if(H5Dread(did1, m_tid1, sm_space, sid1, H5P_DEFAULT, sm_buf1) < 0)
+                /* read the data */
+                if(H5Dread(did1, m_tid1, sm_space1, sid1, H5P_DEFAULT, sm_buf1) < 0)
                     H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Dread failed");
-                if(H5Dread(did2, m_tid2, sm_space, sid2, H5P_DEFAULT, sm_buf2) < 0)
+                if(H5Dread(did2, m_tid2, sm_space2, sid2, H5P_DEFAULT, sm_buf2) < 0)
                     H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Dread failed");
 
+                /* print array indices. get the lower bound of the hyperslab and calculate
+                   the element position at the start of hyperslab */
+                if(H5Sget_select_bounds(sid1, low, high) < 0)
+                    H5TOOLS_GOTO_ERROR(H5DIFF_ERR, "H5Sget_select_bounds failed");
+                /* initialize the current stripmine position; this is necessary to print the array indices */
+                for (j = 0; j < opts->rank; j++)
+                    opts->sm_pos[j] = low[j];
+
+                /* Assume entire data space to be printed */
+                init_acc_pos(opts->rank, opts->dims, opts->acc, opts->pos, opts->p_min_idx);
+
                 /* get array differences. in the case of hyperslab read, increment the number of differences
                 found in each hyperslab and pass the position at the beginning for printing */
-                nfound += diff_array(sm_buf1, sm_buf2, hs_nelmts, elmtno, rank1,
-                        dadims, opts, name1, name2, dam_tid, did1, did2);
-
-                /* reclaim any VL memory, if necessary */
-                if(vl_data1)
-                    H5Treclaim(m_tid1, sm_space, H5P_DEFAULT, sm_buf1);
-                if(vl_data2)
-                    H5Treclaim(m_tid2, sm_space, H5P_DEFAULT, sm_buf2);
+                nfound += diff_array(sm_buf1, sm_buf2, opts, did1, did2);
+
+                if(sm_buf1 != NULL) {
+                    /* reclaim any VL memory, if necessary */
+                    if(vl_data1)
+                        H5Treclaim(m_tid1, sm_space1, H5P_DEFAULT, sm_buf1);
+                    HDfree(sm_buf1);
+                    sm_buf1 = NULL;
+                }
+                if(sm_buf2 != NULL) {
+                    /* reclaim any VL memory, if necessary */
+                    if(vl_data2)
+                        H5Treclaim(m_tid2, sm_space2, H5P_DEFAULT, sm_buf2);
+                    HDfree(sm_buf2);
+                    sm_buf2 = NULL;
+                }
+
+                H5Sclose(sm_space1);
+                H5Sclose(sm_space2);
 
                 /* calculate the next hyperslab offset */
-                for(i = rank1, carry = 1; i > 0 && carry; --i) {
-                    hs_offset[i - 1] += hs_size[i - 1];
-                    if(hs_offset[i - 1] == dadims[i - 1])
-                        hs_offset[i - 1] = 0;
+                for(i = opts->rank, carry = 1; i > 0 && carry; --i) {
+                    if (opts->sset[0] != NULL) {
+                        H5TOOLS_DEBUG("[%d]hs_size1:%ld - hs_block1:%ld - hs_stride1:%ld", i-1, hs_size1[i-1], hs_block1[i - 1], hs_stride1[i - 1]);
+                        if(hs_size1[i - 1] >= hs_block1[i - 1]) {
+                            hs_offset1[i - 1] += hs_size1[i - 1];
+                        }
+                        else {
+                            hs_offset1[i - 1] += hs_stride1[i - 1];
+                        }
+                    }
+                    else
+                        hs_offset1[i - 1] += hs_size1[i - 1];
+                    H5TOOLS_DEBUG("[%d]hs_offset1:%ld - opts->dims:%ld", i-1, hs_offset1[i-1], opts->dims[i - 1]);
+                    if(hs_offset1[i - 1] >= opts->dims[i - 1])
+                        hs_offset1[i - 1] = 0;
                     else
                         carry = 0;
-                } /* i */
-            } /* elmtno */
-            if(sm_buf1 != NULL) {
-                HDfree(sm_buf1);
-                sm_buf1 = NULL;
-            }
-            if(sm_buf2 != NULL) {
-                HDfree(sm_buf2);
-                sm_buf2 = NULL;
-            }
-
-            H5Sclose(sm_space);
+                    H5TOOLS_DEBUG("[%d]hs_offset1:%ld", i-1, hs_offset1[i-1]);
+                    if (opts->sset[1] != NULL) {
+                        H5TOOLS_DEBUG("[%d]hs_size2:%ld - hs_block2:%ld - hs_stride2:%ld", i-1, hs_size2[i-1], hs_block2[i - 1], hs_stride2[i - 1]);
+                        if(hs_size2[i - 1] >= hs_block2[i - 1]) {
+                            hs_offset2[i - 1] += hs_size2[i - 1];
+                        }
+                        else {
+                            hs_offset2[i - 1] += hs_stride2[i - 1];
+                        }
+                    }
+                    else
+                        hs_offset2[i - 1] += hs_size2[i - 1];
+                    H5TOOLS_DEBUG("[%d]hs_offset2:%ld - opts->dims:%ld", i-1, hs_offset2[i-1], opts->dims[i - 1]);
+                    if(hs_offset2[i - 1] >= opts->dims[i - 1])
+                        hs_offset2[i - 1] = 0;
+                    H5TOOLS_DEBUG("[%d]hs_offset2:%ld", i-1, hs_offset2[i-1]);
+                }
+            } /* elmtno for loop */
         } /* hyperslab read */
-        H5TOOLS_DEBUG("can_compare complete");
+        H5TOOLS_DEBUG("can compare complete");
     } /*can_compare*/
 
 
@@ -550,12 +861,20 @@ hsize_t diff_datasetid(hid_t did1, hid_t did2, const char *obj1_name, const char
      * close
      *-------------------------------------------------------------------------
      */
-    H5TOOLS_DEBUG("reclaim any VL memory - errstat:%d", opts->err_stat);
 
 done:
     opts->err_stat = opts->err_stat | ret_value;
 
+    H5TOOLS_DEBUG("free names - errstat:%d", opts->err_stat);
     /* free */
+    if (opts->obj_name[0] != NULL)
+         HDfree(opts->obj_name[0]);
+    opts->obj_name[0] = NULL;
+    if (opts->obj_name[1] != NULL)
+         HDfree(opts->obj_name[1]);
+    opts->obj_name[1] = NULL;
+
+    H5TOOLS_DEBUG("reclaim any VL memory");
     if(buf1 != NULL) {
         /* reclaim any VL memory, if necessary */
         if(vl_data1)
@@ -570,26 +889,31 @@ hsize_t diff_datasetid(hid_t did1, hid_t did2, const char *obj1_name, const char
         HDfree(buf2);
         buf2 = NULL;
     }
+    H5TOOLS_DEBUG("reclaim any stripmine VL memory");
     if(sm_buf1 != NULL) {
         /* reclaim any VL memory, if necessary */
         if(vl_data1)
-            H5Treclaim(m_tid1, sm_space, H5P_DEFAULT, sm_buf1);
+            H5Treclaim(m_tid1, sm_space1, H5P_DEFAULT, sm_buf1);
         HDfree(sm_buf1);
         sm_buf1 = NULL;
     }
     if(sm_buf2 != NULL) {
         /* reclaim any VL memory, if necessary */
         if(vl_data2)
-            H5Treclaim(m_tid2, sm_space, H5P_DEFAULT, sm_buf2);
+            H5Treclaim(m_tid2, sm_space2, H5P_DEFAULT, sm_buf2);
         HDfree(sm_buf2);
         sm_buf2 = NULL;
     }
 
+    H5TOOLS_DEBUG("close ids");
     /* disable error reporting */
     H5E_BEGIN_TRY {
         H5Sclose(sid1);
         H5Sclose(sid2);
-        H5Sclose(sm_space);
+        H5Sclose(sm_space1);
+        H5Sclose(sm_space2);
+        H5Pclose(dcpl1);
+        H5Pclose(dcpl2);
         H5Tclose(f_tid1);
         H5Tclose(f_tid2);
         H5Tclose(m_tid1);
@@ -613,10 +937,9 @@ hsize_t diff_datasetid(hid_t did1, hid_t did2, const char *obj1_name, const char
  *-------------------------------------------------------------------------
  */
 
-int diff_can_type(hid_t f_tid1, hid_t f_tid2, int rank1, int rank2,
-                  hsize_t *dims1, hsize_t *dims2, hsize_t *maxdim1, hsize_t *maxdim2,
-                  const char *obj1_name, const char *obj2_name,
-                  diff_opt_t *opts, int is_compound)
+int
+diff_can_type(hid_t f_tid1, hid_t f_tid2, int rank1, int rank2, hsize_t *dims1, hsize_t *dims2,
+                  hsize_t *maxdim1, hsize_t *maxdim2, diff_opt_t *opts, int is_compound)
 {
     H5T_class_t  tclass1;
     H5T_class_t  tclass2;
@@ -635,19 +958,21 @@ int diff_can_type(hid_t f_tid1, hid_t f_tid2, int rank1, int rank2,
     if((tclass2 = H5Tget_class(f_tid2)) < 0)
         H5TOOLS_GOTO_ERROR(FAIL, "H5Tget_class second object failed");
 
+    H5TOOLS_DEBUG("obj_names: %s - %s", opts->obj_name[0], opts->obj_name[1]);
     if(tclass1 != tclass2) {
-        if((opts->m_verbose || opts->m_list_not_cmp) && obj1_name && obj2_name) {
+        if((opts->mode_verbose || opts->mode_list_not_cmp) && opts->obj_name[0] && opts->obj_name[1]) {
             if(is_compound) {
                 parallel_print("Not comparable: <%s> has a class %s and <%s> has a class %s\n",
-                        obj1_name, get_class(tclass1),
-                        obj2_name, get_class(tclass2));
+                        opts->obj_name[0], get_class(tclass1),
+                        opts->obj_name[1], get_class(tclass2));
             }
             else {
                 parallel_print("Not comparable: <%s> is of class %s and <%s> is of class %s\n",
-                        obj1_name, get_class(tclass1),
-                        obj2_name, get_class(tclass2));
+                        opts->obj_name[0], get_class(tclass1),
+                        opts->obj_name[1], get_class(tclass2));
             }
         }
+
         opts->not_cmp = 1;
         H5TOOLS_GOTO_DONE(0);
     }
@@ -658,10 +983,11 @@ int diff_can_type(hid_t f_tid1, hid_t f_tid2, int rank1, int rank2,
      */
     switch (tclass1) {
         case H5T_TIME:
-            if((opts->m_verbose || opts->m_list_not_cmp) && obj1_name && obj2_name) {
+            if((opts->mode_verbose || opts->mode_list_not_cmp) && opts->obj_name[0] && opts->obj_name[1]) {
                 parallel_print("Not comparable: <%s> and <%s> are of class %s\n",
-                        obj1_name, obj2_name, get_class(tclass2));
+                        opts->obj_name[0], opts->obj_name[1], get_class(tclass2));
             } /* end if */
+
             opts->not_cmp = 1;
             H5TOOLS_GOTO_DONE(0);
             break;
@@ -679,7 +1005,7 @@ int diff_can_type(hid_t f_tid1, hid_t f_tid2, int rank1, int rank2,
         case H5T_NO_CLASS:
         case H5T_NCLASSES:
         default:
-            H5TOOLS_DEBUG("diff_can_type class - %s", get_class(tclass1));
+            H5TOOLS_DEBUG("class - %s", get_class(tclass1));
             break;
     } /* end switch */
 
@@ -687,15 +1013,15 @@ int diff_can_type(hid_t f_tid1, hid_t f_tid2, int rank1, int rank2,
      * check for equal file datatype; warning only
      *-------------------------------------------------------------------------
      */
-    if((H5Tequal(f_tid1, f_tid2) == 0) && (opts->m_verbose) && obj1_name && obj2_name) {
+    if((H5Tequal(f_tid1, f_tid2) == 0) && (opts->mode_verbose) && opts->obj_name[0] && opts->obj_name[1]) {
         H5T_class_t cl = H5Tget_class(f_tid1);
 
         parallel_print("Warning: different storage datatype\n");
         if(cl == H5T_INTEGER || cl == H5T_FLOAT) {
-            parallel_print("<%s> has file datatype ", obj1_name);
+            parallel_print("<%s> has file datatype ", opts->obj_name[0]);
             print_type(f_tid1);
             parallel_print("\n");
-            parallel_print("<%s> has file datatype ", obj2_name);
+            parallel_print("<%s> has file datatype ", opts->obj_name[1]);
             print_type(f_tid2);
             parallel_print("\n");
         }
@@ -706,18 +1032,19 @@ int diff_can_type(hid_t f_tid1, hid_t f_tid2, int rank1, int rank2,
      *-------------------------------------------------------------------------
      */
     if(rank1 != rank2) {
-        if((opts->m_verbose || opts->m_list_not_cmp) && obj1_name && obj2_name) {
-            parallel_print("Not comparable: <%s> has rank %d, dimensions ", obj1_name, rank1);
+        if((opts->mode_verbose || opts->mode_list_not_cmp) && opts->obj_name[0] && opts->obj_name[1]) {
+            parallel_print("Not comparable: <%s> has rank %d, dimensions ", opts->obj_name[0], rank1);
             print_dimensions(rank1, dims1);
             parallel_print(", max dimensions ");
             print_dimensions(rank1, maxdim1);
             parallel_print("\n" );
-            parallel_print("and <%s> has rank %d, dimensions ", obj2_name, rank2);
+            parallel_print("and <%s> has rank %d, dimensions ", opts->obj_name[1], rank2);
             print_dimensions(rank2, dims2);
             parallel_print(", max dimensions ");
             print_dimensions(rank2, maxdim2);
             parallel_print("\n");
         }
+
         opts->not_cmp = 1;
         H5TOOLS_GOTO_DONE(0);
     }
@@ -740,20 +1067,21 @@ int diff_can_type(hid_t f_tid1, hid_t f_tid2, int rank1, int rank2,
      *-------------------------------------------------------------------------
      */
     if(dim_diff == 1) {
-        if((opts->m_verbose || opts->m_list_not_cmp) && obj1_name && obj2_name) {
-            parallel_print("Not comparable: <%s> has rank %d, dimensions ", obj1_name, rank1);
+        if((opts->mode_verbose || opts->mode_list_not_cmp) && opts->obj_name[0] && opts->obj_name[1]) {
+            parallel_print("Not comparable: <%s> has rank %d, dimensions ", opts->obj_name[0], rank1);
             print_dimensions(rank1, dims1);
             if(maxdim1 && maxdim2) {
                 parallel_print(", max dimensions ");
                 print_dimensions(rank1, maxdim1);
                 parallel_print("\n" );
-                parallel_print("and <%s> has rank %d, dimensions ", obj2_name, rank2);
+                parallel_print("and <%s> has rank %d, dimensions ", opts->obj_name[1], rank2);
                 print_dimensions(rank2, dims2);
                 parallel_print(", max dimensions ");
                 print_dimensions(rank2, maxdim2);
                 parallel_print("\n");
             }
         }
+
         opts->not_cmp = 1;
         H5TOOLS_GOTO_DONE(0);
     }
@@ -762,13 +1090,13 @@ int diff_can_type(hid_t f_tid1, hid_t f_tid2, int rank1, int rank2,
      * maximum dimensions; just give a warning
      *-------------------------------------------------------------------------
      */
-    if(maxdim1 && maxdim2 && maxdim_diff == 1 && obj1_name) {
-        if(opts->m_verbose) {
+    if(maxdim1 && maxdim2 && maxdim_diff == 1 && opts->obj_name[0]) {
+        if(opts->mode_verbose) {
             parallel_print( "Warning: different maximum dimensions\n");
-            parallel_print("<%s> has max dimensions ", obj1_name);
+            parallel_print("<%s> has max dimensions ", opts->obj_name[0]);
             print_dimensions(rank1, maxdim1);
             parallel_print("\n");
-            parallel_print("<%s> has max dimensions ", obj2_name);
+            parallel_print("<%s> has max dimensions ", opts->obj_name[1]);
             print_dimensions(rank2, maxdim2);
             parallel_print("\n");
         }
@@ -777,16 +1105,17 @@ int diff_can_type(hid_t f_tid1, hid_t f_tid2, int rank1, int rank2,
     if(tclass1 == H5T_STRING) {
         htri_t vstrtype1 = -1;
         htri_t vstrtype2 = -1;
-        H5TOOLS_DEBUG("diff_can_type end - H5T_STRING");
+        H5TOOLS_DEBUG(" - H5T_STRING");
 
         vstrtype1 = H5Tis_variable_str(f_tid1);
         vstrtype2 = H5Tis_variable_str(f_tid2);
 
         /* no compare if either one but not both are variable string type */
         if (vstrtype1 != vstrtype2) {
-            if((opts->m_verbose || opts->m_list_not_cmp) && obj1_name && obj2_name)
+            if((opts->mode_verbose || opts->mode_list_not_cmp) && opts->obj_name[0] && opts->obj_name[1])
                 parallel_print("Not comparable: <%s> or <%s> is of mixed string type\n",
-                        obj1_name, obj2_name);
+                        opts->obj_name[0], opts->obj_name[1]);
+
             opts->not_cmp = 1;
             H5TOOLS_GOTO_DONE(0);
         }
@@ -798,17 +1127,18 @@ int diff_can_type(hid_t f_tid1, hid_t f_tid2, int rank1, int rank2,
         int   j;
         hid_t memb_type1 = H5I_INVALID_HID;
         hid_t memb_type2 = H5I_INVALID_HID;
-        H5TOOLS_DEBUG("diff_can_type end - H5T_COMPOUND");
+        H5TOOLS_DEBUG(" - H5T_COMPOUND");
 
         nmembs1 = H5Tget_nmembers(f_tid1);
         nmembs2 = H5Tget_nmembers(f_tid2);
 
         if(nmembs1 != nmembs2) {
-            if((opts->m_verbose || opts->m_list_not_cmp) && obj1_name && obj2_name) {
-                parallel_print("Not comparable: <%s> has %d members ", obj1_name, nmembs1);
-                parallel_print("<%s> has %d members ", obj2_name, nmembs2);
+            if((opts->mode_verbose || opts->mode_list_not_cmp) && opts->obj_name[0] && opts->obj_name[1]) {
+                parallel_print("Not comparable: <%s> has %d members ", opts->obj_name[0], nmembs1);
+                parallel_print("<%s> has %d members ", opts->obj_name[1], nmembs2);
                 parallel_print("\n");
             }
+
             opts->not_cmp = 1;
             H5TOOLS_GOTO_DONE(0);
         }
@@ -817,9 +1147,7 @@ int diff_can_type(hid_t f_tid1, hid_t f_tid2, int rank1, int rank2,
             memb_type1 = H5Tget_member_type(f_tid1, (unsigned)j);
             memb_type2 = H5Tget_member_type(f_tid2, (unsigned)j);
 
-            if (diff_can_type(memb_type1, memb_type2, rank1, rank2,
-                    dims1, dims2, maxdim1, maxdim2, obj1_name, obj2_name,
-                    opts, 1) != 1) {
+            if (diff_can_type(memb_type1, memb_type2, rank1, rank2, dims1, dims2, maxdim1, maxdim2, opts, 1) != 1) {
                 opts->not_cmp = 1;
                 H5Tclose(memb_type1);
                 H5Tclose(memb_type2);
@@ -838,19 +1166,17 @@ int diff_can_type(hid_t f_tid1, hid_t f_tid2, int rank1, int rank2,
 }
 
 
+#if defined (H5DIFF_DEBUG_UNUSED)
+/* this function is not currently used, but could be useful */
 /*-------------------------------------------------------------------------
  * Function: print_sizes
  *
  * Purpose: Print datatype sizes
  *-------------------------------------------------------------------------
  */
-#if defined (H5DIFF_DEBUG)
-void print_sizes( const char *obj1,
-                  const char *obj2,
-                  hid_t f_tid1,
-                  hid_t f_tid2,
-                  hid_t m_tid1,
-                  hid_t m_tid2 )
+void print_sizes( const char *obj1, const char *obj2, hid_t f_tid1, hid_t f_tid2, hid_t m_tid1, hid_t m_tid2);
+
+void print_sizes( const char *obj1, const char *obj2, hid_t f_tid1, hid_t f_tid2, hid_t m_tid1, hid_t m_tid2)
 {
     size_t  f_size1, f_size2;       /* size of type in file */
     size_t  m_size1, m_size2;       /* size of type in memory */
diff --git a/tools/lib/h5tools.c b/tools/lib/h5tools.c
index cc51e2cd491..d9c6715c874 100644
--- a/tools/lib/h5tools.c
+++ b/tools/lib/h5tools.c
@@ -29,28 +29,37 @@ int       H5tools_INDENT_g = 0;
 
 
 /* global variables */
+H5E_auto2_t lib_func;
+H5E_auto2_t tools_func;
+void       *lib_edata;
+void       *tools_edata;
+
 hid_t       H5tools_ERR_STACK_g = H5I_INVALID_HID;
 hid_t       H5tools_ERR_CLS_g = H5I_INVALID_HID;
 hid_t       H5E_tools_g = H5I_INVALID_HID;
 hid_t       H5E_tools_min_id_g = H5I_INVALID_HID;
 hid_t       H5E_tools_min_info_id_g = H5I_INVALID_HID;
 hid_t       H5E_tools_min_dbg_id_g = H5I_INVALID_HID;
-int         compound_data;
+
 FILE       *rawattrstream = NULL;      /* should initialize to stdout but gcc moans about it */
 FILE       *rawdatastream = NULL;      /* should initialize to stdout but gcc moans about it */
 FILE       *rawinstream = NULL;        /* should initialize to stdin but gcc moans about it */
 FILE       *rawoutstream = NULL;       /* should initialize to stdout but gcc moans about it */
 FILE       *rawerrorstream = NULL;     /* should initialize to stderr but gcc moans about it */
+
 int         bin_output;         /* binary output */
 int         bin_form = 0;       /* binary form, default NATIVE */
 int         region_output;      /* region output */
 int         oid_output;         /* oid output */
 int         data_output;        /* data output */
 int         attr_data_output;   /* attribute data output */
+int         compound_data;
+
 unsigned    packed_bits_num;    /* number of packed bits to display */
 unsigned    packed_data_offset; /* offset of packed bits to display */
 unsigned    packed_data_length; /* length of packed bits to display */
 unsigned long long packed_data_mask;  /* mask in which packed bits to display */
+
 int         enable_error_stack = 0;   /* re-enable error stack; disable=0 enable=1 */
 
 /* sort parameters */
@@ -103,6 +112,10 @@ const char *drivernames[] = {
 void
 h5tools_init(void)
 {
+    /* Disable error reporting */
+    H5Eget_auto2(H5E_DEFAULT, &lib_func, &lib_edata);
+    H5Eset_auto2(H5E_DEFAULT, NULL, NULL);
+
     if (!h5tools_init_g) {
         H5TOOLS_INIT_ERROR();
 
@@ -121,6 +134,29 @@ h5tools_init(void)
 
         h5tools_init_g++;
     }
+
+    /* Disable tools error reporting */
+    H5Eget_auto2(H5tools_ERR_STACK_g, &tools_func, &tools_edata);
+    H5Eset_auto2(H5tools_ERR_STACK_g, NULL, NULL);
+}
+
+/*-------------------------------------------------------------------------
+ * Function: h5tools_error_report
+ *
+ * Purpose:  Enable error stack reporting after command line is parsed.
+ *
+ * Return:   None
+ *-------------------------------------------------------------------------
+ */
+void
+h5tools_error_report(void)
+{
+    if (h5tools_init_g) {
+        if (enable_error_stack > 0) {
+            H5Eset_auto2(H5E_DEFAULT, lib_func, lib_edata);
+            H5Eset_auto2(H5tools_ERR_STACK_g, tools_func, tools_edata);
+        }
+    }
 }
 
 /*-------------------------------------------------------------------------
@@ -137,16 +173,11 @@ h5tools_init(void)
 void
 h5tools_close(void)
 {
-    H5E_auto2_t  tools_func;
-    void        *tools_edata;
-
     if (h5tools_init_g) {
         /* special case where only data is output to stdout */
         if ((rawoutstream == NULL) && rawdatastream && (rawdatastream == stdout))
             HDfprintf(rawdatastream, "\n");
 
-        H5Eget_auto2(H5tools_ERR_STACK_g, &tools_func, &tools_edata);
-
         if (tools_func)
             H5Eprint2(H5tools_ERR_STACK_g, rawerrorstream);
 
@@ -184,6 +215,10 @@ h5tools_close(void)
         /* Clean up the reference path table, if it's been used */
         term_ref_path_table();
 
+        /* Restore error stacks from init */
+        H5Eset_auto2(H5tools_ERR_STACK_g, tools_func, tools_edata);
+        H5Eset_auto2(H5E_DEFAULT, lib_func, lib_edata);
+
         H5TOOLS_CLOSE_ERROR();
 
         /* Shut down the library */
@@ -1090,8 +1125,8 @@ h5tools_detect_vlen_str(hid_t tid)
  *-------------------------------------------------------------------------
  */
 void
-h5tools_simple_prefix(FILE *stream, const h5tool_format_t *info,
-                      h5tools_context_t *ctx, hsize_t elmtno, int secnum)
+h5tools_simple_prefix(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx,
+        hsize_t elmtno, int secnum)
 {
     h5tools_str_t prefix;
     h5tools_str_t str;          /*temporary for indentation */
@@ -1119,7 +1154,7 @@ h5tools_simple_prefix(FILE *stream, const h5tool_format_t *info,
     H5TOOLS_DEBUG("after CR elmtno=%ld, ctx->ndims=%d", elmtno, ctx->ndims);
 
     /* Calculate new prefix */
-    h5tools_str_prefix(&prefix, info, elmtno, ctx->ndims, ctx);
+    h5tools_str_prefix(&prefix, info, elmtno, ctx);
     H5TOOLS_DEBUG("prefix=%s - str=%s", prefix.s, str.s);
 
     /* Write new prefix to output */
@@ -1186,8 +1221,8 @@ h5tools_simple_prefix(FILE *stream, const h5tool_format_t *info,
  *-------------------------------------------------------------------------
  */
 void
-h5tools_region_simple_prefix(FILE *stream, const h5tool_format_t *info,
-        h5tools_context_t *ctx, hsize_t elmtno, hsize_t *ptdata, int secnum)
+h5tools_region_simple_prefix(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx,
+        hsize_t elmtno, hsize_t *ptdata, int secnum)
 {
     h5tools_str_t prefix;
     h5tools_str_t str;       /*temporary for indentation */
@@ -1211,7 +1246,7 @@ h5tools_region_simple_prefix(FILE *stream, const h5tool_format_t *info,
     }
 
     /* Calculate new prefix */
-    h5tools_str_region_prefix(&prefix, info, elmtno, ptdata, ctx->ndims, ctx->p_max_idx, ctx);
+    h5tools_str_region_prefix(&prefix, info, elmtno, ptdata, ctx);
 
     /* Write new prefix to output */
     if (ctx->indent_level > 0)
@@ -1284,9 +1319,8 @@ h5tools_region_simple_prefix(FILE *stream, const h5tool_format_t *info,
  *-------------------------------------------------------------------------
  */
 hbool_t
-h5tools_render_element(FILE *stream, const h5tool_format_t *info,
-        h5tools_context_t *ctx, h5tools_str_t *buffer, hsize_t *curr_pos,
-        size_t ncols, hsize_t local_elmt_counter, hsize_t elmt_counter)
+h5tools_render_element(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx,
+        h5tools_str_t *buffer, hsize_t *curr_pos, size_t ncols, hsize_t local_elmt_counter, hsize_t elmt_counter)
 {
     hbool_t  dimension_break = TRUE;
     char    *s = NULL;
@@ -1455,9 +1489,8 @@ h5tools_render_element(FILE *stream, const h5tool_format_t *info,
  *-------------------------------------------------------------------------
  */
 hbool_t
-h5tools_render_region_element(FILE *stream, const h5tool_format_t *info,
-        h5tools_context_t *ctx, h5tools_str_t *buffer, hsize_t *curr_pos,
-        size_t ncols, hsize_t *ptdata, hsize_t local_elmt_counter, hsize_t elmt_counter)
+h5tools_render_region_element(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx,
+        h5tools_str_t *buffer, hsize_t *curr_pos, size_t ncols, hsize_t *ptdata, hsize_t local_elmt_counter, hsize_t elmt_counter)
 {
     hbool_t  dimension_break = TRUE;
     char    *s = NULL;
@@ -1474,8 +1507,10 @@ h5tools_render_region_element(FILE *stream, const h5tool_format_t *info,
      * If the element would split on multiple lines if printed at our
      * current location...
      */
-    if (info->line_multi_new == 1 && (ctx->cur_column + h5tools_count_ncols(s) +
-                    HDstrlen(OPT(info->elmt_suf2, " ")) + HDstrlen(OPT(info->line_suf, ""))) > ncols) {
+    if (info->line_multi_new == 1 &&
+            (ctx->cur_column + h5tools_count_ncols(s) +
+                    HDstrlen(OPT(info->elmt_suf2, " ")) +
+                    HDstrlen(OPT(info->line_suf, ""))) > ncols) {
         if (ctx->prev_multiline) {
             /*
              * ... and the previous element also occupied more than one
@@ -1484,7 +1519,8 @@ h5tools_render_region_element(FILE *stream, const h5tool_format_t *info,
             ctx->need_prefix = TRUE;
         }
         else if ((ctx->prev_prefix_len + h5tools_count_ncols(s) +
-                HDstrlen(OPT(info->elmt_suf2, " ")) + HDstrlen(OPT(info->line_suf, ""))) <= ncols) {
+                HDstrlen(OPT(info->elmt_suf2, " ")) +
+                HDstrlen(OPT(info->line_suf, ""))) <= ncols) {
             /*
              * ...but *could* fit on one line otherwise, then we
              * should end the current line and start this element on its
@@ -1515,7 +1551,9 @@ h5tools_render_region_element(FILE *stream, const h5tool_format_t *info,
      * beginning of the line.
      */
     if (info->line_multi_new == 1 && ctx->prev_multiline &&
-            (ctx->cur_column + h5tools_count_ncols(s) + HDstrlen(OPT(info->elmt_suf2, " ")) + HDstrlen(OPT(info->line_suf, ""))) > ncols)
+            (ctx->cur_column + h5tools_count_ncols(s) +
+            HDstrlen(OPT(info->elmt_suf2, " ")) +
+            HDstrlen(OPT(info->line_suf, ""))) > ncols)
         ctx->need_prefix = TRUE;
 
     /*
@@ -1543,7 +1581,9 @@ h5tools_render_region_element(FILE *stream, const h5tool_format_t *info,
          * this check to happen for the first line
          */
         if ((!info->skip_first || local_elmt_counter) &&
-                (ctx->cur_column + HDstrlen(section) + HDstrlen(OPT(info->elmt_suf2, " ")) + HDstrlen(OPT(info->line_suf, ""))) > ncols)
+                (ctx->cur_column + HDstrlen(section) +
+                        HDstrlen(OPT(info->elmt_suf2, " ")) +
+                        HDstrlen(OPT(info->line_suf, ""))) > ncols)
             ctx->need_prefix = 1;
 
         /*
@@ -1589,26 +1629,64 @@ h5tools_render_region_element(FILE *stream, const h5tool_format_t *info,
  *-------------------------------------------------------------------------
  */
 void
-init_acc_pos(h5tools_context_t *ctx, hsize_t *dims)
+init_acc_pos(unsigned ndims, hsize_t *dims, hsize_t *acc, hsize_t *pos, hsize_t *p_min_idx)
 {
     int i;
     unsigned j;
 
     H5TOOLS_START_DEBUG("");
 
-    if(ctx->ndims > 0) {
-        ctx->acc[ctx->ndims - 1] = 1;
-        for (i = ((int)ctx->ndims - 2); i >= 0; i--) {
-            ctx->acc[i] = ctx->acc[i + 1] * dims[i + 1];
-            H5TOOLS_DEBUG("ctx->acc[%d]=%ld", i, ctx->acc[i]);
+    for (i = 0; (unsigned)i < ndims; i++)
+        p_min_idx[i] = 0;
+
+    if(ndims > 0) {
+        acc[ndims - 1] = 1;
+        for (i = ((int)ndims - 2); i >= 0; i--) {
+            acc[i] = acc[i + 1] * dims[i + 1];
+            H5TOOLS_DEBUG("acc[%d]=%ld", i, acc[i]);
         }
-        for (j = 0; j < ctx->ndims; j++)
-            ctx->pos[j] = 0;
+        for (j = 0; j < ndims; j++)
+            pos[j] = 0;
     }
 
     H5TOOLS_ENDDEBUG("");
 }
 
+/*-------------------------------------------------------------------------
+ * Function: calc_acc_pos
+ *
+ * Purpose:  Calculate the number of elements represented by a unit change
+ *           in a certain index position.
+ *
+ * Return:   void
+ *-------------------------------------------------------------------------
+ */
+hsize_t
+calc_acc_pos(unsigned ndims, hsize_t elmtno, hsize_t *acc, hsize_t *pos)
+{
+    int i;
+    hsize_t   curr_pos = elmtno;
+
+    H5TOOLS_START_DEBUG("");
+
+    if(ndims > 0) {
+        for(i = 0; i < (size_t) ndims; i++) {
+            if(curr_pos > 0) {
+                H5TOOLS_DEBUG("curr_pos=%ld - ctx->acc[%d]=%ld", curr_pos, i, acc[i]);
+                pos[i] = curr_pos / acc[i];
+                curr_pos -= acc[i] * pos[i];
+            }
+            else
+                pos[i] = 0;
+            H5TOOLS_DEBUG("curr_pos=%ld - pos[%d]=%ld - acc[%d]=%ld", curr_pos, i, pos[i], i, acc[i]);
+        }
+    }
+
+    H5TOOLS_ENDDEBUG("");
+
+    return curr_pos;
+}
+
 /*-------------------------------------------------------------------------
  * Function: render_bin_output
  *
diff --git a/tools/lib/h5tools.h b/tools/lib/h5tools.h
index 2b6fffbebe9..152ec1a4497 100644
--- a/tools/lib/h5tools.h
+++ b/tools/lib/h5tools.h
@@ -570,9 +570,6 @@ typedef struct h5tools_vfd_info_t {
     const char *name;
 } h5tools_vfd_info_t;
 
-H5TOOLS_DLLVAR const char *volnames[];
-H5TOOLS_DLLVAR const char *drivernames[];
-
 /* This enum should match the entries in the above 'volnames'
  * since they are indices into the 'volnames' array. */
 typedef enum {
@@ -603,14 +600,22 @@ typedef enum {
 
 #include "h5tools_str.h"
 
-H5TOOLS_DLLVAR h5tool_format_t h5tools_dataformat;
-H5TOOLS_DLLVAR const h5tools_dump_header_t h5tools_standardformat;
-H5TOOLS_DLLVAR const h5tools_dump_header_t* h5tools_dump_header_format;
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
+H5TOOLS_DLLVAR const char *volnames[];
+H5TOOLS_DLLVAR const char *drivernames[];
+
+H5TOOLS_DLLVAR h5tool_format_t h5tools_dataformat;
+H5TOOLS_DLLVAR const h5tools_dump_header_t h5tools_standardformat;
+H5TOOLS_DLLVAR const h5tools_dump_header_t* h5tools_dump_header_format;
+H5TOOLS_DLLVAR H5E_auto2_t lib_func;
+H5TOOLS_DLLVAR H5E_auto2_t tools_func;
+H5TOOLS_DLLVAR void *lib_edata;
+H5TOOLS_DLLVAR void *tools_edata;
+
 H5TOOLS_DLLVAR unsigned packed_bits_num;    /* number of packed bits to display */
 H5TOOLS_DLLVAR unsigned packed_data_offset; /* offset of packed bits to display */
 H5TOOLS_DLLVAR unsigned packed_data_length; /* length of packed bits to display */
@@ -644,14 +649,17 @@ H5TOOLS_DLLVAR int     enable_error_stack; /* re-enable error stack; disable=0 e
 /* Definitions of useful routines */
 H5TOOLS_DLL void    h5tools_init(void);
 H5TOOLS_DLL void    h5tools_close(void);
+
+H5TOOLS_DLL void    h5tools_error_report(void);
 H5TOOLS_DLL int     h5tools_set_data_output_file(const char *fname, int is_bin);
 H5TOOLS_DLL int     h5tools_set_attr_output_file(const char *fname, int is_bin);
 H5TOOLS_DLL int     h5tools_set_input_file(const char *fname, int is_bin);
 H5TOOLS_DLL int     h5tools_set_output_file(const char *fname, int is_bin);
 H5TOOLS_DLL int     h5tools_set_error_file(const char *fname, int is_bin);
-H5TOOLS_DLL hid_t   h5tools_get_fapl(hid_t prev_fapl_id, h5tools_vol_info_t *vol_info,
-                        h5tools_vfd_info_t *vfd_info);
-H5TOOLS_DLL herr_t  h5tools_get_vfd_name(hid_t fapl_id, char *drivername, size_t drivername_size);
+
+H5TOOLS_DLL hid_t   h5tools_get_fapl(hid_t prev_fapl_id, h5tools_vol_info_t *vol_info, h5tools_vfd_info_t *vfd_info);
+H5TOOLS_DLL herr_t  h5tools_get_vfd_name(hid_t fapl_id,
+                            char *drivername, size_t drivername_size);
 H5TOOLS_DLL hid_t   h5tools_fopen(const char *fname, unsigned flags, hid_t fapl,
                             hbool_t use_specific_driver, char *drivername, size_t drivername_size);
 H5TOOLS_DLL hid_t   h5tools_get_little_endian_type(hid_t type);
@@ -659,36 +667,29 @@ H5TOOLS_DLL hid_t   h5tools_get_big_endian_type(hid_t type);
 H5TOOLS_DLL htri_t  h5tools_detect_vlen(hid_t tid);
 H5TOOLS_DLL htri_t  h5tools_detect_vlen_str(hid_t tid);
 H5TOOLS_DLL hbool_t h5tools_is_obj_same(hid_t loc_id1, const char *name1, hid_t loc_id2, const char *name2);
-H5TOOLS_DLL void    init_acc_pos(h5tools_context_t *ctx, hsize_t *dims);
+H5TOOLS_DLL void    init_acc_pos(unsigned ndims, hsize_t *dims, hsize_t *acc, hsize_t *pos, hsize_t *p_min_idx);
+H5TOOLS_DLL hsize_t calc_acc_pos(unsigned ndims, hsize_t elemtno, hsize_t *acc, hsize_t *pos);
 H5TOOLS_DLL hbool_t h5tools_is_zero(const void *_mem, size_t size);
 H5TOOLS_DLL int     h5tools_canreadf(const char* name,  hid_t dcpl_id);
 H5TOOLS_DLL int     h5tools_can_encode(H5Z_filter_t filtn);
 
-H5TOOLS_DLL void    h5tools_simple_prefix(FILE *stream, const h5tool_format_t *info,
-                            h5tools_context_t *ctx, hsize_t elmtno, int secnum);
-H5TOOLS_DLL void    h5tools_region_simple_prefix(FILE *stream, const h5tool_format_t *info,
-                            h5tools_context_t *ctx, hsize_t elmtno, hsize_t *ptdata, int secnum);
+H5TOOLS_DLL void    h5tools_simple_prefix(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx,
+                            hsize_t elmtno, int secnum);
+H5TOOLS_DLL void    h5tools_region_simple_prefix(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx,
+                            hsize_t elmtno, hsize_t *ptdata, int secnum);
 
 H5TOOLS_DLL int     render_bin_output(FILE *stream, hid_t container, hid_t tid, void *_mem, hsize_t nelmts);
-H5TOOLS_DLL int     render_bin_output_region_data_blocks(hid_t region_id, FILE *stream,
-                            hid_t container, unsigned ndims, hid_t type_id, hsize_t nblocks, hsize_t *ptdata);
-H5TOOLS_DLL hbool_t render_bin_output_region_blocks(hid_t region_space, hid_t region_id,
-                             FILE *stream, hid_t container);
-H5TOOLS_DLL int     render_bin_output_region_data_points(hid_t region_space, hid_t region_id,
-                            FILE* stream, hid_t container, unsigned ndims, hid_t type_id, hsize_t npoints);
-H5TOOLS_DLL hbool_t render_bin_output_region_points(hid_t region_space, hid_t region_id,
-                             FILE *stream, hid_t container);
-
-H5TOOLS_DLL hbool_t h5tools_render_element(FILE *stream, const h5tool_format_t *info,
-                            h5tools_context_t *ctx, h5tools_str_t *buffer, hsize_t *curr_pos,
-                            size_t ncols, hsize_t local_elmt_counter, hsize_t elmt_counter);
-H5TOOLS_DLL hbool_t h5tools_render_region_element(FILE *stream, const h5tool_format_t *info,
-                            h5tools_context_t *ctx, /*in,out*/
-                            h5tools_str_t *buffer,  /*string into which to render */
-                            hsize_t *curr_pos,      /*total data element position*/
-                            size_t ncols, hsize_t *ptdata,
-                            hsize_t local_elmt_counter, /*element counter*/
-                            hsize_t elmt_counter);
+H5TOOLS_DLL int     render_bin_output_region_data_blocks(hid_t region_id, FILE *stream, hid_t container,
+                            unsigned ndims, hid_t type_id, hsize_t nblocks, hsize_t *ptdata);
+H5TOOLS_DLL hbool_t render_bin_output_region_blocks(hid_t region_space, hid_t region_id, FILE *stream, hid_t container);
+H5TOOLS_DLL int     render_bin_output_region_data_points(hid_t region_space, hid_t region_id, FILE* stream, hid_t container,
+                            unsigned ndims, hid_t type_id, hsize_t npoints);
+H5TOOLS_DLL hbool_t render_bin_output_region_points(hid_t region_space, hid_t region_id, FILE *stream, hid_t container);
+
+H5TOOLS_DLL hbool_t h5tools_render_element(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx, h5tools_str_t *buffer,
+                            hsize_t *curr_pos, size_t ncols, hsize_t local_elmt_counter, hsize_t elmt_counter);
+H5TOOLS_DLL hbool_t h5tools_render_region_element(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx, h5tools_str_t *buffer,
+                            hsize_t *curr_pos, size_t ncols, hsize_t *ptdata, hsize_t local_elmt_counter, hsize_t elmt_counter);
 
 #ifdef __cplusplus
 }
diff --git a/tools/lib/h5tools_dump.c b/tools/lib/h5tools_dump.c
index b59ae9375d4..187ba18363c 100644
--- a/tools/lib/h5tools_dump.c
+++ b/tools/lib/h5tools_dump.c
@@ -253,9 +253,8 @@ h5tools_dump_init(void)
  *-------------------------------------------------------------------------
  */
 int
-h5tools_dump_simple_data(FILE *stream, const h5tool_format_t *info, hid_t container,
-                         h5tools_context_t *ctx,    /* in,out */
-                         unsigned flags, hsize_t nelmts, hid_t type, void *_mem)
+h5tools_dump_simple_data(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx,    /* in,out */
+                         hid_t container, unsigned flags, hsize_t nelmts, hid_t type, void *_mem)
 {
     unsigned char *mem = (unsigned char*) _mem;
     hsize_t        i;               /* element counter  */
@@ -568,9 +567,11 @@ h5tools_print_region_data_blocks(hid_t region_id, FILE *stream, const h5tool_for
                 ctx.indent_level++;
                 if(H5Sget_simple_extent_dims(mem_space, total_size, NULL) >= 0) {
                     /* assume entire data space to be printed */
+                    init_acc_pos(ctx.ndims, total_size, ctx.acc, ctx.pos, ctx.p_min_idx);
+
+                    /* reset data space to be printed */
                     for (indx = 0; indx < (unsigned)ctx.ndims; indx++)
                         ctx.p_min_idx[indx] = start[indx];
-                    init_acc_pos(&ctx, total_size);
 
                     /* print the data */
                     region_flags = START_OF_DATA;
@@ -939,9 +940,7 @@ h5tools_print_region_data_points(hid_t region_space, hid_t region_id,
 
         if(H5Sget_simple_extent_dims(mem_space, total_size, NULL) >= 0) {
             /* assume entire data space to be printed */
-            for (indx = 0; indx < ctx.ndims; indx++)
-                ctx.p_min_idx[indx] = 0;
-            init_acc_pos(&ctx, total_size);
+            init_acc_pos(ctx.ndims, total_size, ctx.acc, ctx.pos, ctx.p_min_idx);
 
             /* print the data */
             region_flags = START_OF_DATA;
@@ -1274,9 +1273,6 @@ h5tools_print_simple_subset(FILE *stream, const h5tool_format_t *info, h5tools_c
     if ((size_t) ctx->ndims > NELMTS(sm_size))
         H5TOOLS_THROW(FAIL, "ndims and sm_size comparision failed");
 
-    if (ctx->ndims > 0)
-        init_acc_pos(ctx, total_size);
-
     size_row_block = ctx->sset->block.data[row_dim];
 
     /* Check if we have VL data in the dataset's datatype */
@@ -1347,27 +1343,25 @@ h5tools_print_simple_subset(FILE *stream, const h5tool_format_t *info, h5tools_c
             for (i = 0; i < ctx->ndims; i++)
                 ctx->p_max_idx[i] = ctx->p_min_idx[i] + MIN(total_size[i], sm_size[i]);
 
-            /* print array indices. get the lower bound of the hyperslab and calulate
-             the element position at the start of hyperslab */
+            /* print array indices. get the lower bound of the hyperslab and calculate
+               the element position at the start of hyperslab */
             if(H5Sget_select_bounds(f_space, low, high) < 0)
                 H5TOOLS_THROW(FAIL, "H5Sget_select_bounds failed");
 
-            elmtno = 0;
+            /* initialize the current stripmine position; this is necessary to print the array indices */
+            ctx->sm_pos = 0;
             for (i = 0; i < (size_t) ctx->ndims - 1; i++) {
                 hsize_t offset = 1; /* accumulation of the previous dimensions */
                 for (j = i + 1; j < (size_t) ctx->ndims; j++)
                     offset *= total_size[j];
-                elmtno += low[i] * offset;
+                ctx->sm_pos += low[i] * offset;
             }
-            elmtno += low[ctx->ndims - 1];
+            ctx->sm_pos += low[ctx->ndims - 1];
 
-            /* initialize the current stripmine position; this is necessary to print the array
-             indices */
-            ctx->sm_pos = elmtno;
 
             ctx->need_prefix = TRUE;
 
-            if(h5tools_dump_simple_data(stream, info, dset, ctx, flags, sm_nelmts, p_type, sm_buf) < 0)
+            if(h5tools_dump_simple_data(stream, info, ctx, dset, flags, sm_nelmts, p_type, sm_buf) < 0)
                 H5TOOLS_THROW(FAIL, "h5tools_dump_simple_data failed");
 
             /* Reclaim any VL memory, if necessary */
@@ -1586,12 +1580,10 @@ h5tools_dump_simple_subset(FILE *stream, const h5tool_format_t *info, h5tools_co
     ctx->ndims = (unsigned)sndims;
 
     /* assume entire data space to be printed */
-    if (ctx->ndims > 0)
-        for (i = 0; i < (size_t) ctx->ndims; i++)
-            ctx->p_min_idx[i] = 0;
-
     if(H5Sget_simple_extent_dims(f_space, total_size, NULL) < 0)
         H5TOOLS_THROW(FAIL, "H5Sget_simple_extent_dims failed");
+    init_acc_pos(ctx->ndims, total_size, ctx->acc, ctx->pos, ctx->p_min_idx);
+
     ctx->size_last_dim = total_size[ctx->ndims - 1];
 
     /* Set the compound datatype field list for display */
@@ -1623,38 +1615,37 @@ CATCH
  *-------------------------------------------------------------------------
  */
 static int
-h5tools_dump_simple_dset(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx,
-                         hid_t dset, hid_t p_type)
+h5tools_dump_simple_dset(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx, hid_t dset, hid_t p_type)
 {
-    hid_t               f_space = H5I_INVALID_HID;                  /* file data space */
-    hsize_t             elmtno;                   /* counter  */
-    size_t              i;                        /* counter  */
-    int                 sndims;                   /* rank of dataspace */
-    int                 carry;                    /* counter carry value */
-    hsize_t             zero[8];                  /* vector of zeros */
-    unsigned int        flags;                    /* buffer extent flags */
-    hsize_t             total_size[H5S_MAX_RANK]; /* total size of dataset*/
-    hbool_t             past_catch = FALSE;
+    hid_t            f_space = H5I_INVALID_HID; /* file data space */
+    hsize_t          elmtno;                    /* counter  */
+    size_t           i = 0;                     /* counter  */
+    int              sndims;                    /* rank of dataspace */
+    int              carry;                     /* counter carry value */
+    hsize_t          zero[8];                   /* vector of zeros */
+    unsigned int     flags;                     /* buffer extent flags */
+    hsize_t          total_size[H5S_MAX_RANK];  /* total size of dataset*/
+    hbool_t          past_catch = FALSE;
 
     /* Print info */
-    size_t              p_type_nbytes;            /* size of memory type */
-    hsize_t             p_nelmts;                 /* total selected elmts */
+    size_t           p_type_nbytes;             /* size of memory type */
+    hsize_t          p_nelmts;                  /* total selected elmts */
 
     /* Stripmine info */
-    hsize_t             sm_size[H5S_MAX_RANK];    /* stripmine size */
-    hsize_t             sm_nbytes;                /* bytes per stripmine */
-    hsize_t             sm_nelmts;                /* elements per stripmine*/
-    unsigned char      *sm_buf = NULL;            /* buffer for raw data */
-    hid_t               sm_space = H5I_INVALID_HID;                 /* stripmine data space */
+    hsize_t          sm_size[H5S_MAX_RANK];     /* stripmine size */
+    hsize_t          sm_nbytes;                 /* bytes per stripmine */
+    hsize_t          sm_nelmts;                 /* elements per stripmine*/
+    unsigned char   *sm_buf = NULL;             /* buffer for raw data */
+    hid_t            sm_space = H5I_INVALID_HID; /* stripmine data space */
 
     /* Hyperslab info */
-    hsize_t             hs_offset[H5S_MAX_RANK];  /* starting offset */
-    hsize_t             hs_size[H5S_MAX_RANK];    /* size this pass */
-    hsize_t             hs_nelmts;                /* elements in request */
+    hsize_t          hs_offset[H5S_MAX_RANK];   /* starting offset */
+    hsize_t          hs_size[H5S_MAX_RANK];     /* size this pass */
+    hsize_t          hs_nelmts;                 /* elements in request */
 
     /* VL data special information */
-    unsigned int        vl_data = 0; /* contains VL datatypes */
-    int                 ret_value = 0;
+    unsigned int     vl_data = 0;               /* contains VL datatypes */
+    int              ret_value = 0;
 
     H5TOOLS_START_DEBUG("");
     if (H5I_INVALID_HID == (f_space = H5Dget_space(dset)))
@@ -1670,11 +1661,8 @@ h5tools_dump_simple_dset(FILE *stream, const h5tool_format_t *info, h5tools_cont
         H5TOOLS_GOTO_ERROR((-1), "ctx->ndims > NELMTS(sm_size) failed");
 
     /* Assume entire data space to be printed */
-    if (ctx->ndims > 0)
-        for (i = 0; i < (size_t)ctx->ndims; i++)
-            ctx->p_min_idx[i] = 0;
-
     H5Sget_simple_extent_dims(f_space, total_size, NULL);
+    init_acc_pos(ctx->ndims, total_size, ctx->acc, ctx->pos, ctx->p_min_idx);
 
     /* calculate the number of elements we're going to print */
     p_nelmts = 1;
@@ -1720,8 +1708,6 @@ h5tools_dump_simple_dset(FILE *stream, const h5tool_format_t *info, h5tools_cont
         sm_space = H5Screate_simple(1, &sm_nelmts, NULL);
         H5TOOLS_DEBUG("sm_nelmts size:%ld", sm_nelmts);
 
-        if (ctx->ndims > 0)
-            init_acc_pos(ctx, total_size);
         H5TOOLS_DEBUG("ctx->ndims:%d", ctx->ndims);
 
         /* The stripmine loop */
@@ -1762,7 +1748,7 @@ h5tools_dump_simple_dset(FILE *stream, const h5tool_format_t *info, h5tools_cont
                 indices */
                 ctx->sm_pos = elmtno;
 
-                if(h5tools_dump_simple_data(stream, info, dset, ctx, flags, hs_nelmts, p_type, sm_buf) < 0)
+                if(h5tools_dump_simple_data(stream, info, ctx, dset, flags, hs_nelmts, p_type, sm_buf) < 0)
                     H5TOOLS_ERROR((-1), "h5tools_dump_simple_data failed");
 
                 /* Reclaim any VL memory, if necessary */
@@ -1841,11 +1827,8 @@ h5tools_dump_simple_mem(FILE *stream, const h5tool_format_t *info, h5tools_conte
         H5TOOLS_THROW((-1), "ctx->ndims > NELMTS(ctx->p_min_idx) failed");
 
     /* Assume entire data space to be printed */
-    if (ctx->ndims > 0)
-        for (i = 0; i < (size_t)ctx->ndims; i++)
-            ctx->p_min_idx[i] = 0;
-
     H5Sget_simple_extent_dims(f_space, total_size, NULL);
+    init_acc_pos(ctx->ndims, total_size, ctx->acc, ctx->pos, ctx->p_min_idx);
 
     /* calculate the number of elements we're going to print */
     p_nelmts = 1;
@@ -1868,14 +1851,12 @@ h5tools_dump_simple_mem(FILE *stream, const h5tool_format_t *info, h5tools_conte
     alloc_size = p_nelmts * H5Tget_size(p_type);
     HDassert(alloc_size == (hsize_t)((size_t)alloc_size)); /*check for overflow*/
     if (NULL != (buf = (unsigned char *)HDmalloc((size_t)alloc_size))) {
-        if (ctx->ndims > 0)
-            init_acc_pos(ctx, total_size);
         H5TOOLS_DEBUG("ctx->ndims:%d", ctx->ndims);
 
         H5TOOLS_DEBUG("Read the data");
         /* Read the data */
         if (H5Aread(attr_id, p_type, buf) >= 0) {
-            if(h5tools_dump_simple_data(stream, info, attr_id, ctx, START_OF_DATA | END_OF_DATA, p_nelmts, p_type, buf) < 0)
+            if(h5tools_dump_simple_data(stream, info, ctx, attr_id, START_OF_DATA | END_OF_DATA, p_nelmts, p_type, buf) < 0)
                 H5TOOLS_ERROR((-1), "h5tools_dump_simple_data failed");
 
             /* Reclaim any VL memory, if necessary */
@@ -3986,6 +3967,226 @@ h5tools_dump_subsetting_header(FILE *stream, const h5tool_format_t *info, h5tool
     h5tools_str_close(&buffer);
 }
 
+/*-------------------------------------------------------------------------
+ * Function:    dump_reference
+ *
+ * Purpose:     Dump reference data
+ *
+ * Return:      void
+ *-------------------------------------------------------------------------
+ */
+void
+h5tools_dump_reference(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx, hid_t container, H5R_ref_t *ref_buf, int ndims)
+{
+    hid_t               new_obj_id = H5I_INVALID_HID;
+    hid_t               new_obj_sid = H5I_INVALID_HID;
+    hsize_t             elmt_counter = 0;  /*counts the # elements printed. */
+    size_t              ncols = 80;        /* available output width        */
+    int                 i;
+    hsize_t             curr_pos = 0;      /* total data element position   */
+    h5tools_str_t       buffer;            /* string into which to render   */
+    h5tools_context_t   datactx;           /* print context  */
+
+    H5TOOLS_START_DEBUG("");
+
+    datactx = *ctx;  /* print context  */
+    /* Assume entire data space to be printed */
+    datactx.need_prefix = TRUE;
+
+    HDmemset(&buffer, 0, sizeof(h5tools_str_t));
+    for(i = 0; i < ndims; i++, datactx.cur_elmt++, elmt_counter++) {
+        H5O_type_t obj_type = -1;   /* Object type */
+        H5R_type_t ref_type;   /* Reference type */
+
+        H5TOOLS_DEBUG("reference loop:%d with curr_pos=%ld", i, curr_pos);
+
+        datactx.need_prefix = TRUE;
+        h5tools_str_reset(&buffer);
+        H5TOOLS_DEBUG("reference loop - h5tools_str_sprint with H5T_STD_REF:%d", i);
+        h5tools_str_sprint(&buffer, info, container, H5T_STD_REF, &ref_buf[i], &datactx);
+        h5tools_render_element(stream, info, &datactx, &buffer, &curr_pos, (size_t)ncols, (hsize_t)i, (hsize_t)ndims);
+
+        ref_type = H5Rget_type((const H5R_ref_t *)&ref_buf[i]);
+        switch (ref_type) {
+            case H5R_OBJECT1:
+                H5TOOLS_DEBUG("ref_type is H5R_OBJECT1");
+                if (H5Rget_obj_type3(&ref_buf[i], H5P_DEFAULT, &obj_type) >= 0) {
+                    switch (obj_type) {
+                        case H5O_TYPE_DATASET:
+                            if((new_obj_id = H5Ropen_object(&ref_buf[i], H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
+                                datactx.indent_level++;
+                                h5tools_dump_data(stream, info, &datactx, new_obj_id, TRUE);
+                                //h5tools_dump_dset(stream, info, &datactx, new_obj_id);
+                                datactx.indent_level--;
+                                if(H5Dclose(new_obj_id) < 0)
+                                    H5TOOLS_INFO("H5Dclose H5R_OBJECT1:H5O_TYPE_DATASET failed");
+                            }
+                            else
+                                H5TOOLS_INFO("H5Ropen_object H5R_OBJECT1:H5O_TYPE_DATASET failed");
+                            break;
+
+                        case H5O_TYPE_GROUP:
+                        case H5O_TYPE_NAMED_DATATYPE:
+                        case H5O_TYPE_MAP:
+                        case H5O_TYPE_UNKNOWN:
+                        case H5O_TYPE_NTYPES:
+                        default:
+                            break;
+                    } /* end switch */
+                }
+                else
+                    H5TOOLS_INFO("H5Rget_obj_type3 H5R_OBJECT1 failed");
+                break;
+            case H5R_DATASET_REGION1:
+                H5TOOLS_DEBUG("ref_type is H5R_DATASET_REGION1");
+                if((new_obj_id = H5Ropen_object(&ref_buf[i], H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
+                    datactx.indent_level++;
+                    h5tools_dump_data(stream, info, &datactx, new_obj_id, TRUE);
+                    //h5tools_dump_dset(stream, info, &datactx, new_obj_id);
+                    datactx.indent_level--;
+                    if(H5Dclose(new_obj_id) < 0)
+                        H5TOOLS_INFO("H5Dclose H5R_DATASET_REGION1 failed");
+                }
+                else
+                    H5TOOLS_INFO("H5Ropen_object H5R_DATASET_REGION1 failed");
+                break;
+            case H5R_OBJECT2:
+                H5TOOLS_DEBUG("ref_type is H5R_OBJECT2");
+                if (H5Rget_obj_type3(&ref_buf[i], H5P_DEFAULT, &obj_type) >= 0) {
+                    switch (obj_type) {
+                        case H5O_TYPE_GROUP:
+                            break;
+
+                        case H5O_TYPE_DATASET:
+                            if((new_obj_id = H5Ropen_object(&ref_buf[i], H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
+                                datactx.indent_level++;
+                                h5tools_dump_data(stream, info, &datactx, new_obj_id, TRUE);
+                                //h5tools_dump_dset(stream, info, &datactx, new_obj_id);
+                                datactx.indent_level--;
+                                if(H5Oclose(new_obj_id) < 0)
+                                    H5TOOLS_INFO("H5Oclose H5R_OBJECT2 failed");
+                            }
+                            else
+                                H5TOOLS_INFO("H5Ropen_object H5R_OBJECT2 failed");
+                            break;
+
+                        case H5O_TYPE_NAMED_DATATYPE:
+                            break;
+
+                        case H5O_TYPE_MAP:
+                        case H5O_TYPE_UNKNOWN:
+                        case H5O_TYPE_NTYPES:
+                        default:
+                            break;
+                    } /* end switch */
+                }
+                else
+                    H5TOOLS_INFO("H5Rget_obj_type3 H5R_OBJECT2 failed");
+                break;
+            case H5R_DATASET_REGION2:
+                H5TOOLS_DEBUG("ref_type is H5R_DATASET_REGION2");
+
+                if (info->line_ncols > 0)
+                    ncols = info->line_ncols;
+
+                /* if (new_obj_id < 0) - could mean that no reference was written do not throw failure */
+                if((new_obj_id = H5Ropen_object(&ref_buf[i], H5P_DEFAULT, H5P_DEFAULT)) < 0)
+                    H5TOOLS_INFO("H5Ropen_object H5R_DATASET_REGION2 failed");
+                else {
+                    if((new_obj_sid = H5Ropen_region(&ref_buf[i], H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
+                        if (h5tools_is_zero(&ref_buf[i], H5Tget_size(H5T_STD_REF))) {
+                            H5TOOLS_DEBUG("NULL H5R_DATASET_REGION2");
+
+                            h5tools_str_reset(&buffer);
+                            h5tools_str_append(&buffer, " {");
+                            h5tools_render_element(stream, info, &datactx, &buffer, &curr_pos, (size_t)ncols, (hsize_t)0, (hsize_t)0);
+
+                            datactx.need_prefix = TRUE;
+                            datactx.indent_level++;
+                            h5tools_str_reset(&buffer);
+                            h5tools_str_append(&buffer, "NULL");
+                            h5tools_render_element(stream, info, &datactx, &buffer, &curr_pos, (size_t)ncols, (hsize_t)0, (hsize_t)0);
+                            datactx.indent_level--;
+                            datactx.need_prefix = TRUE;
+
+                            h5tools_str_reset(&buffer);
+                            h5tools_str_append(&buffer, "}");
+                            h5tools_render_element(stream, info, &datactx, &buffer, &curr_pos, (size_t)ncols, (hsize_t)0, (hsize_t)0);
+                        }
+                        else {
+                            H5S_sel_type region_type;
+
+                            region_type = H5Sget_select_type(new_obj_sid);
+                            if(region_type == H5S_SEL_POINTS) {
+                                /* Print point information */
+                                H5TOOLS_DEBUG("H5S_SEL_POINTS H5R_DATASET_REGION2");
+                                h5tools_dump_region_data_points(new_obj_sid, new_obj_id, stream, info, &datactx,
+                                                    &buffer, &curr_pos, ncols, (hsize_t)i, elmt_counter);
+                            }
+                            else if(region_type == H5S_SEL_HYPERSLABS) {
+                                /* Print block information */
+                                H5TOOLS_DEBUG("H5S_SEL_HYPERSLABS H5R_DATASET_REGION2");
+                                h5tools_dump_region_data_blocks(new_obj_sid, new_obj_id, stream, info, &datactx,
+                                                    &buffer, &curr_pos, ncols, (hsize_t)i, elmt_counter);
+                            }
+                            else
+                                H5TOOLS_INFO("invalid region type");
+                        } /* end else to if (h5tools_is_zero(... */
+                        if(H5Sclose(new_obj_sid) < 0)
+                            H5TOOLS_INFO("H5Sclose H5R_DATASET_REGION2 failed");
+                    }
+                    else
+                        H5TOOLS_INFO("H5Ropen_region H5R_DATASET_REGION2 failed");
+                    if(H5Dclose(new_obj_id) < 0)
+                        H5TOOLS_INFO("H5Dclose H5R_DATASET_REGION2 failed");
+                }
+                break;
+            case H5R_ATTR:
+                H5TOOLS_DEBUG("ref_type is H5R_ATTR");
+                if((new_obj_id = H5Ropen_attr(&ref_buf[i], H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
+                    h5tools_dump_region_attribute(new_obj_id, stream, info, &datactx, &buffer, &curr_pos, (size_t)ncols, (hsize_t)0, (hsize_t)0);
+                    if(H5Aclose(new_obj_id) < 0)
+                        H5TOOLS_INFO("H5Aclose H5R_ATTR failed");
+                }
+                else {
+                    H5TOOLS_DEBUG("NULL H5R_ATTR");
+
+                    h5tools_str_reset(&buffer);
+                    h5tools_str_append(&buffer, " {");
+                    h5tools_render_element(stream, info, &datactx, &buffer, &curr_pos, (size_t)ncols, (hsize_t)0, (hsize_t)0);
+
+                    datactx.need_prefix = TRUE;
+                    datactx.indent_level++;
+                    h5tools_str_reset(&buffer);
+                    h5tools_str_append(&buffer, "NULL");
+                    h5tools_render_element(stream, info, &datactx, &buffer, &curr_pos, (size_t)ncols, (hsize_t)0, (hsize_t)0);
+                    datactx.indent_level--;
+                    datactx.need_prefix = TRUE;
+
+                    h5tools_str_reset(&buffer);
+                    h5tools_str_append(&buffer, "}");
+                    h5tools_render_element(stream, info, &datactx, &buffer, &curr_pos, (size_t)ncols, (hsize_t)0, (hsize_t)0);
+
+                    H5TOOLS_INFO("H5Ropen_attr H5R_ATTR failed");
+                }
+                break;
+            case H5R_BADTYPE:
+            case H5R_MAXTYPE:
+            default:
+                break;
+        } /* end switch */
+
+        if(H5Rdestroy(&ref_buf[i]) < 0)
+            H5TOOLS_INFO("H5Rdestroy failed");
+
+        H5TOOLS_DEBUG("finished reference loop:%d",i);
+    } /* end for(i = 0; i < ndims; i++, ctx->cur_elmt++, elmt_counter++) */
+
+    h5tools_str_close(&buffer);
+
+    H5TOOLS_ENDDEBUG("");
+}
+
 /*-------------------------------------------------------------------------
  * Function:    dump_data
  *
@@ -3999,13 +4200,9 @@ h5tools_dump_data(FILE *stream, const h5tool_format_t *info, h5tools_context_t *
 {
     H5S_class_t        space_type;
     int                ndims;
-    size_t             i;
     hid_t              space = H5I_INVALID_HID;
     hid_t              f_type = H5I_INVALID_HID;
-    hid_t              new_obj_id = H5I_INVALID_HID;
-    hid_t              new_obj_sid = H5I_INVALID_HID;
     hsize_t            total_size[H5S_MAX_RANK];
-    hsize_t            elmt_counter = 0;  /*counts the # elements printed. */
     int                status = -1;
     h5tools_context_t  datactx;            /* print context  */
     h5tools_str_t      buffer;          /* string into which to render   */
@@ -4070,13 +4267,9 @@ h5tools_dump_data(FILE *stream, const h5tool_format_t *info, h5tools_context_t *
         H5TOOLS_DEBUG("ndims=%d - datactx.ndims=%d", ndims, datactx.ndims);
 
         /* Assume entire data space to be printed */
-        if (datactx.ndims > 0)
-            for (i = 0; i < (size_t)datactx.ndims; i++)
-                datactx.p_min_idx[i] = 0;
-
         H5Sget_simple_extent_dims(space, total_size, NULL);
-        if (datactx.ndims > 0)
-            init_acc_pos(&datactx, total_size);
+        init_acc_pos(datactx.ndims, total_size, datactx.acc, datactx.pos, datactx.p_min_idx);
+
         datactx.need_prefix = TRUE;
 
         if (NULL != (ref_buf = (H5R_ref_t *)HDcalloc(MAX(sizeof(unsigned), sizeof(H5R_ref_t)), (size_t)ndims))) {
@@ -4094,197 +4287,7 @@ h5tools_dump_data(FILE *stream, const h5tool_format_t *info, h5tools_context_t *
                     H5TOOLS_GOTO_DONE_NO_RET();
                 }
             }
-            for (i = 0; i < (size_t)ndims; i++, datactx.cur_elmt++, elmt_counter++) {
-                H5O_type_t obj_type = -1;   /* Object type */
-                H5R_type_t ref_type;   /* Reference type */
-
-                H5TOOLS_DEBUG("reference loop:%d with curr_pos=%ld", i, curr_pos);
-
-                datactx.need_prefix = TRUE;
-                h5tools_str_reset(&buffer);
-                H5TOOLS_DEBUG("reference loop - h5tools_str_sprint with H5T_STD_REF:%d", i);
-                h5tools_str_sprint(&buffer, &outputformat, obj_id, H5T_STD_REF, &ref_buf[i], &datactx);
-                h5tools_render_element(stream, &outputformat, &datactx, &buffer, &curr_pos, (size_t)ncols, (hsize_t)i, (hsize_t)ndims);
-
-                ref_type = H5Rget_type((const H5R_ref_t *)&ref_buf[i]);
-                switch (ref_type) {
-                    case H5R_OBJECT1:
-                        H5TOOLS_DEBUG("ref_type is H5R_OBJECT1");
-                        if (H5Rget_obj_type3(&ref_buf[i], H5P_DEFAULT, &obj_type) >= 0) {
-                            switch (obj_type) {
-                                case H5O_TYPE_DATASET:
-                                    if((new_obj_id = H5Ropen_object(&ref_buf[i], H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
-                                        datactx.indent_level++;
-                                        h5tools_dump_data(stream, &outputformat, &datactx, new_obj_id, TRUE);
-                                        datactx.indent_level--;
-                                        if(H5Dclose(new_obj_id) < 0)
-                                            H5TOOLS_INFO("H5Dclose H5R_OBJECT1:H5O_TYPE_DATASET failed");
-                                    }
-                                    else
-                                        H5TOOLS_INFO("H5Ropen_object H5R_OBJECT1:H5O_TYPE_DATASET failed");
-                                    break;
-
-                                case H5O_TYPE_GROUP:
-                                case H5O_TYPE_NAMED_DATATYPE:
-                                case H5O_TYPE_MAP:
-                                case H5O_TYPE_UNKNOWN:
-                                case H5O_TYPE_NTYPES:
-                                default:
-                                    break;
-                            } /* end switch */
-                        }
-                        else
-                            H5TOOLS_INFO("H5Rget_obj_type3 H5R_OBJECT1 failed");
-                        break;
-                    case H5R_DATASET_REGION1:
-                        H5TOOLS_DEBUG("ref_type is H5R_DATASET_REGION1");
-                        if((new_obj_id = H5Ropen_object(&ref_buf[i], H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
-                            datactx.indent_level++;
-                            h5tools_dump_data(stream, &outputformat, &datactx, new_obj_id, TRUE);
-                            datactx.indent_level--;
-                            if(H5Dclose(new_obj_id) < 0)
-                                H5TOOLS_INFO("H5Dclose H5R_DATASET_REGION1 failed");
-                        }
-                        else
-                            H5TOOLS_INFO("H5Ropen_object H5R_DATASET_REGION1 failed");
-                        break;
-                    case H5R_OBJECT2:
-                        H5TOOLS_DEBUG("ref_type is H5R_OBJECT2");
-                        if (H5Rget_obj_type3(&ref_buf[i], H5P_DEFAULT, &obj_type) >= 0) {
-                            switch (obj_type) {
-                                case H5O_TYPE_GROUP:
-                                    break;
-
-                                case H5O_TYPE_DATASET:
-                                    if((new_obj_id = H5Ropen_object(&ref_buf[i], H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
-                                        datactx.indent_level++;
-                                        h5tools_dump_data(stream, &outputformat, &datactx, new_obj_id, TRUE);
-                                        datactx.indent_level--;
-                                        if(H5Oclose(new_obj_id) < 0)
-                                            H5TOOLS_INFO("H5Oclose H5R_OBJECT2 failed");
-                                    }
-                                    else
-                                        H5TOOLS_INFO("H5Ropen_object H5R_OBJECT2 failed");
-                                    break;
-
-                                case H5O_TYPE_NAMED_DATATYPE:
-                                    break;
-
-                                case H5O_TYPE_MAP:
-                                case H5O_TYPE_UNKNOWN:
-                                case H5O_TYPE_NTYPES:
-                                default:
-                                    break;
-                            } /* end switch */
-                        }
-                        else
-                            H5TOOLS_INFO("H5Rget_obj_type3 H5R_OBJECT2 failed");
-                        break;
-                    case H5R_DATASET_REGION2:
-                        H5TOOLS_DEBUG("ref_type is H5R_DATASET_REGION2");
-
-                        if (outputformat.line_ncols > 0)
-                            ncols = outputformat.line_ncols;
-
-                        /* if (new_obj_id < 0) - could mean that no reference was written do not throw failure */
-                        if((new_obj_id = H5Ropen_object(&ref_buf[i], H5P_DEFAULT, H5P_DEFAULT)) < 0)
-                            H5TOOLS_INFO("H5Ropen_object H5R_DATASET_REGION2 failed");
-                        else {
-                            if((new_obj_sid = H5Ropen_region(&ref_buf[i], H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
-                                if (h5tools_is_zero(&ref_buf[i], H5Tget_size(H5T_STD_REF))) {
-                                    H5TOOLS_DEBUG("NULL H5R_DATASET_REGION2");
-
-                                    h5tools_str_reset(&buffer);
-                                    h5tools_str_append(&buffer, " {");
-                                    h5tools_render_element(stream, &outputformat, &datactx, &buffer, &curr_pos, (size_t)ncols, (hsize_t)0, (hsize_t)0);
-
-                                    datactx.indent_level++;
-                                    datactx.need_prefix = TRUE;
-
-                                    h5tools_str_reset(&buffer);
-                                    h5tools_str_append(&buffer, "NULL");
-                                    h5tools_render_element(stream, &outputformat, &datactx, &buffer, &curr_pos, (size_t)ncols, (hsize_t)0, (hsize_t)0);
-
-                                    datactx.indent_level--;
-                                    datactx.need_prefix = TRUE;
-
-                                    h5tools_str_reset(&buffer);
-                                    h5tools_str_append(&buffer, "}");
-                                    h5tools_render_element(stream, &outputformat, &datactx, &buffer, &curr_pos, (size_t)ncols, (hsize_t)0, (hsize_t)0);
-                                }
-                                else {
-                                    H5S_sel_type region_type;
-
-                                    region_type = H5Sget_select_type(new_obj_sid);
-                                    if(region_type == H5S_SEL_POINTS) {
-                                        /* Print point information */
-                                        H5TOOLS_DEBUG("H5S_SEL_POINTS H5R_DATASET_REGION2");
-                                        h5tools_dump_region_data_points(new_obj_sid, new_obj_id, stream, &outputformat, &datactx,
-                                                            &buffer, &curr_pos, ncols, i, elmt_counter);
-                                    }
-                                    else if(region_type == H5S_SEL_HYPERSLABS) {
-                                        /* Print block information */
-                                        H5TOOLS_DEBUG("H5S_SEL_HYPERSLABS H5R_DATASET_REGION2");
-                                        h5tools_dump_region_data_blocks(new_obj_sid, new_obj_id, stream, &outputformat, &datactx,
-                                                            &buffer, &curr_pos, ncols, i, elmt_counter);
-                                    }
-                                    else
-                                        H5TOOLS_INFO("invalid region type");
-                                } /* end else to if (h5tools_is_zero(... */
-                                if(H5Sclose(new_obj_sid) < 0)
-                                    H5TOOLS_INFO("H5Sclose H5R_DATASET_REGION2 failed");
-                            }
-                            else
-                                H5TOOLS_INFO("H5Ropen_region H5R_DATASET_REGION2 failed");
-                            if(H5Dclose(new_obj_id) < 0)
-                                H5TOOLS_INFO("H5Dclose H5R_DATASET_REGION2 failed");
-                        }
-                        break;
-                    case H5R_ATTR:
-                        H5TOOLS_DEBUG("ref_type is H5R_ATTR");
-                        if((new_obj_id = H5Ropen_attr(&ref_buf[i], H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
-                            h5tools_dump_region_attribute(new_obj_id, stream, &outputformat, &datactx,
-                                                &buffer, &curr_pos, ncols, i, elmt_counter);
-                            if(H5Aclose(new_obj_id) < 0)
-                                H5TOOLS_INFO("H5Aclose H5R_ATTR failed");
-                        }
-                        else {
-                            H5TOOLS_DEBUG("NULL H5R_ATTR");
-
-                            h5tools_str_reset(&buffer);
-                            h5tools_str_append(&buffer, " {");
-                            h5tools_render_element(stream, &outputformat, &datactx, &buffer, &curr_pos, (size_t)ncols, (hsize_t)0, (hsize_t)0);
-
-                            datactx.indent_level++;
-                            datactx.need_prefix = TRUE;
-
-                            datactx.indent_level++;
-                            h5tools_str_reset(&buffer);
-                            h5tools_str_append(&buffer, "NULL");
-                            h5tools_render_element(stream, &outputformat, &datactx, &buffer, &curr_pos, (size_t)ncols, (hsize_t)0, (hsize_t)0);
-                            datactx.indent_level--;
-
-                            datactx.indent_level--;
-                            datactx.need_prefix = TRUE;
-
-                            h5tools_str_reset(&buffer);
-                            h5tools_str_append(&buffer, "}");
-                            h5tools_render_element(stream, &outputformat, &datactx, &buffer, &curr_pos, (size_t)ncols, (hsize_t)0, (hsize_t)0);
-
-                            H5TOOLS_INFO("H5Ropen_attr H5R_ATTR failed");
-                        }
-                        break;
-                    case H5R_BADTYPE:
-                    case H5R_MAXTYPE:
-                    default:
-                        break;
-                } /* end switch */
-
-                if(H5Rdestroy(&ref_buf[i]) < 0)
-                    H5TOOLS_INFO("H5Rdestroy failed");
-
-                H5TOOLS_DEBUG("finished reference loop:%d",i);
-            } /* end for(i = 0; i < ndims; i++, datactx->cur_elmt++, elmt_counter++) */
+            h5tools_dump_reference(stream, &outputformat, &datactx, obj_id, ref_buf, ndims);
             HDfree(ref_buf);
         }
         ctx->indent_level--;
diff --git a/tools/lib/h5tools_dump.h b/tools/lib/h5tools_dump.h
index 2cd0bc1745b..add2e46872b 100644
--- a/tools/lib/h5tools_dump.h
+++ b/tools/lib/h5tools_dump.h
@@ -36,63 +36,53 @@ H5TOOLS_DLLVAR table_t *h5dump_type_table;  /*type table reference for datatype
 /* Definitions of useful routines */
 H5TOOLS_DLL void    h5tools_dump_init(void);
 
-H5TOOLS_DLL int     h5tools_dump_dset(FILE *stream, const h5tool_format_t *info,
-                            h5tools_context_t *ctx/*in,out*/, hid_t dset);
-H5TOOLS_DLL int     h5tools_dump_mem(FILE *stream, const h5tool_format_t *info,
-                            h5tools_context_t *ctx/*in,out*/, hid_t obj_id);
-H5TOOLS_DLL int     h5tools_dump_simple_data(FILE *stream, const h5tool_format_t *info, hid_t container,
-                            h5tools_context_t *ctx/*in,out*/, unsigned flags,
-                            hsize_t nelmts, hid_t type, void *_mem);
-H5TOOLS_DLL void    h5tools_dump_datatype(FILE *stream, const h5tool_format_t *info,
-                            h5tools_context_t *ctx/*in,out*/, hid_t type);
-H5TOOLS_DLL void    h5tools_dump_dataspace(FILE *stream, const h5tool_format_t *info,
-                            h5tools_context_t *ctx/*in,out*/, hid_t space);
-H5TOOLS_DLL void    h5tools_dump_attribute(FILE *stream, const h5tool_format_t *info,
-                            h5tools_context_t *ctx/*in,out*/, const char *attr_name, hid_t attr_id);
-H5TOOLS_DLL void    h5tools_dump_oid(FILE *stream, const h5tool_format_t *info,
-                            h5tools_context_t *ctx/*in,out*/, hid_t oid);
-H5TOOLS_DLL void    h5tools_dump_dcpl(FILE *stream, const h5tool_format_t *info,
-                            h5tools_context_t *ctx/*in,out*/, hid_t dcpl, hid_t type_id, hid_t obj_id);
-H5TOOLS_DLL void    h5tools_dump_comment(FILE *stream, const h5tool_format_t *info,
-                            h5tools_context_t *ctx/*in,out*/, hid_t obj_id);
-H5TOOLS_DLL void    h5tools_dump_data(FILE *stream, const h5tool_format_t *info,
-                            h5tools_context_t *ctx, hid_t obj_id, int obj_data);
+H5TOOLS_DLL int     h5tools_dump_dset(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx/*in,out*/,
+                            hid_t dset);
+H5TOOLS_DLL int     h5tools_dump_mem(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx/*in,out*/,
+                            hid_t obj_id);
+H5TOOLS_DLL int     h5tools_dump_simple_data(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx/*in,out*/,
+                            hid_t container, unsigned flags, hsize_t nelmts, hid_t type, void *_mem);
+H5TOOLS_DLL void    h5tools_dump_datatype(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx/*in,out*/,
+                            hid_t type);
+H5TOOLS_DLL void    h5tools_dump_dataspace(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx/*in,out*/,
+                            hid_t space);
+H5TOOLS_DLL void    h5tools_dump_attribute(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx/*in,out*/,
+                            const char *attr_name, hid_t attr_id);
+H5TOOLS_DLL void    h5tools_dump_oid(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx/*in,out*/,
+                            hid_t oid);
+H5TOOLS_DLL void    h5tools_dump_dcpl(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx/*in,out*/,
+                            hid_t dcpl, hid_t type_id, hid_t obj_id);
+H5TOOLS_DLL void    h5tools_dump_comment(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx/*in,out*/,
+                            hid_t obj_id);
+H5TOOLS_DLL void    h5tools_dump_data(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx,
+                            hid_t obj_id, int obj_data);
+H5TOOLS_DLL void    h5tools_dump_reference(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx,
+                            hid_t container, H5R_ref_t *ref_buf, int ndims);
 H5TOOLS_DLL hbool_t h5tools_dump_region_attribute(hid_t region_id,
-                            FILE *stream, const h5tool_format_t *info,
-                            h5tools_context_t *ctx/*in,out*/,
-                            h5tools_str_t *buffer/*string into which to render */,
-                            hsize_t *curr_pos/*total data element position*/,
-                            size_t ncols, hsize_t region_elmt_counter/*element counter*/,
-                            hsize_t elmt_counter);
+                            FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx/*in,out*/,
+                            h5tools_str_t *buffer, hsize_t *curr_pos, size_t ncols, hsize_t region_elmt_counter, hsize_t elmt_counter);
 
 H5TOOLS_DLL hbool_t h5tools_dump_region_data_points(hid_t region_space, hid_t region_id,
-                            FILE *stream, const h5tool_format_t *info,
-                            h5tools_context_t *ctx/*in,out*/,
-                            h5tools_str_t *buffer/*string into which to render */,
-                            hsize_t *curr_pos/*total data element position*/,
-                            size_t ncols, hsize_t region_elmt_counter/*element counter*/,
-                            hsize_t elmt_counter);
+                            FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx/*in,out*/,
+                            h5tools_str_t *buffer, hsize_t *curr_pos, size_t ncols, hsize_t region_elmt_counter, hsize_t elmt_counter);
 
 H5TOOLS_DLL hbool_t h5tools_dump_region_data_blocks(hid_t region_space, hid_t region_id,
-                            FILE *stream, const h5tool_format_t *info,
-                            h5tools_context_t *ctx/*in,out*/,
-                            h5tools_str_t *buffer/*string into which to render */,
-                            hsize_t *curr_pos/*total data element position*/,
-                            size_t ncols, hsize_t region_elmt_counter/*element counter*/,
-                            hsize_t elmt_counter);
+                            FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx/*in,out*/,
+                            h5tools_str_t *buffer, hsize_t *curr_pos, size_t ncols, hsize_t region_elmt_counter, hsize_t elmt_counter);
 
-H5TOOLS_DLL int     h5tools_print_datatype(FILE *stream, h5tools_str_t *buffer/*in,out*/,
-                            const h5tool_format_t *info, h5tools_context_t *ctx/*in,out*/,
+H5TOOLS_DLL int     h5tools_print_datatype(FILE *stream,
+                            h5tools_str_t *buffer/*in,out*/, const h5tool_format_t *info, h5tools_context_t *ctx/*in,out*/,
                             hid_t type, int object_search);
 H5TOOLS_DLL int     h5tools_print_dataspace(h5tools_str_t *buffer/*in,out*/,
                             hid_t space);
-H5TOOLS_DLL int     h5tools_print_enum(FILE *stream, h5tools_str_t *buffer/*in,out*/,
-                            const h5tool_format_t *info, h5tools_context_t *ctx/*in,out*/,
+H5TOOLS_DLL int     h5tools_print_enum(FILE *stream,
+                            h5tools_str_t *buffer/*in,out*/, const h5tool_format_t *info, h5tools_context_t *ctx/*in,out*/,
                             hid_t type);
-H5TOOLS_DLL void    h5tools_print_fill_value(h5tools_str_t *buffer/*in,out*/,
-                            const h5tool_format_t *info, h5tools_context_t *ctx/*in,out*/,
+H5TOOLS_DLL void    h5tools_print_fill_value(
+                            h5tools_str_t *buffer/*in,out*/, const h5tool_format_t *info, h5tools_context_t *ctx/*in,out*/,
                             hid_t dcpl, hid_t type_id, hid_t obj_id);
 H5TOOLS_DLL void    h5tools_print_packed_bits(h5tools_str_t *buffer/*in,out*/, hid_t type);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/tools/lib/h5tools_str.c b/tools/lib/h5tools_str.c
index 5c777a9a208..d612fbd7b31 100644
--- a/tools/lib/h5tools_str.c
+++ b/tools/lib/h5tools_str.c
@@ -278,16 +278,12 @@ h5tools_str_fmt(h5tools_str_t *str/*in,out*/, size_t start, const char *fmt)
  * Purpose: Renders the line prefix value into string STR.
  *
  * Return:  Success:    Pointer to the prefix.
- *
  *          Failure:    NULL
- *
- * Programmer:  Robb Matzke
- *              Thursday, July 23, 1998
  *-------------------------------------------------------------------------
  */
 char *
-h5tools_str_prefix(h5tools_str_t *str/*in,out*/, const h5tool_format_t *info,
-    hsize_t elmtno, unsigned ndims, h5tools_context_t *ctx)
+h5tools_str_prefix(h5tools_str_t *str/*in,out*/, const h5tool_format_t *info, hsize_t elmtno,
+        h5tools_context_t *ctx)
 {
     size_t    i = 0;
     hsize_t   curr_pos = elmtno;
@@ -297,28 +293,16 @@ h5tools_str_prefix(h5tools_str_t *str/*in,out*/, const h5tool_format_t *info,
     H5TOOLS_DEBUG("elmtno=%ld, ctx->ndims=%d", elmtno, ctx->ndims);
     h5tools_str_reset(str);
 
-    H5TOOLS_DEBUG("ndims=%d", ndims);
-    if(ndims > 0) {
-        /*
-         * Calculate the number of elements represented by a unit change in a
-         * certain index position.
-         */
-        for(i = 0; i < (size_t) ndims; i++) {
-            H5TOOLS_DEBUG("curr_pos=%ld - ctx->acc[%d]=%ld", curr_pos, i, ctx->acc[i]);
-            ctx->pos[i] = curr_pos / ctx->acc[i];
-            curr_pos -= ctx->acc[i] * ctx->pos[i];
-            H5TOOLS_DEBUG("curr_pos=%ld - ctx->pos[%d]=%ld - ctx->acc[%d]=%ld", curr_pos, i, ctx->pos[i], i, ctx->acc[i]);
-        }
+    curr_pos = calc_acc_pos(ctx->ndims, elmtno, ctx->acc, ctx->pos);
+    if(ctx->ndims > 0) {
         HDassert(curr_pos == 0);
 
         /* Print the index values */
-        for(i = 0; i < (size_t) ndims; i++) {
+        for(i = 0; i < (size_t) ctx->ndims; i++) {
             if (i)
                 h5tools_str_append(str, "%s", OPT(info->idx_sep, ","));
 
-            h5tools_str_append(str, OPT(info->idx_n_fmt, HSIZE_T_FORMAT),
-                    (hsize_t) ctx->pos[i]);
-
+            h5tools_str_append(str, OPT(info->idx_n_fmt, HSIZE_T_FORMAT), (hsize_t) ctx->pos[i]);
         }
     }
     else        /* Scalar */
@@ -338,52 +322,38 @@ h5tools_str_prefix(h5tools_str_t *str/*in,out*/, const h5tool_format_t *info,
  *
  * Return:  Success:    Pointer to the prefix.
  *          Failure:    NULL
- *
- * In/Out:
- *      h5tools_context_t *ctx
- *      h5tools_str_t     *str
  *-------------------------------------------------------------------------
  */
 char *
-h5tools_str_region_prefix(h5tools_str_t *str, const h5tool_format_t *info,
-        hsize_t elmtno, hsize_t *ptdata, unsigned ndims, hsize_t max_idx[],
-        h5tools_context_t *ctx)
+h5tools_str_region_prefix(h5tools_str_t *str/*in,out*/, const h5tool_format_t *info, hsize_t elmtno,
+        hsize_t *ptdata, h5tools_context_t *ctx)
 {
     size_t    i = 0;
     hsize_t   curr_pos = elmtno;
-    hsize_t   p_prod[H5S_MAX_RANK];
 
-    h5tools_str_reset(str);
+    H5TOOLS_START_DEBUG("");
 
-    if(ndims > 0) {
-        /*
-         * Calculate the number of elements represented by a unit change in a
-         * certain index position.
-         */
-        for(i = ndims - 1, p_prod[ndims - 1] = 1; i > 0; --i)
-            p_prod[i - 1] = (max_idx[i]) * p_prod[i];
+    H5TOOLS_DEBUG("elmtno=%ld, ctx->ndims=%d", elmtno, ctx->ndims);
+    h5tools_str_reset(str);
 
-        for(i = 0; i < (size_t) ndims; i++) {
-            if(curr_pos > 0) {
-                ctx->pos[i] = curr_pos / p_prod[i];
-                curr_pos -= p_prod[i] * ctx->pos[i];
-            }
-            else
-                ctx->pos[i] = 0;
-            ctx->pos[i] += (unsigned long) ptdata[ctx->sm_pos+i];
-        }
+    curr_pos = calc_acc_pos(ctx->ndims, elmtno, ctx->acc, ctx->pos);
+    if(ctx->ndims > 0) {
+        HDassert(curr_pos == 0);
 
         /* Print the index values */
-        for(i = 0; i < (size_t) ndims; i++) {
-            if(i)
+        for(i = 0; i < (size_t) ctx->ndims; i++) {
+            ctx->pos[i] += (unsigned long) ptdata[ctx->sm_pos+i];
+            if (i)
                 h5tools_str_append(str, "%s", OPT(info->idx_sep, ","));
 
             h5tools_str_append(str, OPT(info->idx_n_fmt, HSIZE_T_FORMAT), (hsize_t) ctx->pos[i]);
-
         }
-    } /* if (ndims > 0) */
+    }
     else        /* Scalar */
-        h5tools_str_append(str, OPT(info->idx_n_fmt, HSIZE_T_FORMAT), (hsize_t) 0);
+        h5tools_str_append(str, OPT(info->idx_n_fmt, HSIZE_T_FORMAT), (hsize_t)0);
+    H5TOOLS_DEBUG("str=%s", str->s);
+
+    H5TOOLS_ENDDEBUG("");
 
     /* Add prefix and suffix to the index */
     return h5tools_str_fmt(str, (size_t)0, OPT(info->idx_fmt, "%s: "));
diff --git a/tools/lib/h5tools_str.h b/tools/lib/h5tools_str.h
index 02bfe400e4b..074e86d7329 100644
--- a/tools/lib/h5tools_str.h
+++ b/tools/lib/h5tools_str.h
@@ -31,13 +31,12 @@ H5TOOLS_DLL char    *h5tools_str_reset(h5tools_str_t *str);
 H5TOOLS_DLL char    *h5tools_str_trunc(h5tools_str_t *str, size_t size);
 H5TOOLS_DLL char    *h5tools_str_fmt(h5tools_str_t *str, size_t start, const char *fmt);
 H5TOOLS_DLL char    *h5tools_str_prefix(h5tools_str_t *str, const h5tool_format_t *info,
-                        hsize_t elmtno, unsigned ndims, h5tools_context_t *ctx);
+                        hsize_t elmtno, h5tools_context_t *ctx);
 /*
  * new functions needed to display region reference data
  */
 H5TOOLS_DLL char    *h5tools_str_region_prefix(h5tools_str_t *str, const h5tool_format_t *info,
-                                   hsize_t elmtno, hsize_t *ptdata, unsigned ndims,
-                                   hsize_t max_idx[], h5tools_context_t *ctx);
+                                   hsize_t elmtno, hsize_t *ptdata, h5tools_context_t *ctx);
 H5TOOLS_DLL void     h5tools_str_dump_space_slabs(h5tools_str_t *, hid_t, const h5tool_format_t *, h5tools_context_t *ctx);
 H5TOOLS_DLL void     h5tools_str_dump_space_blocks(h5tools_str_t *, hid_t, const h5tool_format_t *);
 H5TOOLS_DLL void     h5tools_str_dump_space_points(h5tools_str_t *, hid_t, const h5tool_format_t *);
diff --git a/tools/lib/io_timer.c b/tools/lib/io_timer.c
index 472824bf131..5c0c31d91c9 100644
--- a/tools/lib/io_timer.c
+++ b/tools/lib/io_timer.c
@@ -23,7 +23,6 @@
  */
 
 #include "H5private.h"
-#include "hdf5.h"
 
 #include "io_timer.h"
 
diff --git a/tools/src/h5copy/h5copy.c b/tools/src/h5copy/h5copy.c
index 8805d08dd11..5b19ae7993f 100644
--- a/tools/src/h5copy/h5copy.c
+++ b/tools/src/h5copy/h5copy.c
@@ -207,10 +207,6 @@ static int parse_flag(const char* s_flag, unsigned *flag)
 int
 main (int argc, const char *argv[])
 {
-    H5E_auto2_t         func;
-    H5E_auto2_t         tools_func;
-    void               *edata;
-    void               *tools_edata;
     hid_t        fid_src = H5I_INVALID_HID;
     hid_t        fid_dst = H5I_INVALID_HID;
     unsigned     flag = 0;
@@ -226,17 +222,9 @@ main (int argc, const char *argv[])
     h5tools_setprogname(PROGRAMNAME);
     h5tools_setstatus(EXIT_SUCCESS);
 
-    /* Disable error reporting */
-    H5Eget_auto2(H5E_DEFAULT, &func, &edata);
-    H5Eset_auto2(H5E_DEFAULT, NULL, NULL);
-
     /* Initialize h5tools lib */
     h5tools_init();
 
-    /* Disable tools error reporting */
-    H5Eget_auto2(H5tools_ERR_STACK_g, &tools_func, &tools_edata);
-    H5Eset_auto2(H5tools_ERR_STACK_g, NULL, NULL);
-
     /* init linkinfo struct */
     HDmemset(&linkinfo, 0, sizeof(h5tool_link_info_t));
 
@@ -330,10 +318,8 @@ main (int argc, const char *argv[])
         leave(EXIT_FAILURE);
     }
 
-    if (enable_error_stack > 0) {
-        H5Eset_auto2(H5E_DEFAULT, func, edata);
-        H5Eset_auto2(H5tools_ERR_STACK_g, tools_func, tools_edata);
-    }
+    /* enable error reporting if command line option */
+    h5tools_error_report();
 
    /*-------------------------------------------------------------------------
     * open output file
diff --git a/tools/src/h5diff/h5diff_common.c b/tools/src/h5diff/h5diff_common.c
index e0e6f8c7b54..a02ad5a7812 100644
--- a/tools/src/h5diff/h5diff_common.c
+++ b/tools/src/h5diff/h5diff_common.c
@@ -25,7 +25,7 @@ static int check_d_input(const char*);
  * Command-line options: The user can specify short or long-named
  * parameters.
  */
-static const char *s_opts = "hVrv:qn:d:p:NcelxE:S";
+static const char *s_opts = "hVrv:qn:d:p:NcelxE:A:S";
 static struct long_options l_opts[] = {
     { "help",               no_arg, 'h' },
     { "version",            no_arg, 'V' },
@@ -41,6 +41,7 @@ static struct long_options l_opts[] = {
     { "follow-symlinks",    no_arg, 'l' },
     { "no-dangling-links",  no_arg, 'x' },
     { "exclude-path",       require_arg, 'E' },
+    { "exclude-attribute",  require_arg, 'A' },
     { "enable-error-stack", no_arg, 'S' },
     { "vol-value-1",        require_arg, '1' },
     { "vol-name-1",         require_arg, '2' },
@@ -55,7 +56,6 @@ static struct long_options l_opts[] = {
  * Function: check_options
  *
  * Purpose: parse command line input
- *
  *-------------------------------------------------------------------------
  */
 static void check_options(diff_opt_t* opts)
@@ -67,7 +67,7 @@ static void check_options(diff_opt_t* opts)
     /* check between -d , -p, --use-system-epsilon.
      * These options are mutually exclusive.
      */
-    if ((opts->d + opts->p + opts->use_system_epsilon) > 1) {
+    if ((opts->delta_bool + opts->percent_bool + opts->use_system_epsilon) > 1) {
         HDprintf("%s error: -d, -p and --use-system-epsilon options are mutually-exclusive;\n", PROGRAMNAME);
         HDprintf("use no more than one.\n");
         HDprintf("Try '-h' or '--help' option for more information or see the %s entry in the 'HDF5 Reference Manual'.\n", PROGRAMNAME);
@@ -75,27 +75,138 @@ static void check_options(diff_opt_t* opts)
     }
 }
 
+/*-------------------------------------------------------------------------
+ * Function:    parse_hsize_list
+ *
+ * Purpose:     Parse a list of comma or space separated integers and return
+ *              them in a list. The string being passed into this function
+ *              should be at the start of the list you want to parse. You are
+ *              responsible for freeing the array returned from here.
+ *
+ *              Lists in the so-called "terse" syntax are separated by
+ *              semicolons (;). The lists themselves can be separated by
+ *              either commas (,) or white spaces.
+ *
+ * Return:      <none>
+ *-------------------------------------------------------------------------
+ */
+static void
+parse_hsize_list(const char *h_list, subset_d *d)
+{
+    hsize_t        *p_list;
+    const char     *ptr;
+    unsigned int    size_count = 0;
+    unsigned int    i = 0;
+    unsigned int    last_digit = 0;
+
+    if (!h_list || !*h_list || *h_list == ';')
+        return;
+
+    H5TOOLS_START_DEBUG(" - h_list:%s", h_list);
+    /* count how many integers do we have */
+    for (ptr = h_list; ptr && *ptr && *ptr != ';' && *ptr != ']'; ptr++)
+        if (HDisdigit(*ptr)) {
+            if (!last_digit)
+                /* the last read character wasn't a digit */
+                size_count++;
+
+            last_digit = 1;
+        }
+        else
+            last_digit = 0;
+
+    if (size_count == 0) {
+        /* there aren't any integers to read */
+        H5TOOLS_ENDDEBUG("No integers to read");
+        return;
+    }
+    H5TOOLS_DEBUG("Number integers to read=%ld", size_count);
+
+    /* allocate an array for the integers in the list */
+    if((p_list = (hsize_t *)HDcalloc(size_count, sizeof(hsize_t))) == NULL)
+        H5TOOLS_INFO("Unable to allocate space for subset data");
+
+    for (ptr = h_list; i < size_count && ptr && *ptr && *ptr != ';' && *ptr != ']'; ptr++)
+        if(HDisdigit(*ptr)) {
+            /* we should have an integer now */
+            p_list[i++] = (hsize_t)HDstrtoull(ptr, NULL, 0);
+
+            while (HDisdigit(*ptr))
+                /* scroll to end of integer */
+                ptr++;
+        }
+    d->data = p_list;
+    d->len = size_count;
+    H5TOOLS_ENDDEBUG("");
+}
+
+/*-------------------------------------------------------------------------
+ * Function:    parse_subset_params
+ *
+ * Purpose:     Parse the so-called "terse" syntax for specifying subsetting parameters.
+ *
+ * Return:      Success:    struct subset_t object
+ *              Failure:    NULL
+ *-------------------------------------------------------------------------
+ */
+static struct subset_t *
+parse_subset_params(const char *dset)
+{
+    struct subset_t *s = NULL;
+    char   *brace;
+
+    H5TOOLS_START_DEBUG(" - dset:%s", dset);
+    if ((brace = HDstrrchr(dset, '[')) != NULL) {
+        *brace++ = '\0';
+
+        s = (struct subset_t *)HDcalloc(1, sizeof(struct subset_t));
+        parse_hsize_list(brace, &s->start);
+
+        while (*brace && *brace != ';')
+            brace++;
+
+        if (*brace)
+            brace++;
+
+        parse_hsize_list(brace, &s->stride);
+
+        while (*brace && *brace != ';')
+            brace++;
+
+        if (*brace)
+            brace++;
+
+        parse_hsize_list(brace, &s->count);
+
+        while (*brace && *brace != ';')
+            brace++;
+
+        if (*brace)
+            brace++;
+
+        parse_hsize_list(brace, &s->block);
+    }
+    H5TOOLS_ENDDEBUG("");
+
+    return s;
+}
+
 
 /*-------------------------------------------------------------------------
  * Function: parse_command_line
  *
  * Purpose: parse command line input
- *
  *-------------------------------------------------------------------------
  */
 
-void parse_command_line(int argc,
-                        const char* argv[],
-                        const char** fname1,
-                        const char** fname2,
-                        const char** objname1,
-                        const char** objname2,
-                        diff_opt_t* opts)
+void parse_command_line(int argc, const char* argv[], const char** fname1, const char** fname2, const char** objname1, const char** objname2, diff_opt_t* opts)
 {
     int i;
     int opt;
     struct exclude_path_list *exclude_head, *exclude_prev, *exclude_node;
+    struct exclude_path_list *exclude_attr_head, *exclude_attr_prev, *exclude_attr_node;
 
+    H5TOOLS_START_DEBUG("");
     /* process the command-line */
     HDmemset(opts, 0, sizeof (diff_opt_t));
 
@@ -106,15 +217,18 @@ void parse_command_line(int argc,
     opts->do_nans = 1;
 
     /* not Listing objects that are not comparable */
-    opts->m_list_not_cmp = 0;
+    opts->mode_list_not_cmp = 0;
 
     /* initially no not-comparable. */
     /**this is bad in mixing option with results**/
-    opts->not_cmp=0;
+    opts->not_cmp = 0;
 
     /* init for exclude-path option */
     exclude_head = NULL;
 
+    /* init for exclude-attribute option */
+    exclude_attr_head = NULL;
+
     /* parse command line options */
     while ((opt = get_option(argc, argv, s_opts, l_opts)) != EOF) {
         switch ((char)opt) {
@@ -134,7 +248,7 @@ void parse_command_line(int argc,
             break;
 
         case 'v':
-            opts->m_verbose = 1;
+            opts->mode_verbose = 1;
             /* This for loop is for handling style like
              * -v, -v1, --verbose, --verbose=1.
              */
@@ -144,11 +258,11 @@ void parse_command_line(int argc,
                  */
                 if (!strcmp (argv[i], "-v")) {  /* no arg */
                     opt_ind--;
-                    opts->m_verbose_level = 0;
+                    opts->mode_verbose_level = 0;
                     break;
                 }
                 else if (!strncmp (argv[i], "-v", (size_t)2)) {
-                    opts->m_verbose_level = atoi(&argv[i][2]);
+                    opts->mode_verbose_level = atoi(&argv[i][2]);
                     break;
                 }
 
@@ -156,11 +270,11 @@ void parse_command_line(int argc,
                  * long opt
                  */
                 if (!strcmp (argv[i], "--verbose")) {  /* no arg */
-                    opts->m_verbose_level = 0;
+                    opts->mode_verbose_level = 0;
                     break;
                 }
-                else if ( !strncmp (argv[i], "--verbose", (size_t)9) && argv[i][9]=='=') {
-                    opts->m_verbose_level = atoi(&argv[i][10]);
+                else if (!strncmp (argv[i], "--verbose", (size_t)9) && argv[i][9]=='=') {
+                    opts->mode_verbose_level = atoi(&argv[i][10]);
                     break;
                 }
             }
@@ -168,11 +282,11 @@ void parse_command_line(int argc,
 
         case 'q':
             /* use quiet mode; supress the message "0 differences found" */
-            opts->m_quiet = 1;
+            opts->mode_quiet = 1;
             break;
 
         case 'r':
-            opts->m_report = 1;
+            opts->mode_report = 1;
             break;
 
         case 'l':
@@ -214,23 +328,47 @@ void parse_command_line(int argc,
             }
             break;
 
+        case 'A':
+            opts->exclude_attr_path = 1;
+
+            /* create linked list of excluding objects */
+            if( (exclude_attr_node = (struct exclude_path_list*) HDmalloc(sizeof(struct exclude_path_list))) == NULL) {
+                HDprintf("Error: lack of memory!\n");
+                h5diff_exit(EXIT_FAILURE);
+            }
+
+            /* init */
+            exclude_attr_node->obj_path = opt_arg;
+            exclude_attr_node->obj_type = H5TRAV_TYPE_UNKNOWN;
+            exclude_attr_prev = exclude_attr_head;
+
+            if (NULL == exclude_attr_head) {
+                exclude_attr_head = exclude_attr_node;
+                exclude_attr_head->next = NULL;
+            }
+            else {
+                while(NULL != exclude_attr_prev->next)
+                    exclude_attr_prev = exclude_attr_prev->next;
+
+                exclude_attr_node->next = NULL;
+                exclude_attr_prev->next = exclude_attr_node;
+            }
+            break;
+
         case 'd':
-            opts->d = 1;
+            opts->delta_bool = 1;
 
-            if (check_d_input(opt_arg) == - 1) {
+            if (check_d_input(opt_arg) == -1) {
                 HDprintf("<-d %s> is not a valid option\n", opt_arg);
                 usage();
                 h5diff_exit(EXIT_FAILURE);
             }
             opts->delta = HDatof(opt_arg);
-
-            /* -d 0 is the same as default */
-            if (H5_DBL_ABS_EQUAL(opts->delta, (double)0.0F))
-                opts->d=0;
+            /* do not check against default, the DBL_EPSILON is being replaced by user */
             break;
 
         case 'p':
-            opts->p = 1;
+            opts->percent_bool = 1;
             if (check_p_input(opt_arg) == -1) {
                 HDprintf("<-p %s> is not a valid option\n", opt_arg);
                 usage();
@@ -240,12 +378,12 @@ void parse_command_line(int argc,
 
             /* -p 0 is the same as default */
             if (H5_DBL_ABS_EQUAL(opts->percent, (double)0.0F))
-                opts->p = 0;
+                opts->percent_bool = 0;
             break;
 
         case 'n':
-            opts->n = 1;
-            if ( check_n_input(opt_arg) == -1) {
+            opts->count_bool = 1;
+            if (check_n_input(opt_arg) == -1) {
                 HDprintf("<-n %s> is not a valid option\n", opt_arg);
                 usage();
                 h5diff_exit(EXIT_FAILURE);
@@ -258,7 +396,7 @@ void parse_command_line(int argc,
             break;
 
         case 'c':
-            opts->m_list_not_cmp = 1;
+            opts->mode_list_not_cmp = 1;
             break;
 
         case 'e':
@@ -266,35 +404,35 @@ void parse_command_line(int argc,
             break;
 
         case '1':
-            opts->vol_info_1.type = VOL_BY_VALUE;
-            opts->vol_info_1.u.value = (H5VL_class_value_t)HDatoi(opt_arg);
-            opts->custom_vol_1 = TRUE;
+            opts->vol_info[0].type = VOL_BY_VALUE;
+            opts->vol_info[0].u.value = (H5VL_class_value_t)HDatoi(opt_arg);
+            opts->custom_vol[0] = TRUE;
             break;
 
         case '2':
-            opts->vol_info_1.type = VOL_BY_NAME;
-            opts->vol_info_1.u.name = opt_arg;
-            opts->custom_vol_1 = TRUE;
+            opts->vol_info[0].type = VOL_BY_NAME;
+            opts->vol_info[0].u.name = opt_arg;
+            opts->custom_vol[0] = TRUE;
             break;
 
         case '3':
-            opts->vol_info_1.info_string = opt_arg;
+            opts->vol_info[0].info_string = opt_arg;
             break;
 
         case '4':
-            opts->vol_info_2.type = VOL_BY_VALUE;
-            opts->vol_info_2.u.value = (H5VL_class_value_t)HDatoi(opt_arg);
-            opts->custom_vol_2 = TRUE;
+            opts->vol_info[1].type = VOL_BY_VALUE;
+            opts->vol_info[1].u.value = (H5VL_class_value_t)HDatoi(opt_arg);
+            opts->custom_vol[1] = TRUE;
             break;
 
         case '5':
-            opts->vol_info_2.type = VOL_BY_NAME;
-            opts->vol_info_2.u.name = opt_arg;
-            opts->custom_vol_2 = TRUE;
+            opts->vol_info[1].type = VOL_BY_NAME;
+            opts->vol_info[1].u.name = opt_arg;
+            opts->custom_vol[1] = TRUE;
             break;
 
         case '6':
-            opts->vol_info_2.info_string = opt_arg;
+            opts->vol_info[1].info_string = opt_arg;
             break;
         }
     }
@@ -306,30 +444,46 @@ void parse_command_line(int argc,
     if (opts->exclude_path)
         opts->exclude = exclude_head;
 
+    /* if exclude-attribute option is used, keep the exclude attr list */
+    if (opts->exclude_attr_path)
+        opts->exclude_attr = exclude_attr_head;
+
     /* check for file names to be processed */
-    if (argc <= opt_ind || argv[ opt_ind + 1 ] == NULL) {
+    if (argc <= opt_ind || argv[opt_ind + 1] == NULL) {
         error_msg("missing file names\n");
         usage();
         h5diff_exit(EXIT_FAILURE);
     }
 
-    *fname1 = argv[ opt_ind ];
-    *fname2 = argv[ opt_ind + 1 ];
-    *objname1 = argv[ opt_ind + 2 ];
+    *fname1 = argv[opt_ind];
+    *fname2 = argv[opt_ind + 1];
+    *objname1 = argv[opt_ind + 2];
+    H5TOOLS_DEBUG("file1 = %s", *fname1);
+    H5TOOLS_DEBUG("file2 = %s", *fname2);
 
     if (*objname1 == NULL) {
         *objname2 = NULL;
+        H5TOOLS_ENDDEBUG("No obj names");
         return;
     }
+    H5TOOLS_DEBUG("objname1 = %s", *objname1);
 
-    if (argv[ opt_ind + 3 ] != NULL) {
-        *objname2 = argv[ opt_ind + 3 ];
+    if (argv[opt_ind + 3] != NULL) {
+        *objname2 = argv[opt_ind + 3];
     }
     else {
         *objname2 = *objname1;
     }
+    H5TOOLS_DEBUG("objname2 = %s", *objname2);
 
+    /*
+     * TRILABS-227 is complete except for an issue with printing indices
+     * the following calls will enable subsetting
+    opts->sset[0] = parse_subset_params(*objname1);
 
+    opts->sset[1] = parse_subset_params(*objname2);
+    */
+    H5TOOLS_ENDDEBUG("");
 }
 
 
@@ -337,26 +491,25 @@ void parse_command_line(int argc,
  * Function: print_info
  *
  * Purpose: print several information messages after h5diff call
- *
  *-------------------------------------------------------------------------
  */
 void print_info(diff_opt_t* opts)
 {
-    if (opts->m_quiet || opts->err_stat)
+    if (opts->mode_quiet || opts->err_stat)
         return;
 
     if (opts->cmn_objs == 0) {
         HDprintf("No common objects found. Files are not comparable.\n");
-        if (!opts->m_verbose)
+        if (!opts->mode_verbose)
             HDprintf("Use -v for a list of objects.\n");
     }
 
     if (opts->not_cmp == 1) {
-        if (opts->m_list_not_cmp == 0) {
+        if (opts->mode_list_not_cmp == 0) {
             HDprintf("--------------------------------\n");
             HDprintf("Some objects are not comparable\n");
             HDprintf("--------------------------------\n");
-            if (opts->m_verbose)
+            if (opts->mode_verbose)
                 HDprintf("Use -c for a list of objects without details of differences.\n");
             else
                 HDprintf("Use -c for a list of objects.\n");
@@ -370,19 +523,10 @@ void print_info(diff_opt_t* opts)
  * Purpose: check for valid input
  *
  * Return: 1 for ok, -1 for fail
- *
- * Programmer: Pedro Vicente, pvn@ncsa.uiuc.edu
- *
- * Date: May 9, 2003
- *
- * Comments:
- *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 H5_ATTR_PURE static int
-check_n_input( const char *str )
+check_n_input(const char *str)
 {
     unsigned i;
     char c;
@@ -406,24 +550,17 @@ check_n_input( const char *str )
  * Purpose: check for a valid p option input
  *
  * Return: 1 for ok, -1 for fail
- *
- * Date: May 9, 2003
- *
- * Comments:
- *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 static int
-check_p_input( const char *str )
+check_p_input(const char *str)
 {
     double x;
 
     /*
-    the atof return value on a hexadecimal input is different
-    on some systems; we do a character check for this
-    */
+     * the atof return value on a hexadecimal input is different
+     * on some systems; we do a character check for this
+     */
     if (HDstrlen(str) > 2 && str[0] == '0' && str[1] == 'x')
         return -1;
 
@@ -440,24 +577,17 @@ check_p_input( const char *str )
  * Purpose: check for a valid d option input
  *
  * Return: 1 for ok, -1 for fail
- *
- * Date: November 11, 2007
- *
- * Comments:
- *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 static int
-check_d_input( const char *str )
+check_d_input(const char *str)
 {
     double x;
 
     /*
-    the atof return value on a hexadecimal input is different
-    on some systems; we do a character check for this
-    */
+     * the atof return value on a hexadecimal input is different
+     * on some systems; we do a character check for this
+     */
     if (HDstrlen(str) > 2 && str[0] == '0' && str[1] == 'x')
         return -1;
 
@@ -474,7 +604,6 @@ check_d_input( const char *str )
  * Purpose: print a usage message
  *
  * Return: void
- *
  *-------------------------------------------------------------------------
  */
 
@@ -499,10 +628,9 @@ void usage(void)
  PRINTVALSTREAM(rawoutstream, "         Verbose mode with level. Print differences and list of objects.\n");
  PRINTVALSTREAM(rawoutstream, "         Level of detail depends on value of N:\n");
  PRINTVALSTREAM(rawoutstream, "          0 : Identical to '-v' or '--verbose'.\n");
- PRINTVALSTREAM(rawoutstream, "          1 : All level 0 information plus one-line attribute\n");
- PRINTVALSTREAM(rawoutstream, "              status summary.\n");
- PRINTVALSTREAM(rawoutstream, "          2 : All level 1 information plus extended attribute\n");
- PRINTVALSTREAM(rawoutstream, "              status report.\n");
+ PRINTVALSTREAM(rawoutstream, "          1 : All level 0 information plus one-line attribute status summary.\n");
+ PRINTVALSTREAM(rawoutstream, "          2 : All level 1 information plus extended attribute status report.\n");
+ PRINTVALSTREAM(rawoutstream, "          3 : All level 2 information plus file names.\n");
  PRINTVALSTREAM(rawoutstream, "   -q, --quiet\n");
  PRINTVALSTREAM(rawoutstream, "         Quiet mode. Do not produce output.\n");
  PRINTVALSTREAM(rawoutstream, "   --enable-error-stack\n");
@@ -591,7 +719,14 @@ void usage(void)
  PRINTVALSTREAM(rawoutstream, "         excluded.\n");
  PRINTVALSTREAM(rawoutstream, "         This option can be used repeatedly to exclude multiple paths.\n");
  PRINTVALSTREAM(rawoutstream, "\n");
-
+ PRINTVALSTREAM(rawoutstream, "   --exclude-attribute \"path/to/object/with/attribute\"\n");
+ PRINTVALSTREAM(rawoutstream, "         Exclude attributes on the specified path to an object when comparing files or groups.\n");
+ PRINTVALSTREAM(rawoutstream, "\n");
+ PRINTVALSTREAM(rawoutstream, "         If there are multiple paths to an object, only the specified path(s)\n");
+ PRINTVALSTREAM(rawoutstream, "         will be excluded; the comparison will include any path not explicitly\n");
+ PRINTVALSTREAM(rawoutstream, "         excluded.\n");
+ PRINTVALSTREAM(rawoutstream, "         This option can be used repeatedly to exclude multiple paths.\n");
+ PRINTVALSTREAM(rawoutstream, "\n");
  PRINTVALSTREAM(rawoutstream, " Modes of output:\n");
  PRINTVALSTREAM(rawoutstream, "  Default mode: print the number of differences found and where they occured\n");
  PRINTVALSTREAM(rawoutstream, "  -r Report mode: print the above plus the differences\n");
@@ -622,7 +757,22 @@ void usage(void)
  PRINTVALSTREAM(rawoutstream, "      (The option --follow-symlinks overrides the default behavior when\n");
  PRINTVALSTREAM(rawoutstream, "       symbolic links are compared.).\n");
  PRINTVALSTREAM(rawoutstream, "\n");
-
+ /*
+  * TRILABS-227 is complete except for an issue with printing indices
+  * the following will be needed for subsetting
+ PRINTVALSTREAM(rawoutstream, " Subsetting options:\n");
+ PRINTVALSTREAM(rawoutstream, "  Subsetting is available by using the fcompact form of subsetting, as follows:\n");
+ PRINTVALSTREAM(rawoutstream, "    obj1 /foo/mydataset[START;STRIDE;COUNT;BLOCK]\n");
+ PRINTVALSTREAM(rawoutstream, "  It is not required to use all parameters, but until the last parameter value used,\n");
+ PRINTVALSTREAM(rawoutstream, "  all of the semicolons (;) are required, even when a parameter value is not specified. Example:\n");
+ PRINTVALSTREAM(rawoutstream, "    obj1 /foo/mydataset[START;;COUNT;BLOCK]\n");
+ PRINTVALSTREAM(rawoutstream, "    obj1 /foo/mydataset[START]\n");
+ PRINTVALSTREAM(rawoutstream, "  The STRIDE, COUNT, and BLOCK parameters are optional and will default to 1 in\n");
+ PRINTVALSTREAM(rawoutstream, "  each dimension. START is optional and will default to 0 in each dimension.\n");
+ PRINTVALSTREAM(rawoutstream, "  Each of START, STRIDE, COUNT, and BLOCK must be a comma-separated list of integers with\n");
+ PRINTVALSTREAM(rawoutstream, "  one integer for each dimension of the dataset.\n");
+ PRINTVALSTREAM(rawoutstream, "\n");
+*/
  PRINTVALSTREAM(rawoutstream, " Exit code:\n");
  PRINTVALSTREAM(rawoutstream, "  0 if no differences, 1 if differences found, 2 if error\n");
  PRINTVALSTREAM(rawoutstream, "\n");
diff --git a/tools/src/h5diff/h5diff_main.c b/tools/src/h5diff/h5diff_main.c
index c5a0cbf213e..33d6570dfbe 100644
--- a/tools/src/h5diff/h5diff_main.c
+++ b/tools/src/h5diff/h5diff_main.c
@@ -69,10 +69,7 @@
 int main(int argc, const char *argv[])
 {
     int        ret;
-    H5E_auto2_t         func;
-    H5E_auto2_t         tools_func;
-    void               *edata;
-    void               *tools_edata;
+    int        i;
     const char *fname1 = NULL;
     const char *fname2 = NULL;
     const char *objname1  = NULL;
@@ -83,27 +80,17 @@ int main(int argc, const char *argv[])
     h5tools_setprogname(PROGRAMNAME);
     h5tools_setstatus(EXIT_SUCCESS);
 
-    /* Disable error reporting */
-    H5Eget_auto2(H5E_DEFAULT, &func, &edata);
-    H5Eset_auto2(H5E_DEFAULT, NULL, NULL);
-
     /* Initialize h5tools lib */
     h5tools_init();
 
-    /* Disable tools error reporting */
-    H5Eget_auto2(H5tools_ERR_STACK_g, &tools_func, &tools_edata);
-    H5Eset_auto2(H5tools_ERR_STACK_g, NULL, NULL);
-
     /*-------------------------------------------------------------------------
     * process the command-line
     *-------------------------------------------------------------------------
     */
     parse_command_line(argc, argv, &fname1, &fname2, &objname1, &objname2, &opts);
 
-    if (enable_error_stack > 0) {
-        H5Eset_auto2(H5E_DEFAULT, func, edata);
-        H5Eset_auto2(H5tools_ERR_STACK_g, tools_func, tools_edata);
-    }
+    /* enable error reporting if command line option */
+    h5tools_error_report();
 
     /*-------------------------------------------------------------------------
     * do the diff
@@ -130,6 +117,23 @@ int main(int argc, const char *argv[])
     if (opts.err_stat)
         ret = 2;
 
+    /* free any buffers */
+    for (i = 0; i < 2; i++) {
+        if (opts.sset[i]) {
+            if(opts.sset[i]->start.data)
+                HDfree(opts.sset[i]->start.data);
+            if(opts.sset[i]->stride.data)
+                HDfree(opts.sset[i]->stride.data);
+            if(opts.sset[i]->count.data)
+                HDfree(opts.sset[i]->count.data);
+            if(opts.sset[i]->block.data)
+                HDfree(opts.sset[i]->block.data);
+
+            HDfree(opts.sset[i]);
+            opts.sset[i]=NULL;
+        }
+    }
+
     h5diff_exit(ret);
 }
 
diff --git a/tools/src/h5dump/h5dump.c b/tools/src/h5dump/h5dump.c
index dfaff17a899..2b21b1c55cd 100644
--- a/tools/src/h5dump/h5dump.c
+++ b/tools/src/h5dump/h5dump.c
@@ -655,12 +655,12 @@ parse_hsize_list(const char *h_list, subset_d *d)
  *-------------------------------------------------------------------------
  */
 static struct subset_t *
-parse_subset_params(char *dset)
+parse_subset_params(const char *dset)
 {
     struct subset_t *s = NULL;
     char   *brace;
 
-    if (!disable_compact_subset && ((brace = HDstrrchr(dset, '[')) != NULL)) {
+    if (!dump_opts.disable_compact_subset && ((brace = HDstrrchr(dset, '[')) != NULL)) {
         *brace++ = '\0';
 
         s = (struct subset_t *)HDcalloc(1, sizeof(struct subset_t));
@@ -891,50 +891,50 @@ parse_command_line(int argc, const char *argv[])
 parse_start:
         switch ((char)opt) {
         case 'R':
-            display_region = TRUE;
+            dump_opts.display_region = TRUE;
             region_output = TRUE;
             break;
         case 'B':
-            display_bb = TRUE;
+            dump_opts.display_bb = TRUE;
             last_was_dset = FALSE;
             break;
         case 'n':
-            display_fi = TRUE;
+            dump_opts.display_fi = TRUE;
             last_was_dset = FALSE;
             if (opt_arg != NULL)
                 h5trav_set_verbose(HDatoi(opt_arg));
             break;
         case 'p':
-            display_dcpl = TRUE;
+            dump_opts.display_dcpl = TRUE;
             break;
         case 'y':
-            display_ai = FALSE;
+            dump_opts.display_ai = FALSE;
             break;
         case 'e':
-            display_escape = TRUE;
+            dump_opts.display_escape = TRUE;
             break;
         case 'H':
-            display_data = FALSE;
-            display_attr_data = FALSE;
+            dump_opts.display_data = FALSE;
+            dump_opts.display_attr_data = FALSE;
             last_was_dset = FALSE;
             break;
         case 'A':
             if (opt_arg != NULL) {
                 if(0 == HDatoi(opt_arg))
-                    include_attrs = FALSE;
+                    dump_opts.include_attrs = FALSE;
             }
             else {
-                display_data = FALSE;
-                display_attr_data = TRUE;
+                dump_opts.display_data = FALSE;
+                dump_opts.display_attr_data = TRUE;
                 last_was_dset = FALSE;
             }
             break;
         case 'i':
-            display_oid = TRUE;
+            dump_opts.display_oid = TRUE;
             last_was_dset = FALSE;
             break;
         case 'r':
-            display_char = TRUE;
+            dump_opts.display_char = TRUE;
             break;
         case 'V':
             print_version(h5tools_getprogname());
@@ -955,7 +955,7 @@ parse_command_line(int argc, const char *argv[])
             }
             break;
         case 'N':
-            display_all = 0;
+            dump_opts.display_all = 0;
 
             for (i = 0; i < argc; i++)
                 if (!hand[i].func) {
@@ -967,7 +967,7 @@ parse_command_line(int argc, const char *argv[])
             last_was_dset = FALSE;
             break;
         case 'a':
-            display_all = 0;
+            dump_opts.display_all = 0;
 
             for (i = 0; i < argc; i++)
                 if (!hand[i].func) {
@@ -979,7 +979,7 @@ parse_command_line(int argc, const char *argv[])
             last_was_dset = FALSE;
             break;
         case 'd':
-            display_all = 0;
+            dump_opts.display_all = 0;
 
             for (i = 0; i < argc; i++)
                 if (!hand[i].func) {
@@ -996,7 +996,7 @@ parse_command_line(int argc, const char *argv[])
             driver_name_g = opt_arg;
             break;
         case 'g':
-            display_all = 0;
+            dump_opts.display_all = 0;
 
             for (i = 0; i < argc; i++)
                 if (!hand[i].func) {
@@ -1008,7 +1008,7 @@ parse_command_line(int argc, const char *argv[])
             last_was_dset = FALSE;
             break;
         case 'l':
-            display_all = 0;
+            dump_opts.display_all = 0;
 
             for (i = 0; i < argc; i++)
                 if (!hand[i].func) {
@@ -1020,7 +1020,7 @@ parse_command_line(int argc, const char *argv[])
             last_was_dset = FALSE;
             break;
         case 't':
-            display_all = 0;
+            dump_opts.display_all = 0;
 
             for (i = 0; i < argc; i++)
                 if (!hand[i].func) {
@@ -1047,13 +1047,13 @@ parse_command_line(int argc, const char *argv[])
                 }
             }
             else {
-                if(display_attr_data && !display_data) {
+                if(dump_opts.display_attr_data && !dump_opts.display_data) {
                     if (h5tools_set_attr_output_file(opt_arg, 0) < 0) {
                         usage(h5tools_getprogname());
                         goto error;
                     }
                 }
-                if(display_data || display_all) {
+                if(dump_opts.display_data || dump_opts.display_all) {
                     if (h5tools_set_data_output_file(opt_arg, 0) < 0) {
                         usage(h5tools_getprogname());
                         goto error;
@@ -1061,7 +1061,7 @@ parse_command_line(int argc, const char *argv[])
                 }
             }
 
-            usingdasho = TRUE;
+            dump_opts.usingdasho = TRUE;
             last_was_dset = FALSE;
             outfname_g = opt_arg;
             break;
@@ -1111,14 +1111,14 @@ parse_command_line(int argc, const char *argv[])
                 usage(h5tools_getprogname());
                 goto error;
             }
-            display_packed_bits = TRUE;
+            dump_opts.display_packed_bits = TRUE;
             break;
         case 'v':
-            display_vds_first = TRUE;
+            dump_opts.display_vds_first = TRUE;
             break;
         case 'G':
-            vds_gap_size = HDatoi(opt_arg);
-            if (vds_gap_size < 0) {
+            dump_opts.vds_gap_size = HDatoi(opt_arg);
+            if (dump_opts.vds_gap_size < 0) {
                 usage(h5tools_getprogname());
                 goto error;
             }
@@ -1255,7 +1255,7 @@ parse_command_line(int argc, const char *argv[])
                 enable_error_stack = 1;
             break;
         case 'C':
-            disable_compact_subset = TRUE;
+            dump_opts.disable_compact_subset = TRUE;
             break;
         case 'h':
             usage(h5tools_getprogname());
@@ -1357,14 +1357,10 @@ main(int argc, const char *argv[])
     hid_t               fid = H5I_INVALID_HID;
     hid_t               gid = H5I_INVALID_HID;
     hid_t               fapl_id = H5P_DEFAULT;
-    H5E_auto2_t         func;
-    H5E_auto2_t         tools_func;
     H5O_info2_t         oi;
     struct handler_t   *hand = NULL;
     int                 i;
     unsigned            u;
-    void               *edata;
-    void               *tools_edata;
     char               *fname = NULL;
 
     h5tools_setprogname(PROGRAMNAME);
@@ -1373,17 +1369,9 @@ main(int argc, const char *argv[])
     dump_function_table = &ddl_function_table;
     dump_indent = 0;
 
-    /* Disable error reporting */
-    H5Eget_auto2(H5E_DEFAULT, &func, &edata);
-    H5Eset_auto2(H5E_DEFAULT, NULL, NULL);
-
     /* Initialize h5tools lib */
     h5tools_init();
 
-    /* Disable tools error reporting */
-    H5Eget_auto2(H5tools_ERR_STACK_g, &tools_func, &tools_edata);
-    H5Eset_auto2(H5tools_ERR_STACK_g, NULL, NULL);
-
     if((hand = parse_command_line(argc, argv))==NULL) {
         goto done;
     }
@@ -1394,34 +1382,29 @@ main(int argc, const char *argv[])
         goto done;
     }
 
-    if (enable_error_stack > 0) {
-        H5Eset_auto2(H5E_DEFAULT, func, edata);
-        H5Eset_auto2(H5tools_ERR_STACK_g, tools_func, tools_edata);
-    }
-
     /* Check for conflicting options */
     if (doxml_g) {
-        if (!display_all) {
+        if (!dump_opts.display_all) {
             error_msg("option \"%s\" not available for XML\n", "to display selected objects");
             h5tools_setstatus(EXIT_FAILURE);
             goto done;
         }
-        else if (display_bb) {
+        else if (dump_opts.display_bb) {
             error_msg("option \"%s\" not available for XML\n", "--boot-block");
             h5tools_setstatus(EXIT_FAILURE);
             goto done;
         }
-        else if (display_oid == 1) {
+        else if (dump_opts.display_oid == 1) {
             error_msg("option \"%s\" not available for XML\n", "--object-ids");
             h5tools_setstatus(EXIT_FAILURE);
             goto done;
         }
-        else if (display_char == TRUE) {
+        else if (dump_opts.display_char == TRUE) {
             error_msg("option \"%s\" not available for XML\n", "--string");
             h5tools_setstatus(EXIT_FAILURE);
             goto done;
         }
-        else if (usingdasho) {
+        else if (dump_opts.usingdasho) {
             error_msg("option \"%s\" not available for XML\n", "--output");
             h5tools_setstatus(EXIT_FAILURE);
             goto done;
@@ -1439,6 +1422,10 @@ main(int argc, const char *argv[])
         h5tools_setstatus(EXIT_FAILURE);
         goto done;
     }
+
+    /* enable error reporting if command line option */
+    h5tools_error_report();
+
     /* Initialize indexing options */
     h5trav_set_index(sort_by, sort_order);
 
@@ -1584,7 +1571,7 @@ main(int argc, const char *argv[])
         }
 
         if (!doxml_g) {
-            if (display_fi) {
+            if (dump_opts.display_fi) {
                 PRINTVALSTREAM(rawoutstream, "\n");
                 dump_fcontents(fid);
                 end_obj(h5tools_dump_header_format->fileend,h5tools_dump_header_format->fileblockend);
@@ -1592,11 +1579,11 @@ main(int argc, const char *argv[])
                 goto done;
             }
 
-            if (display_bb)
+            if (dump_opts.display_bb)
                 dump_fcpl(fid);
         }
 
-        if(display_all) {
+        if(dump_opts.display_all) {
             if((gid = H5Gopen2(fid, "/", H5P_DEFAULT)) < 0) {
                 error_msg("unable to open root group\n");
                 h5tools_setstatus(EXIT_FAILURE);
@@ -1661,9 +1648,6 @@ main(int argc, const char *argv[])
 
     /* To Do:  clean up XML table */
 
-    H5Eset_auto2(H5E_DEFAULT, func, edata);
-    H5Eset_auto2(H5tools_ERR_STACK_g, tools_func, tools_edata);
-
     leave(h5tools_getstatus());
 
 done:
@@ -1693,9 +1677,6 @@ main(int argc, const char *argv[])
 
     /* To Do:  clean up XML table */
 
-    H5Eset_auto2(H5E_DEFAULT, func, edata);
-    H5Eset_auto2(H5tools_ERR_STACK_g, tools_func, tools_edata);
-
     leave(h5tools_getstatus());
 } /* main */
 
diff --git a/tools/src/h5dump/h5dump.h b/tools/src/h5dump/h5dump.h
index ca1fef698bd..548af09b57a 100644
--- a/tools/src/h5dump/h5dump.h
+++ b/tools/src/h5dump/h5dump.h
@@ -52,8 +52,8 @@ typedef struct h5dump_table_list_t {
 
 h5dump_table_list_t  table_list = {0, 0, NULL};
 table_t             *group_table = NULL, *dset_table = NULL, *type_table = NULL;
-unsigned            dump_indent = 0;              /*how far in to indent the line         */
 
+unsigned     dump_indent = 0;    /* how far in to indent the line */
 int          unamedtype = 0;     /* shared datatype with no name */
 hbool_t      hit_elink = FALSE;  /* whether we have traversed an external link */
 size_t       prefix_len = 1024;
@@ -61,23 +61,26 @@ char         *prefix = NULL;
 const char   *fp_format = NULL;
 
 /* things to display or which are set via command line parameters */
-int          display_all       = TRUE;
-int          display_oid       = FALSE;
-int          display_data      = TRUE;
-int          display_attr_data = TRUE;
-int          display_char      = FALSE; /*print 1-byte numbers as ASCII */
-int          usingdasho        = FALSE;
-int          display_bb        = FALSE; /*superblock */
-int          display_dcpl      = FALSE; /*dcpl */
-int          display_fi        = FALSE; /*file index */
-int          display_ai        = TRUE;  /*array index */
-int          display_escape    = FALSE; /*escape non printable characters */
-int          display_region    = FALSE; /*print region reference data */
-int          disable_compact_subset= FALSE; /* disable compact form of subset notation */
-int          display_packed_bits = FALSE; /*print 1-8 byte numbers as packed bits*/
-int          include_attrs     = TRUE; /* Display attributes */
-int          display_vds_first = FALSE; /* vds display to all by default*/
-int          vds_gap_size       = 0; /* vds skip missing files default is none */
+typedef struct {
+    int          display_all;
+    int          display_oid;
+    int          display_data;
+    int          display_attr_data;
+    int          display_char;           /* print 1-byte numbers as ASCII */
+    int          usingdasho;
+    int          display_bb;             /* superblock */
+    int          display_dcpl;           /* dcpl */
+    int          display_fi;             /* file index */
+    int          display_ai;             /* array index */
+    int          display_escape;         /* escape non printable characters */
+    int          display_region;         /* print region reference data */
+    int          disable_compact_subset; /* disable compact form of subset notation */
+    int          display_packed_bits;    /* print 1-8 byte numbers as packed bits */
+    int          include_attrs;          /* Display attributes */
+    int          display_vds_first;      /* vds display to all by default */
+    int          vds_gap_size;           /* vds skip missing files default is none */
+} dump_opt_t;
+dump_opt_t dump_opts = {TRUE, FALSE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, 0};
 
 #define PACKED_BITS_MAX         8  /* Maximum number of packed-bits to display */
 #define PACKED_BITS_SIZE_MAX    (8*sizeof(long long))  /* Maximum bits size of integer types of packed-bits */
diff --git a/tools/src/h5dump/h5dump_ddl.c b/tools/src/h5dump/h5dump_ddl.c
index 1df205c1302..b50ce526d24 100644
--- a/tools/src/h5dump/h5dump_ddl.c
+++ b/tools/src/h5dump/h5dump_ddl.c
@@ -103,13 +103,13 @@ dump_attr_cb(hid_t oid, const char *attr_name, const H5A_info_t H5_ATTR_UNUSED *
     HDmemset(&ctx, 0, sizeof(ctx));
     ctx.indent_level = dump_indent / COL;
     ctx.cur_column = dump_indent;
-    ctx.display_index = display_ai;
-    ctx.display_char = display_char;
+    ctx.display_index = dump_opts.display_ai;
+    ctx.display_char = dump_opts.display_char;
 
     attr_id = H5Aopen(oid, attr_name, H5P_DEFAULT);
-    oid_output = display_oid;
-    data_output = display_data;
-    attr_data_output = display_attr_data;
+    oid_output = dump_opts.display_oid;
+    data_output = dump_opts.display_data;
+    attr_data_output = dump_opts.display_attr_data;
 
     string_dataformat = *outputformat;
 
@@ -125,7 +125,7 @@ dump_attr_cb(hid_t oid, const char *attr_name, const H5A_info_t H5_ATTR_UNUSED *
     else
         string_dataformat.line_ncols = h5tools_nCols;
 
-    string_dataformat.do_escape = display_escape;
+    string_dataformat.do_escape = dump_opts.display_escape;
     outputformat = &string_dataformat;
 
     h5dump_type_table = type_table;
@@ -185,7 +185,7 @@ dump_all_cb(hid_t group, const char *name, const H5L_info2_t *linfo, void H5_ATT
     else
         string_dataformat.line_ncols = h5tools_nCols;
 
-    string_dataformat.do_escape = display_escape;
+    string_dataformat.do_escape = dump_opts.display_escape;
     outputformat = &string_dataformat;
 
     /* Build the object's path name */
@@ -242,16 +242,16 @@ dump_all_cb(hid_t group, const char *name, const H5L_info2_t *linfo, void H5_ATT
             break;
 
         case H5O_TYPE_DATASET:
-            if(display_data) {
+            if(dump_opts.display_data) {
                 if ((dapl_id = H5Pcreate(H5P_DATASET_ACCESS)) < 0) {
                     error_msg("error in creating default access property list ID\n");
                 }
-                if (display_vds_first) {
+                if (dump_opts.display_vds_first) {
                     if(H5Pset_virtual_view(dapl_id, H5D_VDS_FIRST_MISSING) < 0)
                         error_msg("error in setting access property list ID, virtual_view\n");
                 }
-                if (vds_gap_size > 0) {
-                    if(H5Pset_virtual_printf_gap(dapl_id, (hsize_t)vds_gap_size) < 0)
+                if (dump_opts.vds_gap_size > 0) {
+                    if(H5Pset_virtual_printf_gap(dapl_id, (hsize_t)dump_opts.vds_gap_size) < 0)
                         error_msg("error in setting access property list ID, virtual_printf_gap\n");
                 }
             }
@@ -565,7 +565,7 @@ attr_iteration(hid_t gid, unsigned attr_crt_order_flags)
 {
     /* attribute iteration: if there is a request to do H5_INDEX_CRT_ORDER and tracking order is set
        in the group for attributes, then, sort by creation order, otherwise by name */
-    if(include_attrs) {
+    if(dump_opts.include_attrs) {
         if((sort_by == H5_INDEX_CRT_ORDER) && (attr_crt_order_flags & H5P_CRT_ORDER_TRACKED)) {
             if(H5Aiterate2(gid, sort_by, sort_order, NULL, dump_attr_cb, NULL) < 0) {
                 error_msg("error getting attribute information\n");
@@ -642,7 +642,7 @@ dump_named_datatype(hid_t tid, const char *name)
     else
         string_dataformat.line_ncols = h5tools_nCols;
 
-    string_dataformat.do_escape = display_escape;
+    string_dataformat.do_escape = dump_opts.display_escape;
     outputformat = &string_dataformat;
 
     if ((tcpl_id = H5Tget_create_plist(tid)) < 0) {
@@ -795,7 +795,7 @@ dump_group(hid_t gid, const char *name)
     else
         string_dataformat.line_ncols = h5tools_nCols;
 
-    string_dataformat.do_escape = display_escape;
+    string_dataformat.do_escape = dump_opts.display_escape;
     outputformat = &string_dataformat;
 
     ctx.need_prefix = TRUE;
@@ -831,7 +831,7 @@ dump_group(hid_t gid, const char *name)
             }
     } /* end if */
 
-    if(display_oid)
+    if(dump_opts.display_oid)
         h5tools_dump_oid(rawoutstream, outputformat, &ctx, gid);
 
     h5tools_dump_comment(rawoutstream, outputformat, &ctx, gid);
@@ -926,7 +926,7 @@ dump_dataset(hid_t did, const char *name, struct subset_t *sset)
     else
         string_dataformat.line_ncols = h5tools_nCols;
 
-    string_dataformat.do_escape = display_escape;
+    string_dataformat.do_escape = dump_opts.display_escape;
     outputformat = &string_dataformat;
 
     if ((dcpl_id = H5Dget_create_plist(did)) < 0) {
@@ -967,11 +967,11 @@ dump_dataset(hid_t did, const char *name, struct subset_t *sset)
     h5tools_dump_dataspace(rawoutstream, outputformat, &ctx, space);
     H5Sclose(space);
 
-    if(display_oid) {
+    if(dump_opts.display_oid) {
         h5tools_dump_oid(rawoutstream, outputformat, &ctx, did);
     }
 
-    if(display_dcpl) {
+    if(dump_opts.display_dcpl) {
         h5dump_type_table = type_table;
         h5tools_dump_dcpl(rawoutstream, outputformat, &ctx, dcpl_id, type, did);
         h5dump_type_table = NULL;
@@ -979,16 +979,16 @@ dump_dataset(hid_t did, const char *name, struct subset_t *sset)
     H5Pclose(dcpl_id);
 
     ctx.sset = sset;
-    ctx.display_index = display_ai;
-    ctx.display_char = display_char;
-    if(display_data) {
+    ctx.display_index = dump_opts.display_ai;
+    ctx.display_char = dump_opts.display_char;
+    if(dump_opts.display_data) {
         unsigned  data_loop = 1;
         unsigned  u;
 
-        if(display_packed_bits)
+        if(dump_opts.display_packed_bits)
             data_loop = packed_bits_num;
         for(u = 0; u < data_loop; u++) {
-            if(display_packed_bits) {
+            if(dump_opts.display_packed_bits) {
                 ctx.need_prefix = TRUE;
                 h5tools_simple_prefix(rawoutstream, outputformat, &ctx, (hsize_t)0, 0);
                 /* Render the element */
@@ -1091,7 +1091,7 @@ dump_data(hid_t obj_id, int obj_data, struct subset_t *sset, int display_index)
     else
         string_dataformat.line_ncols = h5tools_nCols;
 
-    string_dataformat.do_escape = display_escape;
+    string_dataformat.do_escape = dump_opts.display_escape;
     outputformat = &string_dataformat;
 
     HDmemset(&ctx, 0, sizeof(ctx));
@@ -1099,7 +1099,7 @@ dump_data(hid_t obj_id, int obj_data, struct subset_t *sset, int display_index)
     ctx.cur_column = dump_indent;
     ctx.sset = sset;
     ctx.display_index = display_index;
-    ctx.display_char = display_char;
+    ctx.display_char = dump_opts.display_char;
 
     if(obj_data == DATASET_DATA)
         print_dataset = TRUE;
@@ -1527,8 +1527,8 @@ handle_attributes(hid_t fid, const char *attr, void H5_ATTR_UNUSED *data, int H5
     HDmemset(&ctx, 0, sizeof(ctx));
     ctx.indent_level = dump_indent / COL;
     ctx.cur_column = dump_indent;
-    ctx.display_index = display_ai;
-    ctx.display_char = display_char;
+    ctx.display_index = dump_opts.display_ai;
+    ctx.display_char = dump_opts.display_char;
 
     string_dataformat = *outputformat;
 
@@ -1544,7 +1544,7 @@ handle_attributes(hid_t fid, const char *attr, void H5_ATTR_UNUSED *data, int H5
     else
         string_dataformat.line_ncols = h5tools_nCols;
 
-    string_dataformat.do_escape = display_escape;
+    string_dataformat.do_escape = dump_opts.display_escape;
     outputformat = &string_dataformat;
 
     attr_name = h5tools_str_replace(attr + j + 1, "\\/", "/");
@@ -1583,9 +1583,9 @@ handle_attributes(hid_t fid, const char *attr, void H5_ATTR_UNUSED *data, int H5
     } /* end if */
 
     attr_id = H5Aopen(oid, attr_name, H5P_DEFAULT);
-    oid_output = display_oid;
-    data_output = display_data;
-    attr_data_output = display_attr_data;
+    oid_output = dump_opts.display_oid;
+    data_output = dump_opts.display_data;
+    attr_data_output = dump_opts.display_attr_data;
 
     h5dump_type_table = type_table;
     h5tools_dump_attribute(rawoutstream, outputformat, &ctx, attr_name, attr_id);
@@ -1637,16 +1637,16 @@ handle_datasets(hid_t fid, const char *dset, void *data, int pe, const char *dis
     struct subset_t *sset = (struct subset_t *)data;
     const char      *real_name = display_name ? display_name : dset;
 
-    if(display_data) {
+    if(dump_opts.display_data) {
         if ((dapl_id = H5Pcreate(H5P_DATASET_ACCESS)) < 0) {
             error_msg("error in creating default access property list ID\n");
         }
-        if (display_vds_first) {
+        if (dump_opts.display_vds_first) {
             if(H5Pset_virtual_view(dapl_id, H5D_VDS_FIRST_MISSING) < 0)
                 error_msg("error in setting access property list ID, virtual_view\n");
         }
-        if (vds_gap_size > 0) {
-            if(H5Pset_virtual_printf_gap(dapl_id, (hsize_t)vds_gap_size) < 0)
+        if (dump_opts.vds_gap_size > 0) {
+            if(H5Pset_virtual_printf_gap(dapl_id, (hsize_t)dump_opts.vds_gap_size) < 0)
                 error_msg("error in setting access property list ID, virtual_printf_gap\n");
         }
     }
diff --git a/tools/src/h5dump/h5dump_extern.h b/tools/src/h5dump/h5dump_extern.h
index 00d3bd2bc75..c615621cb18 100644
--- a/tools/src/h5dump/h5dump_extern.h
+++ b/tools/src/h5dump/h5dump_extern.h
@@ -50,32 +50,35 @@ typedef struct h5dump_table_list_t {
 
 extern h5dump_table_list_t  table_list;
 extern table_t             *group_table, *dset_table, *type_table;
-extern unsigned                  dump_indent;              /*how far in to indent the line         */
 
-extern int          unamedtype;     /* shared datatype with no name */
-extern hbool_t      hit_elink;  /* whether we have traversed an external link */
+extern unsigned     dump_indent;  /* how far in to indent the line */
+extern int          unamedtype;   /* shared datatype with no name */
+extern hbool_t      hit_elink;    /* whether we have traversed an external link */
 extern size_t       prefix_len;
 extern char         *prefix;
 extern const char   *fp_format;
 
 /* things to display or which are set via command line parameters */
-extern int          display_all;
-extern int          display_oid;
-extern int          display_data;
-extern int          display_attr_data;
-extern int          display_char; /*print 1-byte numbers as ASCII */
-extern int          usingdasho;
-extern int          display_bb; /*superblock */
-extern int          display_dcpl; /*dcpl */
-extern int          display_fi; /*file index */
-extern int          display_ai;  /*array index */
-extern int          display_escape; /*escape non printable characters */
-extern int          display_region; /*print region reference data */
-extern int          disable_compact_subset; /* disable compact form of subset notation */
-extern int          display_packed_bits; /*print 1-8 byte numbers as packed bits*/
-extern int          include_attrs; /* Display attributes */
-extern int          display_vds_first; /* vds display to first missing */
-extern int          vds_gap_size; /* vds skip missing files */
+typedef struct {
+    int          display_all;
+    int          display_oid;
+    int          display_data;
+    int          display_attr_data;
+    int          display_char;           /* print 1-byte numbers as ASCII */
+    int          usingdasho;
+    int          display_bb;             /* superblock */
+    int          display_dcpl;           /* dcpl */
+    int          display_fi;             /* file index */
+    int          display_ai;             /* array index */
+    int          display_escape;         /* escape non printable characters */
+    int          display_region;         /* print region reference data */
+    int          disable_compact_subset; /* disable compact form of subset notation */
+    int          display_packed_bits;    /* print 1-8 byte numbers as packed bits */
+    int          include_attrs;          /* Display attributes */
+    int          display_vds_first;      /* vds display to all by default */
+    int          vds_gap_size;           /* vds skip missing files default is none */
+} dump_opt_t;
+extern dump_opt_t dump_opts;
 
 #define PACKED_BITS_MAX         8  /* Maximum number of packed-bits to display */
 #define PACKED_BITS_SIZE_MAX    8*sizeof(long long)  /* Maximum bits size of integer types of packed-bits */
diff --git a/tools/src/h5dump/h5dump_xml.c b/tools/src/h5dump/h5dump_xml.c
index 95aff48cda9..bb47f77641d 100644
--- a/tools/src/h5dump/h5dump_xml.c
+++ b/tools/src/h5dump/h5dump_xml.c
@@ -162,7 +162,7 @@ xml_dump_all_cb(hid_t group, const char *name, const H5L_info2_t *linfo, void H5
     else
         string_dataformat.line_ncols = h5tools_nCols;
 
-    string_dataformat.do_escape = display_escape;
+    string_dataformat.do_escape = dump_opts.display_escape;
     outputformat = &string_dataformat;
 
     /* Build the object's path name */
@@ -888,7 +888,7 @@ xml_print_datatype(hid_t type, unsigned in_group)
     else
         string_dataformat.line_ncols = h5tools_nCols;
 
-    string_dataformat.do_escape = display_escape;
+    string_dataformat.do_escape = dump_opts.display_escape;
     outputformat = &string_dataformat;
 
     if(!in_group && H5Tcommitted(type) > 0) {
@@ -1538,7 +1538,7 @@ xml_dump_datatype(hid_t type)
     else
         string_dataformat.line_ncols = h5tools_nCols;
 
-    string_dataformat.do_escape = display_escape;
+    string_dataformat.do_escape = dump_opts.display_escape;
     outputformat = &string_dataformat;
 
     ctx.indent_level++;
@@ -1669,7 +1669,7 @@ xml_dump_dataspace(hid_t space)
     else
         string_dataformat.line_ncols = h5tools_nCols;
 
-    string_dataformat.do_escape = display_escape;
+    string_dataformat.do_escape = dump_opts.display_escape;
     outputformat = &string_dataformat;
 
     ctx.indent_level++;
@@ -1992,7 +1992,7 @@ xml_dump_attr(hid_t attr, const char *attr_name, const H5A_info_t H5_ATTR_UNUSED
     else
         string_dataformat.line_ncols = h5tools_nCols;
 
-    string_dataformat.do_escape = display_escape;
+    string_dataformat.do_escape = dump_opts.display_escape;
     outputformat = &string_dataformat;
 
     ctx.need_prefix = TRUE;
@@ -2014,7 +2014,7 @@ xml_dump_attr(hid_t attr, const char *attr_name, const H5A_info_t H5_ATTR_UNUSED
         ctx.indent_level++;
         dump_indent += COL;
 
-        if (display_attr_data && space_type != H5S_NULL) {
+        if (dump_opts.display_attr_data && space_type != H5S_NULL) {
             switch (H5Tget_class(type)) {
             case H5T_INTEGER:
             case H5T_FLOAT:
@@ -2293,7 +2293,7 @@ xml_dump_named_datatype(hid_t type, const char *name)
     else
         string_dataformat.line_ncols = h5tools_nCols;
 
-    string_dataformat.do_escape = display_escape;
+    string_dataformat.do_escape = dump_opts.display_escape;
     outputformat = &string_dataformat;
 
     dtxid = (char *)HDmalloc((size_t)100);
@@ -2506,7 +2506,7 @@ xml_dump_group(hid_t gid, const char *name)
     else
         string_dataformat.line_ncols = h5tools_nCols;
 
-    string_dataformat.do_escape = display_escape;
+    string_dataformat.do_escape = dump_opts.display_escape;
     outputformat = &string_dataformat;
 
     if(HDstrcmp(name, "/") == 0) {
@@ -2889,7 +2889,7 @@ xml_print_refs(hid_t did, int source)
     else
         string_dataformat.line_ncols = h5tools_nCols;
 
-    string_dataformat.do_escape = display_escape;
+    string_dataformat.do_escape = dump_opts.display_escape;
     outputformat = &string_dataformat;
 
     for (i = 0; i < (hsize_t)ssiz; i++) {
@@ -3039,7 +3039,7 @@ xml_print_strs(hid_t did, int source)
     else
         string_dataformat.line_ncols = h5tools_nCols;
 
-    string_dataformat.do_escape = display_escape;
+    string_dataformat.do_escape = dump_opts.display_escape;
     outputformat = &string_dataformat;
 
     for (i = 0; i < (hsize_t)ssiz; i++) {
@@ -3151,7 +3151,7 @@ check_filters(hid_t dcpl)
     else
         string_dataformat.line_ncols = h5tools_nCols;
 
-    string_dataformat.do_escape = display_escape;
+    string_dataformat.do_escape = dump_opts.display_escape;
     outputformat = &string_dataformat;
 
     nfilt = H5Pget_nfilters(dcpl);
@@ -3287,7 +3287,7 @@ xml_dump_fill_value(hid_t dcpl, hid_t type)
     else
         string_dataformat.line_ncols = h5tools_nCols;
 
-    string_dataformat.do_escape = display_escape;
+    string_dataformat.do_escape = dump_opts.display_escape;
     outputformat = &string_dataformat;
 
     ctx.indent_level++;
@@ -3627,7 +3627,7 @@ xml_dump_dataset(hid_t did, const char *name, struct subset_t H5_ATTR_UNUSED *ss
     else
         string_dataformat.line_ncols = h5tools_nCols;
 
-    string_dataformat.do_escape = display_escape;
+    string_dataformat.do_escape = dump_opts.display_escape;
     outputformat = &string_dataformat;
 
     xml_name_to_XID(did, tmp, rstr, 100, 1);
@@ -3916,7 +3916,7 @@ xml_dump_dataset(hid_t did, const char *name, struct subset_t H5_ATTR_UNUSED *ss
     dump_indent -= COL;
     tempi = H5Dget_storage_size(did);
 
-    if (display_data && (tempi > 0)) {
+    if (dump_opts.display_data && (tempi > 0)) {
         switch (H5Tget_class(type)) {
         case H5T_INTEGER:
         case H5T_FLOAT:
@@ -4172,7 +4172,7 @@ xml_print_enum(hid_t type)
     else
         string_dataformat.line_ncols = h5tools_nCols;
 
-    string_dataformat.do_escape = display_escape;
+    string_dataformat.do_escape = dump_opts.display_escape;
     outputformat = &string_dataformat;
 
     nmembs = (unsigned)H5Tget_nmembers(type);
diff --git a/tools/src/h5format_convert/h5format_convert.c b/tools/src/h5format_convert/h5format_convert.c
index 2c4cf41c780..d63f36fd0ae 100644
--- a/tools/src/h5format_convert/h5format_convert.c
+++ b/tools/src/h5format_convert/h5format_convert.c
@@ -64,7 +64,7 @@ static struct long_options l_opts[] = {
         { NULL, 0, '\0' }
 };
 
-
+
 /*-------------------------------------------------------------------------
  * Function: usage
  *
@@ -109,7 +109,7 @@ static void usage(const char *prog)
  * Purpose: parse command line input
  *
  * Return: Success: 0
- *  	   Failure: 1
+ *         Failure: 1
  *
  *-------------------------------------------------------------------------
  */
@@ -127,47 +127,47 @@ parse_command_line(int argc, const char **argv)
 
     /* parse command line options */
     while ((opt = get_option(argc, argv, s_opts, l_opts)) != EOF) {
-    switch((char) opt) {
-        case 'h':
-        usage(h5tools_getprogname());
-        h5tools_setstatus(EXIT_SUCCESS);
-        goto error;
-
-        case 'V':
-        print_version(h5tools_getprogname());
-        h5tools_setstatus(EXIT_SUCCESS);
-        goto error;
-
-        case 'v':
-        verbose_g = TRUE;
-        break;
-
-        case 'd': /* -d dname */
-        if(opt_arg != NULL && *opt_arg)
-            dname_g = HDstrdup(opt_arg);
-        if(dname_g == NULL) {
-            h5tools_setstatus(EXIT_FAILURE);
-            error_msg("No dataset name\n", opt_arg);
-            usage(h5tools_getprogname());
-            goto error;
-        }
-        dset_g = TRUE;
-        break;
-
-        case 'n': /* -n */
-        noop_g = TRUE;
-        break;
-
-        case 'E':
-        enable_error_stack = 1;
-        break;
-
-        default:
-        h5tools_setstatus(EXIT_FAILURE);
-        usage(h5tools_getprogname());
-        goto error;
-        break;
-    } /* switch */
+        switch((char) opt) {
+            case 'h':
+                usage(h5tools_getprogname());
+                h5tools_setstatus(EXIT_SUCCESS);
+                goto error;
+
+            case 'V':
+                print_version(h5tools_getprogname());
+                h5tools_setstatus(EXIT_SUCCESS);
+                goto error;
+
+            case 'v':
+                verbose_g = TRUE;
+                break;
+
+            case 'd': /* -d dname */
+                if(opt_arg != NULL && *opt_arg)
+                    dname_g = HDstrdup(opt_arg);
+                if(dname_g == NULL) {
+                    h5tools_setstatus(EXIT_FAILURE);
+                    error_msg("No dataset name\n", opt_arg);
+                    usage(h5tools_getprogname());
+                    goto error;
+                }
+                dset_g = TRUE;
+                break;
+
+            case 'n': /* -n */
+                noop_g = TRUE;
+                break;
+
+            case 'E':
+                enable_error_stack = 1;
+                break;
+
+            default:
+                h5tools_setstatus(EXIT_FAILURE);
+                usage(h5tools_getprogname());
+                goto error;
+                break;
+        } /* switch */
     } /* while */
 
     if (argc <= opt_ind) {
@@ -185,7 +185,7 @@ parse_command_line(int argc, const char **argv)
     return(-1); ;
 } /* parse_command_line() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function: leave
  *
@@ -207,17 +207,17 @@ leave(int ret)
  * Function: convert()
  *
  * Purpose: To downgrade a dataset's indexing type or layout version:
- *		For chunked:
- *		  Downgrade the chunk indexing type to version 1 B-tree
- *	    	  If type is already version 1 B-tree, no further action
- *		For compact/contiguous:
- *		  Downgrade the layout version from 4 to 3
- *		  If version is already <= 3, no further action
- *		For virtual:
- *		  No further action
+ *        For chunked:
+ *          Downgrade the chunk indexing type to version 1 B-tree
+ *              If type is already version 1 B-tree, no further action
+ *        For compact/contiguous:
+ *          Downgrade the layout version from 4 to 3
+ *          If version is already <= 3, no further action
+ *        For virtual:
+ *          No further action
  *
  * Return: Success: 0
- *  	   Failure: 1
+ *         Failure: 1
  *
  *-------------------------------------------------------------------------
  */
@@ -312,7 +312,7 @@ convert(hid_t fid, const char *dname)
     }
 
     if(verbose_g)
-	HDfprintf(stdout, "Converting the dataset...\n");
+        HDfprintf(stdout, "Converting the dataset...\n");
 
     /* Downgrade the dataset */
     if(H5Dformat_convert(did) < 0) {
@@ -377,7 +377,7 @@ convert_dsets_cb(const char *path, const H5O_info2_t *oi, const char *already_vi
             if(verbose_g)
                 HDfprintf(stdout, "Going to process dataset:%s...\n", path);
             if(convert(fid, path) < 0)
-            goto error;
+                goto error;
         } /* end if */
     } /* end if */
 
@@ -387,62 +387,61 @@ convert_dsets_cb(const char *path, const H5O_info2_t *oi, const char *already_vi
     return -1;
 } /* end convert_dsets_cb() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function: main
  *
  * Purpose: To convert the chunk indexing type of a dataset in a file to
- *	    version 1 B-tree.
+ *        version 1 B-tree.
  *
  * Return: Success: 0
- *  	   Failure: 1
+ *         Failure: 1
  *
  *-------------------------------------------------------------------------
  */
 int
 main(int argc, const char *argv[])
 {
-    H5E_auto2_t func;
-    void *edata;
     hid_t fid = H5I_INVALID_HID;
 
     h5tools_setprogname(PROGRAMNAME);
     h5tools_setstatus(EXIT_SUCCESS);
 
-    /* Disable error reporting */
-    H5Eget_auto2(H5E_DEFAULT, &func, &edata);
-    H5Eset_auto2(H5E_DEFAULT, NULL, NULL);
-
     /* Initialize h5tools lib */
     h5tools_init();
 
     /* Parse command line options */
     if(parse_command_line(argc, argv) < 0)
-	goto done;
+        goto done;
     else if(verbose_g)
-	HDfprintf(stdout, "Process command line options\n");
+        HDfprintf(stdout, "Process command line options\n");
 
     if(noop_g && verbose_g)
-	HDfprintf(stdout, "It is noop...\n");
+        HDfprintf(stdout, "It is noop...\n");
+
+    /* enable error reporting if command line option */
+    h5tools_error_report();
 
     /* Open the HDF5 file */
     if((fid = h5tools_fopen(fname_g, H5F_ACC_RDWR, H5P_DEFAULT, FALSE, NULL, 0)) < 0) {
-	error_msg("unable to open file \"%s\"\n", fname_g);
-	h5tools_setstatus(EXIT_FAILURE);
-	goto done;
-    } else if(verbose_g)
-	HDfprintf(stdout, "Open the file %s\n", fname_g);
+        error_msg("unable to open file \"%s\"\n", fname_g);
+        h5tools_setstatus(EXIT_FAILURE);
+        goto done;
+    }
+    else if(verbose_g)
+        HDfprintf(stdout, "Open the file %s\n", fname_g);
 
     if(dset_g) { /* Convert a specified dataset in the file */
-	if(verbose_g)
-	    HDfprintf(stdout, "Going to process dataset: %s...\n", dname_g);
-	if(convert(fid, dname_g) < 0)
-	    goto done;
-    } else { /* Convert all datasets in the file */
-	if(verbose_g)
-	    HDfprintf(stdout, "Processing all datasets in the file...\n");
-	if(h5trav_visit(fid, "/", TRUE, TRUE, convert_dsets_cb, NULL, &fid, H5O_INFO_BASIC) < 0)
-	    goto done;
+        if(verbose_g)
+            HDfprintf(stdout, "Going to process dataset: %s...\n", dname_g);
+        if(convert(fid, dname_g) < 0)
+            goto done;
+    }
+    else { /* Convert all datasets in the file */
+        if(verbose_g)
+            HDfprintf(stdout, "Processing all datasets in the file...\n");
+        if(h5trav_visit(fid, "/", TRUE, TRUE, convert_dsets_cb, NULL, &fid, H5O_INFO_BASIC) < 0)
+            goto done;
     } /* end else */
 
     if(verbose_g) {
@@ -464,19 +463,20 @@ main(int argc, const char *argv[])
 done:
     /* Close the file */
     if(fid >= 0) {
-	if(H5Fclose(fid) < 0) {
-	    error_msg("unable to close file \"%s\"\n", fname_g);
-	    h5tools_setstatus(EXIT_FAILURE);
-	} else if(verbose_g)
-	    HDfprintf(stdout, "Close the file\n");
+        if(H5Fclose(fid) < 0) {
+            error_msg("unable to close file \"%s\"\n", fname_g);
+            h5tools_setstatus(EXIT_FAILURE);
+        }
+        else if(verbose_g) {
+            HDfprintf(stdout, "Close the file\n");
+        }
     }  /* end if */
 
     if(fname_g)
-	HDfree(fname_g);
+        HDfree(fname_g);
     if(dname_g)
-	HDfree(dname_g);
+        HDfree(dname_g);
 
-    H5Eset_auto2(H5E_DEFAULT, func, edata);
     leave(h5tools_getstatus());
 
 } /* end main() */
diff --git a/tools/src/h5jam/h5jam.c b/tools/src/h5jam/h5jam.c
index 009e527f8b0..8b6111233d5 100644
--- a/tools/src/h5jam/h5jam.c
+++ b/tools/src/h5jam/h5jam.c
@@ -120,13 +120,6 @@ usage (const char *prog)
 static void
 leave(int ret)
 {
-    if (ub_file)
-        HDfree (ub_file);
-    if (input_file)
-        HDfree (input_file);
-    if (output_file)
-        HDfree (output_file);
-
     h5tools_close();
 
     HDexit(ret);
@@ -195,8 +188,6 @@ main (int argc, const char *argv[])
     int         ufid = -1;
     int         h5fid = -1;
     int         ofid = -1;
-    void       *edata;
-    H5E_auto2_t func;
     hid_t       ifile = H5I_INVALID_HID;
     hid_t       plist = H5I_INVALID_HID;
     herr_t      status;
@@ -214,20 +205,20 @@ main (int argc, const char *argv[])
     h5tools_setprogname(PROGRAMNAME);
     h5tools_setstatus(EXIT_SUCCESS);
 
-    /* Disable error reporting */
-    H5Eget_auto2(H5E_DEFAULT, &func, &edata);
-    H5Eset_auto2(H5E_DEFAULT, NULL, NULL);
-
     /* Initialize h5tools lib */
     h5tools_init();
 
     parse_command_line(argc, argv);
 
+    /* enable error reporting if command line option */
+    h5tools_error_report();
+
     if (ub_file == NULL) {
         /* no user block */
         error_msg("missing argument for -u <user_file>.\n");
         help_ref_msg(stderr);
-        leave (EXIT_FAILURE);
+        h5tools_setstatus(EXIT_FAILURE);
+        goto done;
     }
 
     testval = H5Fis_accessible(ub_file, H5P_DEFAULT);
@@ -235,13 +226,15 @@ main (int argc, const char *argv[])
     if (testval > 0) {
         error_msg("-u <user_file> cannot be HDF5 file, but it appears to be an HDF5 file.\n");
         help_ref_msg(stderr);
-        leave (EXIT_FAILURE);
+        h5tools_setstatus(EXIT_FAILURE);
+        goto done;
     }
 
     if (input_file == NULL) {
         error_msg("missing argument for -i <HDF5 file>.\n");
         help_ref_msg(stderr);
-        leave (EXIT_FAILURE);
+        h5tools_setstatus(EXIT_FAILURE);
+        goto done;
     }
 
     testval = H5Fis_accessible(input_file, H5P_DEFAULT);
@@ -249,45 +242,49 @@ main (int argc, const char *argv[])
     if (testval <= 0) {
         error_msg("Input HDF5 file \"%s\" is not HDF5 format.\n", input_file);
         help_ref_msg(stderr);
-        leave (EXIT_FAILURE);
+        h5tools_setstatus(EXIT_FAILURE);
+        goto done;
     }
 
     ifile = H5Fopen(input_file, H5F_ACC_RDONLY, H5P_DEFAULT);
 
     if (ifile < 0) {
         error_msg("Can't open input HDF5 file \"%s\"\n", input_file);
-        leave (EXIT_FAILURE);
+        h5tools_setstatus(EXIT_FAILURE);
+        goto done;
     }
 
     plist = H5Fget_create_plist(ifile);
     if (plist < 0) {
         error_msg("Can't get file creation plist for file \"%s\"\n", input_file);
-        H5Fclose(ifile);
-        leave (EXIT_FAILURE);
+        h5tools_setstatus(EXIT_FAILURE);
+        goto done;
     }
 
     status = H5Pget_userblock(plist, &usize);
     if (status < 0) {
         error_msg("Can't get user block for file \"%s\"\n", input_file);
-        H5Pclose(plist);
-        H5Fclose(ifile);
-        leave (EXIT_FAILURE);
+        h5tools_setstatus(EXIT_FAILURE);
+        goto done;
     }
 
     H5Pclose(plist);
+    plist = H5I_INVALID_HID;
     H5Fclose(ifile);
+    ifile = H5I_INVALID_HID;
 
     ufid = HDopen(ub_file, O_RDONLY);
     if(ufid < 0) {
         error_msg("unable to open user block file \"%s\"\n", ub_file);
-        leave (EXIT_FAILURE);
+        h5tools_setstatus(EXIT_FAILURE);
+        goto done;
     }
 
     res = HDfstat(ufid, &sbuf);
     if(res < 0) {
         error_msg("Can't stat file \"%s\"\n", ub_file);
-        HDclose (ufid);
-        leave (EXIT_FAILURE);
+        h5tools_setstatus(EXIT_FAILURE);
+        goto done;
     }
 
     fsize = (off_t)sbuf.st_size;
@@ -295,16 +292,15 @@ main (int argc, const char *argv[])
     h5fid = HDopen(input_file, O_RDONLY);
     if(h5fid < 0) {
         error_msg("unable to open HDF5 file for read \"%s\"\n", input_file);
-        HDclose (ufid);
-        leave (EXIT_FAILURE);
+        h5tools_setstatus(EXIT_FAILURE);
+        goto done;
     }
 
     res = HDfstat(h5fid, &sbuf2);
     if(res < 0) {
         error_msg("Can't stat file \"%s\"\n", input_file);
-        HDclose (h5fid);
-        HDclose (ufid);
-        leave (EXIT_FAILURE);
+        h5tools_setstatus(EXIT_FAILURE);
+        goto done;
     }
 
     h5fsize = (hsize_t)sbuf2.st_size;
@@ -314,9 +310,8 @@ main (int argc, const char *argv[])
 
         if (ofid < 0) {
             error_msg("unable to open output file \"%s\"\n", output_file);
-            HDclose (h5fid);
-            HDclose (ufid);
-            leave (EXIT_FAILURE);
+            h5tools_setstatus(EXIT_FAILURE);
+            goto done;
         }
     }
     else {
@@ -324,9 +319,8 @@ main (int argc, const char *argv[])
 
         if (ofid < 0) {
             error_msg("unable to create output file \"%s\"\n", output_file);
-            HDclose (h5fid);
-            HDclose (ufid);
-            leave (EXIT_FAILURE);
+            h5tools_setstatus(EXIT_FAILURE);
+            goto done;
         }
     }
 
@@ -365,12 +359,11 @@ main (int argc, const char *argv[])
     /* pad the ub */
     if(write_pad(ofid, where, &where) < 0) {
         error_msg("Can't pad file \"%s\"\n", output_file);
-        HDclose (h5fid);
-        HDclose (ufid);
-        HDclose (ofid);
-        leave (EXIT_FAILURE);
+        h5tools_setstatus(EXIT_FAILURE);
+        goto done;
     } /* end if */
 
+done:
     if(ub_file)
         HDfree(ub_file);
     if(input_file)
@@ -378,6 +371,11 @@ main (int argc, const char *argv[])
     if(output_file)
         HDfree(output_file);
 
+    if(plist >= 0)
+        H5Pclose(plist);
+    if(ifile >= 0)
+        H5Fclose(ifile);
+
     if(ufid >= 0)
         HDclose(ufid);
     if(h5fid >= 0)
@@ -385,7 +383,7 @@ main (int argc, const char *argv[])
     if(ofid >= 0)
         HDclose(ofid);
 
-    return h5tools_getstatus();
+    leave(h5tools_getstatus());
 }
 
 /*-------------------------------------------------------------------------
diff --git a/tools/src/h5jam/h5unjam.c b/tools/src/h5jam/h5unjam.c
index 203522bd69f..b48e2c10cd7 100644
--- a/tools/src/h5jam/h5unjam.c
+++ b/tools/src/h5jam/h5unjam.c
@@ -185,6 +185,13 @@ parse_command_line(int argc, const char *argv[])
     return EXIT_FAILURE;
 }
 
+static void
+leave(int ret)
+{
+   h5tools_close();
+   HDexit(ret);
+}
+
 /*-------------------------------------------------------------------------
  * Function:    main
  *
@@ -197,8 +204,6 @@ parse_command_line(int argc, const char *argv[])
 int
 main(int argc, const char *argv[])
 {
-    void               *edata;
-    H5E_auto2_t         func;
     hid_t               ifile = H5I_INVALID_HID;
     hid_t               plist = H5I_INVALID_HID;
     off_t               fsize;
@@ -211,16 +216,15 @@ main(int argc, const char *argv[])
     h5tools_setprogname(PROGRAMNAME);
     h5tools_setstatus(EXIT_SUCCESS);
 
-    /* Disable error reporting  */
-    H5Eget_auto2(H5E_DEFAULT, &func, &edata);
-    H5Eset_auto2(H5E_DEFAULT, NULL, NULL);
-
     /* Initialize h5tools lib  */
     h5tools_init();
 
     if(EXIT_FAILURE == parse_command_line(argc, argv))
         goto done;
 
+    /* enable error reporting if command line option */
+    h5tools_error_report();
+
     if (input_file == NULL) {
         /* no user block  */
         error_msg("missing argument for HDF5 file input.\n");
@@ -319,9 +323,7 @@ main(int argc, const char *argv[])
         HDfree(ub_file);
     }
 
-    h5tools_close();
-
-    return h5tools_getstatus();
+    leave(h5tools_getstatus());
 }
 
 /*-------------------------------------------------------------------------
diff --git a/tools/src/h5ls/h5ls.c b/tools/src/h5ls/h5ls.c
index 765ab633b8c..fef7aa99197 100644
--- a/tools/src/h5ls/h5ls.c
+++ b/tools/src/h5ls/h5ls.c
@@ -1298,230 +1298,6 @@ print_type(h5tools_str_t *buffer, hid_t type, int ind)
     h5tools_str_append(buffer,"%lu-byte class-%u unknown", (unsigned long)H5Tget_size(type), (unsigned)data_class);
 }
 
-/*
- *
- */
-static void
-dump_reference(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx, hid_t container, H5R_ref_t *ref_buf, int ndims)
-{
-    hid_t               new_obj_id = H5I_INVALID_HID;
-    hid_t               new_obj_sid = H5I_INVALID_HID;
-    hsize_t             elmt_counter = 0;  /*counts the # elements printed. */
-    size_t              ncols = 80;        /* available output width        */
-    int                 i;
-    hsize_t             curr_pos = 0;      /* total data element position   */
-    h5tools_str_t       buffer;            /* string into which to render   */
-    h5tools_context_t   datactx;           /* print context  */
-
-    H5TOOLS_START_DEBUG("");
-
-    datactx = *ctx;  /* print context  */
-    /* Assume entire data space to be printed */
-    if (datactx.ndims > 0)
-        for (i = 0; (unsigned)i < datactx.ndims; i++)
-            datactx.p_min_idx[i] = 0;
-    datactx.need_prefix = TRUE;
-
-    HDmemset(&buffer, 0, sizeof(h5tools_str_t));
-    for(i = 0; i < ndims; i++, datactx.cur_elmt++, elmt_counter++) {
-        H5O_type_t obj_type = -1;   /* Object type */
-        H5R_type_t ref_type;   /* Reference type */
-
-        H5TOOLS_DEBUG("reference loop:%d with curr_pos=%ld", i, curr_pos);
-
-        datactx.need_prefix = TRUE;
-        h5tools_str_reset(&buffer);
-        H5TOOLS_DEBUG("reference loop - h5tools_str_sprint with H5T_STD_REF:%d", i);
-        h5tools_str_sprint(&buffer, info, container, H5T_STD_REF, &ref_buf[i], &datactx);
-        h5tools_render_element(stream, info, &datactx, &buffer, &curr_pos, (size_t)ncols, (hsize_t)i, (hsize_t)ndims);
-
-        ref_type = H5Rget_type((const H5R_ref_t *)&ref_buf[i]);
-        switch (ref_type) {
-            case H5R_OBJECT1:
-                H5TOOLS_DEBUG("ref_type is H5R_OBJECT1");
-                if (H5Rget_obj_type3(&ref_buf[i], H5P_DEFAULT, &obj_type) >= 0) {
-                    switch (obj_type) {
-                        case H5O_TYPE_DATASET:
-                            if((new_obj_id = H5Ropen_object(&ref_buf[i], H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
-                                datactx.indent_level++;
-                                h5tools_dump_dset(stream, info, &datactx, new_obj_id);
-                                datactx.indent_level--;
-                                if(H5Dclose(new_obj_id) < 0)
-                                    H5TOOLS_INFO("H5Dclose H5R_OBJECT1:H5O_TYPE_DATASET failed");
-                                if(H5Rdestroy(&ref_buf[i]) < 0)
-                                    H5TOOLS_INFO("H5Rdestroy H5R_OBJECT1:H5O_TYPE_DATASET failed");
-                            }
-                            else
-                                H5TOOLS_INFO("H5Ropen_object H5R_OBJECT1:H5O_TYPE_DATASET failed");
-                            break;
-
-                        case H5O_TYPE_GROUP:
-                        case H5O_TYPE_NAMED_DATATYPE:
-                        case H5O_TYPE_MAP:
-                        case H5O_TYPE_UNKNOWN:
-                        case H5O_TYPE_NTYPES:
-                        default:
-                            break;
-                    } /* end switch */
-                }
-                else
-                    H5TOOLS_INFO("H5Rget_obj_type3 H5R_OBJECT1 failed");
-                break;
-            case H5R_DATASET_REGION1:
-                H5TOOLS_DEBUG("ref_type is H5R_DATASET_REGION1");
-                if((new_obj_id = H5Ropen_object(&ref_buf[i], H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
-                    datactx.indent_level++;
-                    h5tools_dump_dset(stream, info, &datactx, new_obj_id);
-                    datactx.indent_level--;
-                    if(H5Dclose(new_obj_id) < 0)
-                        H5TOOLS_INFO("H5Dclose H5R_DATASET_REGION1 failed");
-                    if(H5Rdestroy(&ref_buf[i]) < 0)
-                        H5TOOLS_INFO("H5Rdestroy H5R_DATASET_REGION1 failed");
-                }
-                else
-                    H5TOOLS_INFO("H5Ropen_object H5R_DATASET_REGION1 failed");
-                break;
-            case H5R_OBJECT2:
-                H5TOOLS_DEBUG("ref_type is H5R_OBJECT2");
-                if (H5Rget_obj_type3(&ref_buf[i], H5P_DEFAULT, &obj_type) >= 0) {
-                    switch (obj_type) {
-                        case H5O_TYPE_GROUP:
-                            break;
-
-                        case H5O_TYPE_DATASET:
-                            if((new_obj_id = H5Ropen_object(&ref_buf[i], H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
-                                datactx.indent_level++;
-                                h5tools_dump_dset(stream, info, &datactx, new_obj_id);
-                                datactx.indent_level--;
-                                if(H5Oclose(new_obj_id) < 0)
-                                    H5TOOLS_INFO("H5Oclose H5R_OBJECT2 failed");
-                                if(H5Rdestroy(&ref_buf[i]) < 0)
-                                    H5TOOLS_INFO("H5Rdestroy H5R_OBJECT2 failed");
-                            }
-                            else
-                                H5TOOLS_INFO("H5Ropen_object H5R_OBJECT2 failed");
-                            break;
-
-                        case H5O_TYPE_NAMED_DATATYPE:
-                            break;
-
-                        case H5O_TYPE_MAP:
-                        case H5O_TYPE_UNKNOWN:
-                        case H5O_TYPE_NTYPES:
-                        default:
-                            break;
-                    } /* end switch */
-                }
-                else
-                    H5TOOLS_INFO("H5Rget_obj_type3 H5R_OBJECT2 failed");
-                break;
-            case H5R_DATASET_REGION2:
-                H5TOOLS_DEBUG("ref_type is H5R_DATASET_REGION2");
-
-                if (info->line_ncols > 0)
-                    ncols = info->line_ncols;
-
-                /* if (new_obj_id < 0) - could mean that no reference was written do not throw failure */
-                if((new_obj_id = H5Ropen_object(&ref_buf[i], H5P_DEFAULT, H5P_DEFAULT)) < 0)
-                    H5TOOLS_INFO("H5Ropen_object H5R_DATASET_REGION2 failed");
-                else {
-                    if((new_obj_sid = H5Ropen_region(&ref_buf[i], H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
-                        if (h5tools_is_zero(&ref_buf[i], H5Tget_size(H5T_STD_REF))) {
-                            H5TOOLS_DEBUG("NULL H5R_DATASET_REGION2");
-
-                            h5tools_str_reset(&buffer);
-                            h5tools_str_append(&buffer, " {");
-                            h5tools_render_element(stream, info, &datactx, &buffer, &curr_pos, (size_t)ncols, (hsize_t)0, (hsize_t)0);
-
-                            datactx.need_prefix = TRUE;
-                            datactx.indent_level++;
-                            h5tools_str_reset(&buffer);
-                            h5tools_str_append(&buffer, "NULL");
-                            h5tools_render_element(stream, info, &datactx, &buffer, &curr_pos, (size_t)ncols, (hsize_t)0, (hsize_t)0);
-                            datactx.indent_level--;
-                            datactx.need_prefix = TRUE;
-
-                            h5tools_str_reset(&buffer);
-                            h5tools_str_append(&buffer, "}");
-                            h5tools_render_element(stream, info, &datactx, &buffer, &curr_pos, (size_t)ncols, (hsize_t)0, (hsize_t)0);
-                        }
-                        else {
-                            H5S_sel_type region_type;
-
-                            region_type = H5Sget_select_type(new_obj_sid);
-                            if(region_type == H5S_SEL_POINTS) {
-                                /* Print point information */
-                                H5TOOLS_DEBUG("H5S_SEL_POINTS H5R_DATASET_REGION2");
-                                h5tools_dump_region_data_points(new_obj_sid, new_obj_id, stream, info, &datactx,
-                                                    &buffer, &curr_pos, ncols, (hsize_t)i, elmt_counter);
-                            }
-                            else if(region_type == H5S_SEL_HYPERSLABS) {
-                                /* Print block information */
-                                H5TOOLS_DEBUG("H5S_SEL_HYPERSLABS H5R_DATASET_REGION2");
-                                h5tools_dump_region_data_blocks(new_obj_sid, new_obj_id, stream, info, &datactx,
-                                                    &buffer, &curr_pos, ncols, (hsize_t)i, elmt_counter);
-                            }
-                            else
-                                H5TOOLS_INFO("invalid region type");
-                        } /* end else to if (h5tools_is_zero(... */
-                        if(H5Sclose(new_obj_sid) < 0)
-                            H5TOOLS_INFO("H5Sclose H5R_DATASET_REGION2 failed");
-                    }
-                    else
-                        H5TOOLS_INFO("H5Ropen_region H5R_DATASET_REGION2 failed");
-                    if(H5Dclose(new_obj_id) < 0)
-                        H5TOOLS_INFO("H5Dclose H5R_DATASET_REGION2 failed");
-                    if(H5Rdestroy(&ref_buf[i]) < 0)
-                        H5TOOLS_INFO("H5Rdestroy H5R_DATASET_REGION2 failed");
-                }
-                break;
-            case H5R_ATTR:
-                H5TOOLS_DEBUG("ref_type is H5R_ATTR");
-                if((new_obj_id = H5Ropen_attr(&ref_buf[i], H5P_DEFAULT, H5P_DEFAULT)) >= 0) {
-                    h5tools_dump_region_attribute(new_obj_id, stream, info, &datactx, &buffer, &curr_pos, (size_t)ncols, (hsize_t)0, (hsize_t)0);
-                    if(H5Aclose(new_obj_id) < 0)
-                        H5TOOLS_INFO("H5Aclose H5R_ATTR failed");
-                    if(H5Rdestroy(&ref_buf[i]) < 0)
-                        H5TOOLS_INFO("H5Rdestroy H5R_ATTR failed");
-                }
-                else {
-                    H5TOOLS_DEBUG("NULL H5R_ATTR");
-
-                    h5tools_str_reset(&buffer);
-                    h5tools_str_append(&buffer, " {");
-                    h5tools_render_element(stream, info, &datactx, &buffer, &curr_pos, (size_t)ncols, (hsize_t)0, (hsize_t)0);
-
-                    datactx.need_prefix = TRUE;
-                    datactx.indent_level++;
-                    h5tools_str_reset(&buffer);
-                    h5tools_str_append(&buffer, "NULL");
-                    h5tools_render_element(stream, info, &datactx, &buffer, &curr_pos, (size_t)ncols, (hsize_t)0, (hsize_t)0);
-                    datactx.indent_level--;
-                    datactx.need_prefix = TRUE;
-
-                    h5tools_str_reset(&buffer);
-                    h5tools_str_append(&buffer, "}");
-                    h5tools_render_element(stream, info, &datactx, &buffer, &curr_pos, (size_t)ncols, (hsize_t)0, (hsize_t)0);
-
-                    H5TOOLS_INFO("H5Ropen_attr H5R_ATTR failed");
-                }
-                break;
-            case H5R_BADTYPE:
-            case H5R_MAXTYPE:
-            default:
-                break;
-        } /* end switch */
-
-        H5TOOLS_DEBUG("finished reference loop:%d",i);
-    } /* end for(i = 0; i < ndims; i++, ctx->cur_elmt++, elmt_counter++) */
-
-    h5tools_str_close(&buffer);
-
-    PRINTVALSTREAM(stream, "\n");
-
-    H5TOOLS_ENDDEBUG("");
-}
-
 /*-------------------------------------------------------------------------
  * Function:    dump_dataset_values
  *
@@ -1653,13 +1429,9 @@ dump_dataset_values(hid_t dset)
         H5TOOLS_DEBUG("ndims=%d - ctx.ndims=%d", ndims, ctx.ndims);
 
         /* Assume entire data space to be printed */
-        if (ctx.ndims > 0)
-            for (i = 0; i < (size_t)ctx.ndims; i++)
-                ctx.p_min_idx[i] = 0;
-
         H5Sget_simple_extent_dims(space, total_size, NULL);
-        if (ctx.ndims > 0)
-            init_acc_pos(&ctx, total_size);
+        init_acc_pos(ctx.ndims, total_size, ctx.acc, ctx.pos, ctx.p_min_idx);
+
         ctx.need_prefix = TRUE;
 
         if (NULL != (ref_buf = (H5R_ref_t *)HDcalloc(MAX(sizeof(unsigned), sizeof(H5R_ref_t)), (size_t)ndims))) {
@@ -1669,7 +1441,9 @@ dump_dataset_values(hid_t dset)
                 H5TOOLS_INFO("H5Dread reference failed");
                 H5TOOLS_GOTO_DONE_NO_RET();
             }
-            dump_reference(rawoutstream, info, &ctx, dset, ref_buf, ndims);
+            h5tools_dump_reference(rawoutstream, info, &ctx, dset, ref_buf, ndims);
+
+            PRINTVALSTREAM(rawoutstream, "\n");
             HDfree(ref_buf);
         }
     }
@@ -1824,13 +1598,9 @@ dump_attribute_values(hid_t attr)
         H5TOOLS_DEBUG("ndims=%d - ctx.ndims=%d", ndims, ctx.ndims);
 
         /* Assume entire data space to be printed */
-        if (ctx.ndims > 0)
-            for (i = 0; i < (size_t)ctx.ndims; i++)
-                ctx.p_min_idx[i] = 0;
-
         H5Sget_simple_extent_dims(space, total_size, NULL);
-        if (ctx.ndims > 0)
-            init_acc_pos(&ctx, total_size);
+        init_acc_pos(ctx.ndims, total_size, ctx.acc, ctx.pos, ctx.p_min_idx);
+
         ctx.need_prefix = TRUE;
 
         if (NULL != (ref_buf = (H5R_ref_t *)HDcalloc(MAX(sizeof(unsigned), sizeof(H5R_ref_t)), (size_t)ndims))) {
@@ -1841,7 +1611,9 @@ dump_attribute_values(hid_t attr)
                 H5TOOLS_GOTO_DONE_NO_RET();
             }
             ctx.indent_level++;
-            dump_reference(rawoutstream, info, &ctx, attr, ref_buf, ndims);
+            h5tools_dump_reference(rawoutstream, info, &ctx, attr, ref_buf, ndims);
+
+            PRINTVALSTREAM(rawoutstream, "\n");
             ctx.indent_level--;
             HDfree(ref_buf);
         }
@@ -2856,10 +2628,6 @@ main(int argc, const char *argv[])
     const char  *preferred_driver = NULL;
     int          err_exit = 0;
     hid_t        fapl_id = H5P_DEFAULT;
-    H5E_auto2_t  func;
-    H5E_auto2_t  tools_func;
-    void        *edata;
-    void        *tools_edata;
     hbool_t custom_vol_fapl = FALSE;
     h5tools_vol_info_t vol_info;
 
@@ -2889,17 +2657,9 @@ main(int argc, const char *argv[])
     h5tools_setprogname(PROGRAMNAME);
     h5tools_setstatus(EXIT_SUCCESS);
 
-    /* Disable error reporting */
-    H5Eget_auto2(H5E_DEFAULT, &func, &edata);
-    H5Eset_auto2(H5E_DEFAULT, NULL, NULL);
-
     /* Initialize h5tools lib */
     h5tools_init();
 
-    /* Disable tools error reporting */
-    H5Eget_auto2(H5tools_ERR_STACK_g, &tools_func, &tools_edata);
-    H5Eset_auto2(H5tools_ERR_STACK_g, NULL, NULL);
-
     /* Initialize fapl info struct */
     HDmemset(&vol_info, 0, sizeof(h5tools_vol_info_t));
 
@@ -3158,6 +2918,9 @@ main(int argc, const char *argv[])
         }
     } /* end for */
 
+    /* enable error reporting if command line option */
+    h5tools_error_report();
+
     /* If no arguments remain then print a usage message (instead of doing
      * absolutely nothing ;-) */
     if (argno >= argc) {
@@ -3208,11 +2971,6 @@ main(int argc, const char *argv[])
         }
     }
 
-    if (enable_error_stack > 0) {
-        H5Eset_auto2(H5E_DEFAULT, func, edata);
-        H5Eset_auto2(H5tools_ERR_STACK_g, tools_func, tools_edata);
-    }
-
     /* Each remaining argument is an hdf5 file followed by an optional slash
      * and object name.
      *
@@ -3271,7 +3029,6 @@ main(int argc, const char *argv[])
             x = oname;
             if (NULL == (oname = HDstrdup(oname))) {
                 HDfprintf(rawerrorstream, "memory allocation failed\n");
-                H5Eset_auto2(H5E_DEFAULT, func, edata);
                 leave(EXIT_FAILURE);
             }
             *x = '\0';
@@ -3316,7 +3073,6 @@ main(int argc, const char *argv[])
                 h5tools_str_reset(&buffer);
                 print_obj_name(&buffer, &iter, oname, "**NOT FOUND**");
                 h5tools_render_element(rawoutstream, info, &ctx, &buffer, &curr_pos, (size_t)info->line_ncols, (hsize_t)0, (hsize_t)0);
-                H5Eset_auto2(H5E_DEFAULT, func, edata);
                 leave(EXIT_FAILURE);
             } /* end if */
         } /* end if */
@@ -3326,7 +3082,6 @@ main(int argc, const char *argv[])
         /* Open the object and display it's information */
         if (li.type == H5L_TYPE_HARD) {
             if (visit_obj(file_id, oname, &iter) < 0) {
-                H5Eset_auto2(H5E_DEFAULT, func, edata);
                 leave(EXIT_FAILURE);
             }
         } /* end if(li.type == H5L_TYPE_HARD) */
@@ -3357,12 +3112,10 @@ main(int argc, const char *argv[])
     if (fapl_id != H5P_DEFAULT) {
         if (0 < H5Pclose(fapl_id)) {
             HDfprintf(rawerrorstream, "Error: Unable to set close fapl entry\n\n");
-            H5Eset_auto2(H5E_DEFAULT, func, edata);
             leave(EXIT_FAILURE);
         }
     }
 
-    H5Eset_auto2(H5E_DEFAULT, func, edata);
     if (err_exit)
         leave(EXIT_FAILURE);
     else
diff --git a/tools/src/h5repack/h5repack_main.c b/tools/src/h5repack/h5repack_main.c
index f7822ca5a89..0ad61c0f0a4 100644
--- a/tools/src/h5repack/h5repack_main.c
+++ b/tools/src/h5repack/h5repack_main.c
@@ -804,10 +804,6 @@ int parse_command_line(int argc, const char **argv, pack_opt_t* options)
 int main(int argc, const char **argv)
 {
     pack_opt_t          options; /*the global options */
-    H5E_auto2_t         func;
-    H5E_auto2_t         tools_func;
-    void               *edata;
-    void               *tools_edata;
     int                 parse_ret;
 
     HDmemset(&options, 0, sizeof(pack_opt_t));
@@ -818,14 +814,6 @@ int main(int argc, const char **argv)
     h5tools_setprogname(PROGRAMNAME);
     h5tools_setstatus(EXIT_SUCCESS);
 
-    /* Disable error reporting */
-    H5Eget_auto2(H5E_DEFAULT, &func, &edata);
-    H5Eset_auto2(H5E_DEFAULT, NULL, NULL);
-
-    /* Disable tools error reporting */
-    H5Eget_auto2(H5tools_ERR_STACK_g, &tools_func, &tools_edata);
-    H5Eset_auto2(H5tools_ERR_STACK_g, NULL, NULL);
-
     /* update hyperslab buffer size from H5TOOLS_BUFSIZE env if exist */
     if (h5tools_getenv_update_hyperslab_bufsize() < 0) {
         HDprintf("Error occurred while retrieving H5TOOLS_BUFSIZE value\n");
@@ -855,10 +843,8 @@ int main(int argc, const char **argv)
         goto done;
     }
 
-    if (enable_error_stack > 0) {
-        H5Eset_auto2(H5E_DEFAULT, func, edata);
-        H5Eset_auto2(H5tools_ERR_STACK_g, tools_func, tools_edata);
-    }
+    /* enable error reporting if command line option */
+    h5tools_error_report();
 
     /* pack it */
     if (h5repack(infile, outfile, &options) < 0) {
diff --git a/tools/src/h5stat/h5stat.c b/tools/src/h5stat/h5stat.c
index fb3d50d790f..ec4b5abbf6c 100644
--- a/tools/src/h5stat/h5stat.c
+++ b/tools/src/h5stat/h5stat.c
@@ -1786,32 +1786,23 @@ main(int argc, const char *argv[])
     iter_t              iter;
     const char         *fname = NULL;
     hid_t               fid = H5I_INVALID_HID;
-    H5E_auto2_t         func;
-    H5E_auto2_t         tools_func;
-    void               *edata;
-    void               *tools_edata;
     struct handler_t   *hand = NULL;
     hid_t               fapl_id = H5P_DEFAULT;
 
     h5tools_setprogname(PROGRAMNAME);
     h5tools_setstatus(EXIT_SUCCESS);
 
-    /* Disable error reporting */
-    H5Eget_auto2(H5E_DEFAULT, &func, &edata);
-    H5Eset_auto2(H5E_DEFAULT, NULL, NULL);
-
     /* Initialize h5tools lib */
     h5tools_init();
 
-    /* Disable tools error reporting */
-    H5Eget_auto2(H5tools_ERR_STACK_g, &tools_func, &tools_edata);
-    H5Eset_auto2(H5tools_ERR_STACK_g, NULL, NULL);
-
     HDmemset(&iter, 0, sizeof(iter));
 
     if(parse_command_line(argc, argv, &hand) < 0)
         goto done;
 
+    /* enable error reporting if command line option */
+    h5tools_error_report();
+
     if (drivername) {
         h5tools_vfd_info_t vfd_info;
 
@@ -1843,11 +1834,6 @@ main(int argc, const char *argv[])
 
     fname = argv[opt_ind];
 
-    if(enable_error_stack > 0) {
-        H5Eset_auto2(H5E_DEFAULT, func, edata);
-        H5Eset_auto2(H5tools_ERR_STACK_g, tools_func, tools_edata);
-    }
-
     /* Check for filename given */
     if(fname) {
         hid_t               fcpl;
@@ -1952,8 +1938,6 @@ main(int argc, const char *argv[])
         h5tools_setstatus(EXIT_FAILURE);
     } /* end if */
 
-    H5Eset_auto2(H5E_DEFAULT, func, edata);
-
     leave(h5tools_getstatus());
 } /* end main() */
 
diff --git a/tools/src/misc/h5clear.c b/tools/src/misc/h5clear.c
index f95d1bc87b2..96cbf9c6c44 100644
--- a/tools/src/misc/h5clear.c
+++ b/tools/src/misc/h5clear.c
@@ -266,14 +266,9 @@ main (int argc, const char *argv[])
     h5tools_setprogname(PROGRAMNAME);
     h5tools_setstatus(EXIT_SUCCESS);
 
-    /* Disable the HDF5 library's error reporting */
-    H5Eset_auto2(H5E_DEFAULT, NULL, NULL);
-
     /* initialize h5tools lib */
     h5tools_init();
 
-    H5Eset_auto2(H5tools_ERR_STACK_g, NULL, NULL);
-
     /* Parse command line options */
     if(parse_command_line(argc, argv) < 0)
         goto done;
@@ -281,6 +276,9 @@ main (int argc, const char *argv[])
     if(fname_g == NULL)
         goto done;
 
+    /* enable error reporting if command line option */
+    h5tools_error_report();
+
     /* Print usage/exit if not using at least one of the options */
     if(!clear_status_flags && !remove_cache_image &&
        !increment_eoa_eof && !print_filesize) {
@@ -387,7 +385,6 @@ main (int argc, const char *argv[])
             warn_msg("No cache image in the file\n");
     }
 
-
     h5tools_setstatus(EXIT_SUCCESS);
 
 done:
diff --git a/tools/src/misc/h5mkgrp.c b/tools/src/misc/h5mkgrp.c
index cbd6e6d6241..4d2d2b85ff1 100644
--- a/tools/src/misc/h5mkgrp.c
+++ b/tools/src/misc/h5mkgrp.c
@@ -49,7 +49,7 @@ typedef struct mkgrp_opt_t {
 
 mkgrp_opt_t params_g;           /* Command line parameter settings */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    leave
  *
@@ -81,7 +81,7 @@ leave(int ret)
     HDexit(ret);
 } /* end leave() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function: usage
  *
@@ -113,7 +113,7 @@ usage(const char *prog)
     PRINTVALSTREAM(rawoutstream, "\n");
 } /* end usage() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    parse_command_line
  *
@@ -248,7 +248,7 @@ parse_command_line(int argc, const char *argv[], mkgrp_opt_t *options)
     return 0;
 } /* parse_command_line() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function: main
  *
@@ -268,9 +268,6 @@ main(int argc, const char *argv[])
     h5tools_setprogname(PROGRAMNAME);
     h5tools_setstatus(EXIT_SUCCESS);
 
-    /* Disable the HDF5 library's error reporting */
-    H5Eset_auto2(H5E_DEFAULT, NULL, NULL);
-
     /* Initialize h5tools lib */
     h5tools_init();
 
@@ -289,6 +286,9 @@ main(int argc, const char *argv[])
         leave(EXIT_FAILURE);
     }
 
+    /* enable error reporting if command line option */
+    h5tools_error_report();
+
     /* Check for creating groups with new format version */
     if(params_g.latest) {
         /* Set the "use the latest version of the format" bounds */
diff --git a/tools/test/h5diff/CMakeTests.cmake b/tools/test/h5diff/CMakeTests.cmake
index 3d9c6f55f3a..43c8c1539ba 100644
--- a/tools/test/h5diff/CMakeTests.cmake
+++ b/tools/test/h5diff/CMakeTests.cmake
@@ -68,6 +68,8 @@
       ${HDF5_TOOLS_TEST_H5DIFF_SOURCE_DIR}/testfiles/tudfilter2.h5
       ${HDF5_TOOLS_TEST_H5DIFF_SOURCE_DIR}/testfiles/diff_strings1.h5
       ${HDF5_TOOLS_TEST_H5DIFF_SOURCE_DIR}/testfiles/diff_strings2.h5
+      ${HDF5_TOOLS_TEST_H5DIFF_SOURCE_DIR}/testfiles/diff_eps1.h5
+      ${HDF5_TOOLS_TEST_H5DIFF_SOURCE_DIR}/testfiles/diff_eps2.h5
       # tools/testfiles/vds
       ${HDF5_TOOLS_DIR}/testfiles/vds/1_a.h5
       ${HDF5_TOOLS_DIR}/testfiles/vds/1_b.h5
@@ -302,6 +304,7 @@
       ${HDF5_TOOLS_TEST_H5DIFF_SOURCE_DIR}/testfiles/h5diff_v2.txt
       ${HDF5_TOOLS_TEST_H5DIFF_SOURCE_DIR}/testfiles/h5diff_v3.txt
       ${HDF5_TOOLS_TEST_H5DIFF_SOURCE_DIR}/testfiles/h5diff_vlstr.txt
+      ${HDF5_TOOLS_TEST_H5DIFF_SOURCE_DIR}/testfiles/h5diff_eps.txt
   )
 
   set (LIST_WIN_TEST_FILES
@@ -541,6 +544,9 @@
   # strings
   set (STRINGS1 diff_strings1.h5)
   set (STRINGS2 diff_strings2.h5)
+  # epsilon
+  set (EPS1 diff_eps1.h5)
+  set (EPS2 diff_eps2.h5)
 
 # VDS tests
   set (FILEV1 1_vds.h5)
@@ -926,6 +932,8 @@
           h5diff_v3.out.err
           h5diff_vlstr.out
           h5diff_vlstr.out.err
+          h5diff_eps.out
+          h5diff_eps.out.err
     )
     set_tests_properties (H5DIFF-clearall-objects PROPERTIES WORKING_DIRECTORY "${PROJECT_BINARY_DIR}/testfiles")
     if (last_test)
@@ -1107,6 +1115,9 @@ ADD_H5_TEST (h5diff_609 0 -d 200 ${FILE1} ${FILE2} g1/dset3 g1/dset4)
 # 6.10: number smaller than smallest difference
 ADD_H5_TEST (h5diff_610 1 -d 1 ${FILE1} ${FILE2} g1/dset3 g1/dset4)
 
+# eps: number smaller than epsilon
+ADD_H5_TEST (h5diff_eps 0 -v3 -d 1e-16 ${EPS1} ${EPS2})
+
 # ##############################################################################
 # # -p
 # ##############################################################################
@@ -1492,9 +1503,9 @@ ADD_H5_TEST (h5diff_484 0 -v --exclude-path "/dset3" ${EXCLUDE_FILE1_1} ${EXCLUD
 # Only one file contains unique objs. Common objs are same.
 # (HDFFV-7837)
 #
-ADD_H5_TEST (h5diff_485 0 -v --exclude-path "/group1" h5diff_exclude3-1.h5 h5diff_exclude3-2.h5)
-ADD_H5_TEST (h5diff_486 0 -v --exclude-path "/group1" h5diff_exclude3-2.h5 h5diff_exclude3-1.h5)
-ADD_H5_TEST (h5diff_487 1 -v --exclude-path "/group1/dset" h5diff_exclude3-1.h5 h5diff_exclude3-2.h5)
+ADD_H5_TEST (h5diff_485 0 -v --exclude-path "/group1" ${EXCLUDE_FILE3_1} ${EXCLUDE_FILE3_2})
+ADD_H5_TEST (h5diff_486 0 -v --exclude-path "/group1" ${EXCLUDE_FILE3_2} ${EXCLUDE_FILE3_1})
+ADD_H5_TEST (h5diff_487 1 -v --exclude-path "/group1/dset" ${EXCLUDE_FILE3_1} ${EXCLUDE_FILE3_2})
 
 # ##############################################################################
 # # diff various multiple vlen and fixed strings in a compound type dataset
@@ -1528,8 +1539,6 @@ ADD_H5_TEST (h5diff_646 1 -v --use-system-epsilon -p 0.05 ${FILE1} ${FILE2} /g1/
 # ##############################################################################
 # # Test array variances
 # ##############################################################################
-#
-# Test with -d , -p and --use-system-epsilon.
 ADD_H5_TEST (h5diff_800 1 -v ${FILE7} ${FILE8} /g1/array /g1/array)
 ADD_H5_TEST (h5diff_801 1 -v ${FILE7} ${FILE8A} /g1/array /g1/array)
 
diff --git a/tools/test/h5diff/h5diffgentest.c b/tools/test/h5diff/h5diffgentest.c
index 1d5354f59ff..df79aa14324 100644
--- a/tools/test/h5diff/h5diffgentest.c
+++ b/tools/test/h5diff/h5diffgentest.c
@@ -96,6 +96,9 @@ size_t H5TOOLS_MALLOCSIZE = (128 * 1024 * 1024);
 /* string dataset and attribute */
 #define DIFF_STRINGS1 "diff_strings1.h5"
 #define DIFF_STRINGS2 "diff_strings2.h5"
+/* double dataset and epsilon */
+#define DIFF_EPS1 "diff_eps1.h5"
+#define DIFF_EPS2 "diff_eps2.h5"
 
 #define UIMAX    4294967295u /*Maximum value for a variable of type unsigned int */
 #define STR_SIZE 3
@@ -110,7 +113,7 @@ size_t H5TOOLS_MALLOCSIZE = (128 * 1024 * 1024);
 
 /* Error macros */
 #define AT()            HDprintf("ERROR at %s:%d in %s()...\n", __FILE__, __LINE__, FUNC);
-#define PROGRAM_ERROR   {AT(); goto error;}
+#define PROGRAM_ERROR   do {AT(); goto error;} while(0)
 
 /* A UD link traversal function.  Shouldn't actually be called. */
 static hid_t
@@ -172,6 +175,7 @@ static void test_comps_vlen_arry(const char *fname, const char *dset,
 static void test_data_nocomparables(const char *fname, int diff);
 static void test_objs_nocomparables(const char *fname1, const char *fname2);
 static void test_objs_strings(const char *fname, const char *fname2);
+static void test_double_epsilon(const char *fname1, const char *fname2);
 
 /* called by test_attributes() and test_datasets() */
 static void write_attr_strings(hid_t loc_id, const char* dset_name, hid_t fid, int make_diffs);
@@ -288,6 +292,9 @@ int main(void)
     /* string dataset and attribute. HDFFV-10028 */
     test_objs_strings(DIFF_STRINGS1, DIFF_STRINGS2);
 
+    /* double dataset and epsilion. HDFFV-10897 */
+    test_double_epsilon(DIFF_EPS1, DIFF_EPS2);
+
     return EXIT_SUCCESS;
 }
 
@@ -4928,73 +4935,73 @@ test_objs_nocomparables(const char *fname1, const char *fname2)
     *------------------------------------------------------------------------*/
     /* file1 */
     if((fid1 = H5Fopen(fname1, H5F_ACC_RDWR, H5P_DEFAULT)) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
 
     /* file2 */
     if((fid2 = H5Fopen(fname2, H5F_ACC_RDWR, H5P_DEFAULT)) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
 
     /*-----------------------------------------------------------------------
     * in file1 : add member objects
     *------------------------------------------------------------------------*/
     /* parent group */
     if((topgid1 = H5Gcreate2(fid1, "diffobjtypes", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT)) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
 
     /* dataset */
     if(write_dset(topgid1, 1, dims, "obj1", H5T_NATIVE_INT, data1) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
 
     /* group */
     if((gid1 = H5Gcreate2(topgid1, "obj2", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT)) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
 
     /* committed type */
     if((tid1 = H5Tcopy(H5T_NATIVE_INT)) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
     if(H5Tcommit2(topgid1, "obj3", tid1, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
 
     /*-----------------------------------------------------------------------
     * in file2 : add member objects
     *------------------------------------------------------------------------*/
     /* parent group */
     if((topgid2 = H5Gcreate2(fid2, "diffobjtypes", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT)) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
 
     /* group */
     if((gid2 = H5Gcreate2(topgid2, "obj1", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT)) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
 
     /* committed type */
     if((tid2 = H5Tcopy(H5T_NATIVE_INT)) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
     if(H5Tcommit2(topgid2, "obj2", tid2, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
 
     /* dataset */
     if(write_dset(topgid2, 1, dims, "obj3", H5T_NATIVE_INT, data2) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
 
     /*-----------------------------------------------------------------------
     * Close IDs
     *-----------------------------------------------------------------------*/
     if(H5Fclose(fid1) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
     if(H5Fclose(fid2) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
     if(H5Gclose(topgid1) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
     if(H5Gclose(topgid2) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
     if(H5Gclose(gid1) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
     if(H5Gclose(gid2) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
     if(H5Tclose(tid1) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
     if(H5Tclose(tid2) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
 
     return;
 
@@ -8018,6 +8025,60 @@ int test_hyperslab(const char *fname, int make_diffs /* flag to modify data buff
     return -1;
 }
 
+/*
+ * Function: test_double_epsilion
+ *
+ * Purpose: Create test files to compare data with epsilion
+ */
+static
+void test_double_epsilon(const char *fname1, const char *fname2)
+{
+    hid_t    fid1 = H5I_INVALID_HID, fid2 = H5I_INVALID_HID;
+    hsize_t  dims1[2] = { 4, 7 };
+    hsize_t  dims2[2] = { 4, 7 };
+    double   wdata[4][7];
+    int i, j;
+
+    /*-------------------------------------------------------------------------
+    * create two files
+    *-------------------------------------------------------------------------
+    */
+    if ((fid1 = H5Fcreate(fname1, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT)) < 0)
+        PROGRAM_ERROR;
+    if ((fid2 = H5Fcreate(fname2, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT)) < 0)
+        PROGRAM_ERROR;
+
+    /*
+    * Initialize data.
+    */
+    for (i=0; i<4; i++)
+        for (j=0; j<7; j++)
+            wdata[i][j] = 0.0;
+
+    /* dataset */
+    if(write_dset(fid1, 2, dims1, "dataset", H5T_IEEE_F64LE, wdata) < 0)
+        PROGRAM_ERROR;
+
+    /*
+    * Initialize data.
+    */
+    for (i=0; i<4; i++)
+        for (j=0; j<7; j++)
+            wdata[i][j] = (double)1.e-19;
+
+    /* dataset */
+    if(write_dset(fid2, 2, dims1, "dataset", H5T_IEEE_F64LE, wdata) < 0)
+        PROGRAM_ERROR;
+
+error:
+    H5E_BEGIN_TRY {
+        H5Fclose(fid1);
+        H5Fclose(fid2);
+    } H5E_END_TRY;
+
+    return;
+}
+
 /*-------------------------------------------------------------------------
  * Function: write_attr
  *
@@ -8073,22 +8134,22 @@ write_dset(hid_t loc_id, int rank, hsize_t *dims, const char *name, hid_t tid, v
 
     /* create a space  */
     if((sid = H5Screate_simple(rank, dims, NULL)) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
 
     /* create the dataset */
     if((did = H5Dcreate2(loc_id, name, tid, sid, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT)) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
 
     /* write */
     if(buf)
         if(H5Dwrite(did, tid, H5S_ALL, H5S_ALL, H5P_DEFAULT, buf) < 0)
-            PROGRAM_ERROR
+            PROGRAM_ERROR;
 
     /* close */
     if(H5Dclose(did) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
     if(H5Sclose(sid) < 0)
-        PROGRAM_ERROR
+        PROGRAM_ERROR;
 
     return SUCCEED;
 
diff --git a/tools/test/h5diff/testfiles/diff_eps1.h5 b/tools/test/h5diff/testfiles/diff_eps1.h5
new file mode 100644
index 0000000000000000000000000000000000000000..2803a1d0ae2cdfe32d772561764131ea3410eae1
GIT binary patch
literal 2272
zcmeD5aB<`1lHy_j0S*oZ76t(@6Gr@pf(INB5f~pPp8#brLg@}Dy@CnCU}OM61_lYJ
zxFFPgbaf#?uC5F~l`!*RG*lad0Skl$bp}j$lpY}=;Nj{R0P<=C)W5J)dIFlxV8P%L
zYzSt;(xV4Vf=rr`feoB~Ap|IeYCz0qg4h5}mJIAr^U?Xtz?2VCDX3u207<(J3?|$R
zCjXfs8d!m%AbBPxh=Cl?oWjfqRnG7Lq7X_7L4`qjwv-mdGB9MI$kUn=?C0+S%Fz(N
ZFfb@U{XuJcN6jA%fzc2c4FOU^003LsG2{RM

literal 0
HcmV?d00001

diff --git a/tools/test/h5diff/testfiles/diff_eps2.h5 b/tools/test/h5diff/testfiles/diff_eps2.h5
new file mode 100644
index 0000000000000000000000000000000000000000..4acf27a1b71169de5a39229fd366076d6d8ca5c4
GIT binary patch
literal 2272
zcmeD5aB<`1lHy_j0S*oZ76t(@6Gr@pf(INB5f~pPp8#brLg@}Dy@CnCU}OM61_lYJ
zxFFPgbaf#?uC5F~l`!*RG*lad0Skl$bp}j$lpY}=;Nj{R0P<=C)W5J)dIFlxV8P%L
zYzSt;(xV4Vf=rr`feoB~Ap|IeYCz0qg4h5}mJIAr^U?Xtz?2VCDX3u207<(J3?|$R
zCjXfs8d!m%AbBPxh=Cl?oWjfqRnG7Lq7X_7L4`qj@=J?i85lB9<Y~<b_VafE<!Fds
h7#I|w{-CwJqvnr>z-S0iKLplX+U9?<`LFeGr2+Z=zGDCY

literal 0
HcmV?d00001

diff --git a/tools/test/h5diff/testfiles/h5diff_10.txt b/tools/test/h5diff/testfiles/h5diff_10.txt
index 0a2fd123afa..b5ff01a17dc 100644
--- a/tools/test/h5diff/testfiles/h5diff_10.txt
+++ b/tools/test/h5diff/testfiles/h5diff_10.txt
@@ -17,10 +17,9 @@ usage: h5diff [OPTIONS] file1 file2 [obj1[ obj2]]
          Verbose mode with level. Print differences and list of objects.
          Level of detail depends on value of N:
           0 : Identical to '-v' or '--verbose'.
-          1 : All level 0 information plus one-line attribute
-              status summary.
-          2 : All level 1 information plus extended attribute
-              status report.
+          1 : All level 0 information plus one-line attribute status summary.
+          2 : All level 1 information plus extended attribute status report.
+          3 : All level 2 information plus file names.
    -q, --quiet
          Quiet mode. Do not produce output.
    --enable-error-stack
@@ -109,6 +108,14 @@ usage: h5diff [OPTIONS] file1 file2 [obj1[ obj2]]
          excluded.
          This option can be used repeatedly to exclude multiple paths.
 
+   --exclude-attribute "path/to/object/with/attribute"
+         Exclude attributes on the specified path to an object when comparing files or groups.
+
+         If there are multiple paths to an object, only the specified path(s)
+         will be excluded; the comparison will include any path not explicitly
+         excluded.
+         This option can be used repeatedly to exclude multiple paths.
+
  Modes of output:
   Default mode: print the number of differences found and where they occured
   -r Report mode: print the above plus the differences
diff --git a/tools/test/h5diff/testfiles/h5diff_58_ref.txt b/tools/test/h5diff/testfiles/h5diff_58_ref.txt
index 6fa22991d7b..48a4b331aa2 100644
--- a/tools/test/h5diff/testfiles/h5diff_58_ref.txt
+++ b/tools/test/h5diff/testfiles/h5diff_58_ref.txt
@@ -1,32 +1,32 @@
 
 dataset: </g1/reference2D> and </g1/reference2D>
 size:           [2]           [2]
-position                                        difference          
+position        reference2D     reference2D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference2D     reference2D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference2D     reference2D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference2D     reference2D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference2D     reference2D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference2D     reference2D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
diff --git a/tools/test/h5diff/testfiles/h5diff_600.txt b/tools/test/h5diff/testfiles/h5diff_600.txt
index 55b8da71ce9..f52d8cca464 100644
--- a/tools/test/h5diff/testfiles/h5diff_600.txt
+++ b/tools/test/h5diff/testfiles/h5diff_600.txt
@@ -17,10 +17,9 @@ usage: h5diff [OPTIONS] file1 file2 [obj1[ obj2]]
          Verbose mode with level. Print differences and list of objects.
          Level of detail depends on value of N:
           0 : Identical to '-v' or '--verbose'.
-          1 : All level 0 information plus one-line attribute
-              status summary.
-          2 : All level 1 information plus extended attribute
-              status report.
+          1 : All level 0 information plus one-line attribute status summary.
+          2 : All level 1 information plus extended attribute status report.
+          3 : All level 2 information plus file names.
    -q, --quiet
          Quiet mode. Do not produce output.
    --enable-error-stack
@@ -109,6 +108,14 @@ usage: h5diff [OPTIONS] file1 file2 [obj1[ obj2]]
          excluded.
          This option can be used repeatedly to exclude multiple paths.
 
+   --exclude-attribute "path/to/object/with/attribute"
+         Exclude attributes on the specified path to an object when comparing files or groups.
+
+         If there are multiple paths to an object, only the specified path(s)
+         will be excluded; the comparison will include any path not explicitly
+         excluded.
+         This option can be used repeatedly to exclude multiple paths.
+
  Modes of output:
   Default mode: print the number of differences found and where they occured
   -r Report mode: print the above plus the differences
diff --git a/tools/test/h5diff/testfiles/h5diff_603.txt b/tools/test/h5diff/testfiles/h5diff_603.txt
index 36cd0efedbb..84111b3cd2d 100644
--- a/tools/test/h5diff/testfiles/h5diff_603.txt
+++ b/tools/test/h5diff/testfiles/h5diff_603.txt
@@ -18,10 +18,9 @@ usage: h5diff [OPTIONS] file1 file2 [obj1[ obj2]]
          Verbose mode with level. Print differences and list of objects.
          Level of detail depends on value of N:
           0 : Identical to '-v' or '--verbose'.
-          1 : All level 0 information plus one-line attribute
-              status summary.
-          2 : All level 1 information plus extended attribute
-              status report.
+          1 : All level 0 information plus one-line attribute status summary.
+          2 : All level 1 information plus extended attribute status report.
+          3 : All level 2 information plus file names.
    -q, --quiet
          Quiet mode. Do not produce output.
    --enable-error-stack
@@ -110,6 +109,14 @@ usage: h5diff [OPTIONS] file1 file2 [obj1[ obj2]]
          excluded.
          This option can be used repeatedly to exclude multiple paths.
 
+   --exclude-attribute "path/to/object/with/attribute"
+         Exclude attributes on the specified path to an object when comparing files or groups.
+
+         If there are multiple paths to an object, only the specified path(s)
+         will be excluded; the comparison will include any path not explicitly
+         excluded.
+         This option can be used repeatedly to exclude multiple paths.
+
  Modes of output:
   Default mode: print the number of differences found and where they occured
   -r Report mode: print the above plus the differences
diff --git a/tools/test/h5diff/testfiles/h5diff_606.txt b/tools/test/h5diff/testfiles/h5diff_606.txt
index c2e9ac1c048..d915d36a7be 100644
--- a/tools/test/h5diff/testfiles/h5diff_606.txt
+++ b/tools/test/h5diff/testfiles/h5diff_606.txt
@@ -18,10 +18,9 @@ usage: h5diff [OPTIONS] file1 file2 [obj1[ obj2]]
          Verbose mode with level. Print differences and list of objects.
          Level of detail depends on value of N:
           0 : Identical to '-v' or '--verbose'.
-          1 : All level 0 information plus one-line attribute
-              status summary.
-          2 : All level 1 information plus extended attribute
-              status report.
+          1 : All level 0 information plus one-line attribute status summary.
+          2 : All level 1 information plus extended attribute status report.
+          3 : All level 2 information plus file names.
    -q, --quiet
          Quiet mode. Do not produce output.
    --enable-error-stack
@@ -110,6 +109,14 @@ usage: h5diff [OPTIONS] file1 file2 [obj1[ obj2]]
          excluded.
          This option can be used repeatedly to exclude multiple paths.
 
+   --exclude-attribute "path/to/object/with/attribute"
+         Exclude attributes on the specified path to an object when comparing files or groups.
+
+         If there are multiple paths to an object, only the specified path(s)
+         will be excluded; the comparison will include any path not explicitly
+         excluded.
+         This option can be used repeatedly to exclude multiple paths.
+
  Modes of output:
   Default mode: print the number of differences found and where they occured
   -r Report mode: print the above plus the differences
diff --git a/tools/test/h5diff/testfiles/h5diff_612.txt b/tools/test/h5diff/testfiles/h5diff_612.txt
index 2e094321a14..1ef8cdf4873 100644
--- a/tools/test/h5diff/testfiles/h5diff_612.txt
+++ b/tools/test/h5diff/testfiles/h5diff_612.txt
@@ -18,10 +18,9 @@ usage: h5diff [OPTIONS] file1 file2 [obj1[ obj2]]
          Verbose mode with level. Print differences and list of objects.
          Level of detail depends on value of N:
           0 : Identical to '-v' or '--verbose'.
-          1 : All level 0 information plus one-line attribute
-              status summary.
-          2 : All level 1 information plus extended attribute
-              status report.
+          1 : All level 0 information plus one-line attribute status summary.
+          2 : All level 1 information plus extended attribute status report.
+          3 : All level 2 information plus file names.
    -q, --quiet
          Quiet mode. Do not produce output.
    --enable-error-stack
@@ -110,6 +109,14 @@ usage: h5diff [OPTIONS] file1 file2 [obj1[ obj2]]
          excluded.
          This option can be used repeatedly to exclude multiple paths.
 
+   --exclude-attribute "path/to/object/with/attribute"
+         Exclude attributes on the specified path to an object when comparing files or groups.
+
+         If there are multiple paths to an object, only the specified path(s)
+         will be excluded; the comparison will include any path not explicitly
+         excluded.
+         This option can be used repeatedly to exclude multiple paths.
+
  Modes of output:
   Default mode: print the number of differences found and where they occured
   -r Report mode: print the above plus the differences
diff --git a/tools/test/h5diff/testfiles/h5diff_615.txt b/tools/test/h5diff/testfiles/h5diff_615.txt
index a07de54f20f..881362e3f8f 100644
--- a/tools/test/h5diff/testfiles/h5diff_615.txt
+++ b/tools/test/h5diff/testfiles/h5diff_615.txt
@@ -18,10 +18,9 @@ usage: h5diff [OPTIONS] file1 file2 [obj1[ obj2]]
          Verbose mode with level. Print differences and list of objects.
          Level of detail depends on value of N:
           0 : Identical to '-v' or '--verbose'.
-          1 : All level 0 information plus one-line attribute
-              status summary.
-          2 : All level 1 information plus extended attribute
-              status report.
+          1 : All level 0 information plus one-line attribute status summary.
+          2 : All level 1 information plus extended attribute status report.
+          3 : All level 2 information plus file names.
    -q, --quiet
          Quiet mode. Do not produce output.
    --enable-error-stack
@@ -110,6 +109,14 @@ usage: h5diff [OPTIONS] file1 file2 [obj1[ obj2]]
          excluded.
          This option can be used repeatedly to exclude multiple paths.
 
+   --exclude-attribute "path/to/object/with/attribute"
+         Exclude attributes on the specified path to an object when comparing files or groups.
+
+         If there are multiple paths to an object, only the specified path(s)
+         will be excluded; the comparison will include any path not explicitly
+         excluded.
+         This option can be used repeatedly to exclude multiple paths.
+
  Modes of output:
   Default mode: print the number of differences found and where they occured
   -r Report mode: print the above plus the differences
diff --git a/tools/test/h5diff/testfiles/h5diff_621.txt b/tools/test/h5diff/testfiles/h5diff_621.txt
index 5f44dd74afa..ba39a994752 100644
--- a/tools/test/h5diff/testfiles/h5diff_621.txt
+++ b/tools/test/h5diff/testfiles/h5diff_621.txt
@@ -18,10 +18,9 @@ usage: h5diff [OPTIONS] file1 file2 [obj1[ obj2]]
          Verbose mode with level. Print differences and list of objects.
          Level of detail depends on value of N:
           0 : Identical to '-v' or '--verbose'.
-          1 : All level 0 information plus one-line attribute
-              status summary.
-          2 : All level 1 information plus extended attribute
-              status report.
+          1 : All level 0 information plus one-line attribute status summary.
+          2 : All level 1 information plus extended attribute status report.
+          3 : All level 2 information plus file names.
    -q, --quiet
          Quiet mode. Do not produce output.
    --enable-error-stack
@@ -110,6 +109,14 @@ usage: h5diff [OPTIONS] file1 file2 [obj1[ obj2]]
          excluded.
          This option can be used repeatedly to exclude multiple paths.
 
+   --exclude-attribute "path/to/object/with/attribute"
+         Exclude attributes on the specified path to an object when comparing files or groups.
+
+         If there are multiple paths to an object, only the specified path(s)
+         will be excluded; the comparison will include any path not explicitly
+         excluded.
+         This option can be used repeatedly to exclude multiple paths.
+
  Modes of output:
   Default mode: print the number of differences found and where they occured
   -r Report mode: print the above plus the differences
diff --git a/tools/test/h5diff/testfiles/h5diff_622.txt b/tools/test/h5diff/testfiles/h5diff_622.txt
index 2e28a42a6de..70421fc0cd0 100644
--- a/tools/test/h5diff/testfiles/h5diff_622.txt
+++ b/tools/test/h5diff/testfiles/h5diff_622.txt
@@ -18,10 +18,9 @@ usage: h5diff [OPTIONS] file1 file2 [obj1[ obj2]]
          Verbose mode with level. Print differences and list of objects.
          Level of detail depends on value of N:
           0 : Identical to '-v' or '--verbose'.
-          1 : All level 0 information plus one-line attribute
-              status summary.
-          2 : All level 1 information plus extended attribute
-              status report.
+          1 : All level 0 information plus one-line attribute status summary.
+          2 : All level 1 information plus extended attribute status report.
+          3 : All level 2 information plus file names.
    -q, --quiet
          Quiet mode. Do not produce output.
    --enable-error-stack
@@ -110,6 +109,14 @@ usage: h5diff [OPTIONS] file1 file2 [obj1[ obj2]]
          excluded.
          This option can be used repeatedly to exclude multiple paths.
 
+   --exclude-attribute "path/to/object/with/attribute"
+         Exclude attributes on the specified path to an object when comparing files or groups.
+
+         If there are multiple paths to an object, only the specified path(s)
+         will be excluded; the comparison will include any path not explicitly
+         excluded.
+         This option can be used repeatedly to exclude multiple paths.
+
  Modes of output:
   Default mode: print the number of differences found and where they occured
   -r Report mode: print the above plus the differences
diff --git a/tools/test/h5diff/testfiles/h5diff_623.txt b/tools/test/h5diff/testfiles/h5diff_623.txt
index 21cb90a1b06..0d74268196d 100644
--- a/tools/test/h5diff/testfiles/h5diff_623.txt
+++ b/tools/test/h5diff/testfiles/h5diff_623.txt
@@ -18,10 +18,9 @@ usage: h5diff [OPTIONS] file1 file2 [obj1[ obj2]]
          Verbose mode with level. Print differences and list of objects.
          Level of detail depends on value of N:
           0 : Identical to '-v' or '--verbose'.
-          1 : All level 0 information plus one-line attribute
-              status summary.
-          2 : All level 1 information plus extended attribute
-              status report.
+          1 : All level 0 information plus one-line attribute status summary.
+          2 : All level 1 information plus extended attribute status report.
+          3 : All level 2 information plus file names.
    -q, --quiet
          Quiet mode. Do not produce output.
    --enable-error-stack
@@ -110,6 +109,14 @@ usage: h5diff [OPTIONS] file1 file2 [obj1[ obj2]]
          excluded.
          This option can be used repeatedly to exclude multiple paths.
 
+   --exclude-attribute "path/to/object/with/attribute"
+         Exclude attributes on the specified path to an object when comparing files or groups.
+
+         If there are multiple paths to an object, only the specified path(s)
+         will be excluded; the comparison will include any path not explicitly
+         excluded.
+         This option can be used repeatedly to exclude multiple paths.
+
  Modes of output:
   Default mode: print the number of differences found and where they occured
   -r Report mode: print the above plus the differences
diff --git a/tools/test/h5diff/testfiles/h5diff_624.txt b/tools/test/h5diff/testfiles/h5diff_624.txt
index 92c98d94367..cb8b8b4c7cc 100644
--- a/tools/test/h5diff/testfiles/h5diff_624.txt
+++ b/tools/test/h5diff/testfiles/h5diff_624.txt
@@ -18,10 +18,9 @@ usage: h5diff [OPTIONS] file1 file2 [obj1[ obj2]]
          Verbose mode with level. Print differences and list of objects.
          Level of detail depends on value of N:
           0 : Identical to '-v' or '--verbose'.
-          1 : All level 0 information plus one-line attribute
-              status summary.
-          2 : All level 1 information plus extended attribute
-              status report.
+          1 : All level 0 information plus one-line attribute status summary.
+          2 : All level 1 information plus extended attribute status report.
+          3 : All level 2 information plus file names.
    -q, --quiet
          Quiet mode. Do not produce output.
    --enable-error-stack
@@ -110,6 +109,14 @@ usage: h5diff [OPTIONS] file1 file2 [obj1[ obj2]]
          excluded.
          This option can be used repeatedly to exclude multiple paths.
 
+   --exclude-attribute "path/to/object/with/attribute"
+         Exclude attributes on the specified path to an object when comparing files or groups.
+
+         If there are multiple paths to an object, only the specified path(s)
+         will be excluded; the comparison will include any path not explicitly
+         excluded.
+         This option can be used repeatedly to exclude multiple paths.
+
  Modes of output:
   Default mode: print the number of differences found and where they occured
   -r Report mode: print the above plus the differences
diff --git a/tools/test/h5diff/testfiles/h5diff_70.txt b/tools/test/h5diff/testfiles/h5diff_70.txt
index efa34ea0bd0..b0b8bf65dd4 100644
--- a/tools/test/h5diff/testfiles/h5diff_70.txt
+++ b/tools/test/h5diff/testfiles/h5diff_70.txt
@@ -1183,10 +1183,42 @@ position        opaque3D of </dset> opaque3D of </dset> difference
 [ 3 2 1 ]          24              0               24             
 24 differences found
 attribute: <reference of </dset>> and <reference of </dset>>
+Not comparable: <reference of </dset>> or <reference of </dset>> is an empty dataset
+Not comparable: <reference of </dset>> or <reference of </dset>> is an empty dataset
 0 differences found
 attribute: <reference2D of </dset>> and <reference2D of </dset>>
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
 0 differences found
 attribute: <reference3D of </dset>> and <reference3D of </dset>>
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
 0 differences found
 attribute: <string of </dset>> and <string of </dset>>
 size:           [2]           [2]
diff --git a/tools/test/h5diff/testfiles/h5diff_700.txt b/tools/test/h5diff/testfiles/h5diff_700.txt
index 851a407d788..6cf98936067 100644
--- a/tools/test/h5diff/testfiles/h5diff_700.txt
+++ b/tools/test/h5diff/testfiles/h5diff_700.txt
@@ -1187,10 +1187,42 @@ position        opaque3D of </dset> opaque3D of </dset> difference
 [ 3 2 1 ]          24              0               24             
 24 differences found
 attribute: <reference of </dset>> and <reference of </dset>>
+Not comparable: <reference of </dset>> or <reference of </dset>> is an empty dataset
+Not comparable: <reference of </dset>> or <reference of </dset>> is an empty dataset
 0 differences found
 attribute: <reference2D of </dset>> and <reference2D of </dset>>
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
 0 differences found
 attribute: <reference3D of </dset>> and <reference3D of </dset>>
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
 0 differences found
 attribute: <string of </dset>> and <string of </dset>>
 size:           [2]           [2]
diff --git a/tools/test/h5diff/testfiles/h5diff_701.txt b/tools/test/h5diff/testfiles/h5diff_701.txt
index 33f1a0f631c..418775449e1 100644
--- a/tools/test/h5diff/testfiles/h5diff_701.txt
+++ b/tools/test/h5diff/testfiles/h5diff_701.txt
@@ -1254,10 +1254,42 @@ position        opaque3D of </dset> opaque3D of </dset> difference
 [ 3 2 1 ]          24              0               24             
 24 differences found
 attribute: <reference of </dset>> and <reference of </dset>>
+Not comparable: <reference of </dset>> or <reference of </dset>> is an empty dataset
+Not comparable: <reference of </dset>> or <reference of </dset>> is an empty dataset
 0 differences found
 attribute: <reference2D of </dset>> and <reference2D of </dset>>
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
 0 differences found
 attribute: <reference3D of </dset>> and <reference3D of </dset>>
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
 0 differences found
 attribute: <string of </dset>> and <string of </dset>>
 size:           [2]           [2]
diff --git a/tools/test/h5diff/testfiles/h5diff_702.txt b/tools/test/h5diff/testfiles/h5diff_702.txt
index 851a407d788..6cf98936067 100644
--- a/tools/test/h5diff/testfiles/h5diff_702.txt
+++ b/tools/test/h5diff/testfiles/h5diff_702.txt
@@ -1187,10 +1187,42 @@ position        opaque3D of </dset> opaque3D of </dset> difference
 [ 3 2 1 ]          24              0               24             
 24 differences found
 attribute: <reference of </dset>> and <reference of </dset>>
+Not comparable: <reference of </dset>> or <reference of </dset>> is an empty dataset
+Not comparable: <reference of </dset>> or <reference of </dset>> is an empty dataset
 0 differences found
 attribute: <reference2D of </dset>> and <reference2D of </dset>>
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
 0 differences found
 attribute: <reference3D of </dset>> and <reference3D of </dset>>
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
 0 differences found
 attribute: <string of </dset>> and <string of </dset>>
 size:           [2]           [2]
diff --git a/tools/test/h5diff/testfiles/h5diff_703.txt b/tools/test/h5diff/testfiles/h5diff_703.txt
index 33f1a0f631c..418775449e1 100644
--- a/tools/test/h5diff/testfiles/h5diff_703.txt
+++ b/tools/test/h5diff/testfiles/h5diff_703.txt
@@ -1254,10 +1254,42 @@ position        opaque3D of </dset> opaque3D of </dset> difference
 [ 3 2 1 ]          24              0               24             
 24 differences found
 attribute: <reference of </dset>> and <reference of </dset>>
+Not comparable: <reference of </dset>> or <reference of </dset>> is an empty dataset
+Not comparable: <reference of </dset>> or <reference of </dset>> is an empty dataset
 0 differences found
 attribute: <reference2D of </dset>> and <reference2D of </dset>>
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
+Not comparable: <reference2D of </dset>> or <reference2D of </dset>> is an empty dataset
 0 differences found
 attribute: <reference3D of </dset>> and <reference3D of </dset>>
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
+Not comparable: <reference3D of </dset>> or <reference3D of </dset>> is an empty dataset
 0 differences found
 attribute: <string of </dset>> and <string of </dset>>
 size:           [2]           [2]
diff --git a/tools/test/h5diff/testfiles/h5diff_80.txt b/tools/test/h5diff/testfiles/h5diff_80.txt
index b223eed552d..11dccd88dd4 100644
--- a/tools/test/h5diff/testfiles/h5diff_80.txt
+++ b/tools/test/h5diff/testfiles/h5diff_80.txt
@@ -528,166 +528,166 @@ position        opaque3D        opaque3D        difference
 24 differences found
 dataset: </g1/reference> and </g1/reference>
 size:           [2]           [2]
-position                                        difference          
+position        reference       reference       difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference       reference       difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 4 differences found
 dataset: </g1/reference2D> and </g1/reference2D>
 size:           [2]           [2]
-position                                        difference          
+position        reference2D     reference2D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference2D     reference2D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference2D     reference2D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference2D     reference2D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference2D     reference2D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference2D     reference2D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 12 differences found
 dataset: </g1/reference3D> and </g1/reference3D>
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
 size:           [2]           [2]
-position                                        difference          
+position        reference3D     reference3D     difference          
 ------------------------------------------------------------
 [ 0 ]          1               0               1              
 [ 1 ]          2               0               2              
diff --git a/tools/test/h5diff/testfiles/h5diff_eps.txt b/tools/test/h5diff/testfiles/h5diff_eps.txt
new file mode 100644
index 00000000000..ef48cb6cbee
--- /dev/null
+++ b/tools/test/h5diff/testfiles/h5diff_eps.txt
@@ -0,0 +1,17 @@
+file1: diff_eps1.h5
+file2: diff_eps2.h5
+
+file1     file2
+---------------------------------------
+    x      x    /              
+    x      x    /DS1           
+
+
+group  : </> and </>
+0 differences found
+Attributes status:  0 common, 0 only in obj1, 0 only in obj2
+
+dataset: </DS1> and </DS1>
+0 differences found
+Attributes status:  0 common, 0 only in obj1, 0 only in obj2
+EXIT CODE: 0
diff --git a/tools/test/h5diff/testfiles/h5diff_reg.txt b/tools/test/h5diff/testfiles/h5diff_reg.txt
index d4f54156ab7..ecb627527dd 100644
--- a/tools/test/h5diff/testfiles/h5diff_reg.txt
+++ b/tools/test/h5diff/testfiles/h5diff_reg.txt
@@ -1,12 +1,11 @@
 
 dataset: </Dataset3> and </Dataset3>
-attribute: <Attr1 of <(null)>> and <Attr1 of <(null)>>
+attribute: <Attr1 of <Dataset3>> and <Attr1 of <Dataset3>>
 0 differences found
-Warning: Cannot open referenced attribute: attribute 1
-Warning: Cannot open referenced attribute: attribute 2
-attribute: <Attr2 of <(null)>> and <Attr2 of <(null)>>
+Warning: Cannot open referenced attribute1
+attribute: <Attr2 of <Dataset3>> and <Attr2 of <Dataset3>>
 0 differences found
-attribute: <Attr3 of <(null)>> and <Attr3 of <(null)>>
+attribute: <Attr3 of <Dataset3>> and <Attr3 of <Dataset3>>
 0 differences found
 0 differences found
    obj1   obj2
diff --git a/tools/test/h5diff/testh5diff.sh.in b/tools/test/h5diff/testh5diff.sh.in
index 2d490a87723..1ac3100adfe 100644
--- a/tools/test/h5diff/testh5diff.sh.in
+++ b/tools/test/h5diff/testh5diff.sh.in
@@ -85,6 +85,7 @@ $SRC_H5DIFF_TESTFILES/h5diff_attr2.h5
 $SRC_H5DIFF_TESTFILES/h5diff_attr3.h5
 $SRC_H5DIFF_TESTFILES/h5diff_dset1.h5
 $SRC_H5DIFF_TESTFILES/h5diff_dset2.h5
+$SRC_H5DIFF_TESTFILES/h5diff_dset3.h5
 $SRC_H5DIFF_TESTFILES/h5diff_hyper1.h5
 $SRC_H5DIFF_TESTFILES/h5diff_hyper2.h5
 $SRC_H5DIFF_TESTFILES/h5diff_empty.h5
@@ -121,6 +122,8 @@ $SRC_H5DIFF_TESTFILES/non_comparables1.h5
 $SRC_H5DIFF_TESTFILES/non_comparables2.h5
 $SRC_H5DIFF_TESTFILES/diff_strings1.h5
 $SRC_H5DIFF_TESTFILES/diff_strings2.h5
+$SRC_H5DIFF_TESTFILES/diff_eps1.h5
+$SRC_H5DIFF_TESTFILES/diff_eps2.h5
 $SRC_TOOLS_TESTFILES/tvlstr.h5
 "
 
@@ -349,6 +352,8 @@ $SRC_H5DIFF_TESTFILES/h5diff_708.txt
 $SRC_H5DIFF_TESTFILES/h5diff_709.txt
 $SRC_H5DIFF_TESTFILES/h5diff_710.txt
 $SRC_H5DIFF_TESTFILES/h5diff_80.txt
+$SRC_H5DIFF_TESTFILES/h5diff_800.txt
+$SRC_H5DIFF_TESTFILES/h5diff_801.txt
 $SRC_H5DIFF_TESTFILES/h5diff_90.txt
 $SRC_H5DIFF_TESTFILES/h5diff_8625.txt
 $SRC_H5DIFF_TESTFILES/h5diff_8639.txt
@@ -357,6 +362,7 @@ $SRC_H5DIFF_TESTFILES/h5diff_v1.txt
 $SRC_H5DIFF_TESTFILES/h5diff_v2.txt
 $SRC_H5DIFF_TESTFILES/h5diff_v3.txt
 $SRC_H5DIFF_TESTFILES/h5diff_vlstr.txt
+$SRC_H5DIFF_TESTFILES/h5diff_eps.txt
 "
 
 #
@@ -763,6 +769,9 @@ TOOLTEST h5diff_609.txt -d 200 h5diff_basic1.h5 h5diff_basic2.h5 g1/dset3 g1/dse
 # 6.10: number smaller than smallest difference
 TOOLTEST h5diff_610.txt -d 1 h5diff_basic1.h5 h5diff_basic2.h5 g1/dset3 g1/dset4
 
+# eps: number smaller than epsilon
+TOOLTEST h5diff_eps.txt -v3 -d 1e-16 h5diff_eps1.h5 h5diff_eps2.h5
+
 
 # ##############################################################################
 # # -p
@@ -1183,6 +1192,12 @@ TOOLTEST h5diff_644.txt -v --use-system-epsilon -d 5 h5diff_basic1.h5 h5diff_bas
 TOOLTEST h5diff_645.txt -v -p 0.05 --use-system-epsilon h5diff_basic1.h5 h5diff_basic2.h5 /g1/dset3 /g1/dset4
 TOOLTEST h5diff_646.txt -v --use-system-epsilon -p 0.05 h5diff_basic1.h5 h5diff_basic2.h5 /g1/dset3 /g1/dset4
 
+# ##############################################################################
+# # Test array variances
+# ##############################################################################
+TOOLTEST h5diff_800 -v h5diff_dset1.h5 h5diff_dset2.h5 /g1/array /g1/array
+TOOLTEST h5diff_801 -v h5diff_dset1.h5 h5diff_dset3.h5 /g1/array /g1/array
+
 # ##############################################################################
 # VDS tests
 # ##############################################################################
diff --git a/tools/test/h5jam/tellub.c b/tools/test/h5jam/tellub.c
index 559c677a424..e7bb5616822 100644
--- a/tools/test/h5jam/tellub.c
+++ b/tools/test/h5jam/tellub.c
@@ -70,11 +70,11 @@ parse_command_line (int argc, const char *argv[])
         switch ((char) opt) {
             case 'h':
                 usage (h5tools_getprogname());
-                HDexit(EXIT_SUCCESS);
+                h5tools_setstatus(EXIT_SUCCESS);
             case '?':
             default:
                 usage (h5tools_getprogname());
-                HDexit(EXIT_FAILURE);
+                h5tools_setstatus(EXIT_FAILURE);
         }
     }
 
@@ -82,10 +82,17 @@ parse_command_line (int argc, const char *argv[])
     if (argc <= opt_ind) {
         error_msg("missing file name\n");
         usage (h5tools_getprogname());
-        HDexit(EXIT_FAILURE);
+        h5tools_setstatus(EXIT_FAILURE);
     }
 } /* end parse_command_line() */
 
+static void
+leave(int ret)
+{
+   h5tools_close();
+   HDexit(ret);
+}
+
 /*-------------------------------------------------------------------------
  * Function:    main
  *
@@ -98,8 +105,6 @@ int
 main (int argc, const char *argv[])
 {
     char *ifname;
-    void *edata;
-    H5E_auto2_t func;
     hid_t ifile;
     hsize_t usize;
     htri_t testval;
@@ -112,16 +117,16 @@ main (int argc, const char *argv[])
     /* Initialize h5tools lib */
     h5tools_init();
 
-    /* Disable error reporting */
-    H5Eget_auto2(H5E_DEFAULT, &func, &edata);
-    H5Eset_auto2(H5E_DEFAULT, NULL, NULL);
-
     parse_command_line(argc, argv);
 
+    /* enable error reporting if command line option */
+    h5tools_error_report();
+
     if(argc <= (opt_ind)) {
         error_msg("missing file name\n");
         usage (h5tools_getprogname());
-        return EXIT_FAILURE;
+        h5tools_setstatus(EXIT_FAILURE);
+        goto done;
     }
 
     ifname = HDstrdup(argv[opt_ind]);
@@ -130,33 +135,38 @@ main (int argc, const char *argv[])
 
     if(testval <= 0) {
         error_msg("Input HDF5 file is not HDF \"%s\"\n", ifname);
-        return EXIT_FAILURE;
+        h5tools_setstatus(EXIT_FAILURE);
+        goto done;
     }
 
     ifile = H5Fopen(ifname, H5F_ACC_RDONLY, H5P_DEFAULT);
 
     if(ifile < 0) {
         error_msg("Can't open input HDF5 file \"%s\"\n", ifname);
-        return EXIT_FAILURE;
+        h5tools_setstatus(EXIT_FAILURE);
+        goto done;
     }
 
     plist = H5Fget_create_plist(ifile);
     if(plist < 0) {
         error_msg("Can't get file creation plist for file \"%s\"\n", ifname);
-        return EXIT_FAILURE;
+        h5tools_setstatus(EXIT_FAILURE);
+        goto done;
     }
 
     status = H5Pget_userblock(plist, &usize);
     if(status < 0) {
         error_msg("Can't get user block for file \"%s\"\n", ifname);
-        return EXIT_FAILURE;
+        h5tools_setstatus(EXIT_FAILURE);
+        goto done;
     }
 
     HDprintf("%ld\n", (long) usize);
 
+done:
     H5Pclose (plist);
     H5Fclose (ifile);
 
-    return EXIT_SUCCESS;
+    leave(h5tools_getstatus());
 } /* end main() */
 
diff --git a/tools/testfiles/trefer_attrR.ddl b/tools/testfiles/trefer_attrR.ddl
index e64c8e6075b..118e7bfa7c9 100644
--- a/tools/testfiles/trefer_attrR.ddl
+++ b/tools/testfiles/trefer_attrR.ddl
@@ -12,16 +12,16 @@ GROUP "/" {
             }
          }
          ATTRIBUTE "trefer_attr.h5/Group1/Dataset2/Attr1" {
-               NULL
+            NULL
          }
-         ATTRIBUTE "trefer_attr.h5/Group1/Attr2"  {
+         ATTRIBUTE "trefer_attr.h5/Group1/Attr2" {
             DATATYPE  H5T_STD_U32LE
             DATASPACE  SIMPLE { ( 4 ) / ( 4 ) }
             DATA {
             (0): 1, 4, 7, 10
             }
          }
-         ATTRIBUTE "trefer_attr.h5/Group1/Datatype1/Attr3"  {
+         ATTRIBUTE "trefer_attr.h5/Group1/Datatype1/Attr3" {
             DATATYPE  H5T_STD_U32LE
             DATASPACE  SIMPLE { ( 4 ) / ( 4 ) }
             DATA {
diff --git a/tools/testfiles/trefer_extR.ddl b/tools/testfiles/trefer_extR.ddl
index 3d4647dab9a..a96e5fdc3fe 100644
--- a/tools/testfiles/trefer_extR.ddl
+++ b/tools/testfiles/trefer_extR.ddl
@@ -12,16 +12,16 @@ GROUP "/" {
             }
          }
          ATTRIBUTE "trefer_ext1.h5/Group1/Dataset2/Attr1" {
-               NULL
+            NULL
          }
-         ATTRIBUTE "trefer_ext1.h5/Group1/Attr2"  {
+         ATTRIBUTE "trefer_ext1.h5/Group1/Attr2" {
             DATATYPE  H5T_STD_U32LE
             DATASPACE  SIMPLE { ( 4 ) / ( 4 ) }
             DATA {
             (0): 1, 4, 7, 10
             }
          }
-         ATTRIBUTE "trefer_ext1.h5/Group1/Datatype1/Attr3"  {
+         ATTRIBUTE "trefer_ext1.h5/Group1/Datatype1/Attr3" {
             DATATYPE  H5T_STD_U32LE
             DATASPACE  SIMPLE { ( 4 ) / ( 4 ) }
             DATA {

From aa9d2bd9bcce7a1a53c9d9cf519df5401041bb74 Mon Sep 17 00:00:00 2001
From: Jerome Soumagne <jsoumagne@hdfgroup.org>
Date: Tue, 14 Jul 2020 20:00:47 -0500
Subject: [PATCH 31/55] H5R: fix type conversion of references within vlen type

Update trefer.c with vlen test case
---
 src/H5Rint.c  |   8 ++
 src/H5Tconv.c |  20 +++-
 src/H5Tref.c  |  63 +++++++-----
 test/trefer.c | 270 ++++++++++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 336 insertions(+), 25 deletions(-)

diff --git a/src/H5Rint.c b/src/H5Rint.c
index 30f3dbbb407..6dfbf2b5432 100644
--- a/src/H5Rint.c
+++ b/src/H5Rint.c
@@ -423,6 +423,10 @@ H5R__destroy(H5R_ref_priv_t *ref)
 
     HDassert(ref != NULL);
 
+    H5R_LOG_DEBUG("Destroying reference, filename=%s, obj_addr=%s, encode size=%u",
+        ref->info.obj.filename, H5R__print_token(ref->info.obj.token),
+        ref->encode_size);
+
     H5MM_xfree(ref->info.obj.filename);
     ref->info.obj.filename = NULL;
 
@@ -1028,6 +1032,10 @@ H5R__encode(const char *filename, const H5R_ref_priv_t *ref, unsigned char *buf,
             HGOTO_ERROR(H5E_REFERENCE, H5E_UNSUPPORTED, FAIL, "internal error (unknown reference type)")
     } /* end switch */
 
+    H5R_LOG_DEBUG("Encoded reference, filename=%s, obj_addr=%s, encode size=%u",
+        ref->info.obj.filename, H5R__print_token(ref->info.obj.token),
+        encode_size);
+
     *nalloc = encode_size;
 
 done:
diff --git a/src/H5Tconv.c b/src/H5Tconv.c
index 06eb44e31ba..15658cc997d 100644
--- a/src/H5Tconv.c
+++ b/src/H5Tconv.c
@@ -3110,8 +3110,24 @@ H5T__conv_vlen(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata, size_t nelmts,
             if(NULL == (tpath = H5T_path_find(src->shared->parent, dst->shared->parent)))
                 HGOTO_ERROR(H5E_DATATYPE, H5E_UNSUPPORTED, FAIL, "unable to convert between src and dest datatypes")
             else if(!H5T_path_noop(tpath)) {
-                if((tsrc_id = H5I_register(H5I_DATATYPE, H5T_copy(src->shared->parent, H5T_COPY_ALL), FALSE)) < 0 ||
-                        (tdst_id = H5I_register(H5I_DATATYPE, H5T_copy(dst->shared->parent, H5T_COPY_ALL), FALSE)) < 0)
+                H5T_t *tsrc_cpy = NULL, *tdst_cpy = NULL;
+
+                if(NULL == (tsrc_cpy = H5T_copy(src->shared->parent, H5T_COPY_ALL)))
+                    HGOTO_ERROR(H5E_DATATYPE, H5E_CANTCOPY, FAIL, "unable to copy src type for conversion")
+                /* References need to know about the src file */
+                if(tsrc_cpy->shared->type == H5T_REFERENCE)
+                    if(H5T_set_loc(tsrc_cpy, src->shared->u.vlen.file, H5T_LOC_MEMORY) < 0)
+                        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTSET, FAIL, "can't set datatype location");
+
+                if(NULL == (tdst_cpy = H5T_copy(dst->shared->parent, H5T_COPY_ALL)))
+                    HGOTO_ERROR(H5E_DATATYPE, H5E_CANTCOPY, FAIL, "unable to copy dst type for conversion")
+                /* References need to know about the dst file */
+                if(tdst_cpy->shared->type == H5T_REFERENCE)
+                    if(H5T_set_loc(tdst_cpy, dst->shared->u.vlen.file, H5T_LOC_MEMORY) < 0)
+                        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTSET, FAIL, "can't set datatype location");
+
+                if(((tsrc_id = H5I_register(H5I_DATATYPE, tsrc_cpy, FALSE)) < 0)
+                    || ((tdst_id = H5I_register(H5I_DATATYPE, tdst_cpy, FALSE)) < 0))
                     HGOTO_ERROR(H5E_DATASET, H5E_CANTREGISTER, FAIL, "unable to register types for conversion")
             } /* end else-if */
             else
diff --git a/src/H5Tref.c b/src/H5Tref.c
index b357baafaca..7c59e758c05 100644
--- a/src/H5Tref.c
+++ b/src/H5Tref.c
@@ -144,7 +144,9 @@ H5T__ref_set_loc(const H5T_t *dt, H5VL_object_t *file, H5T_loc_t loc)
 
     switch(loc) {
         case H5T_LOC_MEMORY: /* Memory based reference datatype */
-            HDassert(NULL == file);
+
+            /* NB. We allow for the file to be non-NULL when doing
+             * memory-to-memory conversion */
 
             /* Mark this type as being stored in memory */
             dt->shared->u.atomic.u.r.loc = H5T_LOC_MEMORY;
@@ -364,9 +366,8 @@ static size_t
 H5T__ref_mem_getsize(H5VL_object_t H5_ATTR_UNUSED *src_file, const void *src_buf,
     size_t H5_ATTR_UNUSED src_size, H5VL_object_t *dst_file, hbool_t *dst_copy)
 {
-    H5VL_object_t *vol_obj;             /* VOL object for src ref's location */
+    H5VL_object_t *vol_obj = NULL;      /* VOL object for src ref's location */
     const H5R_ref_priv_t *src_ref = (const H5R_ref_priv_t *)src_buf;
-    hbool_t files_equal = FALSE;        /* Whether src & dst references are in same file */
     char *file_name_buf_dyn = NULL;     /* Pointer to dynamically allocated buffer for file name, if static buffer is too small */
     unsigned flags = 0;                 /* References flags */
     size_t ret_value = 0;               /* Return value */
@@ -377,14 +378,18 @@ H5T__ref_mem_getsize(H5VL_object_t H5_ATTR_UNUSED *src_file, const void *src_buf
     HDassert(src_buf);
     HDassert(src_size == H5T_REF_MEM_SIZE);
 
-    /* Retrieve VOL object */
-    if(NULL == (vol_obj = H5VL_vol_object(src_ref->loc_id)))
-        HGOTO_ERROR(H5E_ARGS, H5E_BADTYPE, 0, "invalid location identifier")
+    if(NULL != dst_file) {
+        hbool_t files_equal = TRUE;         /* Whether src & dst references are in same file */
 
-    /* Set external flag if referenced file is not destination file */
-    if(H5VL_file_is_same(vol_obj, dst_file, &files_equal) < 0)
-        HGOTO_ERROR(H5E_REFERENCE, H5E_CANTCOMPARE, 0, "can't check if files are equal")
-    flags |= !files_equal ? H5R_IS_EXTERNAL : 0;
+        /* Retrieve VOL object */
+        if(NULL == (vol_obj = H5VL_vol_object(src_ref->loc_id)))
+            HGOTO_ERROR(H5E_ARGS, H5E_BADTYPE, 0, "invalid location identifier")
+
+        /* Set external flag if referenced file is not destination file */
+        if(H5VL_file_is_same(vol_obj, dst_file, &files_equal) < 0)
+            HGOTO_ERROR(H5E_REFERENCE, H5E_CANTCOMPARE, 0, "can't check if files are equal")
+        flags |= !files_equal ? H5R_IS_EXTERNAL : 0;
+    }
 
     /* Force re-calculating encoding size if any flags are set */
     if(flags || !src_ref->encode_size) {
@@ -458,8 +463,8 @@ H5T__ref_mem_read(H5VL_object_t H5_ATTR_UNUSED *src_file, const void *src_buf,
 {
     H5VL_object_t *vol_obj;             /* VOL object for src ref's location */
     const H5R_ref_priv_t *src_ref = (const H5R_ref_priv_t *)src_buf;
-    hbool_t files_equal = FALSE;        /* Whether src & dst references are in same file */
-    char file_name_buf_static[256];     /* File name */
+    hbool_t files_equal = TRUE;         /* Whether src & dst references are in same file */
+    char file_name_buf_static[256] = {'\0'}; /* File name */
     char *file_name_buf_dyn = NULL;     /* Pointer to dynamically allocated buffer for file name, if static buffer is too small */
     ssize_t file_name_len;              /* Size of file name buffer */
     unsigned flags = 0;                 /* References flags */
@@ -470,10 +475,15 @@ H5T__ref_mem_read(H5VL_object_t H5_ATTR_UNUSED *src_file, const void *src_buf,
     /* Sanity check */
     HDassert(src_buf);
     HDassert(src_size == H5T_REF_MEM_SIZE);
-    HDassert(dst_file);
     HDassert(dst_buf);
     HDassert(dst_size);
 
+    /* Memory-to-memory conversion to support vlen conversion */
+    if(NULL == dst_file) {
+        HDmemcpy(dst_buf, src_buf, dst_size);
+        HGOTO_DONE(ret_value);
+    }
+
     /* Retrieve VOL object */
     if(NULL == (vol_obj = H5VL_vol_object(src_ref->loc_id)))
         HGOTO_ERROR(H5E_ARGS, H5E_BADTYPE, 0, "invalid location identifier")
@@ -504,14 +514,16 @@ H5T__ref_mem_read(H5VL_object_t H5_ATTR_UNUSED *src_file, const void *src_buf,
             H5CX_set_libver_bounds(NULL);
     } /* end if */
 
-    /* Get file name */
-    if(H5VL_file_get(vol_obj, H5VL_FILE_GET_NAME, H5P_DATASET_XFER_DEFAULT, NULL, H5I_FILE, sizeof(file_name_buf_static), file_name_buf_static, &file_name_len) < 0)
-        HGOTO_ERROR(H5E_REFERENCE, H5E_CANTGET, 0, "can't get file name")
-    if(file_name_len >= (ssize_t)sizeof(file_name_buf_static)) {
-        if(NULL == (file_name_buf_dyn = (char *)H5MM_malloc((size_t)file_name_len + 1)))
-            HGOTO_ERROR(H5E_RESOURCE, H5E_CANTALLOC, 0, "can't allocate space for file name")
-        if(H5VL_file_get(vol_obj, H5VL_FILE_GET_NAME, H5P_DATASET_XFER_DEFAULT, NULL, H5I_FILE, (size_t)file_name_len + 1, file_name_buf_dyn, &file_name_len) < 0)
+    /* Get file name (if external reference) */
+    if(flags) {
+        if(H5VL_file_get(vol_obj, H5VL_FILE_GET_NAME, H5P_DATASET_XFER_DEFAULT, NULL, H5I_FILE, sizeof(file_name_buf_static), file_name_buf_static, &file_name_len) < 0)
             HGOTO_ERROR(H5E_REFERENCE, H5E_CANTGET, 0, "can't get file name")
+        if(file_name_len >= (ssize_t)sizeof(file_name_buf_static)) {
+            if(NULL == (file_name_buf_dyn = (char *)H5MM_malloc((size_t)file_name_len + 1)))
+                HGOTO_ERROR(H5E_RESOURCE, H5E_CANTALLOC, 0, "can't allocate space for file name")
+            if(H5VL_file_get(vol_obj, H5VL_FILE_GET_NAME, H5P_DATASET_XFER_DEFAULT, NULL, H5I_FILE, (size_t)file_name_len + 1, file_name_buf_dyn, &file_name_len) < 0)
+                HGOTO_ERROR(H5E_REFERENCE, H5E_CANTGET, 0, "can't get file name")
+        } /* end if */
     } /* end if */
 
     /* Encode reference */
@@ -539,7 +551,7 @@ H5T__ref_mem_write(H5VL_object_t *src_file, const void *src_buf, size_t src_size
     H5R_type_t src_type, H5VL_object_t H5_ATTR_UNUSED *dst_file, void *dst_buf,
     size_t dst_size, void H5_ATTR_UNUSED *bg_buf)
 {
-    H5F_t *src_f;
+    H5F_t *src_f = NULL;
     hid_t file_id = H5I_INVALID_HID;
     H5R_ref_priv_t *dst_ref = (H5R_ref_priv_t *)dst_buf;
     herr_t ret_value = SUCCEED;
@@ -547,14 +559,19 @@ H5T__ref_mem_write(H5VL_object_t *src_file, const void *src_buf, size_t src_size
     FUNC_ENTER_STATIC
 
     /* Sanity check */
-    HDassert(src_file);
     HDassert(src_buf);
     HDassert(src_size);
     HDassert(dst_buf);
     HDassert(dst_size == H5T_REF_MEM_SIZE);
 
+    /* Memory-to-memory conversion to support vlen conversion */
+    if(NULL == src_file) {
+        HDmemcpy(dst_buf, src_buf, src_size);
+        HGOTO_DONE(ret_value);
+    }
+
 #ifndef NDEBUG
-    {
+    if((src_type == H5R_OBJECT1) || (src_type == H5R_DATASET_REGION1)) {
         hbool_t is_native = FALSE;  /* Whether the src file is using the native VOL connector */
 
         /* Check if using native VOL connector */
diff --git a/test/trefer.c b/test/trefer.c
index 12651c7b33c..fd97239277c 100644
--- a/test/trefer.c
+++ b/test/trefer.c
@@ -23,6 +23,7 @@
 
 #define FILE_REF_PARAM      "trefer_param.h5"
 #define FILE_REF_OBJ        "trefer_obj.h5"
+#define FILE_REF_VL_OBJ     "trefer_vl_obj.h5"
 #define FILE_REF_REG        "trefer_reg.h5"
 #define FILE_REF_REG_1D     "trefer_reg_1d.h5"
 #define FILE_REF_OBJ_DEL    "trefer_obj_del.h5"
@@ -536,6 +537,273 @@ test_reference_obj(void)
     HDfree(obuf);
 }   /* test_reference_obj() */
 
+/****************************************************************
+**
+**  test_reference_vlen_obj(): Test basic H5R (reference) object reference
+**      within a vlen type.
+**      Tests references to various kinds of objects
+**
+****************************************************************/
+static void
+test_reference_vlen_obj(void)
+{
+    hid_t       fid1;       /* HDF5 File IDs                    */
+    hid_t       dataset,    /* Dataset ID                       */
+                dset2;      /* Dereferenced dataset ID          */
+    hid_t       group;      /* Group ID                         */
+    hid_t       sid1;       /* Dataspace ID                     */
+    hid_t       tid1;       /* Datatype ID                      */
+    hsize_t     dims1[] = {SPACE1_DIM1};
+    hsize_t     vl_dims[] = {1};
+    hid_t       dapl_id;    /* Dataset access property list     */
+    H5R_ref_t     *wbuf,       /* buffer to write to disk          */
+               *rbuf;       /* buffer read from disk            */
+    unsigned    *ibuf, *obuf;
+    unsigned         i, j;       /* Counters                         */
+    H5O_type_t  obj_type;   /* Object type                      */
+    herr_t      ret;        /* Generic return value             */
+    hvl_t       vl_wbuf = {0, NULL}, vl_rbuf = {0, NULL};
+
+    /* Output message about test being performed */
+    MESSAGE(5, ("Testing Object Reference Functions within VLEN type\n"));
+
+    /* Allocate write & read buffers */
+    wbuf = HDcalloc(sizeof(H5R_ref_t), SPACE1_DIM1);
+    rbuf = HDcalloc(sizeof(H5R_ref_t), SPACE1_DIM1);
+    ibuf = HDcalloc(sizeof(unsigned), SPACE1_DIM1);
+    obuf = HDcalloc(sizeof(unsigned), SPACE1_DIM1);
+
+    for (i = 0; i < SPACE1_DIM1; i++)
+        obuf[i] = i * 3;
+
+    /* Create file */
+    fid1 = H5Fcreate(FILE_REF_VL_OBJ, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
+    CHECK(fid1, H5I_INVALID_HID, "H5Fcreate");
+
+    /* Create dataspace for datasets */
+    sid1 = H5Screate_simple(SPACE1_RANK, dims1, NULL);
+    CHECK(sid1, H5I_INVALID_HID, "H5Screate_simple");
+
+    /* Create dataset access property list */
+    dapl_id = H5Pcreate(H5P_DATASET_ACCESS);
+    CHECK(dapl_id, H5I_INVALID_HID, "H5Pcreate");
+
+    /* Create a group */
+    group = H5Gcreate2(fid1, "Group1", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+    CHECK(group, H5I_INVALID_HID, "H5Gcreate2");
+
+    /* Create a dataset (inside Group1) */
+    dataset = H5Dcreate2(group, "Dataset1", H5T_NATIVE_UINT, sid1, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+    CHECK(dataset, H5I_INVALID_HID, "H5Dcreate2");
+
+    /* Write selection to disk */
+    ret = H5Dwrite(dataset, H5T_NATIVE_UINT, H5S_ALL, H5S_ALL, H5P_DEFAULT, obuf);
+    CHECK(ret, FAIL, "H5Dwrite");
+
+    /* Close Dataset */
+    ret = H5Dclose(dataset);
+    CHECK(ret, FAIL, "H5Dclose");
+
+    /* Create another dataset (inside Group1) */
+    dataset = H5Dcreate2(group, "Dataset2", H5T_NATIVE_UCHAR, sid1, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+    CHECK(dataset, FAIL, "H5Dcreate2");
+
+    /* Close Dataset */
+    ret = H5Dclose(dataset);
+    CHECK(ret, FAIL, "H5Dclose");
+
+    /* Close disk dataspace */
+    ret = H5Sclose(sid1);
+    CHECK(ret, FAIL, "H5Sclose");
+
+    /* Create a datatype to refer to */
+    tid1 = H5Tcreate(H5T_COMPOUND, sizeof(s1_t));
+    CHECK(tid1, H5I_INVALID_HID, "H5Tcreate");
+
+    /* Insert fields */
+    ret = H5Tinsert(tid1, "a", HOFFSET(s1_t,a), H5T_NATIVE_INT);
+    CHECK(ret, FAIL, "H5Tinsert");
+
+    ret = H5Tinsert(tid1, "b", HOFFSET(s1_t,b), H5T_NATIVE_INT);
+    CHECK(ret, FAIL, "H5Tinsert");
+
+    ret = H5Tinsert(tid1, "c", HOFFSET(s1_t,c), H5T_NATIVE_FLOAT);
+    CHECK(ret, FAIL, "H5Tinsert");
+
+    /* Save datatype for later */
+    ret = H5Tcommit2(group, "Datatype1", tid1, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+    CHECK(ret, FAIL, "H5Tcommit2");
+
+    /* Close datatype */
+    ret = H5Tclose(tid1);
+    CHECK(ret, FAIL, "H5Tclose");
+
+    /* Close group */
+    ret = H5Gclose(group);
+    CHECK(ret, FAIL, "H5Gclose");
+
+    /* Create vlen type */
+    tid1 = H5Tvlen_create(H5T_STD_REF);
+    CHECK(tid1, H5I_INVALID_HID, "H5Tvlen_create");
+
+    /* Create dataspace for datasets */
+    sid1 = H5Screate_simple(SPACE1_RANK, vl_dims, NULL);
+    CHECK(sid1, H5I_INVALID_HID, "H5Screate_simple");
+
+    /* Create a dataset */
+    dataset = H5Dcreate2(fid1, "Dataset3", tid1, sid1, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+    CHECK(dataset, H5I_INVALID_HID, "H5Dcreate2");
+
+    /* Create reference to dataset */
+    ret = H5Rcreate_object(fid1, "/Group1/Dataset1", H5P_DEFAULT, &wbuf[0]);
+    CHECK(ret, FAIL, "H5Rcreate_object");
+    ret = H5Rget_obj_type3(&wbuf[0], H5P_DEFAULT, &obj_type);
+    CHECK(ret, FAIL, "H5Rget_obj_type3");
+    VERIFY(obj_type, H5O_TYPE_DATASET, "H5Rget_obj_type3");
+
+    /* Create reference to dataset */
+    ret = H5Rcreate_object(fid1, "/Group1/Dataset2", H5P_DEFAULT, &wbuf[1]);
+    CHECK(ret, FAIL, "H5Rcreate_object");
+    ret = H5Rget_obj_type3(&wbuf[1], H5P_DEFAULT, &obj_type);
+    CHECK(ret, FAIL, "H5Rget_obj_type3");
+    VERIFY(obj_type, H5O_TYPE_DATASET, "H5Rget_obj_type3");
+
+    /* Create reference to group */
+    ret = H5Rcreate_object(fid1, "/Group1", H5P_DEFAULT, &wbuf[2]);
+    CHECK(ret, FAIL, "H5Rcreate_object");
+    ret = H5Rget_obj_type3(&wbuf[2], H5P_DEFAULT, &obj_type);
+    CHECK(ret, FAIL, "H5Rget_obj_type3");
+    VERIFY(obj_type, H5O_TYPE_GROUP, "H5Rget_obj_type3");
+
+    /* Create reference to named datatype */
+    ret = H5Rcreate_object(fid1, "/Group1/Datatype1", H5P_DEFAULT, &wbuf[3]);
+    CHECK(ret, FAIL, "H5Rcreate_object");
+    ret = H5Rget_obj_type3(&wbuf[3], H5P_DEFAULT, &obj_type);
+    CHECK(ret, FAIL, "H5Rget_obj_type3");
+    VERIFY(obj_type, H5O_TYPE_NAMED_DATATYPE, "H5Rget_obj_type3");
+
+    /* Store references into vlen */
+    vl_wbuf.len = SPACE1_DIM1;
+    vl_wbuf.p = wbuf;
+
+    /* Write selection to disk */
+    ret = H5Dwrite(dataset, tid1, H5S_ALL, H5S_ALL, H5P_DEFAULT, &vl_wbuf);
+    CHECK(ret, FAIL, "H5Dwrite");
+
+    /* Close disk dataspace */
+    ret = H5Sclose(sid1);
+    CHECK(ret, FAIL, "H5Sclose");
+
+    /* Close Dataset */
+    ret = H5Dclose(dataset);
+    CHECK(ret, FAIL, "H5Dclose");
+
+    /* Close datatype */
+    ret = H5Tclose(tid1);
+    CHECK(ret, FAIL, "H5Tclose");
+
+    /* Close file */
+    ret = H5Fclose(fid1);
+    CHECK(ret, FAIL, "H5Fclose");
+
+    /* Re-open the file */
+    fid1 = H5Fopen(FILE_REF_VL_OBJ, H5F_ACC_RDWR, H5P_DEFAULT);
+    CHECK(fid1, H5I_INVALID_HID, "H5Fopen");
+
+    /* Open the dataset */
+    dataset = H5Dopen2(fid1, "/Dataset3", H5P_DEFAULT);
+    CHECK(dataset, H5I_INVALID_HID, "H5Dopen2");
+
+    tid1 = H5Dget_type(dataset);
+    CHECK(tid1, H5I_INVALID_HID, "H5Dget_type");
+
+    /* Read selection from disk */
+    ret = H5Dread(dataset, tid1, H5S_ALL, H5S_ALL, H5P_DEFAULT, &vl_rbuf);
+    CHECK(ret, FAIL, "H5Dread");
+
+    VERIFY(vl_rbuf.len, SPACE1_DIM1, "H5Dread");
+    rbuf = vl_rbuf.p;
+
+    /* Close datatype */
+    ret = H5Tclose(tid1);
+    CHECK(ret, FAIL, "H5Tclose");
+
+    /* Open dataset object */
+    dset2 = H5Ropen_object(&rbuf[0], H5P_DEFAULT, dapl_id);
+    CHECK(dset2, H5I_INVALID_HID, "H5Ropen_object");
+
+    /* Check information in referenced dataset */
+    sid1 = H5Dget_space(dset2);
+    CHECK(sid1, H5I_INVALID_HID, "H5Dget_space");
+
+    ret = (int)H5Sget_simple_extent_npoints(sid1);
+    VERIFY(ret, SPACE1_DIM1, "H5Sget_simple_extent_npoints");
+
+    /* Read from disk */
+    ret = H5Dread(dset2, H5T_NATIVE_UINT, H5S_ALL, H5S_ALL, H5P_DEFAULT, ibuf);
+    CHECK(ret, FAIL, "H5Dread");
+
+    for(i = 0; i < SPACE1_DIM1; i++)
+        VERIFY(ibuf[i], i * 3, "Data");
+
+    /* Close dereferenced Dataset */
+    ret = H5Dclose(dset2);
+    CHECK(ret, FAIL, "H5Dclose");
+
+    /* Open group object.  GAPL isn't supported yet.  But it's harmless to pass in */
+    group = H5Ropen_object(&rbuf[2], H5P_DEFAULT, H5P_DEFAULT);
+    CHECK(group, H5I_INVALID_HID, "H5Ropen_object");
+
+    /* Close group */
+    ret = H5Gclose(group);
+    CHECK(ret, FAIL, "H5Gclose");
+
+    /* Open datatype object. TAPL isn't supported yet.  But it's harmless to pass in */
+    tid1 = H5Ropen_object(&rbuf[3], H5P_DEFAULT, H5P_DEFAULT);
+    CHECK(tid1, H5I_INVALID_HID, "H5Ropen_object");
+
+    /* Verify correct datatype */
+    {
+        H5T_class_t tclass;
+
+        tclass = H5Tget_class(tid1);
+        VERIFY(tclass, H5T_COMPOUND, "H5Tget_class");
+
+        ret= H5Tget_nmembers(tid1);
+        VERIFY(ret, 3, "H5Tget_nmembers");
+    }
+
+    /* Close datatype */
+    ret = H5Tclose(tid1);
+    CHECK(ret, FAIL, "H5Tclose");
+
+    /* Close Dataset */
+    ret = H5Dclose(dataset);
+    CHECK(ret, FAIL, "H5Dclose");
+
+    /* Close dataset access property list */
+    ret = H5Pclose(dapl_id);
+    CHECK(ret, FAIL, "H5Pclose");
+
+    /* Close file */
+    ret = H5Fclose(fid1);
+    CHECK(ret, FAIL, "H5Fclose");
+
+    /* Destroy references */
+    for(j = 0; j < SPACE1_DIM1; j++) {
+        ret = H5Rdestroy(&wbuf[j]);
+        CHECK(ret, FAIL, "H5Rdestroy");
+        ret = H5Rdestroy(&rbuf[j]);
+        CHECK(ret, FAIL, "H5Rdestroy");
+    }
+
+    /* Free memory buffers */
+    HDfree(wbuf);
+    HDfree(rbuf);
+    HDfree(ibuf);
+    HDfree(obuf);
+}   /* test_reference_vlen_obj() */
+
 /****************************************************************
 **
 **  test_reference_region(): Test basic H5R (reference) object reference code.
@@ -2862,6 +3130,7 @@ test_reference(void)
 
     test_reference_params();    /* Test for correct parameter checking */
     test_reference_obj();       /* Test basic H5R object reference code */
+    test_reference_vlen_obj();  /* Test reference within vlen */
 
     /* Loop through all the combinations of low/high version bounds */
     for(low = H5F_LIBVER_EARLIEST; low < H5F_LIBVER_NBOUNDS; low++) {
@@ -2907,6 +3176,7 @@ cleanup_reference(void)
 {
     HDremove(FILE_REF_PARAM);
     HDremove(FILE_REF_OBJ);
+    HDremove(FILE_REF_VL_OBJ);
     HDremove(FILE_REF_REG);
     HDremove(FILE_REF_REG_1D);
     HDremove(FILE_REF_OBJ_DEL);

From e5145030a4ada243a1ced9e10b87cfff5ccdfff4 Mon Sep 17 00:00:00 2001
From: Allen Byrne <byrn@hdfgroup.org>
Date: Thu, 16 Jul 2020 08:31:48 -0500
Subject: [PATCH 32/55] Correct file name in test

---
 tools/test/h5diff/testh5diff.sh.in | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/tools/test/h5diff/testh5diff.sh.in b/tools/test/h5diff/testh5diff.sh.in
index 1ac3100adfe..27b6ffacbac 100644
--- a/tools/test/h5diff/testh5diff.sh.in
+++ b/tools/test/h5diff/testh5diff.sh.in
@@ -770,7 +770,7 @@ TOOLTEST h5diff_609.txt -d 200 h5diff_basic1.h5 h5diff_basic2.h5 g1/dset3 g1/dse
 TOOLTEST h5diff_610.txt -d 1 h5diff_basic1.h5 h5diff_basic2.h5 g1/dset3 g1/dset4
 
 # eps: number smaller than epsilon
-TOOLTEST h5diff_eps.txt -v3 -d 1e-16 h5diff_eps1.h5 h5diff_eps2.h5
+TOOLTEST h5diff_eps.txt -v3 -d 1e-16 diff_eps1.h5 diff_eps2.h5
 
 
 # ##############################################################################

From 3023b34272cc6ada84aebfa7441a6a55afa3621c Mon Sep 17 00:00:00 2001
From: vchoi <vchoi@jelly.ad.hdfgroup.org>
Date: Thu, 16 Jul 2020 16:40:11 -0500
Subject: [PATCH 33/55] Update MANIFEST. Add new test to Cmake.

---
 MANIFEST            | 1 +
 test/CMakeLists.txt | 1 +
 2 files changed, 2 insertions(+)

diff --git a/MANIFEST b/MANIFEST
index a20b24822a7..870768e9623 100644
--- a/MANIFEST
+++ b/MANIFEST
@@ -1249,6 +1249,7 @@
 ./test/ttsafe.c
 ./test/ttsafe.h
 ./test/ttsafe_acreate.c
+./test/ttsafe_attr_vlen.c
 ./test/ttsafe_cancel.c
 ./test/ttsafe_dcreate.c
 ./test/ttsafe_error.c
diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt
index 009a0717665..311d753663b 100644
--- a/test/CMakeLists.txt
+++ b/test/CMakeLists.txt
@@ -222,6 +222,7 @@ set (ttsafe_SOURCES
     ${HDF5_TEST_SOURCE_DIR}/ttsafe_error.c
     ${HDF5_TEST_SOURCE_DIR}/ttsafe_cancel.c
     ${HDF5_TEST_SOURCE_DIR}/ttsafe_acreate.c
+    ${HDF5_TEST_SOURCE_DIR}/ttsafe_attr_vlen.c
 )
 
 set (H5_TESTS

From 6388a6750ff1dc476b8631d26cd1742730df9fe8 Mon Sep 17 00:00:00 2001
From: Dana Robinson <derobins@hdfgroup.org>
Date: Fri, 17 Jul 2020 05:17:48 -0700
Subject: [PATCH 34/55] Minor normalization with 1.10

---
 src/H5Dchunk.c  |  4 ++--
 src/H5Shyper.c  | 39 +++++++++++++++++++--------------------
 src/H5Spoint.c  | 16 ++++++++--------
 src/H5Sselect.c |  2 +-
 4 files changed, 30 insertions(+), 31 deletions(-)

diff --git a/src/H5Dchunk.c b/src/H5Dchunk.c
index 62e3ec5a4ad..ee835640a7d 100644
--- a/src/H5Dchunk.c
+++ b/src/H5Dchunk.c
@@ -3147,8 +3147,8 @@ H5D__chunk_create(const H5D_t *dset /*in,out*/)
 /*-------------------------------------------------------------------------
  * Function:    H5D__chunk_hash_val
  *
- * Purpose:    To calculate an index based on the dataset's scaled
- *        coordinates and sizes of the faster dimensions.
+ * Purpose:     To calculate an index based on the dataset's scaled
+ *              coordinates and sizes of the faster dimensions.
  *
  * Return:    Hash value index
  *
diff --git a/src/H5Shyper.c b/src/H5Shyper.c
index 7d99f39b209..9f75785c7cb 100644
--- a/src/H5Shyper.c
+++ b/src/H5Shyper.c
@@ -12,7 +12,7 @@
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 /*
- * Programmer:  Quincey Koziol <koziol@ncsa.uiuc.edu>
+ * Programmer:  Quincey Koziol
  *              Thursday, June 18, 1998
  *
  * Purpose:     Hyperslab selection dataspace I/O functions.
@@ -1756,7 +1756,7 @@ H5S__hyper_iter_get_seq_list_gen(H5S_sel_iter_t *iter, size_t maxseq, size_t max
         /* Work back up through the dimensions */
         while(curr_dim >= 0) {
             /* Reset the current span */
-        curr_span = ispan[curr_dim];
+            curr_span = ispan[curr_dim];
 
             /* Increment absolute position */
             abs_arr[curr_dim]++;
@@ -2110,15 +2110,15 @@ H5S__hyper_iter_get_seq_list_opt(H5S_sel_iter_t *iter, size_t maxseq, size_t max
     /* Read in data until an entire sequence can't be written out any longer */
     while(curr_rows > 0) {
 
-#define DUFF_GUTS                              \
-/* Store the sequence information */                      \
-off[curr_seq] = loc;                              \
-len[curr_seq] = actual_bytes;                          \
-                                                                      \
-/* Increment sequence count */                          \
-curr_seq++;                                  \
-                                                                      \
-/* Increment information to reflect block just processed */          \
+#define DUFF_GUTS                                                       \
+/* Store the sequence information */                                    \
+off[curr_seq] = loc;                                                    \
+len[curr_seq] = actual_bytes;                                           \
+                                                                        \
+/* Increment sequence count */                                          \
+curr_seq++;                                                             \
+                                                                        \
+/* Increment information to reflect block just processed */             \
 loc += fast_dim_buf_off;
 
 #ifdef NO_DUFFS_DEVICE
@@ -2574,7 +2574,6 @@ H5S__hyper_iter_get_seq_list_single(H5S_sel_iter_t *iter, size_t maxseq, size_t
  USAGE
     herr_t H5S__hyper_iter_get_seq_list(iter,maxseq,maxelem,nseq,nelem,off,len)
         H5S_t *space;           IN: Dataspace containing selection to use.
-        unsigned flags;         IN: Flags for extra information about operation
         H5S_sel_iter_t *iter;   IN/OUT: Selection iterator describing last
                                     position of interest in selection.
         size_t maxseq;          IN: Maximum number of sequences to generate
@@ -2808,7 +2807,7 @@ H5S__hyper_new_span(hsize_t low, hsize_t high, H5S_hyper_span_info_t *down,
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_new_span() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_new_span_info
@@ -4285,7 +4284,7 @@ H5S__hyper_deserialize(H5S_t **space, const uint8_t **p)
          /* Check for unknown flags */
         if(flags & ~H5S_SELECT_FLAG_BITS)
             HGOTO_ERROR(H5E_DATASPACE, H5E_CANTLOAD, FAIL, "unknown flag for selection")
-     } /* end if */
+     }
      else {
         /* Skip over the remainder of the header */
         pp += 8;
@@ -4301,7 +4300,7 @@ H5S__hyper_deserialize(H5S_t **space, const uint8_t **p)
 
     if(!*space) {
         /* Patch the rank of the allocated dataspace */
-        (void)HDmemset(dims, 0, (size_t)rank * sizeof(dims[0]));
+        HDmemset(dims, 0, (size_t)rank * sizeof(dims[0]));
         if(H5S_set_extent_simple(tmp_space, rank, dims, NULL) < 0)
             HGOTO_ERROR(H5E_DATASPACE, H5E_CANTINIT, FAIL, "can't set dimensions")
     } /* end if */
@@ -4316,7 +4315,7 @@ H5S__hyper_deserialize(H5S_t **space, const uint8_t **p)
 
         /* Sanity checks */
         HDassert(H5S_UNLIMITED == HSIZE_UNDEF);
-        HDassert(version >= 2);
+        HDassert(version >= H5S_HYPER_VERSION_2);
 
          /* Decode start/stride/block/count */
         switch(enc_size) {
@@ -4462,7 +4461,7 @@ H5S__hyper_deserialize(H5S_t **space, const uint8_t **p)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_deserialize() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__hyper_span_blocklist
@@ -4567,7 +4566,7 @@ H5S__hyper_span_blocklist(const H5S_hyper_span_info_t *spans, hsize_t start[],
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__hyper_span_blocklist() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__get_select_hyper_blocklist
@@ -7061,7 +7060,7 @@ H5S__hyper_adjust_s(H5S_t *space, const hssize_t *offset)
              * simultaneous operations */
             H5S__hyper_adjust_s_helper(space->select.sel_info.hslab->span_lst, space->extent.rank, offset, 0, op_gen);
         } /* end if */
-    } /* end if */
+    }
 
 done:
     FUNC_LEAVE_NOAPI(ret_value)
@@ -12175,7 +12174,7 @@ H5S_hyper_get_first_inc_block(const H5S_t *space, hsize_t clip_size,
     hbool_t *partial)
 {
     H5S_hyper_sel_t *hslab;     /* Convenience pointer to hyperslab info */
-    H5S_hyper_dim_t *diminfo;   /* Convenience pointer to diminfo.opt in unlimited dimension */
+    H5S_hyper_dim_t *diminfo;   /* Convenience pointer to diminfo in unlimited dimension */
     hsize_t ret_value = 0;
 
     FUNC_ENTER_NOAPI(0)
diff --git a/src/H5Spoint.c b/src/H5Spoint.c
index 60e810d2c25..be9015fac9f 100644
--- a/src/H5Spoint.c
+++ b/src/H5Spoint.c
@@ -78,7 +78,7 @@ static htri_t H5S__point_shape_same(const H5S_t *space1, const H5S_t *space2);
 static htri_t H5S__point_intersect_block(const H5S_t *space, const hsize_t *start, const hsize_t *end);
 static herr_t H5S__point_adjust_u(H5S_t *space, const hsize_t *offset);
 static herr_t H5S__point_adjust_s(H5S_t *space, const hssize_t *offset);
-static herr_t H5S__point_project_scalar(const H5S_t *spasce, hsize_t *offset);
+static herr_t H5S__point_project_scalar(const H5S_t *space, hsize_t *offset);
 static herr_t H5S__point_project_simple(const H5S_t *space, H5S_t *new_space, hsize_t *offset);
 static herr_t H5S__point_iter_init(const H5S_t *space, H5S_sel_iter_t *iter);
 static herr_t H5S__point_get_version_enc_size(const H5S_t *space, uint32_t *version, uint8_t *enc_size);
@@ -538,7 +538,7 @@ H5S__point_iter_get_seq_list(H5S_sel_iter_t *iter, size_t maxseq, size_t maxelem
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__point_iter_get_seq_list() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__point_iter_release
@@ -873,7 +873,7 @@ H5S__copy_pnt_list(const H5S_pnt_list_t *src, unsigned rank)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__copy_pnt_list() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__free_pnt_list
@@ -915,7 +915,7 @@ H5S__free_pnt_list(H5S_pnt_list_t *pnt_lst)
     FUNC_LEAVE_NOAPI_VOID
 } /* end H5S__free_pnt_list() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__point_copy
@@ -943,7 +943,7 @@ H5S__point_copy(H5S_t *dst, const H5S_t *src, hbool_t H5_ATTR_UNUSED share_selec
 
     FUNC_ENTER_STATIC
 
-    /* Sanity check */
+    /* Sanity checks */
     HDassert(src);
     HDassert(dst);
 
@@ -1189,7 +1189,7 @@ H5S__point_serial_size(const H5S_t *space)
 
     /* Determine the version and encoded size for point selection */
     if(H5S__point_get_version_enc_size(space, &version, &enc_size) < 0)
-        HGOTO_ERROR(H5E_DATASPACE, H5E_CANTGET, FAIL, "can't determine hyper version")
+        HGOTO_ERROR(H5E_DATASPACE, H5E_CANTGET, FAIL, "can't determine version and enc_size")
 
     /* Basic number of bytes required to serialize point selection: */
     if(version >= H5S_POINT_VERSION_2)
@@ -1259,7 +1259,7 @@ H5S__point_serialize(const H5S_t *space, uint8_t **p)
 
     /* Determine the version and encoded size for point selection info */
     if(H5S__point_get_version_enc_size(space, &version, &enc_size) < 0)
-        HGOTO_ERROR(H5E_DATASPACE, H5E_CANTGET, FAIL, "can't determine hyper version")
+        HGOTO_ERROR(H5E_DATASPACE, H5E_CANTGET, FAIL, "can't determine version and enc_size")
 
     /* Store the preamble information */
     UINT32ENCODE(pp, (uint32_t)H5S_GET_SELECT_TYPE(space));  /* Store the type of selection */
@@ -1997,7 +1997,7 @@ H5S__point_shape_same(const H5S_t *space1, const H5S_t *space2)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S__point_shape_same() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5S__point_intersect_block
diff --git a/src/H5Sselect.c b/src/H5Sselect.c
index 901dec1318a..c9d7fc0908a 100644
--- a/src/H5Sselect.c
+++ b/src/H5Sselect.c
@@ -1171,7 +1171,7 @@ H5S_select_iter_init(H5S_sel_iter_t *sel_iter, const H5S_t *space,
     if(sel_iter->rank > 0) {
         H5MM_memcpy(sel_iter->dims, space->extent.size, sizeof(hsize_t) * space->extent.rank);
         H5MM_memcpy(sel_iter->sel_off, space->select.offset, sizeof(hsize_t) * space->extent.rank);
-    } /* end if */
+    }
 
     /* Save the element size */
     sel_iter->elmt_size = elmt_size;

From a2f2887675c2371570cc7084eb7589ecf06ce41c Mon Sep 17 00:00:00 2001
From: Allen Byrne <byrn@hdfgroup.org>
Date: Fri, 17 Jul 2020 13:22:26 -0500
Subject: [PATCH 35/55] add test file ext

---
 .github/workflows/main.yml         | 4 ++--
 tools/test/h5diff/testh5diff.sh.in | 4 ++--
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/.github/workflows/main.yml b/.github/workflows/main.yml
index a3fdadb0543..60e21c78c29 100644
--- a/.github/workflows/main.yml
+++ b/.github/workflows/main.yml
@@ -4,8 +4,8 @@ name: hdf5 dev CI
 on:
   push:
     branches: [ develop, hdf5_1_12, hdf5_1_10, hdf5_1_8 ]
-#  pull_request:
-#    branches: [ develop ]
+  pull_request:
+    branches: [ develop, hdf5_1_12, hdf5_1_10, hdf5_1_8 ]
 
 # A workflow run is made up of one or more jobs that can run sequentially or in parallel
 jobs:
diff --git a/tools/test/h5diff/testh5diff.sh.in b/tools/test/h5diff/testh5diff.sh.in
index 27b6ffacbac..84330eca5d2 100644
--- a/tools/test/h5diff/testh5diff.sh.in
+++ b/tools/test/h5diff/testh5diff.sh.in
@@ -1195,8 +1195,8 @@ TOOLTEST h5diff_646.txt -v --use-system-epsilon -p 0.05 h5diff_basic1.h5 h5diff_
 # ##############################################################################
 # # Test array variances
 # ##############################################################################
-TOOLTEST h5diff_800 -v h5diff_dset1.h5 h5diff_dset2.h5 /g1/array /g1/array
-TOOLTEST h5diff_801 -v h5diff_dset1.h5 h5diff_dset3.h5 /g1/array /g1/array
+TOOLTEST h5diff_800.txt -v h5diff_dset1.h5 h5diff_dset2.h5 /g1/array /g1/array
+TOOLTEST h5diff_801.txt -v h5diff_dset1.h5 h5diff_dset3.h5 /g1/array /g1/array
 
 # ##############################################################################
 # VDS tests

From bae81076214de5b168a2582c0bf88a57b69f99f0 Mon Sep 17 00:00:00 2001
From: Allen Byrne <byrn@hdfgroup.org>
Date: Mon, 20 Jul 2020 10:26:17 -0500
Subject: [PATCH 36/55] Add release notes for tools

---
 release_docs/RELEASE.txt | 40 ++++++++++++++++++++++++++++++++++++++--
 1 file changed, 38 insertions(+), 2 deletions(-)

diff --git a/release_docs/RELEASE.txt b/release_docs/RELEASE.txt
index 84f339a28f5..42ce5e46269 100644
--- a/release_docs/RELEASE.txt
+++ b/release_docs/RELEASE.txt
@@ -659,7 +659,7 @@ Bug Fixes since HDF5-1.10.3 release
     - Fixed the segmentation fault when reading attributes with multiple threads
 
       It was reported that the reading of attributes with variable length string
-      datatype will crash with segmentation fault particularly when the number of 
+      datatype will crash with segmentation fault particularly when the number of
       threads is high (>16 threads).  The problem was due to the file pointer that
       was set in the variable length string datatype for the attribute.  That file
       pointer was already closed when the attribute was accessed.
@@ -1028,7 +1028,43 @@ Bug Fixes since HDF5-1.10.3 release
 
     Tools
     -----
-    -
+    - The tools library was updated by standardizing the error stack process.
+
+      General sequence is:
+          h5tools_setprogname(PROGRAMNAME);
+          h5tools_setstatus(EXIT_SUCCESS);
+          h5tools_init();
+          ... process the command-line (check for error-stack enable) ...
+          h5tools_error_report();
+          ... (do work) ...
+          h5diff_exit(ret);
+
+      (ADB - 2020/07/20, HDFFV-11066)
+
+    - h5diff fixed a command line parsing error.
+
+      h5diff would ignore the argument to -d (delta) if it is smaller than DBL_EPSILON.
+      The macro H5_DBL_ABS_EQUAL was removed and a direct value comparision was used.
+
+      (ADB - 2020/07/20, HDFFV-10897)
+
+    - h5diff added a command line option to ignore attributes.
+
+      h5diff would ignore all objects with a supplied path if the exclude-path argument is used.
+      Adding the exclude-attribute argument will only eclude attributes, with the supplied path,
+      from comparision.
+
+      (ADB - 2020/07/20, HDFFV-5935)
+
+    - h5diff added another level to the verbose argument to print filenames.
+
+      Added verbose level 3 that is level 2 plus the filenames. The levels are:
+          0 : Identical to '-v' or '--verbose'
+          1 : All level 0 information plus one-line attribute status summary
+          2 : All level 1 information plus extended attribute status report
+          3 : All level 2 information plus file names
+
+      (ADB - 2020/07/20, HDFFV-10005)
 
     High-Level APIs:
     ------

From 242459231b40a88741cbc85df4272914b5d8bed3 Mon Sep 17 00:00:00 2001
From: Dana Robinson <derobins@hdfgroup.org>
Date: Mon, 20 Jul 2020 11:50:10 -0700
Subject: [PATCH 37/55] Minor normalization with 1.10.

---
 src/H5B2pkg.h       |   2 +-
 src/H5B2private.h   |   2 +-
 src/H5Bmodule.h     |   2 +-
 src/H5Bpkg.h        |   2 +-
 src/H5Bprivate.h    |   4 +-
 src/H5CXmodule.h    |   2 +-
 src/H5Cmpio.c       | 256 ++++++++++++++++++++++----------------------
 src/H5Dmodule.h     |   2 +-
 src/H5Dpkg.h        |   2 +-
 src/H5EAmodule.h    |   2 +-
 src/H5EApkg.h       |   2 +-
 src/H5EAprivate.h   |   2 +-
 src/H5EAsblock.c    |   8 +-
 src/H5Glink.c       |   8 +-
 src/H5Gloc.c        |   2 +-
 src/H5Gname.c       |  23 ++--
 src/H5Gnode.c       |  19 +---
 src/H5HLmodule.h    |   2 +-
 src/H5HLpkg.h       |   2 +-
 src/H5HLprivate.h   |   2 +-
 src/H5Zfletcher32.c |   2 +-
 src/H5Ztrans.c      |  47 +-------
 src/H5dbg.c         |   3 +-
 23 files changed, 162 insertions(+), 236 deletions(-)

diff --git a/src/H5B2pkg.h b/src/H5B2pkg.h
index 338db5ab4bc..7d73752cc20 100644
--- a/src/H5B2pkg.h
+++ b/src/H5B2pkg.h
@@ -12,7 +12,7 @@
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 /*
- * Programmer:	Quincey Koziol <koziol@ncsa.uiuc.edu>
+ * Programmer:	Quincey Koziol
  *		Monday, January 31, 2005
  *
  * Purpose:	This file contains declarations which are visible only within
diff --git a/src/H5B2private.h b/src/H5B2private.h
index 0b64381835a..9303d4f281d 100644
--- a/src/H5B2private.h
+++ b/src/H5B2private.h
@@ -15,7 +15,7 @@
  *
  * Created:		H5B2private.h
  *			Jan 31 2005
- *			Quincey Koziol <koziol@ncsa.uiuc.edu>
+ *			Quincey Koziol
  *
  * Purpose:		Private header for library accessible B-tree routines.
  *
diff --git a/src/H5Bmodule.h b/src/H5Bmodule.h
index bc4675224ea..c8e1546e570 100644
--- a/src/H5Bmodule.h
+++ b/src/H5Bmodule.h
@@ -11,7 +11,7 @@
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 /*
- * Programmer:	Quincey Koziol <koziol@hdfgroup.org>
+ * Programmer:	Quincey Koziol
  *		Saturday, September 12, 2015
  *
  * Purpose:	This file contains declarations which define macros for the
diff --git a/src/H5Bpkg.h b/src/H5Bpkg.h
index a451cabf15c..a57584e9d4d 100644
--- a/src/H5Bpkg.h
+++ b/src/H5Bpkg.h
@@ -12,7 +12,7 @@
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 /*
- * Programmer:	Quincey Koziol <koziol@ncsa.uiuc.edu>
+ * Programmer:	Quincey Koziol
  *		Thursday, May 15, 2003
  *
  * Purpose:	This file contains declarations which are visible only within
diff --git a/src/H5Bprivate.h b/src/H5Bprivate.h
index 5aa36289036..55bf5b3a521 100644
--- a/src/H5Bprivate.h
+++ b/src/H5Bprivate.h
@@ -15,12 +15,10 @@
  *
  * Created:		H5Bprivate.h
  *			Jul 10 1997
- *			Robb Matzke <matzke@llnl.gov>
+ *			Robb Matzke
  *
  * Purpose:		Private non-prototype header.
  *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 
diff --git a/src/H5CXmodule.h b/src/H5CXmodule.h
index f6a8f2982b9..186f8aace88 100644
--- a/src/H5CXmodule.h
+++ b/src/H5CXmodule.h
@@ -11,7 +11,7 @@
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 /*
- * Programmer:	Quincey Koziol <koziol@lbl.gov>
+ * Programmer:	Quincey Koziol
  *		Sunday, February 25, 2018
  *
  * Purpose:	This file contains declarations which define macros for the
diff --git a/src/H5Cmpio.c b/src/H5Cmpio.c
index 0ac4c4f1c6b..199c494de83 100644
--- a/src/H5Cmpio.c
+++ b/src/H5Cmpio.c
@@ -18,7 +18,7 @@
  *              Quincey Koziol
  *
  * Purpose:     Functions in this file implement support for parallel I/O for
- *		generic cache code.
+ *              generic cache code.
  *
  *-------------------------------------------------------------------------
  */
@@ -28,20 +28,20 @@
 /****************/
 
 #include "H5Cmodule.h"          /* This source code file is part of the H5C module */
-#define H5F_FRIEND		/*suppress error about including H5Fpkg	  */
+#define H5F_FRIEND        /*suppress error about including H5Fpkg      */
 
 
 /***********/
 /* Headers */
 /***********/
-#include "H5private.h"		/* Generic Functions			*/
+#include "H5private.h"          /* Generic Functions                    */
 #include "H5ACprivate.h"        /* Metadata cache                       */
-#include "H5Cpkg.h"		/* Cache				*/
+#include "H5Cpkg.h"             /* Cache                                */
 #include "H5CXprivate.h"        /* API Contexts                         */
-#include "H5Eprivate.h"		/* Error handling		  	*/
-#include "H5Fpkg.h"		/* Files				*/
-#include "H5FDprivate.h"	/* File drivers				*/
-#include "H5MMprivate.h"	/* Memory management			*/
+#include "H5Eprivate.h"         /* Error handling                       */
+#include "H5Fpkg.h"             /* Files                                */
+#include "H5FDprivate.h"        /* File drivers                         */
+#include "H5MMprivate.h"        /* Memory management                    */
 
 
 #ifdef H5_HAVE_PARALLEL
@@ -87,74 +87,74 @@ static herr_t H5C__flush_candidates_in_ring(H5F_t *f, H5C_ring_t ring,
  *
  * Purpose:     Apply the supplied candidate list.
  *
- *		We used to do this by simply having each process write
- *		every mpi_size-th entry in the candidate list, starting
- *		at index mpi_rank, and mark all the others clean.
+ *              We used to do this by simply having each process write
+ *              every mpi_size-th entry in the candidate list, starting
+ *              at index mpi_rank, and mark all the others clean.
  *
- *		However, this can cause unnecessary contention in a file
- *		system by increasing the number of processes writing to
- *		adjacent locations in the HDF5 file.
+ *              However, this can cause unnecessary contention in a file
+ *              system by increasing the number of processes writing to
+ *              adjacent locations in the HDF5 file.
  *
- *		To attempt to minimize this, we now arange matters such
- *		that each process writes n adjacent entries in the
- *		candidate list, and marks all others clean.  We must do
- *		this in such a fashion as to guarantee that each entry
- *		on the candidate list is written by exactly one process,
- *		and marked clean by all others.
+ *              To attempt to minimize this, we now arange matters such
+ *              that each process writes n adjacent entries in the
+ *              candidate list, and marks all others clean.  We must do
+ *              this in such a fashion as to guarantee that each entry
+ *              on the candidate list is written by exactly one process,
+ *              and marked clean by all others.
  *
- *		To do this, first construct a table mapping mpi_rank
- *		to the index of the first entry in the candidate list to
- *		be written by the process of that mpi_rank, and then use
- *		the table to control which entries are written and which
- *		are marked as clean as a function of the mpi_rank.
+ *              To do this, first construct a table mapping mpi_rank
+ *              to the index of the first entry in the candidate list to
+ *              be written by the process of that mpi_rank, and then use
+ *              the table to control which entries are written and which
+ *              are marked as clean as a function of the mpi_rank.
  *
- *		Note that the table must be identical on all processes, as
- *		all see the same candidate list, mpi_size, and mpi_rank --
- *		the inputs used to construct the table.
+ *              Note that the table must be identical on all processes, as
+ *              all see the same candidate list, mpi_size, and mpi_rank --
+ *              the inputs used to construct the table.
  *
- *		We construct the table as follows.  Let:
+ *              We construct the table as follows.  Let:
  *
- *			n = num_candidates / mpi_size;
+ *                  n = num_candidates / mpi_size;
  *
- *			m = num_candidates % mpi_size;
+ *                  m = num_candidates % mpi_size;
  *
- *		Now allocate an array of integers of length mpi_size + 1,
- *		and call this array candidate_assignment_table.
+ *              Now allocate an array of integers of length mpi_size + 1,
+ *              and call this array candidate_assignment_table.
  *
- *		Conceptually, if the number of candidates is a multiple
- *		of the mpi_size, we simply pass through the candidate list
- *		and assign n entries to each process to flush, with the
- *		index of the first entry to flush in the location in
- *		the candidate_assignment_table indicated by the mpi_rank
- *		of the process.
+ *              Conceptually, if the number of candidates is a multiple
+ *              of the mpi_size, we simply pass through the candidate list
+ *              and assign n entries to each process to flush, with the
+ *              index of the first entry to flush in the location in
+ *              the candidate_assignment_table indicated by the mpi_rank
+ *              of the process.
  *
- *		In the more common case in which the candidate list isn't
- *		isn't a multiple of the mpi_size, we pretend it is, and
- *		give num_candidates % mpi_size processes one extra entry
- *		each to make things work out.
+ *              In the more common case in which the candidate list isn't
+ *              isn't a multiple of the mpi_size, we pretend it is, and
+ *              give num_candidates % mpi_size processes one extra entry
+ *              each to make things work out.
  *
- *		Once the table is constructed, we determine the first and
- *		last entry this process is to flush as follows:
+ *              Once the table is constructed, we determine the first and
+ *              last entry this process is to flush as follows:
  *
- *	 	first_entry_to_flush = candidate_assignment_table[mpi_rank]
+ *                  first_entry_to_flush = candidate_assignment_table[mpi_rank]
  *
- *		last_entry_to_flush =
- *			candidate_assignment_table[mpi_rank + 1] - 1;
+ *              last_entry_to_flush =
+ *                  candidate_assignment_table[mpi_rank + 1] - 1;
  *
- *		With these values determined, we simply scan through the
- *		candidate list, marking all entries in the range
- *		[first_entry_to_flush, last_entry_to_flush] for flush,
- *		and all others to be cleaned.
+ *              With these values determined, we simply scan through the
+ *              candidate list, marking all entries in the range
+ *              [first_entry_to_flush, last_entry_to_flush] for flush,
+ *              and all others to be cleaned.
  *
- *		Finally, we scan the LRU from tail to head, flushing
- *		or marking clean the candidate entries as indicated.
- *		If necessary, we scan the pinned list as well.
+ *              Finally, we scan the LRU from tail to head, flushing
+ *              or marking clean the candidate entries as indicated.
+ *              If necessary, we scan the pinned list as well.
  *
- *		Note that this function will fail if any protected or
- *		clean entries appear on the candidate list.
+ *              Note that this function will fail if any protected or
+ *              clean entries appear on the candidate list.
  *
- *		This function is used in managing sync points, and
- *		shouldn't be used elsewhere.
+ *              This function is used in managing sync points, and
+ *              shouldn't be used elsewhere.
  *
  * Return:      Success:        SUCCEED
  *
@@ -176,20 +176,20 @@ H5C_apply_candidate_list(H5F_t * f,
     int                 i;
     int                 m;
     unsigned            n;
-    unsigned		    first_entry_to_flush;
-    unsigned		    last_entry_to_flush;
-    unsigned		    total_entries_to_clear = 0;
-    unsigned		    total_entries_to_flush = 0;
+    unsigned            first_entry_to_flush;
+    unsigned            last_entry_to_flush;
+    unsigned            total_entries_to_clear = 0;
+    unsigned            total_entries_to_flush = 0;
     unsigned          * candidate_assignment_table = NULL;
     unsigned            entries_to_flush[H5C_RING_NTYPES];
     unsigned            entries_to_clear[H5C_RING_NTYPES];
-    haddr_t		addr;
-    H5C_cache_entry_t *	entry_ptr = NULL;
+    haddr_t             addr;
+    H5C_cache_entry_t * entry_ptr = NULL;
 #if H5C_DO_SANITY_CHECKS
-    haddr_t		last_addr;
+    haddr_t             last_addr;
 #endif /* H5C_DO_SANITY_CHECKS */
 #if H5C_APPLY_CANDIDATE_LIST__DEBUG
-    char		tbl_buf[1024];
+    char                tbl_buf[1024];
 #endif /* H5C_APPLY_CANDIDATE_LIST__DEBUG */
     unsigned            u;                      /* Local index variable */
     herr_t              ret_value = SUCCEED;    /* Return value */
@@ -413,10 +413,10 @@ H5C_apply_candidate_list(H5F_t * f,
  * Function:    H5C_construct_candidate_list__clean_cache
  *
  * Purpose:     Construct the list of entries that should be flushed to
- *		clean all entries in the cache.
+ *              clean all entries in the cache.
  *
- *		This function is used in managing sync points, and
- *		shouldn't be used elsewhere.
+ *              This function is used in managing sync points, and
+ *              shouldn't be used elsewhere.
  *
  * Return:      Success:        SUCCEED
  *
@@ -457,7 +457,7 @@ H5C_construct_candidate_list__clean_cache(H5C_t * cache_ptr)
         H5C_cache_entry_t *entry_ptr;
         unsigned nominated_entries_count = 0;
         size_t  nominated_entries_size = 0;
-        haddr_t	nominated_addr;
+        haddr_t nominated_addr;
 
         HDassert( cache_ptr->slist_len > 0 );
 
@@ -522,10 +522,10 @@ H5C_construct_candidate_list__clean_cache(H5C_t * cache_ptr)
  * Function:    H5C_construct_candidate_list__min_clean
  *
  * Purpose:     Construct the list of entries that should be flushed to
- *		get the cache back within its min clean constraints.
+ *              get the cache back within its min clean constraints.
  *
- *		This function is used in managing sync points, and
- *		shouldn't be used elsewhere.
+ *              This function is used in managing sync points, and
+ *              shouldn't be used elsewhere.
  *
  * Return:      Success:        SUCCEED
  *
@@ -582,7 +582,7 @@ H5C_construct_candidate_list__min_clean(H5C_t * cache_ptr)
                 (nominated_entries_count < cache_ptr->slist_len) &&
                 (entry_ptr != NULL) &&
                 (!entry_ptr->flush_me_last)) {
-            haddr_t		nominated_addr;
+            haddr_t nominated_addr;
 
             HDassert( ! (entry_ptr->is_protected) );
             HDassert( ! (entry_ptr->is_read_only) );
@@ -612,24 +612,24 @@ H5C_construct_candidate_list__min_clean(H5C_t * cache_ptr)
  * Function:    H5C_mark_entries_as_clean
  *
  * Purpose:     When the H5C code is used to implement the metadata caches
- *		in PHDF5, only the cache with MPI_rank 0 is allowed to
- *		actually write entries to disk -- all other caches must
- *		retain dirty entries until they are advised that the
- *		entries are clean.
+ *              in PHDF5, only the cache with MPI_rank 0 is allowed to
+ *              actually write entries to disk -- all other caches must
+ *              retain dirty entries until they are advised that the
+ *              entries are clean.
  *
- *		This function exists to allow the H5C code to receive these
- *		notifications.
+ *              This function exists to allow the H5C code to receive these
+ *              notifications.
  *
- *		The function receives a list of entry base addresses
- *		which must refer to dirty entries in the cache.  If any
- *		of the entries are either clean or don't exist, the
- *		function flags an error.
+ *              The function receives a list of entry base addresses
+ *              which must refer to dirty entries in the cache.  If any
+ *              of the entries are either clean or don't exist, the
+ *              function flags an error.
  *
- *		The function scans the list of entries and flushes all
- *		those that are currently unprotected with the
- *		H5C__FLUSH_CLEAR_ONLY_FLAG.  Those that are currently
- *		protected are flagged for clearing when they are
- *		unprotected.
+ *              The function scans the list of entries and flushes all
+ *              those that are currently unprotected with the
+ *              H5C__FLUSH_CLEAR_ONLY_FLAG.  Those that are currently
+ *              protected are flagged for clearing when they are
+ *              unprotected.
  *
  * Return:      Non-negative on success/Negative on failure
  *
@@ -644,22 +644,22 @@ H5C_mark_entries_as_clean(H5F_t *  f,
                           haddr_t * ce_array_ptr)
 {
     H5C_t *             cache_ptr;
-    unsigned		entries_cleared;
+    unsigned            entries_cleared;
     unsigned            pinned_entries_cleared;
     hbool_t             progress;
-    unsigned		entries_examined;
-    unsigned		initial_list_len;
-    haddr_t		addr;
-    unsigned		pinned_entries_marked = 0;
+    unsigned            entries_examined;
+    unsigned            initial_list_len;
+    haddr_t             addr;
+    unsigned            pinned_entries_marked = 0;
 #if H5C_DO_SANITY_CHECKS
-    unsigned		protected_entries_marked = 0;
-    unsigned		other_entries_marked = 0;
-    haddr_t		last_addr;
+    unsigned            protected_entries_marked = 0;
+    unsigned            other_entries_marked = 0;
+    haddr_t             last_addr;
 #endif /* H5C_DO_SANITY_CHECKS */
-    H5C_cache_entry_t *	clear_ptr = NULL;
-    H5C_cache_entry_t *	entry_ptr = NULL;
+    H5C_cache_entry_t * clear_ptr = NULL;
+    H5C_cache_entry_t * entry_ptr = NULL;
     unsigned            u;
-    herr_t		ret_value = SUCCEED;      /* Return value */
+    herr_t              ret_value = SUCCEED;      /* Return value */
 
     FUNC_ENTER_NOAPI(FAIL)
 
@@ -706,7 +706,7 @@ H5C_mark_entries_as_clean(H5F_t *  f,
 
         if(entry_ptr == NULL) {
 #if H5C_DO_SANITY_CHECKS
-	    HDfprintf(stdout,
+            HDfprintf(stdout,
                   "H5C_mark_entries_as_clean: entry[%u] = %a not in cache.\n",
                       u,
                       addr);
@@ -715,7 +715,7 @@ H5C_mark_entries_as_clean(H5F_t *  f,
         } /* end if */
         else if(!entry_ptr->is_dirty) {
 #if H5C_DO_SANITY_CHECKS
-	    HDfprintf(stdout,
+            HDfprintf(stdout,
                       "H5C_mark_entries_as_clean: entry %a is not dirty!?!\n",
                       addr);
 #endif /* H5C_DO_SANITY_CHECKS */
@@ -735,13 +735,13 @@ H5C_mark_entries_as_clean(H5F_t *  f,
             } /* end if */
 
             entry_ptr->clear_on_unprotect = TRUE;
-	    if(entry_ptr->is_pinned)
-		pinned_entries_marked++;
+            if(entry_ptr->is_pinned)
+                pinned_entries_marked++;
 #if H5C_DO_SANITY_CHECKS
-	    else if(entry_ptr->is_protected)
-		protected_entries_marked++;
-	    else
-		other_entries_marked++;
+            else if(entry_ptr->is_protected)
+                protected_entries_marked++;
+            else
+                other_entries_marked++;
 #endif /* H5C_DO_SANITY_CHECKS */
         }
     }
@@ -769,7 +769,7 @@ H5C_mark_entries_as_clean(H5F_t *  f,
      * of the pre_serialize / serialize routines, this may
      * cease to be the case -- requiring a review of this
      * point.
-     *					JRM -- 4/7/15
+     *                    JRM -- 4/7/15
      */
     entries_cleared = 0;
     entries_examined = 0;
@@ -873,9 +873,9 @@ H5C_mark_entries_as_clean(H5F_t *  f,
 herr_t
 H5C_clear_coll_entries(H5C_t *cache_ptr, hbool_t partial)
 {
-    uint32_t		clear_cnt;
-    H5C_cache_entry_t *	entry_ptr = NULL;
-    herr_t              ret_value = SUCCEED;
+    uint32_t                clear_cnt;
+    H5C_cache_entry_t *     entry_ptr = NULL;
+    herr_t                  ret_value = SUCCEED;
 
     FUNC_ENTER_NOAPI_NOINIT
 
@@ -1084,7 +1084,7 @@ H5C__collective_write(H5F_t *f)
 /*-------------------------------------------------------------------------
  * Function:    H5C__flush_candidate_entries
  *
- * Purpose:	Flush or clear (as indicated) the candidate entries that
+ * Purpose:     Flush or clear (as indicated) the candidate entries that
  *              have been marked in the metadata cache.  In so doing,
  *              observe rings and flush dependencies.
  *
@@ -1113,9 +1113,9 @@ H5C__collective_write(H5F_t *f)
  * Return:      Non-negative on success/Negative on failure.
  *
  * Programmer:  John Mainzer
- *		2/10/17
+ *              2/10/17
  *
- * Changes:	None.
+ * Changes:     None.
  *
  *-------------------------------------------------------------------------
  */
@@ -1124,17 +1124,17 @@ H5C__flush_candidate_entries(H5F_t *f, unsigned entries_to_flush[H5C_RING_NTYPES
     unsigned entries_to_clear[H5C_RING_NTYPES])
 {
 #if H5C_DO_SANITY_CHECKS
-    int			i;
-    uint32_t		index_len = 0;
-    size_t		index_size = (size_t)0;
-    size_t		clean_index_size = (size_t)0;
-    size_t		dirty_index_size = (size_t)0;
-    size_t		slist_size = (size_t)0;
-    uint32_t		slist_len = 0;
+    int             i;
+    uint32_t        index_len = 0;
+    size_t          index_size = (size_t)0;
+    size_t          clean_index_size = (size_t)0;
+    size_t          dirty_index_size = (size_t)0;
+    size_t          slist_size = (size_t)0;
+    uint32_t        slist_len = 0;
 #endif /* H5C_DO_SANITY_CHECKS */
-    H5C_ring_t		ring;
+    H5C_ring_t      ring;
     H5C_t             * cache_ptr;
-    herr_t		ret_value = SUCCEED;
+    herr_t          ret_value = SUCCEED;
 
     FUNC_ENTER_STATIC
 
@@ -1164,7 +1164,7 @@ H5C__flush_candidate_entries(H5F_t *f, unsigned entries_to_flush[H5C_RING_NTYPES
         clean_index_size += cache_ptr->clean_index_ring_size[i];
         dirty_index_size += cache_ptr->dirty_index_ring_size[i];
 
-	slist_len += cache_ptr->slist_ring_len[i];
+        slist_len += cache_ptr->slist_ring_len[i];
         slist_size += cache_ptr->slist_ring_size[i];
     } /* end for */
 
@@ -1206,7 +1206,7 @@ H5C__flush_candidate_entries(H5F_t *f, unsigned entries_to_flush[H5C_RING_NTYPES
 /*-------------------------------------------------------------------------
  * Function:    H5C__flush_candidates_in_ring
  *
- * Purpose:	Flush or clear (as indicated) the candidate entries
+ * Purpose:     Flush or clear (as indicated) the candidate entries
  *              contained in the specified cache and ring.  All candidate
  *              entries in rings outside the specified ring must have been
  *              flushed (or cleared) on entry.
@@ -1235,7 +1235,7 @@ H5C__flush_candidate_entries(H5F_t *f, unsigned entries_to_flush[H5C_RING_NTYPES
  * Return:      Non-negative on success/Negative on failure.
  *
  * Programmer:  John Mainzer
- *		2/10/17
+ *              2/10/17
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Dmodule.h b/src/H5Dmodule.h
index b259b69b741..27ccf545ff7 100644
--- a/src/H5Dmodule.h
+++ b/src/H5Dmodule.h
@@ -11,7 +11,7 @@
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 /*
- * Programmer:	Quincey Koziol <koziol@hdfgroup.org>
+ * Programmer:	Quincey Koziol
  *		Saturday, September 12, 2015
  *
  * Purpose:	This file contains declarations which define macros for the
diff --git a/src/H5Dpkg.h b/src/H5Dpkg.h
index c46e38b6d0c..37a27d3abce 100644
--- a/src/H5Dpkg.h
+++ b/src/H5Dpkg.h
@@ -12,7 +12,7 @@
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 /*
- * Programmer:    Quincey Koziol <koziol@ncsa.uiuc.edu>
+ * Programmer:    Quincey Koziol
  *        Monday, April 14, 2003
  *
  * Purpose:    This file contains declarations which are visible only within
diff --git a/src/H5EAmodule.h b/src/H5EAmodule.h
index d3e06b7708d..c3a4c7ce17d 100644
--- a/src/H5EAmodule.h
+++ b/src/H5EAmodule.h
@@ -11,7 +11,7 @@
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 /*
- * Programmer:	Quincey Koziol <koziol@hdfgroup.org>
+ * Programmer:	Quincey Koziol
  *		Saturday, September 12, 2015
  *
  * Purpose:	This file contains declarations which define macros for the
diff --git a/src/H5EApkg.h b/src/H5EApkg.h
index bb3f39c76e3..b70231dfd9d 100644
--- a/src/H5EApkg.h
+++ b/src/H5EApkg.h
@@ -12,7 +12,7 @@
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 /*
- * Programmer:      Quincey Koziol <koziol@hdfgroup.org>
+ * Programmer:      Quincey Koziol
  *                  Tuesday, June 17, 2008
  *
  * Purpose:         This file contains declarations which are visible only
diff --git a/src/H5EAprivate.h b/src/H5EAprivate.h
index 11952566168..af0ef3a22dc 100644
--- a/src/H5EAprivate.h
+++ b/src/H5EAprivate.h
@@ -15,7 +15,7 @@
  *
  * Created:     H5EAprivate.h
  *              Jun 17 2008
- *              Quincey Koziol <koziol@hdfgroup.org>
+ *              Quincey Koziol
  *
  * Purpose:     Private header for library accessible extensible
  *              array routines.
diff --git a/src/H5EAsblock.c b/src/H5EAsblock.c
index b4671f8c5dc..fb7c458449c 100644
--- a/src/H5EAsblock.c
+++ b/src/H5EAsblock.c
@@ -15,7 +15,7 @@
  *
  * Created:		H5EAsblock.c
  *			Sep 30 2008
- *			Quincey Koziol <koziol@hdfgroup.org>
+ *			Quincey Koziol
  *
  * Purpose:		Super block routines for extensible arrays.
  *
@@ -98,7 +98,6 @@ H5FL_BLK_DEFINE(page_init);
  * Return:	Non-NULL pointer to super block on success/NULL on failure
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Sep 30 2008
  *
  *-------------------------------------------------------------------------
@@ -179,7 +178,6 @@ END_FUNC(PKG)   /* end H5EA__sblock_alloc() */
  * Return:	Valid file address on success/HADDR_UNDEF on failure
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Sep 30 2008
  *
  *-------------------------------------------------------------------------
@@ -267,7 +265,6 @@ END_FUNC(PKG)   /* end H5EA__sblock_create() */
  * Return:	Non-NULL pointer to data block on success/NULL on failure
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Sep 30 2008
  *
  *-------------------------------------------------------------------------
@@ -328,7 +325,6 @@ END_FUNC(PKG)   /* end H5EA__sblock_protect() */
  * Return:	Non-negative on success/Negative on failure
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Sep 30 2008
  *
  *-------------------------------------------------------------------------
@@ -359,7 +355,6 @@ END_FUNC(PKG)   /* end H5EA__sblock_unprotect() */
  * Return:	SUCCEED/FAIL
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Sep 30 2008
  *
  *-------------------------------------------------------------------------
@@ -408,7 +403,6 @@ END_FUNC(PKG)   /* end H5EA__sblock_delete() */
  * Return:	Non-negative on success/Negative on failure
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Sep 30 2008
  *
  *-------------------------------------------------------------------------
diff --git a/src/H5Glink.c b/src/H5Glink.c
index 6c42f1da010..cbe530735ef 100644
--- a/src/H5Glink.c
+++ b/src/H5Glink.c
@@ -15,7 +15,7 @@
  *
  * Created:		H5Glink.c
  *			Nov 13 2006
- *			Quincey Koziol <koziol@hdfgroup.org>
+ *			Quincey Koziol
  *
  * Purpose:		Functions for handling links in groups.
  *
@@ -98,7 +98,6 @@ static int H5G_link_cmp_corder_dec(const void *lnk1, const void *lnk2);
  *              (i.e. same as strcmp())
  *
  * Programmer:	Quincey Koziol
- *		koziol@ncsa.uiuc.edu
  *		Sep  5 2005
  *
  *-------------------------------------------------------------------------
@@ -125,7 +124,6 @@ H5G_link_cmp_name_inc(const void *lnk1, const void *lnk2)
  *              (i.e. opposite strcmp())
  *
  * Programmer:	Quincey Koziol
- *		koziol@ncsa.uiuc.edu
  *		Sep 25 2006
  *
  *-------------------------------------------------------------------------
@@ -151,7 +149,6 @@ H5G_link_cmp_name_dec(const void *lnk1, const void *lnk2)
  *              as equal, their order in the sorted array is undefined.
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Nov  6 2006
  *
  *-------------------------------------------------------------------------
@@ -186,7 +183,6 @@ H5G_link_cmp_corder_inc(const void *lnk1, const void *lnk2)
  *              as equal, their order in the sorted array is undefined.
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Nov  6 2006
  *
  *-------------------------------------------------------------------------
@@ -217,7 +213,6 @@ H5G_link_cmp_corder_dec(const void *lnk1, const void *lnk2)
  * Return:	Non-negative on success/Negative on failure
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Sep 16 2006
  *
  *-------------------------------------------------------------------------
@@ -561,7 +556,6 @@ H5G__link_release_table(H5G_link_table_t *ltable)
  * Return:	Non-negative on success/Negative on failure
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Nov 13 2006
  *
  *-------------------------------------------------------------------------
diff --git a/src/H5Gloc.c b/src/H5Gloc.c
index 4d89abb5e50..0243b41e25c 100644
--- a/src/H5Gloc.c
+++ b/src/H5Gloc.c
@@ -15,7 +15,7 @@
  *
  * Created:		H5Gloc.c
  *			Sep 13 2005
- *			Quincey Koziol <koziol@ncsa.uiuc.edu>
+ *			Quincey Koziol
  *
  * Purpose:		Functions for working with group "locations"
  *
diff --git a/src/H5Gname.c b/src/H5Gname.c
index 4b0f04c4628..e1004de8529 100644
--- a/src/H5Gname.c
+++ b/src/H5Gname.c
@@ -15,7 +15,7 @@
  *
  * Created:		H5Gname.c
  *			Sep 12 2005
- *			Quincey Koziol <koziol@ncsa.uiuc.edu>
+ *			Quincey Koziol
  *
  * Purpose:		Functions for handling group hierarchy paths.
  *
@@ -123,7 +123,6 @@ H5FL_BLK_EXTERN(str_buf);
  *		Failure:	Ptr to the null terminator of NAME.
  *
  * Programmer:	Robb Matzke
- *		matzke@llnl.gov
  *		Aug 11 1997
  *
  *-------------------------------------------------------------------------
@@ -216,7 +215,7 @@ H5G_normalize(const char *name)
  * Return: TRUE for valid prefix, FALSE for not a valid prefix, FAIL
  *              on error
  *
- * Programmer: Quincey Koziol, koziol@ncsa.uiuc.edu
+ * Programmer: Quincey Koziol
  *
  * Date: September 24, 2002
  *
@@ -281,7 +280,7 @@ H5G_common_path(const H5RS_str_t *fullpath_r, const H5RS_str_t *prefix_r)
  *
  * Return: Pointer to reference counted string on success, NULL on error
  *
- * Programmer: Quincey Koziol, koziol@ncsa.uiuc.edu
+ * Programmer: Quincey Koziol
  *
  * Date: August 19, 2005
  *
@@ -343,7 +342,7 @@ H5G_build_fullpath(const char *prefix, const char *name)
  * Return:	Success:	Non-NULL, combined path
  *		Failure:	NULL
  *
- * Programmer:	Quincey Koziol, koziol@ncsa.uiuc.edu
+ * Programmer:	Quincey Koziol
  *              Tuesday, October 11, 2005
  *
  *-------------------------------------------------------------------------
@@ -379,7 +378,7 @@ H5G_build_fullpath_refstr_str(H5RS_str_t *prefix_r, const char *name)
  *
  * Return: Pointer to reference counted string on success, NULL on error
  *
- * Programmer: Quincey Koziol, koziol@ncsa.uiuc.edu
+ * Programmer: Quincey Koziol
  *
  * Date: August 19, 2005
  *
@@ -448,7 +447,7 @@ H5G__name_init(H5G_name_t *name, const char *path)
  * Return:	Success:	Non-negative
  *		Failure:	Negative
  *
- * Programmer:	Pedro Vicente, pvn@ncsa.uiuc.edu
+ * Programmer:	Pedro Vicente
  *              Thursday, August 22, 2002
  *
  *-------------------------------------------------------------------------
@@ -552,10 +551,6 @@ H5G_name_copy(H5G_name_t *dst, const H5G_name_t *src, H5_copy_depth_t depth)
  * Programmer:	Quincey Koziol
  *              Tuesday, December 13, 2005
  *
- * Modifications: Leon Arber
- * 		  Oct. 18, 2006
- * 		  Added functionality to get the name for a reference.
- *
  *-------------------------------------------------------------------------
  */
 ssize_t
@@ -639,7 +634,7 @@ H5G_name_reset(H5G_name_t *name)
  *
  * Return:	Success
  *
- * Programmer: Pedro Vicente, pvn@ncsa.uiuc.edu
+ * Programmer: Pedro Vicente
  *
  * Date: August 22, 2002
  *
@@ -777,7 +772,7 @@ H5G_name_move_path(H5RS_str_t **path_r_ptr, const char *full_suffix, const char
  *
  * Return: Success: 0, Failure: -1
  *
- * Programmer: Pedro Vicente, pvn@ncsa.uiuc.edu
+ * Programmer: Pedro Vicente
  *
  * Date: June 5, 2002
  *
@@ -1060,7 +1055,7 @@ H5G_name_replace_cb(void *obj_ptr, hid_t obj_id, void *key)
  *
  * Return: Success: 0, Failure: -1
  *
- * Programmer: Pedro Vicente, pvn@ncsa.uiuc.edu
+ * Programmer: Pedro Vicente
  *
  * Date: June 11, 2002
  *
diff --git a/src/H5Gnode.c b/src/H5Gnode.c
index 9faa0b564d4..2e7b3675b8d 100644
--- a/src/H5Gnode.c
+++ b/src/H5Gnode.c
@@ -15,7 +15,7 @@
  *
  * Created:	    H5Gnode.c
  *              Jun 26 1997
- *              Robb Matzke <matzke@llnl.gov>
+ *              Robb Matzke
  *
  * Purpose:     Functions for handling symbol table nodes.  A
  *              symbol table node is a small collection of symbol
@@ -145,8 +145,6 @@ H5FL_SEQ_DEFINE(H5G_entry_t);
  * Programmer:  Robb Matzke
  *              Wednesday, October  8, 1997
  *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 static H5UC_t *
@@ -169,7 +167,6 @@ H5G_node_get_shared(const H5F_t *f, const void H5_ATTR_UNUSED *_udata)
  * Return:      Non-negative on success/Negative on failure
  *
  * Programmer:  Robb Matzke
- *              matzke@llnl.gov
  *              Jul  8 1997
  *
  *-------------------------------------------------------------------------
@@ -199,7 +196,6 @@ H5G_node_decode_key(const H5B_shared_t *shared, const uint8_t *raw, void *_key)
  * Return:      Non-negative on success/Negative on failure
  *
  * Programmer:  Robb Matzke
- *              matzke@llnl.gov
  *              Jul  8 1997
  *
  *-------------------------------------------------------------------------
@@ -270,7 +266,6 @@ H5G_node_debug_key(FILE *stream, int indent, int fwidth, const void *_key,
  * Return:      Non-negative on success/Negative on failure
  *
  * Programmer:  Quincey Koziol
- *              koziol@ncsa.uiuc.edu
  *              Jan 15 2003
  *
  *-------------------------------------------------------------------------
@@ -310,7 +305,6 @@ H5G__node_free(H5G_node_t *sym)
  *          Failure:    Negative
  *
  * Programmer:  Robb Matzke
- *              matzke@llnl.gov
  *              Jun 23 1997
  *
  *-------------------------------------------------------------------------
@@ -382,11 +376,8 @@ H5G__node_create(H5F_t *f, H5B_ins_t H5_ATTR_UNUSED op, void *_lt_key,
  *          Failure:    FAIL (same as LT_KEY<RT_KEY)
  *
  * Programmer:  Robb Matzke
- *              matzke@llnl.gov
  *              Jun 23 1997
  *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 static herr_t
@@ -439,11 +430,8 @@ H5G_node_cmp2(void *_lt_key, void *_udata, void *_rt_key)
  *          Failure:    FAIL (same as UDATA < LT_KEY)
  *
  * Programmer:  Robb Matzke
- *              matzke@llnl.gov
  *              Jun 23 1997
  *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 static herr_t
@@ -501,7 +489,6 @@ H5G_node_cmp3(void *_lt_key, void *_udata, void *_rt_key)
  *              Failure:    Negative if not found.
  *
  * Programmer:  Robb Matzke
- *              matzke@llnl.gov
  *              Jun 23 1997
  *
  *-------------------------------------------------------------------------
@@ -591,7 +578,6 @@ H5G_node_found(H5F_t *f, haddr_t addr, const void H5_ATTR_UNUSED *_lt_key,
  *              Failure:    H5B_INS_ERROR, NEW_NODE_P might not be initialized.
  *
  * Programmer:  Robb Matzke
- *              matzke@llnl.gov
  *              Jun 24 1997
  *
  *-------------------------------------------------------------------------
@@ -951,7 +937,6 @@ H5G_node_remove(H5F_t *f, haddr_t addr, void H5_ATTR_NDEBUG_UNUSED *_lt_key/*in,
  * Return:      Non-negative on success/Negative on failure
  *
  * Programmer:  Robb Matzke
- *              matzke@llnl.gov
  *              Jun 24 1997
  *
  *-------------------------------------------------------------------------
@@ -1368,7 +1353,6 @@ H5G__node_copy(H5F_t *f, const void H5_ATTR_UNUSED *_lt_key, haddr_t addr,
  * Return:      Non-negative on success/Negative on failure
  *
  * Programmer:  Quincey Koziol
- *              koziol@hdfgroup.org
  *              Nov 19 2006
  *
  *-------------------------------------------------------------------------
@@ -1475,7 +1459,6 @@ H5G__node_iterate_size(H5F_t *f, const void H5_ATTR_UNUSED *_lt_key,
  * Return:      0(zero) on success/Negative on failure
  *
  * Programmer:  Robb Matzke
- *              matzke@llnl.gov
  *              Aug  4 1997
  *
  *-------------------------------------------------------------------------
diff --git a/src/H5HLmodule.h b/src/H5HLmodule.h
index b0fd750a5e2..712c7c12d2d 100644
--- a/src/H5HLmodule.h
+++ b/src/H5HLmodule.h
@@ -11,7 +11,7 @@
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 /*
- * Programmer:	Quincey Koziol <koziol@hdfgroup.org>
+ * Programmer:	Quincey Koziol
  *		Saturday, September 12, 2015
  *
  * Purpose:	This file contains declarations which define macros for the
diff --git a/src/H5HLpkg.h b/src/H5HLpkg.h
index 44a2cfbb5b5..9891e10ffc3 100644
--- a/src/H5HLpkg.h
+++ b/src/H5HLpkg.h
@@ -12,7 +12,7 @@
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 /*
- * Programmer: Quincey Koziol <koziol@hdfgroup.org>
+ * Programmer: Quincey Koziol
  *             Wednesday, July 9, 2003
  *
  * Purpose:     This file contains declarations which are visible
diff --git a/src/H5HLprivate.h b/src/H5HLprivate.h
index 7a53b25ecfd..60505ee468c 100644
--- a/src/H5HLprivate.h
+++ b/src/H5HLprivate.h
@@ -15,7 +15,7 @@
  *
  * Created:         H5HLprivate.h
  *                  Jul 16 1997
- *                  Robb Matzke <matzke@llnl.gov>
+ *                  Robb Matzke
  *
  * Purpose:         Private declarations for the H5HL (local heap) package.
  *
diff --git a/src/H5Zfletcher32.c b/src/H5Zfletcher32.c
index 4d75d1454b7..c40e9b4301f 100644
--- a/src/H5Zfletcher32.c
+++ b/src/H5Zfletcher32.c
@@ -12,7 +12,7 @@
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 /*
- * Programmer:  Raymond Lu <slu@ncsa.uiuc.edu>
+ * Programmer:  Raymond Lu
  *              Jan 3, 2003
  */
 
diff --git a/src/H5Ztrans.c b/src/H5Ztrans.c
index dfc984ab130..1c8d4152404 100644
--- a/src/H5Ztrans.c
+++ b/src/H5Ztrans.c
@@ -400,8 +400,6 @@ static void H5Z_print(H5Z_node *tree, FILE *stream);
  * Return:      Always succeeds.
  * Programmer:  Bill Wendling
  *              26. August 2003
- * Modifications:
-  *              Leon Arber:  Added FUNC_ENTER / FUNC_LEAVE pairs
 *
  *-------------------------------------------------------------------------
  */
@@ -565,8 +563,6 @@ H5Z_get_token(H5Z_token *current)
  * Return:      Nothing
  * Programmer:  Bill Wendling
  *              25. August 2003
- * Modifications:
- *              Leon Arber: Added FUNC_ENTER / FUNC_LEAVE pairs
  *
  *-------------------------------------------------------------------------
  */
@@ -634,8 +630,6 @@ H5Z_xform_parse(const char *expression, H5Z_datval_ptrs* dat_val_pointers)
  *              NULLure:    NULL
  * Programmer:  Bill Wendling
  *              26. August 2003
- * Modifications:
-  *              Leon Arber: Added FUNC_ENTER / FUNC_LEAVE pairs
 *
  *-------------------------------------------------------------------------
  */
@@ -728,8 +722,6 @@ H5Z_parse_expression(H5Z_token *current, H5Z_datval_ptrs* dat_val_pointers)
  *              NULLure:    NULL
  * Programmer:  Bill Wendling
  *              26. August 2003
- * Modifications:
-  *              Leon Arber: Added FUNC_ENTER / FUNC_LEAVE pairs
 *
  *-------------------------------------------------------------------------
  */
@@ -828,8 +820,6 @@ H5Z_parse_term(H5Z_token *current, H5Z_datval_ptrs* dat_val_pointers)
  *              NULLure:    NULL
  * Programmer:  Bill Wendling
  *              26. August 2003
- * Modifications:
- *              Leon Arber: Added FUNC_ENTER / FUNC_LEAVE pairs
  *
  *-------------------------------------------------------------------------
  */
@@ -972,8 +962,6 @@ H5Z_parse_factor(H5Z_token *current, H5Z_datval_ptrs* dat_val_pointers)
  *              NULLure:    NULL
  * Programmer:  Bill Wendling
  *              26. August 2003
- * Modifications:
- *              Leon Arber: Added FUNC_ENTER / FUNC_LEAVE pairs
  *
  *-------------------------------------------------------------------------
  */
@@ -1002,7 +990,6 @@ H5Z_new_node(H5Z_token_type type)
  * Return:      SUCCEED if transform applied successfully, FAIL otherwise
  * Programmer:  Leon Arber
  * 		5/1/04
- * Modifications:
  *
  *-------------------------------------------------------------------------
  */
@@ -1115,8 +1102,6 @@ H5Z_xform_eval(H5Z_data_xform_t *data_xform_prop, void* array, size_t array_size
  * Return:      Nothing
  * Programmer:  Leon Arber
  * 		5/1/04
- * Modifications:
- *
  *
  * Notes:   In the case of a polynomial data transform (ie, the left and right subtree
  * are both of type H5Z_XFORM_SYMBOL), the convention is that the left hand side
@@ -1213,8 +1198,6 @@ H5Z_xform_eval_full(H5Z_node *tree, const size_t array_size,  const hid_t array_
  * Function:    H5Z_find_type
  * Return:      Native type of datatype that is passed in
  * Programmer:  Leon Arber, 4/20/04
- * Modifications:
- *
  *
  *-------------------------------------------------------------------------
  */
@@ -1301,7 +1284,6 @@ H5Z_xform_find_type(const H5T_t* type)
  *              of the one passed in.
  * Programmer:  Leon Arber
  *              April 1, 2004.
- * Modifications:
  *
  *-------------------------------------------------------------------------
  */
@@ -1375,7 +1357,6 @@ H5Z_xform_copy_tree(H5Z_node* tree, H5Z_datval_ptrs* dat_val_pointers, H5Z_datva
  * Return:      TRUE or FALSE
  * Programmer:  Raymond Lu
  *              15 March 2012
- * Modifications:
  *
  *-------------------------------------------------------------------------
  */
@@ -1404,7 +1385,6 @@ H5Z_op_is_numbs(H5Z_node* _tree)
  * Return:      TRUE or FALSE
  * Programmer:  Raymond Lu
  *              15 March 2012
- * Modifications:
  *
  *-------------------------------------------------------------------------
  */
@@ -1490,11 +1470,6 @@ H5Z_xform_reduce_tree(H5Z_node* tree)
  * Return:      None.
  * Programmer:  Leon Arber
  *              April 1, 2004.
- * Modifications:
- *              Raymond Lu
- *              15 March 2012
- *              I added a new macro H5Z_XFORM_DO_OP6 to handle the special
- *              operations like -x or +x when the left operand is empty.
  *
  *-------------------------------------------------------------------------
  */
@@ -1525,14 +1500,10 @@ H5Z_do_op(H5Z_node* tree)
  *      Success: SUCCEED
  *      Failure: FAIL
  *
- * Programmer: Quincey Koziol, koziol@ncsa.uiuc.edu
+ * Programmer: Quincey Koziol
  *
  * Date: May 4, 2004
  *
- * Comments:
- *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 H5Z_data_xform_t *
@@ -1616,14 +1587,10 @@ H5Z_xform_create(const char *expr)
  *      Success: SUCCEED
  *      Failure: FAIL
  *
- * Programmer: Quincey Koziol, koziol@ncsa.uiuc.edu
+ * Programmer: Quincey Koziol
  *
  * Date: May 4, 2004
  *
- * Comments:
- *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -1662,7 +1629,7 @@ H5Z_xform_destroy(H5Z_data_xform_t *data_xform_prop)
  *      Success: SUCCEED
  *      Failure: FAIL
  *
- * Programmer: Quincey Koziol, koziol@ncsa.uiuc.edu
+ * Programmer: Quincey Koziol
  *
  * Date: May 4, 2004
  *
@@ -1742,14 +1709,12 @@ H5Z_xform_copy(H5Z_data_xform_t **data_xform_prop)
  *
  * Return:  TRUE for no data transform, FALSE for a data transform
  *
- * Programmer: Quincey Koziol, koziol@ncsa.uiuc.edu
+ * Programmer: Quincey Koziol
  *
  * Date: May 4, 2004
  *
  * Comments: Can't fail
  *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 hbool_t
@@ -1773,12 +1738,10 @@ H5Z_xform_noop(const H5Z_data_xform_t *data_xform_prop)
  * Return:
  *          Pointer to a copy of the string in the data_xform property.
  *
- * Programmer: Leon Arber, larber@ncsa.uiuc.edu
+ * Programmer: Leon Arber
  *
  * Date: Sept. 4, 2004
  *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 const char *
diff --git a/src/H5dbg.c b/src/H5dbg.c
index 4939bcabef8..c01ad88aef7 100644
--- a/src/H5dbg.c
+++ b/src/H5dbg.c
@@ -15,7 +15,7 @@
  *
  * Created:		H5dbg.c
  *			Mar  4 2006
- *			Quincey Koziol <koziol@ncsa.uiuc.edu>
+ *			Quincey Koziol
  *
  * Purpose:		Generic debugging routines
  *
@@ -70,7 +70,6 @@
  * Return:	Non-negative on success/Negative on failure
  *
  * Programmer:	Quincey Koziol
- *		koziol@ncsa.uiuc.edu
  *		Mar  4 2006
  *
  *-------------------------------------------------------------------------

From e0b86594c25c7372720ec4b3fff0add7a122f18c Mon Sep 17 00:00:00 2001
From: Allen Byrne <byrn@hdfgroup.org>
Date: Mon, 20 Jul 2020 16:46:49 -0500
Subject: [PATCH 38/55] revert error-stack enable

---
 tools/test/h5format_convert/testh5fc.sh.in | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/tools/test/h5format_convert/testh5fc.sh.in b/tools/test/h5format_convert/testh5fc.sh.in
index d780a3d88b6..2cdd4453192 100644
--- a/tools/test/h5format_convert/testh5fc.sh.in
+++ b/tools/test/h5format_convert/testh5fc.sh.in
@@ -483,7 +483,7 @@ TOOLTEST_OUT h5fc_v_n_all.ddl h5fc_non_v3.h5 -v -n
 #
 #
 # h5format_convert -v h5fc_err_level.h5 (error encountered in converting the dataset)
-TOOLTEST_MASK_OUT h5fc_v_err.ddl h5fc_err_level.h5 -v --enable-error-stack
+TOOLTEST_MASK_OUT h5fc_v_err.ddl h5fc_err_level.h5 -v
 #
 #
 #

From 88e458ac435340f327f252b82ad9b6c1c1f4f618 Mon Sep 17 00:00:00 2001
From: Binh-Minh Ribler <bmribler@hdfgroup.org>
Date: Wed, 22 Jul 2020 16:13:26 -0500
Subject: [PATCH 39/55] Fix HDFFV-11120 and HDFFV-11121 (CVE-2018-13870 and
 CVE-2018-13869)

Description:
    When a buffer overflow occurred because a name length was corrupted
    and became very large, h5dump produced a segfault on one file and a
    memcpy parameter overlap on another file.  This commit added checks
    that detect a read pass the end of the buffer to prevent these error
    conditions.
Platforms tested:
    Linux/64 (jelly)
    SunOS 5.11 (emu)
---
 release_docs/RELEASE.txt | 11 +++++++++++
 src/H5Olink.c            | 19 ++++++++++++++++++-
 2 files changed, 29 insertions(+), 1 deletion(-)

diff --git a/release_docs/RELEASE.txt b/release_docs/RELEASE.txt
index 84f339a28f5..ba8eabedd7c 100644
--- a/release_docs/RELEASE.txt
+++ b/release_docs/RELEASE.txt
@@ -656,6 +656,17 @@ Bug Fixes since HDF5-1.10.3 release
 
     Library
     -------
+    - Fixed issues CVE-2018-13870 and CVE-2018-13869
+
+      When a buffer overflow occurred because a name length was corrupted
+      and became very large, h5dump crashed on memory access violation.
+
+      A check for reading pass the end of the buffer was added to multiple
+      locations to prevent the crashes and h5dump now simply fails with an
+      error message when this error condition occurs.
+
+      (BMR - 2020/7/22, HDFFV-11120 and HDFFV-11121)
+
     - Fixed the segmentation fault when reading attributes with multiple threads
 
       It was reported that the reading of attributes with variable length string
diff --git a/src/H5Olink.c b/src/H5Olink.c
index 1f0c6c77104..8aaf2d282c5 100644
--- a/src/H5Olink.c
+++ b/src/H5Olink.c
@@ -119,11 +119,12 @@ H5FL_DEFINE_STATIC(H5O_link_t);
 static void *
 H5O__link_decode(H5F_t *f, H5O_t H5_ATTR_UNUSED *open_oh,
     unsigned H5_ATTR_UNUSED mesg_flags, unsigned H5_ATTR_UNUSED *ioflags,
-    size_t H5_ATTR_UNUSED p_size, const uint8_t *p)
+    size_t p_size, const uint8_t *p)
 {
     H5O_link_t          *lnk = NULL;    /* Pointer to link message */
     size_t              len = 0;        /* Length of a string in the message */
     unsigned char       link_flags;     /* Flags for encoding link info */
+    const uint8_t       *p_end = p + p_size;  /* End of the p buffer */
     void                *ret_value = NULL;      /* Return value */
 
     FUNC_ENTER_STATIC
@@ -199,6 +200,11 @@ H5O__link_decode(H5F_t *f, H5O_t H5_ATTR_UNUSED *open_oh,
     if(len == 0)
         HGOTO_ERROR(H5E_OHDR, H5E_CANTLOAD, NULL, "invalid name length")
 
+    /* Make sure that length doesn't exceed buffer size, which could occur
+       when the file is corrupted */
+    if(p + len > p_end)
+        HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "name length causes read pass end of buffer")
+
     /* Get the link's name */
     if(NULL == (lnk->name = (char *)H5MM_malloc(len + 1)))
         HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, NULL, "memory allocation failed")
@@ -218,6 +224,12 @@ H5O__link_decode(H5F_t *f, H5O_t H5_ATTR_UNUSED *open_oh,
             UINT16DECODE(p, len)
             if(len == 0)
                 HGOTO_ERROR(H5E_OHDR, H5E_CANTLOAD, NULL, "invalid link length")
+
+            /* Make sure that length doesn't exceed buffer size, which could occur
+               when the file is corrupted */
+            if(p + len > p_end)
+                HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "name length causes read pass end of buffer")
+
             if(NULL == (lnk->u.soft.name = (char *)H5MM_malloc((size_t)len + 1)))
                 HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, NULL, "memory allocation failed")
             H5MM_memcpy(lnk->u.soft.name, p, len);
@@ -238,6 +250,11 @@ H5O__link_decode(H5F_t *f, H5O_t H5_ATTR_UNUSED *open_oh,
             lnk->u.ud.size = len;
             if(len > 0)
             {
+                /* Make sure that length doesn't exceed buffer size, which could
+                   occur when the file is corrupted */
+                if(p + len > p_end)
+                    HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "name length causes read pass end of buffer")
+
                 if(NULL == (lnk->u.ud.udata = H5MM_malloc((size_t)len)))
                     HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, NULL, "memory allocation failed")
                 H5MM_memcpy(lnk->u.ud.udata, p, len);

From 6e740457cc338a7c4db95be4458c76828da7a872 Mon Sep 17 00:00:00 2001
From: Dana Robinson <derobins@hdfgroup.org>
Date: Mon, 27 Jul 2020 11:09:05 -0700
Subject: [PATCH 40/55] Minor normalization with 1.10 branch

---
 src/H5Adense.c |  80 ++++++++-----------
 src/H5Aint.c   | 207 +++++++++++++++++++++++--------------------------
 src/H5B2.c     |  17 +---
 src/H5B2hdr.c  |  11 +--
 src/H5EAdbg.c  |  58 +++++++-------
 src/H5Eint.c   |   3 +-
 src/H5F.c      | 134 +++++++++++++-------------------
 src/H5Gloc.c   |   4 +-
 src/H5Ochunk.c |  11 +--
 src/H5Ocont.c  |   6 +-
 src/H5TS.c     |   1 +
 11 files changed, 220 insertions(+), 312 deletions(-)

diff --git a/src/H5Adense.c b/src/H5Adense.c
index a73fcc67373..fd92e8f8762 100644
--- a/src/H5Adense.c
+++ b/src/H5Adense.c
@@ -171,7 +171,6 @@ typedef struct H5A_bt2_ud_rmbi_t {
  * Return:      SUCCEED/FAIL
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Dec  4 2006
  *
  *-------------------------------------------------------------------------
@@ -290,9 +289,8 @@ HDfprintf(stderr, "%s: ainfo->corder_bt2_addr = %a\n", FUNC, ainfo->corder_bt2_a
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
- *		Dec 11 2006
+ * Programmer:  Quincey Koziol
+ *              Dec 11 2006
  *
  *-------------------------------------------------------------------------
  */
@@ -351,9 +349,8 @@ H5A__dense_fnd_cb(const H5A_t *attr, hbool_t *took_ownership, void *_user_attr)
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
- *		Dec 11 2006
+ * Programmer:  Quincey Koziol
+ *              Dec 11 2006
  *
  *-------------------------------------------------------------------------
  */
@@ -440,9 +437,8 @@ H5A__dense_open(H5F_t *f, const H5O_ainfo_t *ainfo, const char *name)
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
- *		Dec  4 2006
+ * Programmer:  Quincey Koziol
+ *              Dec  4 2006
  *
  *-------------------------------------------------------------------------
  */
@@ -598,7 +594,7 @@ H5A__dense_insert(H5F_t *f, const H5O_ainfo_t *ainfo, H5A_t *attr)
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Tuesday, February 20, 2007
  *
  *-------------------------------------------------------------------------
@@ -632,7 +628,7 @@ H5A__dense_write_bt2_cb2(void *_record, void *_op_data, hbool_t *changed)
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Tuesday, December  5, 2006
  *
  *-------------------------------------------------------------------------
@@ -743,9 +739,8 @@ H5A__dense_write_bt2_cb(void *_record, void *_op_data, hbool_t *changed)
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
- *		Dec  4 2006
+ * Programmer:  Quincey Koziol
+ *              Dec  4 2006
  *
  *-------------------------------------------------------------------------
  */
@@ -840,9 +835,8 @@ H5A__dense_write(H5F_t *f, const H5O_ainfo_t *ainfo, H5A_t *attr)
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
- *		Dec  5 2006
+ * Programmer:  Quincey Koziol
+ *              Dec  5 2006
  *
  *-------------------------------------------------------------------------
  */
@@ -883,9 +877,8 @@ H5A__dense_copy_fh_cb(const void *obj, size_t obj_len, void *_udata)
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
- *		Jan  3 2007
+ * Programmer:  Quincey Koziol
+ *              Jan  3 2007
  *
  *-------------------------------------------------------------------------
  */
@@ -1065,9 +1058,8 @@ H5A__dense_rename(H5F_t *f, const H5O_ainfo_t *ainfo, const char *old_name,
  *
  * Return:      H5_ITER_ERROR/H5_ITER_CONT/H5_ITER_STOP
  *
- * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
- *		Dec  5 2006
+ * Programmer:  Quincey Koziol
+ *              Dec  5 2006
  *
  *-------------------------------------------------------------------------
  */
@@ -1161,9 +1153,8 @@ H5A__dense_iterate_bt2_cb(const void *_record, void *_bt2_udata)
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
- *		Dec  5 2006
+ * Programmer:  Quincey Koziol
+ *              Dec  5 2006
  *
  *-------------------------------------------------------------------------
  */
@@ -1296,9 +1287,8 @@ H5A__dense_iterate(H5F_t *f, hid_t loc_id, const H5O_ainfo_t *ainfo,
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
- *		Dec 11 2006
+ * Programmer:  Quincey Koziol
+ *              Dec 11 2006
  *
  *-------------------------------------------------------------------------
  */
@@ -1360,9 +1350,8 @@ H5A__dense_remove_bt2_cb(const void *_record, void *_udata)
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
- *		Dec 11 2006
+ * Programmer:  Quincey Koziol
+ *              Dec 11 2006
  *
  *-------------------------------------------------------------------------
  */
@@ -1448,9 +1437,8 @@ H5A__dense_remove(H5F_t *f, const H5O_ainfo_t *ainfo, const char *name)
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
- *		Feb 14 2007
+ * Programmer:  Quincey Koziol
+ *              Feb 14 2007
  *
  *-------------------------------------------------------------------------
  */
@@ -1574,9 +1562,8 @@ H5A__dense_remove_by_idx_bt2_cb(const void *_record, void *_bt2_udata)
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
- *		Feb 14 2007
+ * Programmer:  Quincey Koziol
+ *              Feb 14 2007
  *
  *-------------------------------------------------------------------------
  */
@@ -1702,9 +1689,8 @@ H5A__dense_remove_by_idx(H5F_t *f, const H5O_ainfo_t *ainfo, H5_index_t idx_type
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
- *		Dec 11 2006
+ * Programmer:  Quincey Koziol
+ *              Dec 11 2006
  *
  *-------------------------------------------------------------------------
  */
@@ -1788,9 +1774,8 @@ H5A__dense_exists(H5F_t *f, const H5O_ainfo_t *ainfo, const char *name)
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
- *		Jan  3 2007
+ * Programmer:  Quincey Koziol
+ *              Jan  3 2007
  *
  *-------------------------------------------------------------------------
  */
@@ -1852,9 +1837,8 @@ H5A__dense_delete_bt2_cb(const void *_record, void *_bt2_udata)
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
- *		Dec  6 2006
+ * Programmer:  Quincey Koziol
+ *              Dec  6 2006
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Aint.c b/src/H5Aint.c
index cd0ab80936d..d6ea1f4d0a8 100644
--- a/src/H5Aint.c
+++ b/src/H5Aint.c
@@ -122,10 +122,10 @@ const unsigned H5O_attr_ver_bounds[] = {
 /* Local Variables */
 /*******************/
 
-typedef H5A_t*    H5A_t_ptr;
+typedef H5A_t*      H5A_t_ptr;
 H5FL_SEQ_DEFINE(H5A_t_ptr);
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__create
  *
@@ -288,16 +288,16 @@ H5A__create(const H5G_loc_t *loc, const char *attr_name, const H5T_t *type,
     FUNC_LEAVE_NOAPI_TAG(ret_value)
 } /* H5A__create() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__create_by_name
  *
- * Purpose:    Create an attribute on object, according to it's name
+ * Purpose:     Create an attribute on object, according to it's name
  *
- * Return:    Non-negative on success/Negative on failure
+ * Return:      SUCCEED/FAIL
  *
- * Programmer:    Quincey Koziol
- *        December 6, 2017
+ * Programmer:  Quincey Koziol
+ *              December 6, 2017
  *
  *-------------------------------------------------------------------------
  */
@@ -306,8 +306,8 @@ H5A__create_by_name(const H5G_loc_t *loc, const char *obj_name, const char *attr
     const H5T_t *type, const H5S_t *space, hid_t acpl_id)
 {
     H5G_loc_t   obj_loc;                /* Location used to open group */
-    H5G_name_t  obj_path;                /* Opened object group hier. path */
-    H5O_loc_t   obj_oloc;                /* Opened object object location */
+    H5G_name_t  obj_path;               /* Opened object group hier. path */
+    H5O_loc_t   obj_oloc;               /* Opened object object location */
     hbool_t     loc_found = FALSE;      /* Entry at 'obj_name' found */
     H5A_t       *attr = NULL;           /* Attribute from object header */
     H5A_t       *ret_value = NULL;      /* Return value */
@@ -349,22 +349,21 @@ H5A__create_by_name(const H5G_loc_t *loc, const char *obj_name, const char *attr
     FUNC_LEAVE_NOAPI(ret_value)
 } /* H5A__create_by_name() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__open_common
  *
- * Purpose:
- *      Finishes initializing an attributes the open
+ * Purpose:     Finishes initializing an attributes the open
  *
  * Usage:
  *  herr_t H5A__open_common(loc, name)
  *      const H5G_loc_t *loc;   IN: Pointer to group location for object
  *      H5A_t *attr;            IN/OUT: Pointer to attribute to initialize
  *
- * Return: Non-negative on success/Negative on failure
+ * Return:      SUCCEED/FAIL
  *
- * Programmer:    Quincey Koziol
- *        December 18, 2006
+ * Programmer:  Quincey Koziol
+ *              December 18, 2006
  *
  *-------------------------------------------------------------------------
  */
@@ -406,7 +405,7 @@ H5A__open_common(const H5G_loc_t *loc, H5A_t *attr)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* H5A__open_common() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__open
  *
@@ -451,13 +450,13 @@ H5A__open(const H5G_loc_t *loc, const char *attr_name)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* H5A__open() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__open_by_idx
  *
  * Purpose:     Open an attribute according to its index order
  *
- * Return:    Non-negative on success/Negative on failure
+ * Return:      SUCCEED/FAIL
  *
  * Programmer:    Quincey Koziol
  *        April 2, 1998
@@ -515,7 +514,7 @@ H5A__open_by_idx(const H5G_loc_t *loc, const char *obj_name, H5_index_t idx_type
     FUNC_LEAVE_NOAPI(ret_value)
 } /* H5A__open_by_idx() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__open_by_name
  *
@@ -579,7 +578,7 @@ H5A__open_by_name(const H5G_loc_t *loc, const char *obj_name, const char *attr_n
     FUNC_LEAVE_NOAPI(ret_value)
 } /* H5A__open_by_name() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5A__read
@@ -681,12 +680,12 @@ H5A__read(const H5A_t *attr, const H5T_t *mem_type, void *buf)
     if(tconv_buf)
         tconv_buf = H5FL_BLK_FREE(attr_buf, tconv_buf);
     if(bkg_buf)
-    bkg_buf = H5FL_BLK_FREE(attr_buf, bkg_buf);
+        bkg_buf = H5FL_BLK_FREE(attr_buf, bkg_buf);
 
     FUNC_LEAVE_NOAPI_TAG(ret_value)
 } /* H5A__read() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5A__write
@@ -800,7 +799,7 @@ H5A__write(H5A_t *attr, const H5T_t *mem_type, const void *buf)
     FUNC_LEAVE_NOAPI_TAG(ret_value)
 } /* H5A__write() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5A__get_name
@@ -821,7 +820,7 @@ ssize_t
 H5A__get_name(H5A_t *attr, size_t buf_size, char *buf)
 {
     size_t              copy_len, nbytes;
-    ssize_t        ret_value = -1;         /* Return value */
+    ssize_t             ret_value = -1;         /* Return value */
 
     FUNC_ENTER_PACKAGE_NOERR
 
@@ -846,7 +845,7 @@ H5A__get_name(H5A_t *attr, size_t buf_size, char *buf)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* H5A__get_name() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A_get_space
  *
@@ -883,14 +882,13 @@ H5A_get_space(H5A_t *attr)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5A_get_space() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__get_type
  *
  * Purpose:     Returns an ID for the datatype of an attribute
  *
  * Return:      Success:    A valid ID for the datatype of an attribute
- *
  *              Failure:    H5I_INVALID_HID
  *
  *-------------------------------------------------------------------------
@@ -946,7 +944,7 @@ H5A__get_type(H5A_t *attr)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5A__get_type() */
 
-
+
 /*--------------------------------------------------------------------------
  NAME
     H5A__get_create_plist
@@ -978,7 +976,7 @@ H5A__get_create_plist(H5A_t* attr)
 
     /* Create the property list object to return */
     if((new_plist_id = H5P_copy_plist(plist, TRUE)) < 0)
-    HGOTO_ERROR(H5E_PLIST, H5E_CANTINIT, FAIL, "unable to copy attribute creation properties")
+        HGOTO_ERROR(H5E_PLIST, H5E_CANTINIT, FAIL, "unable to copy attribute creation properties")
     if(NULL == (new_plist = (H5P_genplist_t *)H5I_object(new_plist_id)))
         HGOTO_ERROR(H5E_PLIST, H5E_BADTYPE, FAIL, "can't get property list")
 
@@ -992,7 +990,7 @@ H5A__get_create_plist(H5A_t* attr)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5A__get_create_plist() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__get_info
  *
@@ -1033,14 +1031,13 @@ H5A__get_info(const H5A_t *attr, H5A_info_t *ainfo)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5A__get_info() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__copy
  *
  * Purpose:     Copies attribute OLD_ATTR.
  *
  * Return:      Success:    Pointer to a new copy of the OLD_ATTR argument.
- *
  *              Failure:    NULL
  *
  * Programmer:    Robb Matzke
@@ -1096,7 +1093,7 @@ H5A__copy(H5A_t *_new_attr, const H5A_t *old_attr)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5A__copy() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__shared_free
  *
@@ -1148,7 +1145,7 @@ H5A__shared_free(H5A_t *attr)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5A__shared_free() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__close_cb
  *
@@ -1180,7 +1177,7 @@ H5A__close_cb(H5VL_object_t *attr_vol_obj)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5A__close_cb() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__close
  *
@@ -1231,7 +1228,7 @@ H5A__close(H5A_t *attr)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5A__close() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A_oloc
  *
@@ -1263,7 +1260,7 @@ H5A_oloc(H5A_t *attr)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5A_oloc() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A_nameof
  *
@@ -1295,7 +1292,7 @@ H5A_nameof(H5A_t *attr)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5A_nameof() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A_type
  *
@@ -1325,7 +1322,7 @@ H5A_type(const H5A_t *attr)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5A_type() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__exists_by_name
  *
@@ -1371,7 +1368,7 @@ H5A__exists_by_name(H5G_loc_t loc, const char *obj_name, const char *attr_name)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* H5A__exists_by_name() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__compact_build_table_cb
  *
@@ -1381,7 +1378,6 @@ H5A__exists_by_name(H5G_loc_t loc, const char *obj_name, const char *attr_name)
  * Return:    Non-negative on success/Negative on failure
  *
  * Programmer:    Quincey Koziol
- *        koziol@hdfgroup.org
  *        Dec 18 2006
  *
  * Modification:Raymond Lu
@@ -1432,7 +1428,7 @@ H5A__compact_build_table_cb(H5O_t H5_ATTR_UNUSED *oh, H5O_mesg_t *mesg/*in,out*/
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5A__compact_build_table_cb() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__compact_build_table
  *
@@ -1444,8 +1440,8 @@ H5A__compact_build_table_cb(H5O_t H5_ATTR_UNUSED *oh, H5O_mesg_t *mesg/*in,out*/
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:    Quincey Koziol
- *            Dec 18, 2006
+ * Programmer:  Quincey Koziol
+ *              Dec 18, 2006
  *
  *-------------------------------------------------------------------------
  */
@@ -1495,18 +1491,16 @@ H5A__compact_build_table(H5F_t *f, H5O_t *oh, H5_index_t idx_type,
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5A__compact_build_table() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__dense_build_table_cb
  *
  * Purpose:    Callback routine for building table of attributes from dense
  *              attribute storage.
  *
- * Return:    Success:        Non-negative
- *        Failure:    Negative
+ * Return:      SUCCEED/FAIL
  *
  * Programmer:    Quincey Koziol
- *        koziol@hdfgroup.org
  *        Dec 11 2006
  *
  *-------------------------------------------------------------------------
@@ -1539,7 +1533,7 @@ H5A__dense_build_table_cb(const H5A_t *attr, void *_udata)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5A__dense_build_table_cb() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__dense_build_table
  *
@@ -1624,21 +1618,20 @@ H5A__dense_build_table(H5F_t *f, const H5O_ainfo_t *ainfo,
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5A__dense_build_table() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__attr_cmp_name_inc
  *
- * Purpose:    Callback routine for comparing two attribute names, in
+ * Purpose:     Callback routine for comparing two attribute names, in
  *              increasing alphabetic order
  *
- * Return:    An integer less than, equal to, or greater than zero if the
+ * Return:      An integer less than, equal to, or greater than zero if the
  *              first argument is considered to be respectively less than,
  *              equal to, or greater than the second.  If two members compare
  *              as equal, their order in the sorted array is undefined.
  *              (i.e. same as strcmp())
  *
  * Programmer:    Quincey Koziol
- *        koziol@hdfgroup.org
  *        Dec 11 2006
  *
  *-------------------------------------------------------------------------
@@ -1652,7 +1645,7 @@ H5A__attr_cmp_name_inc(const void *attr1, const void *attr2)
             (*(const H5A_t * const *)attr2)->shared->name))
 } /* end H5A__attr_cmp_name_inc() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__attr_cmp_name_dec
  *
@@ -1666,7 +1659,6 @@ H5A__attr_cmp_name_inc(const void *attr1, const void *attr2)
  *              (i.e. opposite of strcmp())
  *
  * Programmer:    Quincey Koziol
- *        koziol@hdfgroup.org
  *        Feb  8 2007
  *
  *-------------------------------------------------------------------------
@@ -1680,7 +1672,7 @@ H5A__attr_cmp_name_dec(const void *attr1, const void *attr2)
             (*(const H5A_t * const *)attr1)->shared->name))
 } /* end H5A__attr_cmp_name_dec() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__attr_cmp_corder_inc
  *
@@ -1693,7 +1685,6 @@ H5A__attr_cmp_name_dec(const void *attr1, const void *attr2)
  *              as equal, their order in the sorted array is undefined.
  *
  * Programmer:    Quincey Koziol
- *        koziol@hdfgroup.org
  *        Feb  8 2007
  *
  *-------------------------------------------------------------------------
@@ -1715,21 +1706,20 @@ H5A__attr_cmp_corder_inc(const void *attr1, const void *attr2)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5A__attr_cmp_corder_inc() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__attr_cmp_corder_dec
  *
- * Purpose:    Callback routine for comparing two attributes, in
+ * Purpose:     Callback routine for comparing two attributes, in
  *              decreasing creation order
  *
- * Return:    An integer less than, equal to, or greater than zero if the
+ * Return:      An integer less than, equal to, or greater than zero if the
  *              second argument is considered to be respectively less than,
  *              equal to, or greater than the first.  If two members compare
  *              as equal, their order in the sorted array is undefined.
  *
- * Programmer:    Quincey Koziol
- *        koziol@hdfgroup.org
- *        Feb  8 2007
+ * Programmer:  Quincey Koziol
+ *              Feb  8 2007
  *
  *-------------------------------------------------------------------------
  */
@@ -1750,17 +1740,16 @@ H5A__attr_cmp_corder_dec(const void *attr1, const void *attr2)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5A__attr_cmp_corder_dec() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__attr_sort_table
  *
  * Purpose:     Sort table containing a list of attributes for an object
  *
- * Return:    Success:        Non-negative
- *        Failure:    Negative
+ * Return:      SUCCEED/FAIL
  *
- * Programmer:    Quincey Koziol
- *            Dec 11, 2006
+ * Programmer:  Quincey Koziol
+ *              Dec 11, 2006
  *
  *-------------------------------------------------------------------------
  */
@@ -1795,7 +1784,7 @@ H5A__attr_sort_table(H5A_attr_table_t *atable, H5_index_t idx_type,
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5A__attr_sort_table() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__attr_iterate_table
  *
@@ -1804,8 +1793,8 @@ H5A__attr_sort_table(H5A_attr_table_t *atable, H5_index_t idx_type,
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:    Quincey Koziol
- *            Dec 18, 2006
+ * Programmer:  Quincey Koziol
+ *              Dec 18, 2006
  *
  *-------------------------------------------------------------------------
  */
@@ -1877,7 +1866,7 @@ H5A__attr_iterate_table(const H5A_attr_table_t *atable, hsize_t skip,
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5A__attr_iterate_table() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__attr_release_table
  *
@@ -1885,7 +1874,7 @@ H5A__attr_iterate_table(const H5A_attr_table_t *atable, hsize_t skip,
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:      Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Dec 11, 2006
  *
  *-------------------------------------------------------------------------
@@ -1893,7 +1882,7 @@ H5A__attr_iterate_table(const H5A_attr_table_t *atable, hsize_t skip,
 herr_t
 H5A__attr_release_table(H5A_attr_table_t *atable)
 {
-    herr_t    ret_value = SUCCEED;    /* Return value */
+    herr_t  ret_value = SUCCEED;    /* Return value */
 
     FUNC_ENTER_PACKAGE
 
@@ -1918,18 +1907,16 @@ H5A__attr_release_table(H5A_attr_table_t *atable)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5A__attr_release_table() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__get_ainfo
  *
  * Purpose:     Retrieves the "attribute info" message for an object.  Also
  *              sets the number of attributes correctly, if it isn't set up yet.
  *
- * Return:      Success:    TRUE/FALSE whether message was found & retrieved
- *              Failure:    FAIL if error occurred
+ * Return:      TRUE/FALSE/FAIL
  *
  * Programmer:  Quincey Koziol
- *              koziol@hdfgroup.org
  *              Mar 11 2007
  *
  *-------------------------------------------------------------------------
@@ -1949,11 +1936,11 @@ H5A__get_ainfo(H5F_t *f, H5O_t *oh, H5O_ainfo_t *ainfo)
 
     /* Check if the "attribute info" message exists */
     if((ret_value = H5O_msg_exists_oh(oh, H5O_AINFO_ID)) < 0)
-    HGOTO_ERROR(H5E_ATTR, H5E_NOTFOUND, FAIL, "unable to check object header")
+        HGOTO_ERROR(H5E_ATTR, H5E_NOTFOUND, FAIL, "unable to check object header")
     if(ret_value > 0) {
         /* Retrieve the "attribute info" structure */
         if(NULL == H5O_msg_read_oh(f, oh, H5O_AINFO_ID, ainfo))
-        HGOTO_ERROR(H5E_ATTR, H5E_CANTGET, FAIL, "can't read AINFO message")
+            HGOTO_ERROR(H5E_ATTR, H5E_CANTGET, FAIL, "can't read AINFO message")
 
         /* Check if we don't know how many attributes there are */
         if(ainfo->nattrs == HSIZET_MAX) {
@@ -1982,7 +1969,7 @@ H5A__get_ainfo(H5F_t *f, H5O_t *oh, H5O_ainfo_t *ainfo)
     FUNC_LEAVE_NOAPI_TAG(ret_value)
 } /* end H5A__get_ainfo() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__set_version
  *
@@ -1993,7 +1980,6 @@ H5A__get_ainfo(H5F_t *f, H5O_t *oh, H5O_ainfo_t *ainfo)
  * Return:      SUCCEED/FAIL
  *
  * Programmer:  Quincey Koziol
- *              koziol@hdfgroup.org
  *              Jul 17 2007
  *
  *-------------------------------------------------------------------------
@@ -2044,7 +2030,7 @@ H5A__set_version(const H5F_t *f, H5A_t *attr)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5A__set_version() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__attr_copy_file
  *
@@ -2254,10 +2240,10 @@ H5A__attr_copy_file(const H5A_t *attr_src, H5F_t *file_dst, hbool_t *recompute_s
 
             H5MM_memcpy(buf, attr_src->shared->data, attr_src->shared->data_size);
 
-        /* Allocate background memory */
-        if(H5T_path_bkg(tpath_src_mem) || H5T_path_bkg(tpath_mem_dst))
-        if(NULL == (bkg_buf = H5FL_BLK_CALLOC(attr_buf, buf_size)))
-            HGOTO_ERROR(H5E_ATTR, H5E_CANTALLOC, NULL, "memory allocation failed")
+            /* Allocate background memory */
+            if(H5T_path_bkg(tpath_src_mem) || H5T_path_bkg(tpath_mem_dst))
+                if(NULL == (bkg_buf = H5FL_BLK_CALLOC(attr_buf, buf_size)))
+                    HGOTO_ERROR(H5E_ATTR, H5E_CANTALLOC, NULL, "memory allocation failed")
 
             /* Convert from source file to memory */
             if(H5T_convert(tpath_src_mem, tid_src, tid_mem, nelmts, (size_t)0, (size_t)0, buf, bkg_buf) < 0)
@@ -2265,9 +2251,9 @@ H5A__attr_copy_file(const H5A_t *attr_src, H5F_t *file_dst, hbool_t *recompute_s
 
             H5MM_memcpy(reclaim_buf, buf, buf_size);
 
-        /* Set background buffer to all zeros */
-        if(bkg_buf)
-        HDmemset(bkg_buf, 0, buf_size);
+            /* Set background buffer to all zeros */
+            if(bkg_buf)
+                HDmemset(bkg_buf, 0, buf_size);
 
             /* Convert from memory to destination file */
             if(H5T_convert(tpath_mem_dst, tid_mem, tid_dst, nelmts, (size_t)0, (size_t)0, buf, bkg_buf) < 0)
@@ -2327,7 +2313,7 @@ H5A__attr_copy_file(const H5A_t *attr_src, H5F_t *file_dst, hbool_t *recompute_s
     FUNC_LEAVE_NOAPI(ret_value)
 } /* H5A__attr_copy_file() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__attr_post_copy_file
  *
@@ -2420,7 +2406,7 @@ H5A__attr_post_copy_file(const H5O_loc_t *src_oloc, const H5A_t *attr_src,
     FUNC_LEAVE_NOAPI(ret_value)
 } /* H5A__attr_post_copy_file() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__dense_post_copy_file_cb
  *
@@ -2478,7 +2464,7 @@ H5A__dense_post_copy_file_cb(const H5A_t *attr_src, void *_udata)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5A__dense_post_copy_file_cb() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__dense_post_copy_file_all
  *
@@ -2487,7 +2473,6 @@ H5A__dense_post_copy_file_cb(const H5A_t *attr_src, void *_udata)
  * Return:      SUCCEED/FAIL
  *
  * Programmer:  Peter Cao
- *              xcao@hdfgroup.org
  *              July 20, 2007
  *
  *-------------------------------------------------------------------------
@@ -2525,7 +2510,7 @@ H5A__dense_post_copy_file_all(const H5O_loc_t *src_oloc, const H5O_ainfo_t *ainf
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5A__dense_post_copy_file_all */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__rename_by_name
  *
@@ -2533,7 +2518,7 @@ H5A__dense_post_copy_file_all(const H5O_loc_t *src_oloc, const H5O_ainfo_t *ainf
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              February 20, 2007
  *
  *-------------------------------------------------------------------------
@@ -2543,10 +2528,10 @@ H5A__rename_by_name(H5G_loc_t loc, const char *obj_name, const char *old_attr_na
     const char *new_attr_name)
 {
     H5G_loc_t   obj_loc;                /* Location used to open group */
-    H5G_name_t  obj_path;                /* Opened object group hier. path */
-    H5O_loc_t   obj_oloc;                /* Opened object object location */
+    H5G_name_t  obj_path;               /* Opened object group hier. path */
+    H5O_loc_t   obj_oloc;               /* Opened object object location */
     hbool_t     loc_found = FALSE;      /* Entry at 'obj_name' found */
-    herr_t    ret_value = SUCCEED;    /* Return value */
+    herr_t      ret_value = SUCCEED;    /* Return value */
 
     FUNC_ENTER_PACKAGE
 
@@ -2575,7 +2560,7 @@ H5A__rename_by_name(H5G_loc_t loc, const char *obj_name, const char *old_attr_na
     FUNC_LEAVE_NOAPI(ret_value)
 } /* H5A__rename_by_name() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__iterate_common
  *
@@ -2583,7 +2568,7 @@ H5A__rename_by_name(H5G_loc_t loc, const char *obj_name, const char *old_attr_na
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              December 6, 2017
  *
  *-------------------------------------------------------------------------
@@ -2610,7 +2595,7 @@ H5A__iterate_common(hid_t loc_id, H5_index_t idx_type, H5_iter_order_t order,
     FUNC_LEAVE_NOAPI(ret_value)
 } /* H5A__iterate_common() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__iterate
  *
@@ -2675,7 +2660,7 @@ H5A__iterate(const H5G_loc_t *loc, const char *obj_name, H5_index_t idx_type, H5
 } /* end H5A__iterate() */
 
 #ifndef H5_NO_DEPRECATED_SYMBOLS
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__iterate_old
  *
@@ -2683,7 +2668,7 @@ H5A__iterate(const H5G_loc_t *loc, const char *obj_name, H5_index_t idx_type, H5
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              December 6, 2017
  *
  *-------------------------------------------------------------------------
@@ -2725,7 +2710,7 @@ H5A__iterate_old(hid_t loc_id, unsigned *attr_num, H5A_operator1_t op,
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              December 6, 2017
  *
  *-------------------------------------------------------------------------
@@ -2734,8 +2719,8 @@ herr_t
 H5A__delete_by_name(const H5G_loc_t *loc, const char *obj_name, const char *attr_name)
 {
     H5G_loc_t   obj_loc;                /* Location used to open group */
-    H5G_name_t  obj_path;                /* Opened object group hier. path */
-    H5O_loc_t   obj_oloc;                /* Opened object object location */
+    H5G_name_t  obj_path;               /* Opened object group hier. path */
+    H5O_loc_t   obj_oloc;               /* Opened object object location */
     hbool_t     loc_found = FALSE;      /* Entry at 'obj_name' found */
     herr_t ret_value = SUCCEED;         /* Return value */
 
@@ -2763,7 +2748,7 @@ H5A__delete_by_name(const H5G_loc_t *loc, const char *obj_name, const char *attr
     FUNC_LEAVE_NOAPI(ret_value)
 } /* H5A__delete_by_name() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5A__delete_by_idx
  *
@@ -2771,7 +2756,7 @@ H5A__delete_by_name(const H5G_loc_t *loc, const char *obj_name, const char *attr
  *
  * Return:      SUCCEED/FAIL
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              December 6, 2017
  *
  *-------------------------------------------------------------------------
@@ -2781,8 +2766,8 @@ H5A__delete_by_idx(const H5G_loc_t *loc, const char *obj_name, H5_index_t idx_ty
     H5_iter_order_t order, hsize_t n)
 {
     H5G_loc_t   obj_loc;                /* Location used to open group */
-    H5G_name_t  obj_path;                /* Opened object group hier. path */
-    H5O_loc_t   obj_oloc;                /* Opened object object location */
+    H5G_name_t  obj_path;               /* Opened object group hier. path */
+    H5O_loc_t   obj_oloc;               /* Opened object object location */
     hbool_t     loc_found = FALSE;      /* Entry at 'obj_name' found */
     herr_t ret_value = SUCCEED;         /* Return value */
 
diff --git a/src/H5B2.c b/src/H5B2.c
index c9ed30368e8..5c83de2702b 100644
--- a/src/H5B2.c
+++ b/src/H5B2.c
@@ -15,7 +15,7 @@
  *
  * Created:		H5B2.c
  *			Jan 31 2005
- *			Quincey Koziol <koziol@ncsa.uiuc.edu>
+ *			Quincey Koziol
  *
  * Purpose:		Implements a B-tree, with several modifications from
  *                      the "standard" methods.
@@ -129,7 +129,6 @@ H5FL_DEFINE_STATIC(H5B2_t);
  *              filled in), negative on failure
  *
  * Programmer:	Quincey Koziol
- *		koziol@ncsa.uiuc.edu
  *		Jan 31 2005
  *
  *-------------------------------------------------------------------------
@@ -200,7 +199,6 @@ H5B2_create(H5F_t *f, const H5B2_create_t *cparam, void *ctx_udata)
  *              NULL on failure
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Oct 15 2009
  *
  *-------------------------------------------------------------------------
@@ -264,7 +262,6 @@ H5B2_open(H5F_t *f, haddr_t addr, void *ctx_udata)
  * Return:	Non-negative on success/Negative on failure
  *
  * Programmer:	Quincey Koziol
- *		koziol@ncsa.uiuc.edu
  *		Feb  2 2005
  *
  *-------------------------------------------------------------------------
@@ -307,7 +304,6 @@ H5B2_insert(H5B2_t *bt2, void *udata)
  * Return:	Non-negative on success/Negative on failure
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Dec 23 2015
  *
  *-------------------------------------------------------------------------
@@ -379,7 +375,6 @@ H5B2_update(H5B2_t *bt2, void *udata, H5B2_modify_t op, void *op_data)
  * Return:	SUCCEED/FAIL
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Nov  5 2009
  *
  *-------------------------------------------------------------------------
@@ -414,7 +409,6 @@ H5B2_get_addr(const H5B2_t *bt2, haddr_t *addr_p)
  * Return:	Value from callback: non-negative on success, negative on error
  *
  * Programmer:	Quincey Koziol
- *		koziol@ncsa.uiuc.edu
  *		Feb 11 2005
  *
  *-------------------------------------------------------------------------
@@ -465,7 +459,6 @@ H5B2_iterate(H5B2_t *bt2, H5B2_operator_t op, void *op_data)
  * Return:	Non-negative (TRUE/FALSE) on success, negative on failure.
  *
  * Programmer:	Quincey Koziol
- *		koziol@ncsa.uiuc.edu
  *		Feb 23 2005
  *
  *-------------------------------------------------------------------------
@@ -705,7 +698,6 @@ H5B2_find(H5B2_t *bt2, void *udata, H5B2_found_t op, void *op_data)
  * Return:	Non-negative on success, negative on failure.
  *
  * Programmer:	Quincey Koziol
- *		koziol@ncsa.uiuc.edu
  *		Feb 23 2005
  *
  *-------------------------------------------------------------------------
@@ -894,7 +886,6 @@ H5B2_index(H5B2_t *bt2, H5_iter_order_t order, hsize_t idx, H5B2_found_t op,
  * Return:	Non-negative on success/Negative on failure
  *
  * Programmer:	Quincey Koziol
- *		koziol@ncsa.uiuc.edu
  *		Feb 25 2005
  *
  *-------------------------------------------------------------------------
@@ -968,7 +959,6 @@ H5B2_remove(H5B2_t *bt2, void *udata, H5B2_remove_t op, void *op_data)
  * Return:	Non-negative on success/Negative on failure
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Nov 14 2006
  *
  *-------------------------------------------------------------------------
@@ -1051,7 +1041,6 @@ H5B2_remove_by_idx(H5B2_t *bt2, H5_iter_order_t order, hsize_t idx,
  * Return:	Non-negative on success/Negative on failure
  *
  * Programmer:	Quincey Koziol
- *		koziol@ncsa.uiuc.edu
  *		Feb 25 2005
  *
  *-------------------------------------------------------------------------
@@ -1092,7 +1081,6 @@ H5B2_get_nrec(const H5B2_t *bt2, hsize_t *nrec)
  * Return:	Non-negative on success, negative on failure.
  *
  * Programmer:	Quincey Koziol
- *		koziol@ncsa.uiuc.edu
  *		Mar  8 2005
  *
  *-------------------------------------------------------------------------
@@ -1150,7 +1138,6 @@ H5B2_neighbor(H5B2_t *bt2, H5B2_compare_t range, void *udata,
  * Return:	Non-negative on success, negative on failure.
  *
  * Programmer:	Quincey Koziol
- *		koziol@ncsa.uiuc.edu
  *		Mar 10 2005
  *
  *-------------------------------------------------------------------------
@@ -1384,7 +1371,6 @@ H5B2_modify(H5B2_t *bt2, void *udata, H5B2_modify_t op, void *op_data)
  * Return:	Non-negative on success/Negative on failure
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Oct 15 2009
  *
  *-------------------------------------------------------------------------
@@ -1493,7 +1479,6 @@ H5B2_close(H5B2_t *bt2)
  * Return:	Non-negative on success, negative on failure.
  *
  * Programmer:	Quincey Koziol
- *		koziol@ncsa.uiuc.edu
  *		Mar  9 2005
  *
  *-------------------------------------------------------------------------
diff --git a/src/H5B2hdr.c b/src/H5B2hdr.c
index 68669e8058f..9ba82353ab6 100644
--- a/src/H5B2hdr.c
+++ b/src/H5B2hdr.c
@@ -15,7 +15,7 @@
  *
  * Created:		H5B2int.c
  *			Feb 27 2006
- *			Quincey Koziol <koziol@ncsa.uiuc.edu>
+ *			Quincey Koziol
  *
  * Purpose:		Internal routines for managing v2 B-trees.
  *
@@ -101,7 +101,6 @@ H5FL_SEQ_DEFINE(H5B2_node_info_t);
  * Return:	Non-negative on success/Negative on failure
  *
  * Programmer:	Quincey Koziol
- *		koziol@ncsa.uiuc.edu
  *		Feb  2 2005
  *
  *-------------------------------------------------------------------------
@@ -230,7 +229,6 @@ H5B2__hdr_init(H5B2_hdr_t *hdr, const H5B2_create_t *cparam, void *ctx_udata,
  * Return:	Non-negative on success/Negative on failure
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Oct 27 2009
  *
  *-------------------------------------------------------------------------
@@ -276,7 +274,6 @@ H5B2__hdr_alloc(H5F_t *f)
  * Return:	Non-negative on success/Negative on failure
  *
  * Programmer:	Quincey Koziol
- *		koziol@ncsa.uiuc.edu
  *		Mar 21 2006
  *
  *-------------------------------------------------------------------------
@@ -355,7 +352,6 @@ H5B2__hdr_create(H5F_t *f, const H5B2_create_t *cparam, void *ctx_udata)
  * Return:	Non-negative on success/Negative on failure
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Oct 13 2009
  *
  *-------------------------------------------------------------------------
@@ -391,7 +387,6 @@ H5B2__hdr_incr(H5B2_hdr_t *hdr)
  * Return:	Non-negative on success/Negative on failure
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Oct 13 2009
  *
  *-------------------------------------------------------------------------
@@ -428,7 +423,6 @@ H5B2__hdr_decr(H5B2_hdr_t *hdr)
  * Return:      SUCCEED (Can't fail)
  *
  * Programmer:  Quincey Koziol
- *              koziol@hdfgroup.org
  *              Oct 27 2009
  *
  *-------------------------------------------------------------------------
@@ -456,7 +450,6 @@ H5B2__hdr_fuse_incr(H5B2_hdr_t *hdr)
  * Return:      The file's reference count after the decrement. (Can't fail)
  *
  * Programmer:  Quincey Koziol
- *              koziol@hdfgroup.org
  *              Oct 27 2009
  *
  *-------------------------------------------------------------------------
@@ -485,7 +478,6 @@ H5B2__hdr_fuse_decr(H5B2_hdr_t *hdr)
  * Return:	Non-negative on success/Negative on failure
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Oct 13 2009
  *
  *-------------------------------------------------------------------------
@@ -517,7 +509,6 @@ H5B2__hdr_dirty(H5B2_hdr_t *hdr)
  * Return:	Non-NULL pointer to header on success/NULL on failure
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Dec 18 2015
  *
  *-------------------------------------------------------------------------
diff --git a/src/H5EAdbg.c b/src/H5EAdbg.c
index eb3624be99c..20c6a4dec39 100644
--- a/src/H5EAdbg.c
+++ b/src/H5EAdbg.c
@@ -174,15 +174,14 @@ END_FUNC(PKG)   /* end H5EA__hdr_debug() */
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5EA__iblock_debug
+ * Function:    H5EA__iblock_debug
  *
- * Purpose:	Prints debugging info about a extensible array index block.
+ * Purpose:     Prints debugging info about a extensible array index block.
  *
- * Return:	Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
- *		Sep 11 2008
+ * Programmer:  Quincey Koziol
+ *              Sep 11 2008
  *
  *-------------------------------------------------------------------------
  */
@@ -214,7 +213,7 @@ H5EA__iblock_debug(H5F_t *f, haddr_t H5_ATTR_UNUSED addr, FILE *stream, int inde
 
     /* Load the extensible array header */
     if(NULL == (hdr = H5EA__hdr_protect(f, hdr_addr, dbg_ctx, H5AC__READ_ONLY_FLAG)))
-	H5E_THROW(H5E_CANTPROTECT, "unable to load extensible array header")
+        H5E_THROW(H5E_CANTPROTECT, "unable to load extensible array header")
 
     /* Sanity check */
     HDassert(H5F_addr_eq(hdr->idx_blk_addr, addr));
@@ -228,16 +227,16 @@ H5EA__iblock_debug(H5F_t *f, haddr_t H5_ATTR_UNUSED addr, FILE *stream, int inde
 
     /* Print the values */
     HDfprintf(stream, "%*s%-*s %s\n", indent, "", fwidth,
-	      "Array class ID:",  hdr->cparam.cls->name);
+        "Array class ID:",  hdr->cparam.cls->name);
     HDfprintf(stream, "%*s%-*s %Zu\n", indent, "", fwidth,
-	      "Index Block size:",
-	      iblock->size);
+        "Index Block size:",
+        iblock->size);
     HDfprintf(stream, "%*s%-*s %Zu\n", indent, "", fwidth,
-	      "# of data block addresses in index block:",
-	      iblock->ndblk_addrs);
+        "# of data block addresses in index block:",
+        iblock->ndblk_addrs);
     HDfprintf(stream, "%*s%-*s %Zu\n", indent, "", fwidth,
-	      "# of super block addresses in index block:",
-	      iblock->nsblk_addrs);
+        "# of super block addresses in index block:",
+        iblock->nsblk_addrs);
 
     /* Check if there are any elements in index block */
     if(hdr->cparam.idx_blk_elmts > 0) {
@@ -292,21 +291,20 @@ CATCH
     if(iblock && H5EA__iblock_unprotect(iblock, H5AC__NO_FLAGS_SET) < 0)
         H5E_THROW(H5E_CANTUNPROTECT, "unable to release extensible array index block")
     if(hdr && H5EA__hdr_unprotect(hdr, H5AC__NO_FLAGS_SET) < 0)
-	H5E_THROW(H5E_CANTUNPROTECT, "unable to release extensible array header")
+        H5E_THROW(H5E_CANTUNPROTECT, "unable to release extensible array header")
 
 END_FUNC(PKG)   /* end H5EA__iblock_debug() */
 
-
+
 /*-------------------------------------------------------------------------
- * Function:	H5EA__sblock_debug
+ * Function:    H5EA__sblock_debug
  *
- * Purpose:	Prints debugging info about a extensible array super block.
+ * Purpose:     Prints debugging info about a extensible array super block.
  *
- * Return:	Non-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
- * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
- *		Sep 30 2008
+ * Programmer:  Quincey Koziol
+ *              Sep 30 2008
  *
  *-------------------------------------------------------------------------
  */
@@ -338,7 +336,7 @@ H5EA__sblock_debug(H5F_t *f, haddr_t addr, FILE *stream, int indent,
 
     /* Load the extensible array header */
     if(NULL == (hdr = H5EA__hdr_protect(f, hdr_addr, dbg_ctx, H5AC__READ_ONLY_FLAG)))
-	H5E_THROW(H5E_CANTPROTECT, "unable to load extensible array header")
+        H5E_THROW(H5E_CANTPROTECT, "unable to load extensible array header")
 
     /* Protect super block */
     /* (Note: setting parent of super block to 'hdr' for this operation should be OK -QAK) */
@@ -350,16 +348,16 @@ H5EA__sblock_debug(H5F_t *f, haddr_t addr, FILE *stream, int indent,
 
     /* Print the values */
     HDfprintf(stream, "%*s%-*s %s\n", indent, "", fwidth,
-	      "Array class ID:",  hdr->cparam.cls->name);
+        "Array class ID:",  hdr->cparam.cls->name);
     HDfprintf(stream, "%*s%-*s %Zu\n", indent, "", fwidth,
-	      "Super Block size:",
-	      sblock->size);
+        "Super Block size:",
+        sblock->size);
     HDfprintf(stream, "%*s%-*s %Zu\n", indent, "", fwidth,
-	      "# of data block addresses in super block:",
-	      sblock->ndblks);
+        "# of data block addresses in super block:",
+        sblock->ndblks);
     HDfprintf(stream, "%*s%-*s %Zu\n", indent, "", fwidth,
-	      "# of elements in data blocks from this super block:",
-	      sblock->dblk_nelmts);
+        "# of elements in data blocks from this super block:",
+        sblock->dblk_nelmts);
 
     /* Check if there are any data block addresses in super block */
     if(sblock->ndblks > 0) {
diff --git a/src/H5Eint.c b/src/H5Eint.c
index fe72449471c..2371a5f3ebf 100644
--- a/src/H5Eint.c
+++ b/src/H5Eint.c
@@ -33,7 +33,6 @@
 /* Headers */
 /***********/
 #include "H5private.h"          /* Generic Functions                        */
-#include "H5CXprivate.h"        /* API Contexts                             */
 #include "H5Epkg.h"             /* Error handling                           */
 #include "H5Iprivate.h"         /* IDs                                      */
 #include "H5MMprivate.h"        /* Memory management                        */
@@ -576,7 +575,7 @@ H5E__walk(const H5E_t *estack, H5E_direction_t direction, const H5E_walk_op_t *o
                     ret_value = (op->u.func2)((unsigned)(estack->nused - (size_t)(i + 1)), estack->slot + i, client_data);
             } /* end else */
 
-            if(ret_value  < 0)
+            if(ret_value < 0)
                 HERROR(H5E_ERROR, H5E_CANTLIST, "can't walk error stack");
         } /* end if */
     } /* end else */
diff --git a/src/H5F.c b/src/H5F.c
index 3dbd2921c92..9d426ac79bc 100644
--- a/src/H5F.c
+++ b/src/H5F.c
@@ -549,8 +549,8 @@ H5Fget_obj_ids(hid_t file_id, unsigned types, size_t max_objs, hid_t *oid_list)
  * Purpose:     Returns a pointer to the file handle of the low-level file
  *              driver.
  *
- * Return:      SUCCEED/FAIL
- *
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -637,9 +637,7 @@ H5Fis_accessible(const char *filename, hid_t fapl_id)
  *              the list of file creation and file access properties.
  *
  * Return:      Success:    A file ID
- *
  *              Failure:    H5I_INVALID_HID
- *
  *-------------------------------------------------------------------------
  */
 hid_t
@@ -739,9 +737,7 @@ H5Fcreate(const char *filename, unsigned flags, hid_t fcpl_id, hid_t fapl_id)
  * See Also:    H5Fpublic.h for a list of possible values for FLAGS.
  *
  * Return:      Success:    A file ID
- *
  *              Failure:    H5I_INVALID_HID
- *
  *-------------------------------------------------------------------------
  */
 hid_t
@@ -820,7 +816,8 @@ H5Fopen(const char *filename, unsigned flags, hid_t fapl_id)
  *              not remove them from the cache.  The OBJECT_ID can be a file,
  *              dataset, group, attribute, or named data type.
  *
- * Return:      Non-negative on success/Negative on failure
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -1008,7 +1005,8 @@ H5Freopen(hid_t file_id)
  * Purpose:     Public API to retrieve the file's 'intent' flags passed
  *              during H5Fopen()
  *
- * Return:      Non-negative on success/negative on failure
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -1079,9 +1077,7 @@ H5Fget_fileno(hid_t file_id, unsigned long *fnumber)
  * Purpose:     Retrieves the amount of free space in the file.
  *
  * Return:      Success:    Amount of free space for type
- *
  *              Failure:    -1
- *
  *-------------------------------------------------------------------------
  */
 hssize_t
@@ -1175,9 +1171,7 @@ H5Fget_filesize(hid_t file_id, hsize_t *size)
  *              this now.
  *
  * Return:      Success:    Bytes copied / number of bytes needed
- *
  *              Failure:    -1
- *
  *-------------------------------------------------------------------------
  */
 ssize_t
@@ -1212,8 +1206,8 @@ H5Fget_file_image(hid_t file_id, void *buf_ptr, size_t buf_len)
  *              filled in by the caller.  This allows us to adapt for
  *              obsolete versions of the structure.
  *
- * Return:      SUCCEED/FAIL
- *
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -1249,8 +1243,8 @@ H5Fget_mdc_config(hid_t file_id, H5AC_cache_config_t *config_ptr)
  *              configuration, using the contents of the instance of
  *              H5AC_cache_config_t pointed to by config_ptr.
  *
- * Return:      SUCCEED/FAIL
- *
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -1283,8 +1277,8 @@ H5Fset_mdc_config(hid_t file_id, H5AC_cache_config_t *config_ptr)
  *              the hit rate statistics were reset either manually or
  *              automatically.
  *
- * Return:      SUCCEED/FAIL
- *
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -1320,8 +1314,8 @@ H5Fget_mdc_hit_rate(hid_t file_id, double *hit_rate_ptr)
  *              the ptr parameters are NULL, the associated datum is
  *              not returned.
  *
- * Return:      SUCCEED/FAIL
- *
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -1360,8 +1354,8 @@ H5Fget_mdc_size(hid_t file_id, size_t *max_size_ptr, size_t *min_clean_size_ptr,
  *              you are controlling cache size from your program instead
  *              of using our cache size control code.
  *
- * Return:      SUCCEED/FAIL
- *
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -1402,9 +1396,7 @@ H5Freset_mdc_hit_rate_stats(hid_t file_id)
  *              not the actual name after resolving symlinks, etc.
  *
  * Return:      Success:    The length of the file name
- *
  *              Failure:    -1
- *
  *-------------------------------------------------------------------------
  */
 ssize_t
@@ -1444,8 +1436,8 @@ H5Fget_name(hid_t obj_id, char *name/*out*/, size_t size)
  *                 in the SOHM table if there is one.
  *              3. The amount of free space tracked in the file.
  *
- * Return:      SUCCEED/FAIL
- *
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -1486,8 +1478,8 @@ H5Fget_info2(hid_t obj_id, H5F_info2_t *finfo)
  * Purpose:     To retrieve the collection of read retries for metadata
  *              items with checksum.
  *
- * Return:      SUCCEED/FAIL
- *
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -1525,9 +1517,7 @@ H5Fget_metadata_read_retry_info(hid_t file_id, H5F_retry_info_t *info)
  *              sections.
  *
  * Return:      Success:   The total # of free space sections
- *
  *              Failure:   -1
- *
  *-------------------------------------------------------------------------
  */
 ssize_t
@@ -1562,8 +1552,8 @@ H5Fget_free_sections(hid_t file_id, H5F_mem_t type, size_t nsects,
  *              provided file, potentially closing any cached files
  *              unless they are held open from somewhere\ else.
  *
- * Return:      SUCCEED/FAIL
- *
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -1618,8 +1608,8 @@ H5Fclear_elink_file_cache(hid_t file_id)
  *              set up flush dependency/proxy even for file opened without
  *              SWMR to resolve issues with opened objects.
  *
- * Return:      Non-negative on success/negative on failure
- *
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -1654,7 +1644,8 @@ H5Fstart_swmr_write(hid_t file_id)
  * Purpose:     Start metadata cache logging operations for a file.
  *                  - Logging must have been set up via the fapl.
  *
- * Return:      Non-negative on success/Negative on errors
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -1686,7 +1677,8 @@ H5Fstart_mdc_logging(hid_t file_id)
  *                  - Does not close the log file.
  *                  - Logging must have been set up via the fapl.
  *
- * Return:      Non-negative on success/Negative on errors
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -1718,7 +1710,8 @@ H5Fstop_mdc_logging(hid_t file_id)
  *              set up via the fapl. is_currently_logging determines if
  *              log messages are being recorded at this time.
  *
- * Return:      Non-negative on success/Negative on errors
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -1752,7 +1745,8 @@ H5Fget_mdc_logging_status(hid_t file_id, hbool_t *is_enabled,
  *              H5Fset_latest_format() starting release 1.10.2.
  *              See explanation for H5Fset_latest_format() in H5Fdeprec.c.
  *
- * Return:     Non-negative on success/Negative on failure
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -1788,7 +1782,8 @@ H5Fset_libver_bounds(hid_t file_id, H5F_libver_t low, H5F_libver_t high)
  *              downgrade persistent file space to non-persistent
  *              for 1.8 library.
  *
- * Return:      Non-negative on success/Negative on failure
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -1822,7 +1817,8 @@ H5Fformat_convert(hid_t file_id)
  *
  * Purpose:     Resets statistics for the page buffer layer.
  *
- * Return:      Non-negative on success/Negative on failure
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -1852,7 +1848,8 @@ H5Freset_page_buffering_stats(hid_t file_id)
  *
  * Purpose:     Retrieves statistics for the page buffer layer.
  *
- * Return:      Non-negative on success/Negative on failure
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -1890,7 +1887,8 @@ H5Fget_page_buffering_stats(hid_t file_id, unsigned accesses[2], unsigned hits[2
  *              image_len:   --size of the on disk metadata cache image
  *                           --zero if no cache image
  *
- * Return:      Non-negative on success/Negative on failure
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -1918,14 +1916,12 @@ H5Fget_mdc_image_info(hid_t file_id, haddr_t *image_addr, hsize_t *image_len)
 /*-------------------------------------------------------------------------
  * Function:    H5Fget_eoa
  *
- * Purpose:     Returns the address of the first byte after the last
+ * Purpose:     Gets the address of the first byte after the last
  *              allocated memory in the file.
  *              (See H5FDget_eoa() in H5FD.c)
  *
- * Return:      Success:    First byte after allocated memory.
- *              Failure:    HADDR_UNDEF
- *
- *              Non-negative on success/Negative on failure
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -1958,7 +1954,8 @@ H5Fget_eoa(hid_t file_id, haddr_t *eoa)
  *
  * Purpose:     Set the EOA for the file to the maximum of (EOA, EOF) + increment
  *
- * Return:      Non-negative on success/Negative on errors
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -1984,24 +1981,13 @@ H5Fincrement_filesize(hid_t file_id, hsize_t increment)
 
 
 /*-------------------------------------------------------------------------
- * Function: H5Fget_dset_no_attrs_hint
- *
- * Purpose:
- *
- *     Get the file-level setting to create minimized dataset object headers.
- *     Result is stored at pointer `minimize`.
- *
- * Return:
+ * Function:    H5Fget_dset_no_attrs_hint
  *
- *     Success: SUCCEED (0) (non-negative value)
- *     Failure: FAIL (-1) (negative value)
+ * Purpose:     Get the file-level setting to create minimized dataset object headers.
+ *              Result is stored at pointer `minimize`.
  *
- * Programmer:
- *
- *     Jacob Smith
- *     15 August 2018
- *
- * Changes: None.
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
@@ -2029,23 +2015,13 @@ H5Fget_dset_no_attrs_hint(hid_t file_id, hbool_t *minimize)
 
 
 /*-------------------------------------------------------------------------
- * Function: H5Fset_dset_no_attrs_hint
- *
- * Purpose:
- *
- *     Set the file-level setting to create minimized dataset object headers.
+ * Function:    H5Fset_dset_no_attrs_hint
  *
- * Return:
+ * Purpose:     Set the file-level setting to create minimized dataset object
+ *              headers.
  *
- *     Success: SUCCEED (0) (non-negative value)
- *     Failure: FAIL (-1) (negative value)
- *
- * Programmer:
- *
- *     Jacob Smith
- *     15 August 2018
- *
- * Changes: None.
+ * Return:      Success:    Non-negative
+ *              Failure:    Negative
  *-------------------------------------------------------------------------
  */
 herr_t
diff --git a/src/H5Gloc.c b/src/H5Gloc.c
index 0243b41e25c..2461c517dfc 100644
--- a/src/H5Gloc.c
+++ b/src/H5Gloc.c
@@ -809,9 +809,9 @@ H5G__loc_info_cb(H5G_loc_t H5_ATTR_UNUSED *grp_loc/*in*/, const char H5_ATTR_UNU
 
 
 /*-------------------------------------------------------------------------
- * Function:	H5G_loc_info
+ * Function:    H5G_loc_info
  *
- * Purpose:	Retrieve the data model information for an object from a group location
+ * Purpose:     Retrieve the data model information for an object from a group location
  *              and path to that object
  *
  * Return:	Non-negative on success/Negative on failure
diff --git a/src/H5Ochunk.c b/src/H5Ochunk.c
index 72402e45d2b..cb31cec4aa2 100644
--- a/src/H5Ochunk.c
+++ b/src/H5Ochunk.c
@@ -15,7 +15,7 @@
  *
  * Created:		H5Ochunk.c
  *			Jul 13 2008
- *			Quincey Koziol <koziol@hdfgroup.org>
+ *			Quincey Koziol
  *
  * Purpose:		Object header chunk routines.
  *
@@ -84,7 +84,6 @@ H5FL_DEFINE(H5O_chunk_proxy_t);
  * Return:      SUCCEED/FAIL
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Jul 13 2008
  *
  *-------------------------------------------------------------------------
@@ -146,14 +145,13 @@ H5O__chunk_add(H5F_t *f, H5O_t *oh, unsigned idx, unsigned cont_chunkno)
 
 
 /*-------------------------------------------------------------------------
- * Function:    H5O_chunk_protect
+ * Function:    H5O__chunk_protect
  *
  * Purpose:     Protect an object header chunk for modifications
  *
  * Return:      SUCCEED/FAIL
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Jul 17 2008
  *
  *-------------------------------------------------------------------------
@@ -227,7 +225,6 @@ H5O__chunk_protect(H5F_t *f, H5O_t *oh, unsigned idx)
  * Return:      SUCCEED/FAIL
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Jul 17 2008
  *
  *-------------------------------------------------------------------------
@@ -278,7 +275,6 @@ H5O__chunk_unprotect(H5F_t *f, H5O_chunk_proxy_t *chk_proxy, hbool_t dirtied)
  * Return:      SUCCEED/FAIL
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		May  6 2010
  *
  *-------------------------------------------------------------------------
@@ -319,7 +315,6 @@ H5O__chunk_resize(H5O_t *oh, H5O_chunk_proxy_t *chk_proxy)
  * Return:      SUCCEED/FAIL
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Jul 13 2008
  *
  *-------------------------------------------------------------------------
@@ -370,7 +365,6 @@ H5O__chunk_update_idx(H5F_t *f, H5O_t *oh, unsigned idx)
  * Return:      SUCCEED/FAIL
  *
  * Programmer:	Quincey Koziol
- *		koziol@hdfgroup.org
  *		Jul 13 2008
  *
  *-------------------------------------------------------------------------
@@ -415,7 +409,6 @@ H5O__chunk_delete(H5F_t *f, H5O_t *oh, unsigned idx)
  * Return:      SUCCEED/FAIL
  *
  * Programmer:	Quincey Koziol
- *              koziol@hdfgroup.org
  *              July 13, 2008
  *
  *-------------------------------------------------------------------------
diff --git a/src/H5Ocont.c b/src/H5Ocont.c
index ad54272c538..68a88e2d90a 100644
--- a/src/H5Ocont.c
+++ b/src/H5Ocont.c
@@ -15,7 +15,7 @@
  *
  * Created:             H5Ocont.c
  *                      Aug  6 1997
- *                      Robb Matzke <matzke@llnl.gov>
+ *                      Robb Matzke
  *
  * Purpose:             The object header continuation message.  This
  *                      message is only generated and read from within
@@ -83,7 +83,6 @@ H5FL_DEFINE(H5O_cont_t);
  *              Failure:        NULL
  *
  * Programmer:  Robb Matzke
- *              matzke@llnl.gov
  *              Aug  6 1997
  *
  *-------------------------------------------------------------------------
@@ -127,7 +126,6 @@ H5O__cont_decode(H5F_t *f, H5O_t H5_ATTR_UNUSED *open_oh,
  * Return:      Non-negative on success/Negative on failure
  *
  * Programmer:  Robb Matzke
- *              matzke@llnl.gov
  *              Aug  7 1997
  *
  *-------------------------------------------------------------------------
@@ -166,7 +164,6 @@ H5O__cont_encode(H5F_t *f, hbool_t H5_ATTR_UNUSED disable_shared, uint8_t *p, co
  *              Failure:        zero
  *
  * Programmer:  Quincey Koziol
- *              koziol@ncsa.uiuc.edu
  *              Sep  6 2005
  *
  *-------------------------------------------------------------------------
@@ -253,7 +250,6 @@ H5O__cont_delete(H5F_t *f, H5O_t *open_oh, void *_mesg)
  * Return:      Non-negative on success/Negative on failure
  *
  * Programmer:  Robb Matzke
- *              matzke@llnl.gov
  *              Aug  6 1997
  *
  *-------------------------------------------------------------------------
diff --git a/src/H5TS.c b/src/H5TS.c
index 3643ed545a3..ee3b2191dee 100644
--- a/src/H5TS.c
+++ b/src/H5TS.c
@@ -678,3 +678,4 @@ H5TS_create_thread(void *(*func)(void *), H5TS_attr_t *attr, void *udata)
 } /* H5TS_create_thread */
 
 #endif  /* H5_HAVE_THREADSAFE */
+

From 799f2891c2b305ad30eae53b758d96a083e4699e Mon Sep 17 00:00:00 2001
From: Allen Byrne <byrn@hdfgroup.org>
Date: Mon, 27 Jul 2020 15:47:10 -0500
Subject: [PATCH 41/55] Revert err file

---
 tools/test/h5format_convert/testfiles/h5fc_v_err.ddl.err | 8 --------
 1 file changed, 8 deletions(-)

diff --git a/tools/test/h5format_convert/testfiles/h5fc_v_err.ddl.err b/tools/test/h5format_convert/testfiles/h5fc_v_err.ddl.err
index d85a99975fc..e69de29bb2d 100644
--- a/tools/test/h5format_convert/testfiles/h5fc_v_err.ddl.err
+++ b/tools/test/h5format_convert/testfiles/h5fc_v_err.ddl.err
@@ -1,8 +0,0 @@
-h5format_convert error: unable to downgrade dataset "/DSET_ERR"
-H5tools-DIAG: Error detected in HDF5:tools (version (number)) thread (IDs):
-  #000: (file name) line (number) in h5trav_visit(): traverse failed
-    major: Failure in tools library
-    minor: error in function
-  #001: (file name) line (number) in traverse(): H5Lvisit_by_name failed
-    major: Failure in tools library
-    minor: error in function

From 5857bb817019b8513f796c9564de3f1845f9a44a Mon Sep 17 00:00:00 2001
From: Allen Byrne <byrn@hdfgroup.org>
Date: Mon, 27 Jul 2020 16:15:50 -0500
Subject: [PATCH 42/55] Only one line needed to compare

---
 tools/test/h5format_convert/testfiles/h5fc_v_err.ddl.err | 1 +
 1 file changed, 1 insertion(+)

diff --git a/tools/test/h5format_convert/testfiles/h5fc_v_err.ddl.err b/tools/test/h5format_convert/testfiles/h5fc_v_err.ddl.err
index e69de29bb2d..e72892de697 100644
--- a/tools/test/h5format_convert/testfiles/h5fc_v_err.ddl.err
+++ b/tools/test/h5format_convert/testfiles/h5fc_v_err.ddl.err
@@ -0,0 +1 @@
+h5format_convert error: unable to downgrade dataset "/DSET_ERR"

From 91f5320ff0e9579d47f5d91bcd80de40c30c166f Mon Sep 17 00:00:00 2001
From: Dana Robinson <derobins@hdfgroup.org>
Date: Mon, 27 Jul 2020 17:32:01 -0700
Subject: [PATCH 43/55] Updates H5Sset_extent_none() to set H5S_NULL

The API call used to set the internal H5S_NO_CLASS value which
produced errors when such a dataspace was passed to many other API
calls.

Fixes HDFFV-11027
---
 release_docs/RELEASE.txt | 15 ++++++++
 src/H5S.c                |  7 +++-
 test/tselect.c           | 80 +++++++++++++++++++++++++++++++++++++++-
 3 files changed, 98 insertions(+), 4 deletions(-)

diff --git a/release_docs/RELEASE.txt b/release_docs/RELEASE.txt
index 84f339a28f5..9dd54fa104d 100644
--- a/release_docs/RELEASE.txt
+++ b/release_docs/RELEASE.txt
@@ -951,6 +951,21 @@ Bug Fixes since HDF5-1.10.3 release
 
       (DER - 2019/12/09, HDFFV-10945)
 
+    - H5Sset_extent_none() sets the dataspace class to H5S_NO_CLASS which
+      causes asserts/errors when passed to other dataspace API calls.
+
+      H5S_NO_CLASS is an internal class value that should not have been
+      exposed via a public API call.
+
+      In debug builds of the library, this can cause asserts to trip. In
+      non-debug builds, it will produce normal library errors.
+
+      The new library behavior is for H5Sset_extent_none() to convert
+      the dataspace into one of type H5S_NULL, which is better handled
+      by the library and easier for developers to reason about.
+
+      (DER - 2020/07/27, HDFFV-11027)
+
 
     Java Library:
     ----------------
diff --git a/src/H5S.c b/src/H5S.c
index bea86caf280..7e48076317a 100644
--- a/src/H5S.c
+++ b/src/H5S.c
@@ -437,6 +437,9 @@ H5S__extent_release(H5S_extent_t *extent)
             extent->max = H5FL_ARR_FREE(hsize_t, extent->max);
     } /* end if */
 
+    extent->rank = 0;
+    extent->nelem = 0;
+
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5S__extent_release() */
 
@@ -1832,7 +1835,7 @@ H5Sget_simple_extent_type(hid_t sid)
  RETURNS
     Non-negative on success/Negative on failure
  DESCRIPTION
-    This function resets the type of a dataspace back to "none" with no
+    This function resets the type of a dataspace to H5S_NULL with no
     extent information stored for the dataspace.
 --------------------------------------------------------------------------*/
 herr_t
@@ -1852,7 +1855,7 @@ H5Sset_extent_none(hid_t space_id)
     if(H5S__extent_release(&space->extent) < 0)
         HGOTO_ERROR(H5E_RESOURCE, H5E_CANTDELETE, FAIL, "can't release previous dataspace")
 
-    space->extent.type = H5S_NO_CLASS;
+    space->extent.type = H5S_NULL;
 
 done:
     FUNC_LEAVE_API(ret_value)
diff --git a/test/tselect.c b/test/tselect.c
index aa0ab118fd8..607212b3d3e 100644
--- a/test/tselect.c
+++ b/test/tselect.c
@@ -15442,14 +15442,14 @@ test_hyper_io_1d(void)
 
     /* Get the dataset's dataspace */
     sid = H5Dget_space(did);
-    CHECK(sid, H5I_INVALID_HID, "H5Pcreate");
+    CHECK(sid, H5I_INVALID_HID, "H5Dget_space");
     ret = H5Sselect_hyperslab(sid, H5S_SELECT_SET, offset, stride, count, block);
     CHECK(ret, FAIL, "H5Sselect_hyperslab");
 
     /* Set up contiguous memory dataspace for the selected elements */
     dimsm[0] = count[0];
     mid = H5Screate_simple(RANK, dimsm, NULL);
-    CHECK(mid, H5I_INVALID_HID, "H5Screate");
+    CHECK(mid, H5I_INVALID_HID, "H5Screate_simple");
 
     /* Read all the selected 10th elements in the dataset into "rdata" */
     ret = H5Dread(did, H5T_NATIVE_INT, mid, sid, H5P_DEFAULT, rdata);
@@ -15473,6 +15473,77 @@ test_hyper_io_1d(void)
 
 }   /* test_hyper_io_1d() */
 
+
+/****************************************************************
+**
+**  test_get_extent_no_class:
+**  Test to verify the behavior of dataspace code when passed
+**  a dataspace modified by H5Sset_extent_none().
+**
+****************************************************************/
+static void
+test_h5s_set_extent_none(void)
+{
+    hid_t sid = H5I_INVALID_HID;
+    hid_t dst_sid = H5I_INVALID_HID;
+    hid_t null_sid = H5I_INVALID_HID;
+    int rank = 1;
+    hsize_t current_dims = 123;
+    H5S_class_t cls;
+    int out_rank;
+    hsize_t out_dims;
+    hsize_t out_maxdims;
+    hssize_t out_points;
+    htri_t equal;
+    herr_t ret;
+
+    /* Specific values here don't matter as we're just going to reset */
+    sid = H5Screate_simple(rank, &current_dims, NULL);
+    CHECK(sid, H5I_INVALID_HID, "H5Screate_simple");
+
+    /* Dataspace class will be H5S_NULL after this.
+     * In versions prior to 1.10.7 / 1.12.1 this would produce a
+     * dataspace with the internal H5S_NO_SPACE class.
+     */
+    ret = H5Sset_extent_none(sid);
+    CHECK(ret, FAIL, "H5Sset_extent_none");
+    cls = H5Sget_simple_extent_type(sid);
+    VERIFY(cls, H5S_NULL, "H5Sget_simple_extent_type");
+
+    /* Extent getters should generate normal results and not segfault.
+     */
+    out_rank = H5Sget_simple_extent_dims(sid, &out_dims, &out_maxdims);
+    VERIFY(out_rank, 0, "H5Sget_simple_extent_dims");
+    out_rank = H5Sget_simple_extent_ndims(sid);
+    VERIFY(out_rank, 0, "H5Sget_simple_extent_ndims");
+    out_points = H5Sget_simple_extent_npoints(sid);
+    VERIFY(out_points, 0, "H5Sget_simple_extent_npoints");
+
+    /* Check that copying the new (non-)extent works.
+     */
+    dst_sid = H5Screate_simple(rank, &current_dims, NULL);
+    CHECK(dst_sid, H5I_INVALID_HID, "H5Screate_simple");
+    ret = H5Sextent_copy(dst_sid, sid);
+    CHECK(ret, FAIL, "H5Sextent_copy");
+
+    /* Check that H5Sset_extent_none() produces the same extent as
+     * H5Screate(H5S_NULL).
+     */
+    null_sid = H5Screate(H5S_NULL);
+    CHECK(null_sid, H5I_INVALID_HID, "H5Screate");
+    equal = H5Sextent_equal(sid, null_sid);
+    VERIFY(equal, TRUE, "H5Sextent_equal");
+
+    /* Close */
+    ret = H5Sclose(sid);
+    CHECK(ret, FAIL, "H5Sclose");
+    ret = H5Sclose(dst_sid);
+    CHECK(ret, FAIL, "H5Sclose");
+    ret = H5Sclose(null_sid);
+    CHECK(ret, FAIL, "H5Sclose");
+
+} /* test_get_extent_no_class() */
+
 
 /****************************************************************
 **
@@ -15660,6 +15731,11 @@ test_select(void)
     /* Test reading of 1-d disjoint file space to 1-d single block memory space */
     test_hyper_io_1d();
 
+    /* Test H5Sset_extent_none() functionality after we updated it to set
+     * the class to H5S_NULL instead of H5S_NO_CLASS.
+     */
+    test_h5s_set_extent_none();
+
 }   /* test_select() */
 
 

From dbba42c306a16f174d1dbbfb75795db13433eaad Mon Sep 17 00:00:00 2001
From: Dana Robinson <derobins@hdfgroup.org>
Date: Mon, 27 Jul 2020 17:38:41 -0700
Subject: [PATCH 44/55] Fixes typo in tselect.c

---
 test/tselect.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/test/tselect.c b/test/tselect.c
index 607212b3d3e..8c5a0f20d0d 100644
--- a/test/tselect.c
+++ b/test/tselect.c
@@ -15503,7 +15503,7 @@ test_h5s_set_extent_none(void)
 
     /* Dataspace class will be H5S_NULL after this.
      * In versions prior to 1.10.7 / 1.12.1 this would produce a
-     * dataspace with the internal H5S_NO_SPACE class.
+     * dataspace with the internal H5S_NO_CLASS class.
      */
     ret = H5Sset_extent_none(sid);
     CHECK(ret, FAIL, "H5Sset_extent_none");

From c78326eb92d7e0d2087b306d7d216083ce95f3c4 Mon Sep 17 00:00:00 2001
From: Dana Robinson <derobins@hdfgroup.org>
Date: Mon, 27 Jul 2020 17:40:25 -0700
Subject: [PATCH 45/55] Fixed additional typos in tselect.c comments.

---
 test/tselect.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/test/tselect.c b/test/tselect.c
index 8c5a0f20d0d..c98db5df831 100644
--- a/test/tselect.c
+++ b/test/tselect.c
@@ -15476,7 +15476,7 @@ test_hyper_io_1d(void)
 
 /****************************************************************
 **
-**  test_get_extent_no_class:
+**  test_h5s_set_extent_none:
 **  Test to verify the behavior of dataspace code when passed
 **  a dataspace modified by H5Sset_extent_none().
 **
@@ -15542,7 +15542,7 @@ test_h5s_set_extent_none(void)
     ret = H5Sclose(null_sid);
     CHECK(ret, FAIL, "H5Sclose");
 
-} /* test_get_extent_no_class() */
+} /* test_h5s_set_extent_none() */
 
 
 /****************************************************************

From e4603ff8a171e82de6373ba6eddcf59d5eeab5aa Mon Sep 17 00:00:00 2001
From: Dana Robinson <derobins@hdfgroup.org>
Date: Tue, 28 Jul 2020 08:28:38 -0700
Subject: [PATCH 46/55] Updated the Java tests to deal with H5Sset_extent_none
 changes

---
 java/test/TestH5S.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/java/test/TestH5S.java b/java/test/TestH5S.java
index 985342b6713..97c0b68ecb0 100644
--- a/java/test/TestH5S.java
+++ b/java/test/TestH5S.java
@@ -171,7 +171,7 @@ public void testH5Sset_extent_none() {
         try {
             H5.H5Sset_extent_none(H5sid);
             read_type = H5.H5Sget_simple_extent_type(H5sid);
-            assertTrue("H5.H5Sget_simple_extent_type: "+read_type, HDF5Constants.H5S_NO_CLASS == read_type);
+            assertTrue("H5.H5Sget_simple_extent_type: "+read_type, HDF5Constants.H5S_NULL == read_type);
         }
         catch (Throwable err) {
             err.printStackTrace();

From 707e30c6be1954c0027374124207e46caae68cbc Mon Sep 17 00:00:00 2001
From: Binh-Minh Ribler <bmribler@hdfgroup.org>
Date: Tue, 28 Jul 2020 12:20:13 -0500
Subject: [PATCH 47/55] Fixed typos in error messages.

---
 src/H5Olink.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/H5Olink.c b/src/H5Olink.c
index 8aaf2d282c5..c27b51f786e 100644
--- a/src/H5Olink.c
+++ b/src/H5Olink.c
@@ -203,7 +203,7 @@ H5O__link_decode(H5F_t *f, H5O_t H5_ATTR_UNUSED *open_oh,
     /* Make sure that length doesn't exceed buffer size, which could occur
        when the file is corrupted */
     if(p + len > p_end)
-        HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "name length causes read pass end of buffer")
+        HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "name length causes read past end of buffer")
 
     /* Get the link's name */
     if(NULL == (lnk->name = (char *)H5MM_malloc(len + 1)))
@@ -228,7 +228,7 @@ H5O__link_decode(H5F_t *f, H5O_t H5_ATTR_UNUSED *open_oh,
             /* Make sure that length doesn't exceed buffer size, which could occur
                when the file is corrupted */
             if(p + len > p_end)
-                HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "name length causes read pass end of buffer")
+                HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "name length causes read past end of buffer")
 
             if(NULL == (lnk->u.soft.name = (char *)H5MM_malloc((size_t)len + 1)))
                 HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, NULL, "memory allocation failed")
@@ -253,7 +253,7 @@ H5O__link_decode(H5F_t *f, H5O_t H5_ATTR_UNUSED *open_oh,
                 /* Make sure that length doesn't exceed buffer size, which could
                    occur when the file is corrupted */
                 if(p + len > p_end)
-                    HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "name length causes read pass end of buffer")
+                    HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "name length causes read past end of buffer")
 
                 if(NULL == (lnk->u.ud.udata = H5MM_malloc((size_t)len)))
                     HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, NULL, "memory allocation failed")

From 1f7fa50137a66eeda1e2ee2f46ee1cc11c2001f5 Mon Sep 17 00:00:00 2001
From: Allen Byrne <byrn@hdfgroup.org>
Date: Wed, 29 Jul 2020 08:23:51 -0500
Subject: [PATCH 48/55] Correct h5diff filenames

---
 MANIFEST                                      |   8 ++++----
 tools/test/h5diff/CMakeTests.cmake            |  16 ++++++++--------
 tools/test/h5diff/h5diffgentest.c             |   8 ++++----
 tools/test/h5diff/testfiles/h5diff_eps.txt    |   8 ++++----
 .../{diff_eps1.h5 => h5diff_eps1.h5}          | Bin
 .../{diff_eps2.h5 => h5diff_eps2.h5}          | Bin
 .../{diff_strings1.h5 => h5diff_strings1.h5}  | Bin
 .../{diff_strings2.h5 => h5diff_strings2.h5}  | Bin
 tools/test/h5diff/testh5diff.sh.in            |  18 +++++++++---------
 9 files changed, 29 insertions(+), 29 deletions(-)
 rename tools/test/h5diff/testfiles/{diff_eps1.h5 => h5diff_eps1.h5} (100%)
 rename tools/test/h5diff/testfiles/{diff_eps2.h5 => h5diff_eps2.h5} (100%)
 rename tools/test/h5diff/testfiles/{diff_strings1.h5 => h5diff_strings1.h5} (100%)
 rename tools/test/h5diff/testfiles/{diff_strings2.h5 => h5diff_strings2.h5} (100%)

diff --git a/MANIFEST b/MANIFEST
index f2c831867c3..9720ebf9a1d 100644
--- a/MANIFEST
+++ b/MANIFEST
@@ -2400,8 +2400,6 @@
 
 
 #test files for h5diff
-./tools/test/h5diff/testfiles/diff_eps1.txt
-./tools/test/h5diff/testfiles/diff_eps2.txt
 ./tools/test/h5diff/testfiles/h5diff_10.txt
 ./tools/test/h5diff/testfiles/h5diff_11.txt
 ./tools/test/h5diff/testfiles/h5diff_12.txt
@@ -2609,6 +2607,8 @@
 ./tools/test/h5diff/testfiles/h5diff_dset3.h5
 ./tools/test/h5diff/testfiles/h5diff_dtypes.h5
 ./tools/test/h5diff/testfiles/h5diff_empty.h5
+./tools/test/h5diff/testfiles/h5diff_eps1.h5
+./tools/test/h5diff/testfiles/h5diff_eps2.h5
 ./tools/test/h5diff/testfiles/h5diff_hyper1.h5
 ./tools/test/h5diff/testfiles/h5diff_hyper2.h5
 ./tools/test/h5diff/testfiles/h5diff_types.h5
@@ -2649,8 +2649,8 @@
 ./tools/test/h5diff/testfiles/h5diff_ud.txt
 ./tools/test/h5diff/testfiles/h5diff_udfail.err
 ./tools/test/h5diff/testfiles/h5diff_udfail.txt
-./tools/test/h5diff/testfiles/diff_strings1.h5
-./tools/test/h5diff/testfiles/diff_strings2.h5
+./tools/test/h5diff/testfiles/h5diff_strings1.h5
+./tools/test/h5diff/testfiles/h5diff_strings2.h5
 ./tools/test/h5diff/testfiles/h5diff_vlstr.txt
 #vds
 ./tools/test/h5diff/testfiles/h5diff_v1.txt
diff --git a/tools/test/h5diff/CMakeTests.cmake b/tools/test/h5diff/CMakeTests.cmake
index 43c8c1539ba..74e39298112 100644
--- a/tools/test/h5diff/CMakeTests.cmake
+++ b/tools/test/h5diff/CMakeTests.cmake
@@ -66,10 +66,10 @@
       ${HDF5_TOOLS_TEST_H5DIFF_SOURCE_DIR}/testfiles/non_comparables2.h5
       ${HDF5_TOOLS_TEST_H5DIFF_SOURCE_DIR}/testfiles/tudfilter.h5
       ${HDF5_TOOLS_TEST_H5DIFF_SOURCE_DIR}/testfiles/tudfilter2.h5
-      ${HDF5_TOOLS_TEST_H5DIFF_SOURCE_DIR}/testfiles/diff_strings1.h5
-      ${HDF5_TOOLS_TEST_H5DIFF_SOURCE_DIR}/testfiles/diff_strings2.h5
-      ${HDF5_TOOLS_TEST_H5DIFF_SOURCE_DIR}/testfiles/diff_eps1.h5
-      ${HDF5_TOOLS_TEST_H5DIFF_SOURCE_DIR}/testfiles/diff_eps2.h5
+      ${HDF5_TOOLS_TEST_H5DIFF_SOURCE_DIR}/testfiles/h5diff_strings1.h5
+      ${HDF5_TOOLS_TEST_H5DIFF_SOURCE_DIR}/testfiles/h5diff_strings2.h5
+      ${HDF5_TOOLS_TEST_H5DIFF_SOURCE_DIR}/testfiles/h5diff_eps1.h5
+      ${HDF5_TOOLS_TEST_H5DIFF_SOURCE_DIR}/testfiles/h5diff_eps2.h5
       # tools/testfiles/vds
       ${HDF5_TOOLS_DIR}/testfiles/vds/1_a.h5
       ${HDF5_TOOLS_DIR}/testfiles/vds/1_b.h5
@@ -542,11 +542,11 @@
   set (ATTR_VERBOSE_LEVEL_FILE1 h5diff_attr_v_level1.h5)
   set (ATTR_VERBOSE_LEVEL_FILE2 h5diff_attr_v_level2.h5)
   # strings
-  set (STRINGS1 diff_strings1.h5)
-  set (STRINGS2 diff_strings2.h5)
+  set (STRINGS1 h5diff_strings1.h5)
+  set (STRINGS2 h5diff_strings2.h5)
   # epsilon
-  set (EPS1 diff_eps1.h5)
-  set (EPS2 diff_eps2.h5)
+  set (EPS1 h5diff_eps1.h5)
+  set (EPS2 h5diff_eps2.h5)
 
 # VDS tests
   set (FILEV1 1_vds.h5)
diff --git a/tools/test/h5diff/h5diffgentest.c b/tools/test/h5diff/h5diffgentest.c
index df79aa14324..bdc2ddc3c7c 100644
--- a/tools/test/h5diff/h5diffgentest.c
+++ b/tools/test/h5diff/h5diffgentest.c
@@ -94,11 +94,11 @@ size_t H5TOOLS_MALLOCSIZE = (128 * 1024 * 1024);
 #define NON_COMPARBLES1 "non_comparables1.h5"
 #define NON_COMPARBLES2 "non_comparables2.h5"
 /* string dataset and attribute */
-#define DIFF_STRINGS1 "diff_strings1.h5"
-#define DIFF_STRINGS2 "diff_strings2.h5"
+#define DIFF_STRINGS1 "h5diff_strings1.h5"
+#define DIFF_STRINGS2 "h5diff_strings2.h5"
 /* double dataset and epsilon */
-#define DIFF_EPS1 "diff_eps1.h5"
-#define DIFF_EPS2 "diff_eps2.h5"
+#define DIFF_EPS1 "h5diff_eps1.h5"
+#define DIFF_EPS2 "h5diff_eps2.h5"
 
 #define UIMAX    4294967295u /*Maximum value for a variable of type unsigned int */
 #define STR_SIZE 3
diff --git a/tools/test/h5diff/testfiles/h5diff_eps.txt b/tools/test/h5diff/testfiles/h5diff_eps.txt
index ef48cb6cbee..00514e60f50 100644
--- a/tools/test/h5diff/testfiles/h5diff_eps.txt
+++ b/tools/test/h5diff/testfiles/h5diff_eps.txt
@@ -1,10 +1,10 @@
-file1: diff_eps1.h5
-file2: diff_eps2.h5
+file1: h5diff_eps1.h5
+file2: h5diff_eps2.h5
 
 file1     file2
 ---------------------------------------
-    x      x    /              
-    x      x    /DS1           
+    x      x    /
+    x      x    /DS1
 
 
 group  : </> and </>
diff --git a/tools/test/h5diff/testfiles/diff_eps1.h5 b/tools/test/h5diff/testfiles/h5diff_eps1.h5
similarity index 100%
rename from tools/test/h5diff/testfiles/diff_eps1.h5
rename to tools/test/h5diff/testfiles/h5diff_eps1.h5
diff --git a/tools/test/h5diff/testfiles/diff_eps2.h5 b/tools/test/h5diff/testfiles/h5diff_eps2.h5
similarity index 100%
rename from tools/test/h5diff/testfiles/diff_eps2.h5
rename to tools/test/h5diff/testfiles/h5diff_eps2.h5
diff --git a/tools/test/h5diff/testfiles/diff_strings1.h5 b/tools/test/h5diff/testfiles/h5diff_strings1.h5
similarity index 100%
rename from tools/test/h5diff/testfiles/diff_strings1.h5
rename to tools/test/h5diff/testfiles/h5diff_strings1.h5
diff --git a/tools/test/h5diff/testfiles/diff_strings2.h5 b/tools/test/h5diff/testfiles/h5diff_strings2.h5
similarity index 100%
rename from tools/test/h5diff/testfiles/diff_strings2.h5
rename to tools/test/h5diff/testfiles/h5diff_strings2.h5
diff --git a/tools/test/h5diff/testh5diff.sh.in b/tools/test/h5diff/testh5diff.sh.in
index 84330eca5d2..4e622ee9a76 100644
--- a/tools/test/h5diff/testh5diff.sh.in
+++ b/tools/test/h5diff/testh5diff.sh.in
@@ -120,10 +120,10 @@ $SRC_H5DIFF_TESTFILES/h5diff_attr_v_level2.h5
 $SRC_H5DIFF_TESTFILES/h5diff_enum_invalid_values.h5
 $SRC_H5DIFF_TESTFILES/non_comparables1.h5
 $SRC_H5DIFF_TESTFILES/non_comparables2.h5
-$SRC_H5DIFF_TESTFILES/diff_strings1.h5
-$SRC_H5DIFF_TESTFILES/diff_strings2.h5
-$SRC_H5DIFF_TESTFILES/diff_eps1.h5
-$SRC_H5DIFF_TESTFILES/diff_eps2.h5
+$SRC_H5DIFF_TESTFILES/h5diff_strings1.h5
+$SRC_H5DIFF_TESTFILES/h5diff_strings2.h5
+$SRC_H5DIFF_TESTFILES/h5diff_eps1.h5
+$SRC_H5DIFF_TESTFILES/h5diff_eps2.h5
 $SRC_TOOLS_TESTFILES/tvlstr.h5
 "
 
@@ -723,10 +723,10 @@ TOOLTEST h5diff_59.txt -v h5diff_dtypes.h5 h5diff_dtypes.h5 dset11a dset11b
 
 # Strings
 # ( HDFFV-10128 )
-TOOLTEST h5diff_60.txt -v diff_strings1.h5 diff_strings2.h5 string1 string1
-TOOLTEST h5diff_61.txt -v diff_strings1.h5 diff_strings2.h5 string2 string2
-TOOLTEST h5diff_62.txt -v diff_strings1.h5 diff_strings2.h5 string3 string3
-TOOLTEST h5diff_63.txt -v diff_strings1.h5 diff_strings2.h5 string4 string4
+TOOLTEST h5diff_60.txt -v h5diff_strings1.h5 h5diff_strings2.h5 string1 string1
+TOOLTEST h5diff_61.txt -v h5diff_strings1.h5 h5diff_strings2.h5 string2 string2
+TOOLTEST h5diff_62.txt -v h5diff_strings1.h5 h5diff_strings2.h5 string3 string3
+TOOLTEST h5diff_63.txt -v h5diff_strings1.h5 h5diff_strings2.h5 string4 string4
 
 # ##############################################################################
 # # Error messages
@@ -770,7 +770,7 @@ TOOLTEST h5diff_609.txt -d 200 h5diff_basic1.h5 h5diff_basic2.h5 g1/dset3 g1/dse
 TOOLTEST h5diff_610.txt -d 1 h5diff_basic1.h5 h5diff_basic2.h5 g1/dset3 g1/dset4
 
 # eps: number smaller than epsilon
-TOOLTEST h5diff_eps.txt -v3 -d 1e-16 diff_eps1.h5 diff_eps2.h5
+TOOLTEST h5diff_eps.txt -v3 -d 1e-16 h5diff_eps1.h5 h5diff_eps2.h5
 
 
 # ##############################################################################

From 6a1cf090c6a2f970084c714a2f75a31d68a0a6a8 Mon Sep 17 00:00:00 2001
From: Allen Byrne <byrn@hdfgroup.org>
Date: Wed, 29 Jul 2020 12:56:03 -0500
Subject: [PATCH 49/55] Correct reference file

---
 tools/test/h5diff/testfiles/h5diff_eps.txt | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/tools/test/h5diff/testfiles/h5diff_eps.txt b/tools/test/h5diff/testfiles/h5diff_eps.txt
index 00514e60f50..3a71366dd88 100644
--- a/tools/test/h5diff/testfiles/h5diff_eps.txt
+++ b/tools/test/h5diff/testfiles/h5diff_eps.txt
@@ -3,8 +3,8 @@ file2: h5diff_eps2.h5
 
 file1     file2
 ---------------------------------------
-    x      x    /
-    x      x    /DS1
+    x      x    /              
+    x      x    /DS1           
 
 
 group  : </> and </>

From ff4a9d0ec2e85cf15f769006e92e756a79869ab8 Mon Sep 17 00:00:00 2001
From: Allen Byrne <byrn@hdfgroup.org>
Date: Thu, 30 Jul 2020 11:25:24 -0500
Subject: [PATCH 50/55] Warnings reduction in tools

---
 tools/lib/h5diff.c            |   2 +-
 tools/lib/h5diff.h            |   1 +
 tools/lib/h5diff_array.c      | 201 +++++++++++++++++-----------------
 tools/lib/h5diff_attr.c       |  12 +-
 tools/lib/h5diff_dset.c       |  14 +--
 tools/lib/h5tools.c           |   2 +-
 tools/lib/h5tools_dump.c      |   6 +-
 tools/lib/h5tools_str.c       |  16 ++-
 tools/src/h5import/h5import.c |   4 +-
 tools/src/h5ls/h5ls.c         |   2 -
 10 files changed, 126 insertions(+), 134 deletions(-)

diff --git a/tools/lib/h5diff.c b/tools/lib/h5diff.c
index 96c2d320200..87a3b11903b 100644
--- a/tools/lib/h5diff.c
+++ b/tools/lib/h5diff.c
@@ -234,7 +234,7 @@ is_exclude_path (char *path, h5trav_type_t type, diff_opt_t *opts)
  *           0 - not excluded path
  *------------------------------------------------------------------------*/
 static int
-is_exclude_attr (char *path, h5trav_type_t type, diff_opt_t *opts)
+is_exclude_attr (const char *path, h5trav_type_t type, diff_opt_t *opts)
 {
     struct exclude_path_list *exclude_ptr;
     int   ret_cmp;
diff --git a/tools/lib/h5diff.h b/tools/lib/h5diff.h
index c3c111f1d44..f44f653a914 100644
--- a/tools/lib/h5diff.h
+++ b/tools/lib/h5diff.h
@@ -57,6 +57,7 @@ typedef struct {
     int        mode_list_not_cmp;          /* list not comparable messages */
     int        print_header;               /* print header */
     int        print_percentage;           /* print percentage */
+    int        print_dims;                 /* print dimension index */
     int        delta_bool;                 /* delta, absolute value to compare */
     double     delta;                      /* delta value */
     int        use_system_epsilon;         /* flag to use system epsilon (1 or 0) */
diff --git a/tools/lib/h5diff_array.c b/tools/lib/h5diff_array.c
index 9b680ece330..1a4c7277c08 100644
--- a/tools/lib/h5diff_array.c
+++ b/tools/lib/h5diff_array.c
@@ -134,7 +134,7 @@ typedef struct mcomp_t {
  */
 static hbool_t all_zero(const void *_mem, size_t size);
 static int ull2float(unsigned long long ull_value, float *f_value);
-static hsize_t character_compare(char *mem1, char *mem2, hsize_t elemtno, ssize_t u, diff_opt_t *opts);
+static hsize_t character_compare(char *mem1, char *mem2, hsize_t elemtno, size_t u, diff_opt_t *opts);
 static hsize_t character_compare_opt(unsigned char *mem1, unsigned char *mem2, hsize_t elemtno, diff_opt_t *opts);
 static hbool_t equal_float(float value, float expected, diff_opt_t *opts);
 static hbool_t equal_double(double value, double expected, diff_opt_t *opts);
@@ -143,7 +143,7 @@ static hbool_t equal_ldouble(long double value, long double expected, diff_opt_t
 #endif
 
 static int print_data(diff_opt_t *opts);
-static void print_pos(diff_opt_t *opts, hsize_t elemtno, ssize_t u);
+static void print_pos(diff_opt_t *opts, hsize_t elemtno, size_t u);
 static void h5diff_print_char(char ch);
 
 static hsize_t diff_region(hid_t obj1_id, hid_t obj2_id, hid_t region1_id, hid_t region2_id, diff_opt_t *opts);
@@ -210,7 +210,6 @@ diff_array(void *_mem1, void *_mem2, diff_opt_t *opts, hid_t container1_id, hid_
     unsigned char  *mem1 = (unsigned char*) _mem1;
     unsigned char  *mem2 = (unsigned char*) _mem2;
     hsize_t         i;
-    int             j;
     mcomp_t         members;
     H5T_class_t     type_class;
 
@@ -680,7 +679,7 @@ diff_datum(void *_mem1, void *_mem2, hsize_t elemtno, diff_opt_t *opts, hid_t co
                      */
                     nfound += 1;
                     opts->print_percentage = 0;
-                    print_pos(opts, elemtno, -1);
+                    print_pos(opts, elemtno, 0);
                     if (print_data(opts)) {
                         parallel_print(S_FORMAT, enum_name1, enum_name2);
                     }
@@ -690,7 +689,7 @@ diff_datum(void *_mem1, void *_mem2, hsize_t elemtno, diff_opt_t *opts, hid_t co
                     if (HDstrcmp(enum_name1, enum_name2) != 0) {
                         nfound = 1;
                         opts->print_percentage = 0;
-                        print_pos(opts, elemtno, -1);
+                        print_pos(opts, elemtno, 0);
                         if (print_data(opts)) {
                             parallel_print(S_FORMAT, enum_name1, enum_name2);
                         }
@@ -1528,7 +1527,7 @@ static hsize_t diff_region(hid_t obj1_id, hid_t obj2_id, hid_t region1_id, hid_t
  *-------------------------------------------------------------------------
  */
 
-static hsize_t character_compare(char *mem1, char *mem2, hsize_t elemtno, ssize_t u, diff_opt_t *opts)
+static hsize_t character_compare(char *mem1, char *mem2, hsize_t elemtno, size_t u, diff_opt_t *opts)
 {
     hsize_t nfound = 0; /* differences found */
     char    temp1_uchar;
@@ -1541,6 +1540,7 @@ static hsize_t character_compare(char *mem1, char *mem2, hsize_t elemtno, ssize_
     if (temp1_uchar != temp2_uchar) {
         if (print_data(opts)) {
             opts->print_percentage = 0;
+            opts->print_dims = 1;
             print_pos(opts, elemtno, u);
             parallel_print("  ");
             h5diff_print_char(temp1_uchar);
@@ -1580,7 +1580,7 @@ static hsize_t character_compare_opt(unsigned char *mem1, unsigned char *mem2, h
     if (opts->delta_bool && !opts->percent_bool) {
         if (PDIFF(temp1_uchar,temp2_uchar) > opts->delta) {
             opts->print_percentage = 0;
-            print_pos(opts, elemtno, -1);
+            print_pos(opts, elemtno, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar));
             }
@@ -1592,7 +1592,7 @@ static hsize_t character_compare_opt(unsigned char *mem1, unsigned char *mem2, h
         PER_UNSIGN(signed char, temp1_uchar, temp2_uchar);
         if (per > opts->percent) {
             opts->print_percentage = 1;
-            print_pos(opts, elemtno, -1);
+            print_pos(opts, elemtno, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT_P, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar), per);
             }
@@ -1604,7 +1604,7 @@ static hsize_t character_compare_opt(unsigned char *mem1, unsigned char *mem2, h
         PER_UNSIGN(signed char, temp1_uchar, temp2_uchar);
         if (per > opts->percent && PDIFF(temp1_uchar,temp2_uchar) > opts->delta) {
             opts->print_percentage = 1;
-            print_pos(opts, elemtno, -1);
+            print_pos(opts, elemtno, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT_P, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar), per);
             }
@@ -1613,7 +1613,7 @@ static hsize_t character_compare_opt(unsigned char *mem1, unsigned char *mem2, h
     }
     else if (temp1_uchar != temp2_uchar) {
         opts->print_percentage = 0;
-        print_pos(opts, elemtno, -1);
+        print_pos(opts, elemtno, 0);
         if (print_data(opts)) {
             parallel_print(I_FORMAT, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar));
         }
@@ -1668,7 +1668,7 @@ static hsize_t diff_float_element(unsigned char *mem1, unsigned char *mem2, hsiz
         if (!isnan1 && !isnan2) {
             if ((double) ABS(temp1_float - temp2_float) > opts->delta) {
                 opts->print_percentage = 0;
-                print_pos(opts, elem_idx, -1);
+                print_pos(opts, elem_idx, 0);
                 if (print_data(opts)) {
                     parallel_print(F_FORMAT, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
                 }
@@ -1678,7 +1678,7 @@ static hsize_t diff_float_element(unsigned char *mem1, unsigned char *mem2, hsiz
         /* only one is NaN, assume difference */
         else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
             opts->print_percentage = 0;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(F_FORMAT, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
             }
@@ -1704,7 +1704,7 @@ static hsize_t diff_float_element(unsigned char *mem1, unsigned char *mem2, hsiz
 
             if (not_comparable && !both_zero) {
                 opts->print_percentage = 1;
-                print_pos(opts, elem_idx, -1);
+                print_pos(opts, elem_idx, 0);
                 if (print_data(opts)) {
                     parallel_print(F_FORMAT_P_NOTCOMP, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
                 }
@@ -1712,7 +1712,7 @@ static hsize_t diff_float_element(unsigned char *mem1, unsigned char *mem2, hsiz
             }
             else if (per > opts->percent) {
                 opts->print_percentage = 1;
-                print_pos(opts, elem_idx, -1);
+                print_pos(opts, elem_idx, 0);
                 if (print_data(opts)) {
                     parallel_print(F_FORMAT_P, (double) temp1_float, (double) temp2_float,
                             (double) ABS(temp1_float - temp2_float), (double) ABS(1 - temp2_float / temp1_float));
@@ -1723,7 +1723,7 @@ static hsize_t diff_float_element(unsigned char *mem1, unsigned char *mem2, hsiz
         /* only one is NaN, assume difference */
         else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
             opts->print_percentage = 0;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(F_FORMAT, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
             }
@@ -1750,7 +1750,7 @@ static hsize_t diff_float_element(unsigned char *mem1, unsigned char *mem2, hsiz
 
             if (not_comparable && !both_zero) {
                 opts->print_percentage = 1;
-                print_pos(opts, elem_idx, -1);
+                print_pos(opts, elem_idx, 0);
                 if (print_data(opts)) {
                     parallel_print(F_FORMAT_P_NOTCOMP, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
                 }
@@ -1758,7 +1758,7 @@ static hsize_t diff_float_element(unsigned char *mem1, unsigned char *mem2, hsiz
             }
             else if (per > opts->percent && (double) ABS(temp1_float - temp2_float) > opts->delta) {
                 opts->print_percentage = 1;
-                print_pos(opts, elem_idx, -1);
+                print_pos(opts, elem_idx, 0);
                 if (print_data(opts)) {
                     parallel_print(F_FORMAT_P, (double) temp1_float, (double) temp2_float,
                             (double) ABS(temp1_float - temp2_float), (double) ABS(1 - temp2_float / temp1_float));
@@ -1769,7 +1769,7 @@ static hsize_t diff_float_element(unsigned char *mem1, unsigned char *mem2, hsiz
         /* only one is NaN, assume difference */
         else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
             opts->print_percentage = 0;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(F_FORMAT, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
             }
@@ -1783,7 +1783,7 @@ static hsize_t diff_float_element(unsigned char *mem1, unsigned char *mem2, hsiz
     else {
         if (equal_float(temp1_float, temp2_float, opts) == FALSE) {
             opts->print_percentage = 0;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(F_FORMAT, (double) temp1_float, (double) temp2_float, (double) ABS(temp1_float - temp2_float));
             }
@@ -1836,7 +1836,7 @@ static hsize_t diff_double_element(unsigned char *mem1, unsigned char *mem2, hsi
         if (!isnan1 && !isnan2) {
             if (ABS(temp1_double-temp2_double) > opts->delta) {
                 opts->print_percentage = 0;
-                print_pos(opts, elem_idx, -1);
+                print_pos(opts, elem_idx, 0);
                 if (print_data(opts)) {
                     parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
                 }
@@ -1846,7 +1846,7 @@ static hsize_t diff_double_element(unsigned char *mem1, unsigned char *mem2, hsi
         /* only one is NaN, assume difference */
         else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
             opts->print_percentage = 0;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
             }
@@ -1873,7 +1873,7 @@ static hsize_t diff_double_element(unsigned char *mem1, unsigned char *mem2, hsi
 
             if (not_comparable && !both_zero) {
                 opts->print_percentage = 1;
-                print_pos(opts, elem_idx, -1);
+                print_pos(opts, elem_idx, 0);
                 if (print_data(opts)) {
                     parallel_print(F_FORMAT_P_NOTCOMP, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
                 }
@@ -1881,7 +1881,7 @@ static hsize_t diff_double_element(unsigned char *mem1, unsigned char *mem2, hsi
             }
             else if (per > opts->percent) {
                 opts->print_percentage = 1;
-                print_pos(opts, elem_idx, -1);
+                print_pos(opts, elem_idx, 0);
                 if (print_data(opts)) {
                     parallel_print(F_FORMAT_P, temp1_double, temp2_double,
                             ABS(temp1_double - temp2_double), ABS(1 - temp2_double / temp1_double));
@@ -1892,7 +1892,7 @@ static hsize_t diff_double_element(unsigned char *mem1, unsigned char *mem2, hsi
         /* only one is NaN, assume difference */
         else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
             opts->print_percentage = 0;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
             }
@@ -1919,7 +1919,7 @@ static hsize_t diff_double_element(unsigned char *mem1, unsigned char *mem2, hsi
 
             if (not_comparable && !both_zero)  {
                 opts->print_percentage = 1;
-                print_pos(opts, elem_idx, -1);
+                print_pos(opts, elem_idx, 0);
                 if (print_data(opts)) {
                     parallel_print(F_FORMAT_P_NOTCOMP, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
                 }
@@ -1927,7 +1927,7 @@ static hsize_t diff_double_element(unsigned char *mem1, unsigned char *mem2, hsi
             }
             else if (per > opts->percent && ABS(temp1_double-temp2_double) > opts->delta) {
                 opts->print_percentage = 1;
-                print_pos(opts, elem_idx, -1);
+                print_pos(opts, elem_idx, 0);
                 if (print_data(opts)) {
                     parallel_print(F_FORMAT_P, temp1_double, temp2_double,
                             ABS(temp1_double - temp2_double), ABS(1 - temp2_double / temp1_double));
@@ -1938,7 +1938,7 @@ static hsize_t diff_double_element(unsigned char *mem1, unsigned char *mem2, hsi
         /* only one is NaN, assume difference */
         else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
             opts->print_percentage = 0;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
             }
@@ -1952,7 +1952,7 @@ static hsize_t diff_double_element(unsigned char *mem1, unsigned char *mem2, hsi
     else {
         if (equal_double(temp1_double, temp2_double, opts) == FALSE) {
             opts->print_percentage = 0;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
             }
@@ -2009,7 +2009,7 @@ static hsize_t diff_ldouble_element(unsigned char *mem1, unsigned char *mem2, hs
         if (!isnan1 && !isnan2) {
             if (ABS(temp1_double-temp2_double) > opts->delta) {
                 opts->print_percentage = 0;
-                print_pos(opts, elem_idx, -1);
+                print_pos(opts, elem_idx, 0);
                 if (print_data(opts)) {
                     parallel_print(LD_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
                 }
@@ -2019,7 +2019,7 @@ static hsize_t diff_ldouble_element(unsigned char *mem1, unsigned char *mem2, hs
         /* only one is NaN, assume difference */
         else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
             opts->print_percentage = 0;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
             }
@@ -2046,7 +2046,7 @@ static hsize_t diff_ldouble_element(unsigned char *mem1, unsigned char *mem2, hs
 
             if (not_comparable && !both_zero) {
                 opts->print_percentage = 1;
-                print_pos(opts, elem_idx, -1);
+                print_pos(opts, elem_idx, 0);
                 if (print_data(opts)) {
                     parallel_print(LD_FORMAT_P_NOTCOMP, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
                 }
@@ -2054,7 +2054,7 @@ static hsize_t diff_ldouble_element(unsigned char *mem1, unsigned char *mem2, hs
             }
             else if (per > opts->percent) {
                 opts->print_percentage = 1;
-                print_pos(opts, elem_idx, -1);
+                print_pos(opts, elem_idx, 0);
                 if (print_data(opts)) {
                     parallel_print(LD_FORMAT_P, temp1_double, temp2_double, ABS(temp1_double - temp2_double), ABS(1 - temp2_double / temp1_double));
                 }
@@ -2064,7 +2064,7 @@ static hsize_t diff_ldouble_element(unsigned char *mem1, unsigned char *mem2, hs
         /* only one is NaN, assume difference */
         else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
             opts->print_percentage = 0;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
             }
@@ -2091,7 +2091,7 @@ static hsize_t diff_ldouble_element(unsigned char *mem1, unsigned char *mem2, hs
 
             if (not_comparable && !both_zero) {
                 opts->print_percentage = 1;
-                print_pos(opts, elem_idx, -1);
+                print_pos(opts, elem_idx, 0);
                 if (print_data(opts)) {
                     parallel_print(LD_FORMAT_P_NOTCOMP, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
                 }
@@ -2099,7 +2099,7 @@ static hsize_t diff_ldouble_element(unsigned char *mem1, unsigned char *mem2, hs
             }
             else if (per > opts->percent && ABS(temp1_double-temp2_double) > opts->delta) {
                 opts->print_percentage = 1;
-                print_pos(opts, elem_idx, -1);
+                print_pos(opts, elem_idx, 0);
                 if (print_data(opts)) {
                     parallel_print(LD_FORMAT_P, temp1_double, temp2_double, ABS(temp1_double - temp2_double), ABS(1 - temp2_double / temp1_double));
                 }
@@ -2109,7 +2109,7 @@ static hsize_t diff_ldouble_element(unsigned char *mem1, unsigned char *mem2, hs
         /* only one is NaN, assume difference */
         else if ((isnan1 && !isnan2) || (!isnan1 && isnan2)) {
             opts->print_percentage = 0;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(F_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
             }
@@ -2122,7 +2122,7 @@ static hsize_t diff_ldouble_element(unsigned char *mem1, unsigned char *mem2, hs
      */
     else if (equal_ldouble(temp1_double, temp2_double, opts) == FALSE) {
         opts->print_percentage = 0;
-        print_pos(opts, elem_idx, -1);
+        print_pos(opts, elem_idx, 0);
         if (print_data(opts)) {
             parallel_print(LD_FORMAT, temp1_double, temp2_double, ABS(temp1_double - temp2_double));
         }
@@ -2159,7 +2159,7 @@ static hsize_t diff_schar_element(unsigned char *mem1, unsigned char *mem2, hsiz
     if (opts->delta_bool && !opts->percent_bool) {
         if (ABS(temp1_char-temp2_char) > opts->delta) {
             opts->print_percentage = 0;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT, temp1_char, temp2_char, ABS(temp1_char - temp2_char));
             }
@@ -2172,7 +2172,7 @@ static hsize_t diff_schar_element(unsigned char *mem1, unsigned char *mem2, hsiz
 
         if (not_comparable && !both_zero) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT_P_NOTCOMP, temp1_char, temp2_char, ABS(temp1_char - temp2_char));
             }
@@ -2180,7 +2180,7 @@ static hsize_t diff_schar_element(unsigned char *mem1, unsigned char *mem2, hsiz
         }
         else if (per > opts->percent) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT_P, temp1_char, temp2_char, ABS(temp1_char - temp2_char), per);
             }
@@ -2193,7 +2193,7 @@ static hsize_t diff_schar_element(unsigned char *mem1, unsigned char *mem2, hsiz
 
         if (not_comparable && !both_zero) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT_P_NOTCOMP, temp1_char, temp2_char, ABS(temp1_char - temp2_char));
             }
@@ -2201,7 +2201,7 @@ static hsize_t diff_schar_element(unsigned char *mem1, unsigned char *mem2, hsiz
         }
         else if (per > opts->percent && ABS(temp1_char - temp2_char) > opts->delta) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT_P, temp1_char, temp2_char, ABS(temp1_char - temp2_char), per);
             }
@@ -2210,7 +2210,7 @@ static hsize_t diff_schar_element(unsigned char *mem1, unsigned char *mem2, hsiz
     }
     else if (temp1_char != temp2_char) {
         opts->print_percentage = 0;
-        print_pos(opts, elem_idx, -1);
+        print_pos(opts, elem_idx, 0);
         if (print_data(opts)) {
             parallel_print(I_FORMAT, temp1_char, temp2_char, ABS(temp1_char - temp2_char));
         }
@@ -2246,7 +2246,7 @@ static hsize_t diff_uchar_element(unsigned char *mem1, unsigned char *mem2, hsiz
     if (opts->delta_bool && !opts->percent_bool) {
         if (PDIFF(temp1_uchar, temp2_uchar) > opts->delta) {
             opts->print_percentage = 0;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar));
             }
@@ -2259,7 +2259,7 @@ static hsize_t diff_uchar_element(unsigned char *mem1, unsigned char *mem2, hsiz
 
         if (not_comparable && !both_zero) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT_P_NOTCOMP, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar));
             }
@@ -2267,7 +2267,7 @@ static hsize_t diff_uchar_element(unsigned char *mem1, unsigned char *mem2, hsiz
         }
         else if (per > opts->percent) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT_P, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar), per);
             }
@@ -2280,7 +2280,7 @@ static hsize_t diff_uchar_element(unsigned char *mem1, unsigned char *mem2, hsiz
 
         if (not_comparable && !both_zero) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT_P_NOTCOMP, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar));
             }
@@ -2288,7 +2288,7 @@ static hsize_t diff_uchar_element(unsigned char *mem1, unsigned char *mem2, hsiz
         }
         else if (per > opts->percent && PDIFF(temp1_uchar, temp2_uchar) > opts->delta) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT_P, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar), per);
             }
@@ -2297,7 +2297,7 @@ static hsize_t diff_uchar_element(unsigned char *mem1, unsigned char *mem2, hsiz
     }
     else if (temp1_uchar != temp2_uchar) {
         opts->print_percentage = 0;
-        print_pos(opts, elem_idx, -1);
+        print_pos(opts, elem_idx, 0);
         if (print_data(opts)) {
             parallel_print(I_FORMAT, temp1_uchar, temp2_uchar, PDIFF(temp1_uchar, temp2_uchar));
         }
@@ -2333,7 +2333,7 @@ static hsize_t diff_short_element(unsigned char *mem1, unsigned char *mem2, hsiz
     if (opts->delta_bool && !opts->percent_bool) {
         if (ABS(temp1_short - temp2_short) > opts->delta) {
             opts->print_percentage = 0;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT, temp1_short, temp2_short, ABS(temp1_short - temp2_short));
             }
@@ -2346,7 +2346,7 @@ static hsize_t diff_short_element(unsigned char *mem1, unsigned char *mem2, hsiz
 
         if (not_comparable && !both_zero) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT_P_NOTCOMP, temp1_short, temp2_short, ABS(temp1_short - temp2_short));
             }
@@ -2354,7 +2354,7 @@ static hsize_t diff_short_element(unsigned char *mem1, unsigned char *mem2, hsiz
         }
         else if (per > opts->percent) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT_P, temp1_short, temp2_short, ABS(temp1_short - temp2_short), per);
             }
@@ -2367,7 +2367,7 @@ static hsize_t diff_short_element(unsigned char *mem1, unsigned char *mem2, hsiz
 
         if (not_comparable && !both_zero) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT_P_NOTCOMP, temp1_short, temp2_short, ABS(temp1_short - temp2_short));
             }
@@ -2375,7 +2375,7 @@ static hsize_t diff_short_element(unsigned char *mem1, unsigned char *mem2, hsiz
         }
         else if (per > opts->percent && ABS(temp1_short - temp2_short) > opts->delta) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT_P, temp1_short, temp2_short, ABS(temp1_short - temp2_short), per);
             }
@@ -2384,7 +2384,7 @@ static hsize_t diff_short_element(unsigned char *mem1, unsigned char *mem2, hsiz
     }
     else if (temp1_short != temp2_short) {
         opts->print_percentage = 0;
-        print_pos(opts, elem_idx, -1);
+        print_pos(opts, elem_idx, 0);
         if (print_data(opts)) {
             parallel_print(I_FORMAT, temp1_short, temp2_short, ABS(temp1_short - temp2_short));
         }
@@ -2420,7 +2420,7 @@ static hsize_t diff_ushort_element(unsigned char *mem1, unsigned char *mem2, hsi
     if (opts->delta_bool && !opts->percent_bool) {
         if (PDIFF(temp1_ushort, temp2_ushort) > opts->delta) {
             opts->print_percentage = 0;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort));
             }
@@ -2433,7 +2433,7 @@ static hsize_t diff_ushort_element(unsigned char *mem1, unsigned char *mem2, hsi
 
         if (not_comparable && !both_zero) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT_P_NOTCOMP, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort));
             }
@@ -2441,7 +2441,7 @@ static hsize_t diff_ushort_element(unsigned char *mem1, unsigned char *mem2, hsi
         }
         else if (per > opts->percent) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT_P, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort), per);
             }
@@ -2454,7 +2454,7 @@ static hsize_t diff_ushort_element(unsigned char *mem1, unsigned char *mem2, hsi
 
         if (not_comparable && !both_zero) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT_P_NOTCOMP, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort));
             }
@@ -2462,7 +2462,7 @@ static hsize_t diff_ushort_element(unsigned char *mem1, unsigned char *mem2, hsi
         }
         else if (per > opts->percent && PDIFF(temp1_ushort, temp2_ushort) > opts->delta) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT_P, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort), per);
             }
@@ -2471,7 +2471,7 @@ static hsize_t diff_ushort_element(unsigned char *mem1, unsigned char *mem2, hsi
     }
     else if (temp1_ushort != temp2_ushort) {
         opts->print_percentage = 0;
-        print_pos(opts, elem_idx, -1);
+        print_pos(opts, elem_idx, 0);
         if (print_data(opts)) {
             parallel_print(I_FORMAT, temp1_ushort, temp2_ushort, PDIFF(temp1_ushort, temp2_ushort));
         }
@@ -2507,7 +2507,7 @@ static hsize_t diff_int_element(unsigned char *mem1, unsigned char *mem2, hsize_
     if (opts->delta_bool && !opts->percent_bool) {
         if (ABS(temp1_int-temp2_int) > opts->delta) {
             opts->print_percentage = 0;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT, temp1_int, temp2_int, ABS(temp1_int - temp2_int));
             }
@@ -2520,7 +2520,7 @@ static hsize_t diff_int_element(unsigned char *mem1, unsigned char *mem2, hsize_
 
         if (not_comparable && !both_zero) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT_P_NOTCOMP, temp1_int, temp2_int, ABS(temp1_int - temp2_int));
             }
@@ -2528,7 +2528,7 @@ static hsize_t diff_int_element(unsigned char *mem1, unsigned char *mem2, hsize_
         }
         else if (per > opts->percent) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT_P, temp1_int, temp2_int, ABS(temp1_int - temp2_int), per);
             }
@@ -2541,7 +2541,7 @@ static hsize_t diff_int_element(unsigned char *mem1, unsigned char *mem2, hsize_
 
         if (not_comparable && !both_zero) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT_P_NOTCOMP, temp1_int, temp2_int, ABS(temp1_int - temp2_int));
             }
@@ -2549,7 +2549,7 @@ static hsize_t diff_int_element(unsigned char *mem1, unsigned char *mem2, hsize_
         }
         else if (per > opts->percent && ABS(temp1_int - temp2_int) > opts->delta) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(I_FORMAT_P, temp1_int, temp2_int, ABS(temp1_int - temp2_int), per);
             }
@@ -2558,7 +2558,7 @@ static hsize_t diff_int_element(unsigned char *mem1, unsigned char *mem2, hsize_
     }
     else if (temp1_int != temp2_int) {
         opts->print_percentage = 0;
-        print_pos(opts, elem_idx, -1);
+        print_pos(opts, elem_idx, 0);
         if (print_data(opts)) {
             parallel_print(I_FORMAT, temp1_int, temp2_int, ABS(temp1_int - temp2_int));
         }
@@ -2594,7 +2594,7 @@ static hsize_t diff_uint_element(unsigned char *mem1, unsigned char *mem2, hsize
     if (opts->delta_bool && !opts->percent_bool) {
         if (PDIFF(temp1_uint, temp2_uint) > opts->delta) {
             opts->print_percentage = 0;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(UI_FORMAT, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint));
             }
@@ -2607,7 +2607,7 @@ static hsize_t diff_uint_element(unsigned char *mem1, unsigned char *mem2, hsize
 
         if (not_comparable && !both_zero) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(UI_FORMAT_P_NOTCOMP, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint));
             }
@@ -2615,7 +2615,7 @@ static hsize_t diff_uint_element(unsigned char *mem1, unsigned char *mem2, hsize
         }
         else if (per > opts->percent) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(UI_FORMAT_P, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint), per);
             }
@@ -2628,7 +2628,7 @@ static hsize_t diff_uint_element(unsigned char *mem1, unsigned char *mem2, hsize
 
         if (not_comparable && !both_zero) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(UI_FORMAT_P_NOTCOMP, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint));
             }
@@ -2636,7 +2636,7 @@ static hsize_t diff_uint_element(unsigned char *mem1, unsigned char *mem2, hsize
         }
         else if (per > opts->percent && PDIFF(temp1_uint,temp2_uint) > opts->delta) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(UI_FORMAT_P, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint), per);
             }
@@ -2645,7 +2645,7 @@ static hsize_t diff_uint_element(unsigned char *mem1, unsigned char *mem2, hsize
     }
     else if (temp1_uint != temp2_uint) {
         opts->print_percentage = 0;
-        print_pos(opts, elem_idx, -1);
+        print_pos(opts, elem_idx, 0);
         if (print_data(opts)) {
             parallel_print(UI_FORMAT, temp1_uint, temp2_uint, PDIFF(temp1_uint, temp2_uint));
         }
@@ -2681,7 +2681,7 @@ static hsize_t diff_long_element(unsigned char *mem1, unsigned char *mem2, hsize
     if (opts->delta_bool && !opts->percent_bool) {
         if (ABS(temp1_long-temp2_long) > opts->delta) {
             opts->print_percentage = 0;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(LI_FORMAT, temp1_long, temp2_long, ABS(temp1_long - temp2_long));
             }
@@ -2694,7 +2694,7 @@ static hsize_t diff_long_element(unsigned char *mem1, unsigned char *mem2, hsize
 
         if (not_comparable && !both_zero) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(LI_FORMAT_P_NOTCOMP, temp1_long, temp2_long, ABS(temp1_long - temp2_long));
             }
@@ -2702,7 +2702,7 @@ static hsize_t diff_long_element(unsigned char *mem1, unsigned char *mem2, hsize
         }
         else if (per > opts->percent) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(LI_FORMAT_P, temp1_long, temp2_long, ABS(temp1_long - temp2_long), per);
             }
@@ -2715,7 +2715,7 @@ static hsize_t diff_long_element(unsigned char *mem1, unsigned char *mem2, hsize
 
         if (not_comparable && !both_zero) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(LI_FORMAT_P_NOTCOMP, temp1_long, temp2_long, ABS(temp1_long - temp2_long));
             }
@@ -2723,7 +2723,7 @@ static hsize_t diff_long_element(unsigned char *mem1, unsigned char *mem2, hsize
         }
         else if (per > opts->percent && ABS(temp1_long-temp2_long) > opts->delta) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(LI_FORMAT_P, temp1_long, temp2_long, ABS(temp1_long - temp2_long), per);
             }
@@ -2732,7 +2732,7 @@ static hsize_t diff_long_element(unsigned char *mem1, unsigned char *mem2, hsize
     }
     else if (temp1_long != temp2_long) {
         opts->print_percentage = 0;
-        print_pos(opts, elem_idx, -1);
+        print_pos(opts, elem_idx, 0);
         if (print_data(opts)) {
             parallel_print(LI_FORMAT, temp1_long, temp2_long, ABS(temp1_long - temp2_long));
         }
@@ -2768,7 +2768,7 @@ static hsize_t diff_ulong_element(unsigned char *mem1, unsigned char *mem2, hsiz
     if (opts->delta_bool && !opts->percent_bool) {
         if (PDIFF(temp1_ulong, temp2_ulong) > opts->delta) {
             opts->print_percentage = 0;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(ULI_FORMAT, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong));
             }
@@ -2781,7 +2781,7 @@ static hsize_t diff_ulong_element(unsigned char *mem1, unsigned char *mem2, hsiz
 
         if (not_comparable && !both_zero) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(ULI_FORMAT_P_NOTCOMP, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong));
             }
@@ -2789,7 +2789,7 @@ static hsize_t diff_ulong_element(unsigned char *mem1, unsigned char *mem2, hsiz
         }
         else if (per > opts->percent) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(ULI_FORMAT_P, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong), per);
             }
@@ -2802,7 +2802,7 @@ static hsize_t diff_ulong_element(unsigned char *mem1, unsigned char *mem2, hsiz
 
         if (not_comparable && !both_zero) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(ULI_FORMAT_P_NOTCOMP, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong));
             }
@@ -2810,7 +2810,7 @@ static hsize_t diff_ulong_element(unsigned char *mem1, unsigned char *mem2, hsiz
         }
         else if (per > opts->percent && PDIFF(temp1_ulong,temp2_ulong) > opts->delta) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(ULI_FORMAT_P, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong), per);
             }
@@ -2819,7 +2819,7 @@ static hsize_t diff_ulong_element(unsigned char *mem1, unsigned char *mem2, hsiz
     }
     else if (temp1_ulong != temp2_ulong) {
         opts->print_percentage = 0;
-        print_pos(opts, elem_idx, -1);
+        print_pos(opts, elem_idx, 0);
         if (print_data(opts)) {
             parallel_print(ULI_FORMAT, temp1_ulong, temp2_ulong, PDIFF(temp1_ulong, temp2_ulong));
         }
@@ -2856,7 +2856,7 @@ static hsize_t diff_llong_element(unsigned char *mem1, unsigned char *mem2, hsiz
     if (opts->delta_bool && !opts->percent_bool) {
         if (ABS( temp1_llong-temp2_llong) > opts->delta) {
             opts->print_percentage = 0;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(LLI_FORMAT, temp1_llong, temp2_llong, ABS(temp1_llong - temp2_llong));
             }
@@ -2869,7 +2869,7 @@ static hsize_t diff_llong_element(unsigned char *mem1, unsigned char *mem2, hsiz
 
         if (not_comparable && !both_zero) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(LLI_FORMAT_P_NOTCOMP, temp1_llong, temp2_llong, ABS(temp1_llong - temp2_llong));
             }
@@ -2877,7 +2877,7 @@ static hsize_t diff_llong_element(unsigned char *mem1, unsigned char *mem2, hsiz
         }
         else if (per > opts->percent) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(LLI_FORMAT_P, temp1_llong, temp2_llong, ABS(temp1_llong - temp2_llong),per);
             }
@@ -2890,7 +2890,7 @@ static hsize_t diff_llong_element(unsigned char *mem1, unsigned char *mem2, hsiz
 
         if (not_comparable && !both_zero) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(LLI_FORMAT_P_NOTCOMP, temp1_llong, temp2_llong, ABS(temp1_llong - temp2_llong));
             }
@@ -2898,7 +2898,7 @@ static hsize_t diff_llong_element(unsigned char *mem1, unsigned char *mem2, hsiz
         }
         else if (per > opts->percent && ABS(temp1_llong-temp2_llong) > opts->delta) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(LLI_FORMAT_P, temp1_llong, temp2_llong, ABS(temp1_llong - temp2_llong),per);
             }
@@ -2908,7 +2908,7 @@ static hsize_t diff_llong_element(unsigned char *mem1, unsigned char *mem2, hsiz
     else {
         if (temp1_llong != temp2_llong) {
             opts->print_percentage = 0;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(LLI_FORMAT, temp1_llong, temp2_llong, ABS(temp1_llong - temp2_llong));
             }
@@ -2947,7 +2947,7 @@ static hsize_t diff_ullong_element(unsigned char *mem1, unsigned char *mem2, hsi
     if (opts->delta_bool && !opts->percent_bool) {
         if (PDIFF(temp1_ullong,temp2_ullong) > (unsigned long long) opts->delta) {
             opts->print_percentage = 0;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(ULLI_FORMAT, temp1_ullong, temp2_ullong, PDIFF(temp1_ullong, temp2_ullong));
             }
@@ -2962,7 +2962,7 @@ static hsize_t diff_ullong_element(unsigned char *mem1, unsigned char *mem2, hsi
 
         if (not_comparable && !both_zero) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(ULLI_FORMAT_P_NOTCOMP, temp1_ullong, temp2_ullong, PDIFF(temp1_ullong, temp2_ullong));
             }
@@ -2970,7 +2970,7 @@ static hsize_t diff_ullong_element(unsigned char *mem1, unsigned char *mem2, hsi
         }
         else if (per > opts->percent) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(ULLI_FORMAT_P, temp1_ullong, temp2_ullong, PDIFF(temp1_ullong,temp2_ullong), per);
             }
@@ -2985,7 +2985,7 @@ static hsize_t diff_ullong_element(unsigned char *mem1, unsigned char *mem2, hsi
 
         if (not_comparable && !both_zero) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(ULLI_FORMAT_P_NOTCOMP, temp1_ullong, temp2_ullong, PDIFF(temp1_ullong, temp2_ullong));
             }
@@ -2993,7 +2993,7 @@ static hsize_t diff_ullong_element(unsigned char *mem1, unsigned char *mem2, hsi
         }
         else if (per > opts->percent && PDIFF(temp1_ullong,temp2_ullong) > (unsigned long long) opts->delta) {
             opts->print_percentage = 1;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(ULLI_FORMAT_P, temp1_ullong, temp2_ullong, PDIFF(temp1_ullong, temp2_ullong), per);
             }
@@ -3003,7 +3003,7 @@ static hsize_t diff_ullong_element(unsigned char *mem1, unsigned char *mem2, hsi
     else {
         if (temp1_ullong != temp2_ullong) {
             opts->print_percentage = 0;
-            print_pos(opts, elem_idx, -1);
+            print_pos(opts, elem_idx, 0);
             if (print_data(opts)) {
                 parallel_print(ULLI_FORMAT, temp1_ullong, temp2_ullong, PDIFF(temp1_ullong, temp2_ullong));
             }
@@ -3254,7 +3254,7 @@ void print_header(diff_opt_t *opts)
  *-------------------------------------------------------------------------
  */
 static
-void print_pos(diff_opt_t *opts, hsize_t idx, ssize_t u)
+void print_pos(diff_opt_t *opts, hsize_t idx, size_t u)
 {
     int i,j;
 
@@ -3317,7 +3317,7 @@ void print_pos(diff_opt_t *opts, hsize_t idx, ssize_t u)
              * Calculate the number of elements represented by a unit change in a
              * certain index position.
              */
-            calc_acc_pos(opts->rank, curr_pos, opts->acc, opts->pos);
+            calc_acc_pos((unsigned)opts->rank, curr_pos, opts->acc, opts->pos);
 
             for (i = 0; i < opts->rank; i++) {
                 H5TOOLS_DEBUG("pos loop:%d with opts->pos=%ld opts->sm_pos=%ld", i, opts->pos[i], opts->sm_pos[i]);
@@ -3329,10 +3329,11 @@ void print_pos(diff_opt_t *opts, hsize_t idx, ssize_t u)
             parallel_print("]");
         }
         else {
-            if (u >= 0) {
+            if (opts->print_dims) {
                 parallel_print("[ ");
                 parallel_print("%zu", u);
                 parallel_print("]");
+                opts->print_dims = 0;
             }
             else
                 parallel_print("      ");
diff --git a/tools/lib/h5diff_attr.c b/tools/lib/h5diff_attr.c
index 774859b5ddd..b7ec2e885b4 100644
--- a/tools/lib/h5diff_attr.c
+++ b/tools/lib/h5diff_attr.c
@@ -387,18 +387,16 @@ hsize_t diff_attr_data(hid_t attr1_id, hid_t attr2_id,
         j = (int)HDstrlen(name1);
         H5TOOLS_DEBUG("attr1_name: %s - %d", name1, j);
         if (j > 0) {
-            opts->obj_name[0] = (char *)HDcalloc((size_t)j + 1, sizeof(char));
-            HDstrncpy(opts->obj_name[0], name1, (size_t)j);
-            opts->obj_name[0][j] = '\0';
+            opts->obj_name[0] = (char *)HDmalloc((size_t)j + 1);
+            HDstrncpy(opts->obj_name[0], name1, (size_t)j + 1);
         }
     }
     if (name2) {
         j = (int)HDstrlen(name2);
         H5TOOLS_DEBUG("attr2_name: %s - %d", name2, j);
         if (j > 0) {
-            opts->obj_name[1] = (char *)HDcalloc((size_t)j + 1, sizeof(char));
-            HDstrncpy(opts->obj_name[1], name2, (size_t)j);
-            opts->obj_name[1][j] = '\0';
+            opts->obj_name[1] = (char *)HDmalloc((size_t)j + 1);
+            HDstrncpy(opts->obj_name[1], name2, (size_t)j + 1);
         }
     }
     H5TOOLS_DEBUG("attr_names: %s - %s", opts->obj_name[0], opts->obj_name[1]);
@@ -424,7 +422,7 @@ hsize_t diff_attr_data(hid_t attr1_id, hid_t attr2_id,
             opts->nelmts *= dims1[j];
         }
         opts->rank = rank1;
-        init_acc_pos(opts->rank, opts->dims, opts->acc, opts->pos, opts->p_min_idx);
+        init_acc_pos((unsigned)opts->rank, opts->dims, opts->acc, opts->pos, opts->p_min_idx);
 
         /*---------------------------------------------------------------------
         * read
diff --git a/tools/lib/h5diff_dset.c b/tools/lib/h5diff_dset.c
index 602255e9ff6..944440ed6b5 100644
--- a/tools/lib/h5diff_dset.c
+++ b/tools/lib/h5diff_dset.c
@@ -277,9 +277,8 @@ diff_datasetid(hid_t did1, hid_t did2, const char *obj1_name, const char *obj2_n
         j = (int)HDstrlen(obj1_name);
         H5TOOLS_DEBUG("obj1_name: %s - %d", obj1_name, j);
         if (j > 0) {
-            opts->obj_name[0] = (char *)HDcalloc((size_t)j + 1, sizeof(char));
-            HDstrncpy(opts->obj_name[0], obj1_name, (size_t)j );
-            opts->obj_name[0][j] = '\0';
+            opts->obj_name[0] = (char *)HDmalloc((size_t)j + 1);
+            HDstrncpy(opts->obj_name[0], obj1_name, (size_t)j + 1);
         }
     }
 
@@ -289,9 +288,8 @@ diff_datasetid(hid_t did1, hid_t did2, const char *obj1_name, const char *obj2_n
         j = (int)HDstrlen(obj2_name);
         H5TOOLS_DEBUG("obj2_name: %s - %d", obj2_name, j);
         if (j > 0) {
-            opts->obj_name[1] = (char *)HDcalloc((size_t)j + 1, sizeof(char));
-            HDstrncpy(opts->obj_name[1], obj2_name, (size_t)j);
-            opts->obj_name[1][j] = '\0';
+            opts->obj_name[1] = (char *)HDmalloc((size_t)j + 1);
+            HDstrncpy(opts->obj_name[1], obj2_name, (size_t)j + 1);
         }
     }
 
@@ -451,7 +449,7 @@ diff_datasetid(hid_t did1, hid_t did2, const char *obj1_name, const char *obj2_n
         } /* end if */
 
         /* Assume entire data space to be printed */
-        init_acc_pos(opts->rank, opts->dims, opts->acc, opts->pos, opts->p_min_idx);
+        init_acc_pos((unsigned)opts->rank, opts->dims, opts->acc, opts->pos, opts->p_min_idx);
 
         for(i = 0; i < opts->rank; i++) {
             opts->p_max_idx[i] = opts->dims[i];
@@ -792,7 +790,7 @@ diff_datasetid(hid_t did1, hid_t did2, const char *obj1_name, const char *obj2_n
                     opts->sm_pos[j] = low[j];
 
                 /* Assume entire data space to be printed */
-                init_acc_pos(opts->rank, opts->dims, opts->acc, opts->pos, opts->p_min_idx);
+                init_acc_pos((unsigned)opts->rank, opts->dims, opts->acc, opts->pos, opts->p_min_idx);
 
                 /* get array differences. in the case of hyperslab read, increment the number of differences
                 found in each hyperslab and pass the position at the beginning for printing */
diff --git a/tools/lib/h5tools.c b/tools/lib/h5tools.c
index d9c6715c874..55c69a7285c 100644
--- a/tools/lib/h5tools.c
+++ b/tools/lib/h5tools.c
@@ -1670,7 +1670,7 @@ calc_acc_pos(unsigned ndims, hsize_t elmtno, hsize_t *acc, hsize_t *pos)
     H5TOOLS_START_DEBUG("");
 
     if(ndims > 0) {
-        for(i = 0; i < (size_t) ndims; i++) {
+        for(i = 0; i < (int)ndims; i++) {
             if(curr_pos > 0) {
                 H5TOOLS_DEBUG("curr_pos=%ld - ctx->acc[%d]=%ld", curr_pos, i, acc[i]);
                 pos[i] = curr_pos / acc[i];
diff --git a/tools/lib/h5tools_dump.c b/tools/lib/h5tools_dump.c
index 187ba18363c..b1be5774a32 100644
--- a/tools/lib/h5tools_dump.c
+++ b/tools/lib/h5tools_dump.c
@@ -1252,7 +1252,6 @@ h5tools_print_simple_subset(FILE *stream, const h5tool_format_t *info, h5tools_c
     size_t            j;                       /* counters  */
     hsize_t           zero[1] = {0};           /* vector of zeros */
     unsigned int      flags;                   /* buffer extent flags */
-    hsize_t           elmtno;                  /* elemnt index  */
     hsize_t           low[H5S_MAX_RANK];       /* low bound of hyperslab */
     hsize_t           high[H5S_MAX_RANK];      /* higher bound of hyperslab */
     size_t            p_type_nbytes;           /* size of memory type */
@@ -1565,9 +1564,8 @@ static herr_t
 h5tools_dump_simple_subset(FILE *stream, const h5tool_format_t *info, h5tools_context_t *ctx, hid_t dset, hid_t p_type)
 {
     int     sndims;
-    hid_t   f_space = H5I_INVALID_HID;            /* file data space */
-    size_t  i;                       /* counters  */
-    hsize_t total_size[H5S_MAX_RANK];/* total size of dataset*/
+    hid_t   f_space = H5I_INVALID_HID;    /* file data space */
+    hsize_t total_size[H5S_MAX_RANK];     /* total size of dataset*/
     hbool_t past_catch = FALSE;
     herr_t  ret_value = SUCCEED;
 
diff --git a/tools/lib/h5tools_str.c b/tools/lib/h5tools_str.c
index d612fbd7b31..1c573a79822 100644
--- a/tools/lib/h5tools_str.c
+++ b/tools/lib/h5tools_str.c
@@ -286,17 +286,14 @@ h5tools_str_prefix(h5tools_str_t *str/*in,out*/, const h5tool_format_t *info, hs
         h5tools_context_t *ctx)
 {
     size_t    i = 0;
-    hsize_t   curr_pos = elmtno;
 
     H5TOOLS_START_DEBUG("");
 
     H5TOOLS_DEBUG("elmtno=%ld, ctx->ndims=%d", elmtno, ctx->ndims);
     h5tools_str_reset(str);
 
-    curr_pos = calc_acc_pos(ctx->ndims, elmtno, ctx->acc, ctx->pos);
+    calc_acc_pos(ctx->ndims, elmtno, ctx->acc, ctx->pos);
     if(ctx->ndims > 0) {
-        HDassert(curr_pos == 0);
-
         /* Print the index values */
         for(i = 0; i < (size_t) ctx->ndims; i++) {
             if (i)
@@ -329,17 +326,14 @@ h5tools_str_region_prefix(h5tools_str_t *str/*in,out*/, const h5tool_format_t *i
         hsize_t *ptdata, h5tools_context_t *ctx)
 {
     size_t    i = 0;
-    hsize_t   curr_pos = elmtno;
 
     H5TOOLS_START_DEBUG("");
 
     H5TOOLS_DEBUG("elmtno=%ld, ctx->ndims=%d", elmtno, ctx->ndims);
     h5tools_str_reset(str);
 
-    curr_pos = calc_acc_pos(ctx->ndims, elmtno, ctx->acc, ctx->pos);
+    calc_acc_pos(ctx->ndims, elmtno, ctx->acc, ctx->pos);
     if(ctx->ndims > 0) {
-        HDassert(curr_pos == 0);
-
         /* Print the index values */
         for(i = 0; i < (size_t) ctx->ndims; i++) {
             ctx->pos[i] += (unsigned long) ptdata[ctx->sm_pos+i];
@@ -678,6 +672,7 @@ h5tools_str_sprint(h5tools_str_t *str, const h5tool_format_t *info, hid_t contai
     if(info->raw) {
         size_t i;
 
+        H5TOOLS_DEBUG("info->raw");
         if(1 == nsize)
             h5tools_str_append(str, OPT(info->fmt_raw, "0x%02x"), ucp_vp[0]);
         else
@@ -688,8 +683,11 @@ h5tools_str_sprint(h5tools_str_t *str, const h5tool_format_t *info, hid_t contai
             }
     }
     else {
-        if((type_class = H5Tget_class(type)) < 0)
+        H5TOOLS_DEBUG("H5Tget_class(type)");
+        if((type_class = H5Tget_class(type)) < 0) {
+            H5TOOLS_ENDDEBUG(" with %s", "NULL");
             return NULL;
+        }
         switch (type_class) {
             case H5T_FLOAT:
                 H5TOOLS_DEBUG("H5T_FLOAT");
diff --git a/tools/src/h5import/h5import.c b/tools/src/h5import/h5import.c
index b11fe7fde51..4a642e08162 100644
--- a/tools/src/h5import/h5import.c
+++ b/tools/src/h5import/h5import.c
@@ -3735,8 +3735,8 @@ static int getExternalFilename(struct Input *in, FILE *strm)
         return (-1);
     }
 
-    in->externFilename = (char *) HDmalloc ((size_t) (HDstrlen(temp)) * sizeof(char));
-    (void) HDstrcpy(in->externFilename, temp);
+    in->externFilename = (char *) HDmalloc ((size_t) (HDstrlen(temp) + 1) * sizeof(char));
+    (void) HDstrncpy(in->externFilename, temp, HDstrlen(temp) + 1);
     return (0);
 }
 
diff --git a/tools/src/h5ls/h5ls.c b/tools/src/h5ls/h5ls.c
index fef7aa99197..e239cbc2b67 100644
--- a/tools/src/h5ls/h5ls.c
+++ b/tools/src/h5ls/h5ls.c
@@ -1313,7 +1313,6 @@ dump_dataset_values(hid_t dset)
     hid_t               space = H5I_INVALID_HID;
     hsize_t             total_size[H5S_MAX_RANK];
     int                 ndims;
-    size_t              i;
     char                string_prefix[64];
     static char         fmt_double[16];
     static char         fmt_float[16];
@@ -1481,7 +1480,6 @@ dump_attribute_values(hid_t attr)
     hid_t               space = H5I_INVALID_HID;
     hsize_t             total_size[H5S_MAX_RANK];
     int                 ndims;
-    size_t              i;
     char                string_prefix[64];
     static char         fmt_double[16];
     static char         fmt_float[16];

From fc57490e02835ddfce644135e93e893f77b379d3 Mon Sep 17 00:00:00 2001
From: Allen Byrne <byrn@hdfgroup.org>
Date: Fri, 31 Jul 2020 07:49:48 -0500
Subject: [PATCH 51/55] Mingw copy disabled

---
 tools/test/h5diff/CMakeTests.cmake | 7 ++++---
 tools/test/h5jam/tellub.c          | 6 ++++--
 2 files changed, 8 insertions(+), 5 deletions(-)

diff --git a/tools/test/h5diff/CMakeTests.cmake b/tools/test/h5diff/CMakeTests.cmake
index 74e39298112..5aa1d1acdb3 100644
--- a/tools/test/h5diff/CMakeTests.cmake
+++ b/tools/test/h5diff/CMakeTests.cmake
@@ -341,9 +341,10 @@
   # Overwrite system dependent files (Windows) and not VS2015
   #
   set (COPY_WINDOWS_FILES false)
-  if (MINGW)
-    set (COPY_WINDOWS_FILES true)
-  endif ()
+  # MinGW tests may depend on host system
+  #if (MINGW)
+  #  set (COPY_WINDOWS_FILES true)
+  #endif ()
   if (WIN32 AND MSVC_VERSION LESS 1900)
     set (COPY_WINDOWS_FILES true)
   endif ()
diff --git a/tools/test/h5jam/tellub.c b/tools/test/h5jam/tellub.c
index e7bb5616822..453444d4d18 100644
--- a/tools/test/h5jam/tellub.c
+++ b/tools/test/h5jam/tellub.c
@@ -71,6 +71,7 @@ parse_command_line (int argc, const char *argv[])
             case 'h':
                 usage (h5tools_getprogname());
                 h5tools_setstatus(EXIT_SUCCESS);
+                break;
             case '?':
             default:
                 usage (h5tools_getprogname());
@@ -105,7 +106,7 @@ int
 main (int argc, const char *argv[])
 {
     char *ifname;
-    hid_t ifile;
+    hid_t ifile = H5I_INVALID_HID;
     hsize_t usize;
     htri_t testval;
     herr_t status;
@@ -165,7 +166,8 @@ main (int argc, const char *argv[])
 
 done:
     H5Pclose (plist);
-    H5Fclose (ifile);
+    if(ifile >= 0)
+        H5Fclose (ifile);
 
     leave(h5tools_getstatus());
 } /* end main() */

From 08dca47475f41e93348cf0c2ea708e787c232014 Mon Sep 17 00:00:00 2001
From: Dana Robinson <derobins@hdfgroup.org>
Date: Fri, 31 Jul 2020 11:40:29 -0700
Subject: [PATCH 52/55] Minor normalizations with hdf5_1_10

---
 test/chunk_info.c    |  28 +-
 test/dtypes.c        | 598 +++++++++++++++++++------------------------
 test/gen_new_super.c |  34 ++-
 test/gen_nullspace.c |  27 +-
 test/links.c         |  19 +-
 test/th5o.c          |  22 +-
 test/trefer.c        |   8 +-
 test/vds_swmr.h      |   2 -
 test/vfd.c           |   7 +-
 9 files changed, 331 insertions(+), 414 deletions(-)

diff --git a/test/chunk_info.c b/test/chunk_info.c
index 0afff660f2b..3ed1d56991f 100644
--- a/test/chunk_info.c
+++ b/test/chunk_info.c
@@ -685,7 +685,7 @@ test_get_chunk_info_highest_v18(hid_t fapl)
 
     /* Verify that the number of chunks is NUM_CHUNKS */
     if(H5Dget_num_chunks(dset, dspace, &nchunks) < 0) TEST_ERROR
-    VERIFY(nchunks, NUM_CHUNKS, "H5Dget_num_chunks, number of chunks");
+    if(nchunks != NUM_CHUNKS) TEST_ERROR
 
     /* Attempt to get info of a chunk from an empty dataset, verify the
        returned address and size in the case of H5D_ALLOC_TIME_EARLY */
@@ -693,11 +693,12 @@ test_get_chunk_info_highest_v18(hid_t fapl)
     reinit_vars(&read_flt_msk, &addr, &size);
     ret = H5Dget_chunk_info(dset, dspace, chk_index, out_offset, &read_flt_msk, &addr, &size);
     if(ret < 0) TEST_ERROR
+
     /* Because of H5D_ALLOC_TIME_EARLY, addr cannot be HADDR_UNDEF and size not 0 */
     if(addr == HADDR_UNDEF)
-        FAIL_PUTS_ERROR(MSG_CHK_ADDR);
+        TEST_ERROR
     if(size == EMPTY_CHK_SIZE)
-        FAIL_PUTS_ERROR(MSG_CHK_SIZE);
+        TEST_ERROR
 
     chk_index = 10;
     reinit_vars(&read_flt_msk, &addr, &size);
@@ -705,9 +706,9 @@ test_get_chunk_info_highest_v18(hid_t fapl)
     if(ret < 0) TEST_ERROR
     /* Because of H5D_ALLOC_TIME_EARLY, addr cannot be HADDR_UNDEF and size not 0 */
     if(addr == HADDR_UNDEF)
-        FAIL_PUTS_ERROR(MSG_CHK_ADDR);
+        TEST_ERROR
     if(size == EMPTY_CHK_SIZE)
-        FAIL_PUTS_ERROR(MSG_CHK_SIZE);
+        TEST_ERROR
 
     /* Attempt to get info of a chunk given its coords from an empty dataset,
        verify the returned address and size */
@@ -717,9 +718,9 @@ test_get_chunk_info_highest_v18(hid_t fapl)
         TEST_ERROR
     /* Because of H5D_ALLOC_TIME_EARLY, addr cannot be HADDR_UNDEF and size not 0 */
     if(addr == HADDR_UNDEF)
-        FAIL_PUTS_ERROR(MSG_CHK_ADDR);
+        TEST_ERROR
     if(size == 0)
-        FAIL_PUTS_ERROR(MSG_CHK_SIZE);
+        TEST_ERROR
 
     if(H5Dclose(dset) < 0) TEST_ERROR
 
@@ -819,7 +820,7 @@ test_chunk_info_single_chunk(const char *filename, hid_t fapl)
 
     /* Get the number of chunks and verify that no chunk has been written */
     if(H5Dget_num_chunks(dset, dspace, &nchunks) < 0) TEST_ERROR
-    VERIFY(nchunks, NO_CHUNK_WRITTEN, "H5Dget_num_chunks, number of chunks");
+    if(nchunks != NO_CHUNK_WRITTEN) TEST_ERROR
 
     /* Initialize the array of chunk data for the single chunk */
     for(ii = 0; ii < NX; ii++)
@@ -832,7 +833,7 @@ test_chunk_info_single_chunk(const char *filename, hid_t fapl)
 
     /* Get and verify that one chunk had been written */
     if(H5Dget_num_chunks(dset, dspace, &nchunks) < 0) TEST_ERROR
-    VERIFY(nchunks, ONE_CHUNK_WRITTEN, "H5Dget_num_chunks, number of chunks");
+    if(nchunks != ONE_CHUNK_WRITTEN) TEST_ERROR
 
     /* Offset of the only chunk */
     offset[0] = 0;
@@ -1937,8 +1938,7 @@ test_flt_msk_with_skip_compress(hid_t fapl)
  *
  * Purpose:     Tests functions related to chunk information
  *
- * Return:      Success:    SUCCEED
- *              Failure:    FAIL
+ * Return:      EXIT_SUCCESS/EXIT_FAILURE
  *
  * Programmer:  Binh-Minh Ribler
  *              November 5, 2018
@@ -1969,19 +1969,19 @@ main(void)
     nerrors += test_flt_msk_with_skip_compress(fapl) < 0 ? 1 : 0;
 
     if(nerrors)
-        TEST_ERROR
+        goto error;
 
     HDprintf("All chunk query tests passed.\n");
 
     h5_cleanup(FILENAME, fapl);
 
-    return SUCCEED;
+    return EXIT_SUCCESS;
 
 error:
     nerrors = MAX(1, nerrors);
     HDprintf("***** %d QUERY CHUNK INFO TEST%s FAILED! *****\n",
               nerrors, 1 == nerrors ? "" : "S");
-    return FAIL;
+    return EXIT_FAILURE;
 }
 
 /****************************************************************************
diff --git a/test/dtypes.c b/test/dtypes.c
index 0f95830d5eb..6dfc47d596e 100644
--- a/test/dtypes.c
+++ b/test/dtypes.c
@@ -134,10 +134,8 @@ typedef enum {
 static int num_opaque_conversions_g = 0;
 
 static int opaque_check(int tag_it);
-static herr_t convert_opaque(hid_t st, hid_t dt,
-               H5T_cdata_t *cdata,
-        size_t nelmts, size_t buf_stride,
-               size_t bkg_stride, void *_buf,
+static herr_t convert_opaque(hid_t st, hid_t dt, H5T_cdata_t *cdata,
+        size_t nelmts, size_t buf_stride, size_t bkg_stride, void *_buf,
         void *bkg, hid_t dset_xfer_plid);
 static int opaque_long(void);
 static int opaque_funcs(void);
@@ -146,16 +144,13 @@ static int opaque_funcs(void);
 /*-------------------------------------------------------------------------
  * Function:    reset_hdf5
  *
- * Purpose:    Reset the hdf5 library.  This causes statistics to be printed
- *        and counters to be reset.
+ * Purpose:     Reset the hdf5 library.  This causes statistics to be printed
+ *              and counters to be reset.
  *
- * Return:    void
+ * Return:      void
  *
- * Programmer:    Robb Matzke
+ * Programmer:  Robb Matzke
  *              Monday, November 16, 1998
- *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 static void
@@ -189,14 +184,10 @@ reset_hdf5(void)
  * Purpose:     Test type classes
  *
  * Return:      Success:        0
- *
  *              Failure:        number of errors
  *
  * Programmer:  Robb Matzke
  *              Tuesday, December  9, 1997
- *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 static int
@@ -290,20 +281,16 @@ test_classes(void)
  * Purpose:     Are we able to copy a datatype?
  *
  * Return:      Success:        0
- *
  *              Failure:        number of errors
  *
  * Programmer:  Robb Matzke
  *              Tuesday, December  9, 1997
- *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 static int
 test_copy(void)
 {
-    hid_t               a_copy;
+    hid_t         a_copy;
     herr_t        status;
 
     TESTING("H5Tcopy()");
@@ -313,12 +300,12 @@ test_copy(void)
 
     /* We should not be able to close a built-in byte */
     H5E_BEGIN_TRY {
-    status = H5Tclose (H5T_NATIVE_SCHAR);
+        status = H5Tclose (H5T_NATIVE_SCHAR);
     } H5E_END_TRY;
     if (status>=0) {
-    H5_FAILED();
-    HDputs ("    Should not be able to close a predefined type!");
-    goto error;
+        H5_FAILED();
+        HDputs ("    Should not be able to close a predefined type!");
+        goto error;
     }
 
     PASSED();
@@ -336,7 +323,6 @@ test_copy(void)
  *              in nested types)
  *
  * Return:      Success:        0
- *
  *              Failure:        number of errors
  *
  * Programmer:  Quincey Koziol
@@ -512,14 +498,10 @@ test_detect(void)
  * Purpose:     Tests various things about compound datatypes.
  *
  * Return:      Success:        0
- *
  *              Failure:        number of errors
  *
  * Programmer:  Robb Matzke
  *              Wednesday, January  7, 1998
- *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 static int
@@ -673,38 +655,34 @@ test_compound_1(void)
 /*-------------------------------------------------------------------------
  * Function:    test_compound_2
  *
- * Purpose:    Tests a compound type conversion where the source and
- *        destination are the same except for the order of the
- *        elements.
- *
- * Return:    Success:    0
+ * Purpose:     Tests a compound type conversion where the source and
+ *              destination are the same except for the order of the
+ *              elements.
  *
- *        Failure:    number of errors
+ * Return:      Success:    0
+ *              Failure:    number of errors
  *
- * Programmer:    Robb Matzke
+ * Programmer:  Robb Matzke
  *              Thursday, June 17, 1999
- *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 static int
 test_compound_2(void)
 {
     struct st {
-    int a, b, c[4], d, e;
+        int a, b, c[4], d, e;
     } *s_ptr;
     struct dt {
-    int e, d, c[4], b, a;
+        int e, d, c[4], b, a;
     } *d_ptr;
 
     const size_t    nelmts = NTESTELEM;
-    const hsize_t    four = 4;
-    unsigned char    *buf=NULL, *orig=NULL, *bkg=NULL;
-    hid_t        st=-1, dt=-1;
-    hid_t               array_dt;
-    int64_t        nmembs;
-    int            i;
+    const hsize_t   four = 4;
+    unsigned char  *buf=NULL, *orig=NULL, *bkg=NULL;
+    hid_t           st=-1, dt=-1;
+    hid_t           array_dt;
+    int64_t         nmembs;
+    int             i;
 
     TESTING("compound element reordering");
 
@@ -716,15 +694,15 @@ test_compound_2(void)
     bkg = (unsigned char*)HDmalloc(nelmts * sizeof(struct dt));
     orig = (unsigned char*)HDmalloc(nelmts * sizeof(struct st));
     for (i=0; i<(int)nelmts; i++) {
-    s_ptr = ((struct st*)((void *)orig)) + i;
-    s_ptr->a    = i*8+0;
-    s_ptr->b    = i*8+1;
-    s_ptr->c[0] = i*8+2;
-    s_ptr->c[1] = i*8+3;
-    s_ptr->c[2] = i*8+4;
-    s_ptr->c[3] = i*8+5;
-    s_ptr->d    = i*8+6;
-    s_ptr->e    = i*8+7;
+        s_ptr = ((struct st*)((void *)orig)) + i;
+        s_ptr->a    = i*8+0;
+        s_ptr->b    = i*8+1;
+        s_ptr->c[0] = i*8+2;
+        s_ptr->c[1] = i*8+3;
+        s_ptr->c[2] = i*8+4;
+        s_ptr->c[3] = i*8+5;
+        s_ptr->d    = i*8+6;
+        s_ptr->e    = i*8+7;
     }
     HDmemcpy(buf, orig, nelmts*sizeof(struct st));
 
@@ -754,26 +732,26 @@ test_compound_2(void)
 
     /* Compare results */
     for (i=0; i<(int)nelmts; i++) {
-    s_ptr = ((struct st*)((void *)orig)) + i;
-    d_ptr = ((struct dt*)((void *)buf))  + i;
-    if (s_ptr->a    != d_ptr->a    ||
-        s_ptr->b    != d_ptr->b    ||
-        s_ptr->c[0] != d_ptr->c[0] ||
-        s_ptr->c[1] != d_ptr->c[1] ||
-        s_ptr->c[2] != d_ptr->c[2] ||
-        s_ptr->c[3] != d_ptr->c[3] ||
-        s_ptr->d    != d_ptr->d    ||
-        s_ptr->e    != d_ptr->e) {
-        H5_FAILED();
-        HDprintf("    i=%d\n", i);
-        HDprintf("    src={a=%d, b=%d, c=[%d,%d,%d,%d], d=%d, e=%d\n",
-        s_ptr->a, s_ptr->b, s_ptr->c[0], s_ptr->c[1], s_ptr->c[2],
-        s_ptr->c[3], s_ptr->d, s_ptr->e);
-        HDprintf("    dst={a=%d, b=%d, c=[%d,%d,%d,%d], d=%d, e=%d\n",
-        d_ptr->a, d_ptr->b, d_ptr->c[0], d_ptr->c[1], d_ptr->c[2],
-        d_ptr->c[3], d_ptr->d, d_ptr->e);
-        goto error;
-    }
+        s_ptr = ((struct st*)((void *)orig)) + i;
+        d_ptr = ((struct dt*)((void *)buf))  + i;
+        if (s_ptr->a    != d_ptr->a    ||
+            s_ptr->b    != d_ptr->b    ||
+            s_ptr->c[0] != d_ptr->c[0] ||
+            s_ptr->c[1] != d_ptr->c[1] ||
+            s_ptr->c[2] != d_ptr->c[2] ||
+            s_ptr->c[3] != d_ptr->c[3] ||
+            s_ptr->d    != d_ptr->d    ||
+            s_ptr->e    != d_ptr->e) {
+            H5_FAILED();
+            HDprintf("    i=%d\n", i);
+            HDprintf("    src={a=%d, b=%d, c=[%d,%d,%d,%d], d=%d, e=%d\n",
+            s_ptr->a, s_ptr->b, s_ptr->c[0], s_ptr->c[1], s_ptr->c[2],
+            s_ptr->c[3], s_ptr->d, s_ptr->e);
+            HDprintf("    dst={a=%d, b=%d, c=[%d,%d,%d,%d], d=%d, e=%d\n",
+            d_ptr->a, d_ptr->b, d_ptr->c[0], d_ptr->c[1], d_ptr->c[2],
+            d_ptr->c[3], d_ptr->d, d_ptr->e);
+            goto error;
+        }
     }
 
     /* Release resources */
@@ -804,29 +782,25 @@ test_compound_2(void)
 /*-------------------------------------------------------------------------
  * Function:    test_compound_3
  *
- * Purpose:    Tests compound conversions where the source and destination
- *        are the same except the destination is missing a couple
- *        members which appear in the source.
+ * Purpose:     Tests compound conversions where the source and destination
+ *              are the same except the destination is missing a couple
+ *              members which appear in the source.
  *
- * Return:    Success:    0
- *
- *        Failure:    number of errors
+ * Return:      Success:    0
+ *              Failure:    number of errors
  *
- * Programmer:    Robb Matzke
+ * Programmer:  Robb Matzke
  *              Thursday, June 17, 1999
- *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 static int
 test_compound_3(void)
 {
     struct st {
-    int a, b, c[4], d, e;
+        int a, b, c[4], d, e;
     } *s_ptr;
-    struct dt {
-    int a,    c[4],    e;
+        struct dt {
+        int a,    c[4],    e;
     } *d_ptr;
 
     const size_t    nelmts = NTESTELEM;
@@ -884,24 +858,24 @@ test_compound_3(void)
 
     /* Compare results */
     for (i=0; i<(int)nelmts; i++) {
-    s_ptr = ((struct st*)((void *)orig)) + i;
-    d_ptr = ((struct dt*)((void *)buf))  + i;
-    if (s_ptr->a    != d_ptr->a    ||
-        s_ptr->c[0] != d_ptr->c[0] ||
-        s_ptr->c[1] != d_ptr->c[1] ||
-        s_ptr->c[2] != d_ptr->c[2] ||
-        s_ptr->c[3] != d_ptr->c[3] ||
-        s_ptr->e    != d_ptr->e) {
-        H5_FAILED();
-        HDprintf("    i=%d\n", i);
-        HDprintf("    src={a=%d, b=%d, c=[%d,%d,%d,%d], d=%d, e=%d\n",
-        s_ptr->a, s_ptr->b, s_ptr->c[0], s_ptr->c[1], s_ptr->c[2],
-        s_ptr->c[3], s_ptr->d, s_ptr->e);
-        HDprintf("    dst={a=%d, c=[%d,%d,%d,%d], e=%d\n",
-        d_ptr->a, d_ptr->c[0], d_ptr->c[1], d_ptr->c[2],
-        d_ptr->c[3], d_ptr->e);
-        goto error;
-    }
+        s_ptr = ((struct st*)((void *)orig)) + i;
+        d_ptr = ((struct dt*)((void *)buf))  + i;
+        if (s_ptr->a    != d_ptr->a    ||
+            s_ptr->c[0] != d_ptr->c[0] ||
+            s_ptr->c[1] != d_ptr->c[1] ||
+            s_ptr->c[2] != d_ptr->c[2] ||
+            s_ptr->c[3] != d_ptr->c[3] ||
+            s_ptr->e    != d_ptr->e) {
+            H5_FAILED();
+            HDprintf("    i=%d\n", i);
+            HDprintf("    src={a=%d, b=%d, c=[%d,%d,%d,%d], d=%d, e=%d\n",
+            s_ptr->a, s_ptr->b, s_ptr->c[0], s_ptr->c[1], s_ptr->c[2],
+            s_ptr->c[3], s_ptr->d, s_ptr->e);
+            HDprintf("    dst={a=%d, c=[%d,%d,%d,%d], e=%d\n",
+            d_ptr->a, d_ptr->c[0], d_ptr->c[1], d_ptr->c[2],
+            d_ptr->c[3], d_ptr->e);
+            goto error;
+        }
     }
 
     /* Release resources */
@@ -931,19 +905,15 @@ test_compound_3(void)
 /*-------------------------------------------------------------------------
  * Function:    test_compound_4
  *
- * Purpose:    Tests compound conversions when the destination has the same
- *        fields as the source but one or more of the fields are
- *        smaller.
+ * Purpose:     Tests compound conversions when the destination has the same
+ *              fields as the source but one or more of the fields are
+ *              smaller.
  *
- * Return:    Success:    0
- *
- *        Failure:    number of errors
+ * Return:      Success:    0
+ *              Failure:    number of errors
  *
- * Programmer:    Robb Matzke
+ * Programmer:  Robb Matzke
  *              Thursday, June 17, 1999
- *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 static int
@@ -951,13 +921,13 @@ test_compound_4(void)
 {
 
     struct st {
-    int a, b, c[4], d, e;
+        int a, b, c[4], d, e;
     } *s_ptr;
     struct dt {
-    short b;
-    int a, c[4];
-    short d;
-    int e;
+        short b;
+        int a, c[4];
+        short d;
+        int e;
     } *d_ptr;
 
     const size_t    nelmts = NTESTELEM;
@@ -1017,26 +987,26 @@ test_compound_4(void)
 
     /* Compare results */
     for (i=0; i<(int)nelmts; i++) {
-    s_ptr = ((struct st*)((void *)orig)) + i;
-    d_ptr = ((struct dt*)((void *)buf))  + i;
-    if (s_ptr->a    != d_ptr->a    ||
-        s_ptr->b    != d_ptr->b    ||
-        s_ptr->c[0] != d_ptr->c[0] ||
-        s_ptr->c[1] != d_ptr->c[1] ||
-        s_ptr->c[2] != d_ptr->c[2] ||
-        s_ptr->c[3] != d_ptr->c[3] ||
-        s_ptr->d    != d_ptr->d    ||
-        s_ptr->e    != d_ptr->e) {
-        H5_FAILED();
-        HDprintf("    i=%d\n", i);
-        HDprintf("    src={a=%d, b=%d, c=[%d,%d,%d,%d], d=%d, e=%d\n",
-        s_ptr->a, s_ptr->b, s_ptr->c[0], s_ptr->c[1], s_ptr->c[2],
-        s_ptr->c[3], s_ptr->d, s_ptr->e);
-        HDprintf("    dst={a=%d, b=%d, c=[%d,%d,%d,%d], d=%d, e=%d\n",
-        d_ptr->a, d_ptr->b, d_ptr->c[0], d_ptr->c[1], d_ptr->c[2],
-        d_ptr->c[3], d_ptr->d, d_ptr->e);
-        goto error;
-    }
+        s_ptr = ((struct st*)((void *)orig)) + i;
+        d_ptr = ((struct dt*)((void *)buf))  + i;
+        if (s_ptr->a    != d_ptr->a    ||
+            s_ptr->b    != d_ptr->b    ||
+            s_ptr->c[0] != d_ptr->c[0] ||
+            s_ptr->c[1] != d_ptr->c[1] ||
+            s_ptr->c[2] != d_ptr->c[2] ||
+            s_ptr->c[3] != d_ptr->c[3] ||
+            s_ptr->d    != d_ptr->d    ||
+            s_ptr->e    != d_ptr->e) {
+            H5_FAILED();
+            HDprintf("    i=%d\n", i);
+            HDprintf("    src={a=%d, b=%d, c=[%d,%d,%d,%d], d=%d, e=%d\n",
+            s_ptr->a, s_ptr->b, s_ptr->c[0], s_ptr->c[1], s_ptr->c[2],
+            s_ptr->c[3], s_ptr->d, s_ptr->e);
+            HDprintf("    dst={a=%d, b=%d, c=[%d,%d,%d,%d], d=%d, e=%d\n",
+            d_ptr->a, d_ptr->b, d_ptr->c[0], d_ptr->c[1], d_ptr->c[2],
+            d_ptr->c[3], d_ptr->d, d_ptr->e);
+            goto error;
+        }
     }
 
     /* Release resources */
@@ -1066,20 +1036,16 @@ test_compound_4(void)
 /*-------------------------------------------------------------------------
  * Function:    test_compound_5
  *
- * Purpose:    Many versions of HDF5 have a bug in the optimized compound
+ * Purpose:     Many versions of HDF5 have a bug in the optimized compound
  *              datatype conversion function, H5T_conv_struct_opt(), which
  *              is triggered when the top-level type contains a struct
  *              which must undergo a conversion.
  *
- * Return:    Success:    0
- *
- *        Failure:    number of errors
+ * Return:      Success:    0
+ *              Failure:    number of errors
  *
- * Programmer:    Robb Matzke
+ * Programmer:  Robb Matzke
  *              Thursday, June 17, 1999
- *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 static int
@@ -1156,7 +1122,8 @@ test_compound_5(void)
         src[1].coll_ids[2]!=dst[1].coll_ids[2] ||
         src[1].coll_ids[3]!=dst[1].coll_ids[3]) {
         H5_FAILED();
-    } else {
+    }
+    else {
         PASSED();
         retval = 0;
     }
@@ -1171,19 +1138,15 @@ test_compound_5(void)
 /*-------------------------------------------------------------------------
  * Function:    test_compound_6
  *
- * Purpose:    Tests compound conversions when the destination has the same
- *        fields as the source but one or more of the fields are
- *        larger.
+ * Purpose:     Tests compound conversions when the destination has the same
+ *              fields as the source but one or more of the fields are
+ *              larger.
  *
- * Return:    Success:    0
- *
- *        Failure:    number of errors
+ * Return:      Success:    0
+ *              Failure:    number of errors
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Wednesday, December 13, 2000
- *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 static int
@@ -1244,18 +1207,18 @@ test_compound_6(void)
 
     /* Compare results */
     for (i=0; i<(int)nelmts; i++) {
-    s_ptr = ((struct st*)((void *)orig)) + i;
-    d_ptr = ((struct dt*)((void *)buf))  + i;
-    if (s_ptr->b    != d_ptr->b    ||
-        s_ptr->d    != d_ptr->d) {
-        H5_FAILED();
-        HDprintf("    i=%d\n", i);
-        HDprintf("    src={b=%d, d=%d\n",
-           (int)s_ptr->b, (int)s_ptr->d);
-        HDprintf("    dst={b=%ld, d=%ld\n",
-           d_ptr->b, d_ptr->d);
-        goto error;
-    }
+        s_ptr = ((struct st*)((void *)orig)) + i;
+        d_ptr = ((struct dt*)((void *)buf))  + i;
+        if (s_ptr->b    != d_ptr->b    ||
+            s_ptr->d    != d_ptr->d) {
+            H5_FAILED();
+            HDprintf("    i=%d\n", i);
+            HDprintf("    src={b=%d, d=%d\n",
+            (int)s_ptr->b, (int)s_ptr->d);
+            HDprintf("    dst={b=%ld, d=%ld\n",
+            d_ptr->b, d_ptr->d);
+            goto error;
+        }
     }
 
     /* Release resources */
@@ -1284,15 +1247,14 @@ test_compound_6(void)
 /*-------------------------------------------------------------------------
  * Function:    test_compound_7
  *
- * Purpose:    Tests inserting fields into compound datatypes when the field
+ * Purpose:     Tests inserting fields into compound datatypes when the field
  *              overlaps the end of the compound datatype.  Also, tests
  *              increasing compound type size.
  *
- * Return:    Success:    0
- *
- *        Failure:    number of errors
+ * Return:      Success:    0
+ *              Failure:    number of errors
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Tuesday, December 18, 2001
  *
  * Modifications:
@@ -1686,9 +1648,6 @@ test_compound_8(void)
  *
  * Programmer:  Raymond Lu
  *              Wednesday, June 9, 2004
- *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 static int
@@ -4758,17 +4717,13 @@ test_conv_enum_2(void)
 /*-------------------------------------------------------------------------
  * Function:    test_conv_bitfield
  *
- * Purpose:    Test bitfield conversions.
- *
- * Return:    Success:    0
+ * Purpose:     Test bitfield conversions.
  *
- *        Failure:    number of errors
+ * Return:      Success:    0
+ *              Failure:    number of errors
  *
- * Programmer:    Robb Matzke
+ * Programmer:  Robb Matzke
  *              Thursday, May 20, 1999
- *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 static int
@@ -4790,10 +4745,9 @@ test_conv_bitfield(void)
     buf[2] = buf[3] = 0x55; /*irrelevant*/
     if (H5Tconvert(st, dt, (size_t)1, buf, NULL, H5P_DEFAULT) < 0) goto error;
     if (buf[0]!=0xAA || buf[1]!=0xAA || buf[2]!=0 || buf[3]!=0) {
-    H5_FAILED();
-    printf("    s=0xaaaa, d=0x%02x%02x%02x%02x (test 1)\n",
-        buf[3], buf[2], buf[1], buf[0]);
-    goto error;
+        H5_FAILED();
+        HDprintf("    s=0xaaaa, d=0x%02x%02x%02x%02x (test 1)\n", buf[3], buf[2], buf[1], buf[0]);
+        goto error;
     }
 
     /*
@@ -4809,10 +4763,9 @@ test_conv_bitfield(void)
     buf[0] = 0xA8; buf[1] = 0x2A; buf[2] = buf[3] = 0;
     if (H5Tconvert(st, dt, (size_t)1, buf, NULL, H5P_DEFAULT) < 0) goto error;
     if (buf[0]!=0 || buf[1]!=0xA8 || buf[2]!=0x2A || buf[3]!=0) {
-    H5_FAILED();
-    printf("    s=0x2AA8 d=0x%02x%02x%02x%02x (test 2)\n",
-        buf[3], buf[2], buf[1], buf[0]);
-    goto error;
+        H5_FAILED();
+        HDprintf("    s=0x2AA8 d=0x%02x%02x%02x%02x (test 2)\n", buf[3], buf[2], buf[1], buf[0]);
+        goto error;
     }
 
     /*
@@ -4823,10 +4776,9 @@ test_conv_bitfield(void)
     buf[0] = 0xA8; buf[1] = 0x2A; buf[2] = buf[3] = 0;
     if (H5Tconvert(st, dt, (size_t)1, buf, NULL, H5P_DEFAULT) < 0) goto error;
     if (buf[0]!=0xff || buf[1]!=0xAB || buf[2]!=0xEA || buf[3]!=0xff) {
-    H5_FAILED();
-    printf("    s=0x2AA8 d=0x%02x%02x%02x%02x (test 3)\n",
-        buf[3], buf[2], buf[1], buf[0]);
-    goto error;
+        H5_FAILED();
+        HDprintf("    s=0x2AA8 d=0x%02x%02x%02x%02x (test 3)\n", buf[3], buf[2], buf[1], buf[0]);
+        goto error;
     }
 
     H5Tclose(st);
@@ -4855,18 +4807,14 @@ test_conv_bitfield(void)
 /*-------------------------------------------------------------------------
  * Function:    test_bitfield_funcs
  *
- * Purpose:    Test some datatype functions that are and aren't supposed
+ * Purpose:     Test some datatype functions that are and aren't supposed
  *              work for bitfield type.
  *
- * Return:    Success:    0
- *
- *        Failure:    number of errors
+ * Return:      Success:    0
+ *              Failure:    number of errors
  *
- * Programmer:    Raymond Lu
+ * Programmer:  Raymond Lu
  *              Wednesday, April 5, 2006
- *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 static int
@@ -4984,17 +4932,13 @@ test_bitfield_funcs(void)
 /*-------------------------------------------------------------------------
  * Function:    convert_opaque
  *
- * Purpose:    A fake opaque conversion functions
- *
- * Return:    Success:    0
+ * Purpose:     A fake opaque conversion functions
  *
- *        Failure:    -1
+ * Return:      Success:    0
+ *              Failure:    -1
  *
- * Programmer:    Robb Matzke
+ * Programmer:  Robb Matzke
  *              Friday, June  4, 1999
- *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 static herr_t
@@ -5003,7 +4947,8 @@ convert_opaque(hid_t H5_ATTR_UNUSED st, hid_t H5_ATTR_UNUSED dt, H5T_cdata_t *cd
                size_t H5_ATTR_UNUSED bkg_stride, void H5_ATTR_UNUSED *_buf,
         void H5_ATTR_UNUSED *bkg, hid_t H5_ATTR_UNUSED dset_xfer_plid)
 {
-    if (H5T_CONV_CONV==cdata->command) num_opaque_conversions_g++;
+    if (H5T_CONV_CONV==cdata->command)
+        num_opaque_conversions_g++;
     return 0;
 }
 
@@ -5011,17 +4956,13 @@ convert_opaque(hid_t H5_ATTR_UNUSED st, hid_t H5_ATTR_UNUSED dt, H5T_cdata_t *cd
 /*-------------------------------------------------------------------------
  * Function:    test_opaque
  *
- * Purpose:    Driver function to test opaque datatypes
- *
- * Return:    Success:    0
+ * Purpose:     Driver function to test opaque datatypes
  *
- *        Failure:    number of errors
+ * Return:      Success:    0
+ *              Failure:    number of errors
  *
- * Programmer:    Raymond Lu
+ * Programmer:  Raymond Lu
  *              June 2, 2004
- *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 static int
@@ -5054,25 +4995,23 @@ test_opaque(void)
 /*-------------------------------------------------------------------------
  * Function:    opaque_check
  *
- * Purpose:    Test opaque datatypes
- *
- * Return:    Success:    0
+ * Purpose:     Test opaque datatypes
  *
- *        Failure:    number of errors
+ * Return:      Success:    0
+ *              Failure:    number of errors
  *
- * Programmer:    Robb Matzke
+ * Programmer:  Robb Matzke
  *              Thursday, May 20, 1999
- *
  *-------------------------------------------------------------------------
  */
 static int
 opaque_check(int tag_it)
 {
 #define OPAQUE_NELMTS 1000
-    hid_t    st=-1, dt=-1;
+    hid_t     st=-1, dt=-1;
     herr_t    status;
-    char    buf[1]; /*not really used*/
-    int        saved;
+    char      buf[1]; /*not really used*/
+    int       saved;
 
     saved = num_opaque_conversions_g = 0;
 
@@ -5088,29 +5027,29 @@ opaque_check(int tag_it)
 
     /* Make sure that we can't convert between the types yet */
     H5E_BEGIN_TRY {
-    status = H5Tconvert(st, dt, (size_t)OPAQUE_NELMTS, buf, NULL, H5P_DEFAULT);
+        status = H5Tconvert(st, dt, (size_t)OPAQUE_NELMTS, buf, NULL, H5P_DEFAULT);
     } H5E_END_TRY;
     if (status>=0) {
-    H5_FAILED();
-    printf("    opaque conversion should have failed but succeeded\n");
-    goto error;
+        H5_FAILED();
+        HDprintf("    opaque conversion should have failed but succeeded\n");
+        goto error;
     }
 
     /* Register a conversion function */
     if (H5Tregister(H5T_PERS_HARD, "o_test", st, dt, convert_opaque) < 0)
-    goto error;
+        goto error;
 
     /* Try the conversion again, this time it should work */
     if (H5Tconvert(st, dt, (size_t)OPAQUE_NELMTS, buf, NULL, H5P_DEFAULT) < 0) goto error;
     if (saved+1 != num_opaque_conversions_g) {
-    H5_FAILED();
-    printf("    unexpected number of opaque conversions\n");
-    goto error;
+        H5_FAILED();
+        HDprintf("    unexpected number of opaque conversions\n");
+        goto error;
     }
 
     /* Unregister conversion function */
     if (H5Tunregister(H5T_PERS_HARD, "o_test", st, dt, convert_opaque) < 0)
-    goto error;
+        goto error;
 
     H5Tclose(st);
     H5Tclose(dt);
@@ -5127,12 +5066,12 @@ opaque_check(int tag_it)
 /*-------------------------------------------------------------------------
  * Function:    opaque_long
  *
- * Purpose:    Test named (committed) opaque datatypes w/very long tags
+ * Purpose:     Test named (committed) opaque datatypes w/very long tags
  *
- * Return:    Success:    0
- *        Failure:    number of errors
+ * Return:      Success:    0
+ *              Failure:    number of errors
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Tuesday, June 14, 2005
  *
  *-------------------------------------------------------------------------
@@ -5142,7 +5081,7 @@ opaque_long(void)
 {
     char     *long_tag = NULL;
     hid_t    dt = -1;
-    herr_t      ret;
+    herr_t   ret;
 
     /* Build opaque type */
     if((dt=H5Tcreate(H5T_OPAQUE, (size_t)4)) < 0) TEST_ERROR
@@ -5154,7 +5093,7 @@ opaque_long(void)
 
     /* Set opaque type's tag */
     H5E_BEGIN_TRY {
-    ret = H5Tset_tag(dt, long_tag);
+        ret = H5Tset_tag(dt, long_tag);
     } H5E_END_TRY;
     if(ret != FAIL) TEST_ERROR
 
@@ -5179,24 +5118,20 @@ opaque_long(void)
 /*-------------------------------------------------------------------------
  * Function:    opaque_funcs
  *
- * Purpose:    Test some type functions that are and aren't supposed to
+ * Purpose:     Test some type functions that are and aren't supposed to
  *              work with opaque type.
  *
- * Return:    Success:    0
- *
- *        Failure:    number of errors
+ * Return:      Success:    0
+ *              Failure:    number of errors
  *
- * Programmer:    Raymond Lu
+ * Programmer:  Raymond Lu
  *              Wednesday, April 5, 2006
- *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 static int
 opaque_funcs(void)
 {
-    hid_t    type = -1, super=-1;
+    hid_t       type = -1, super=-1;
     size_t      size;
     H5T_pad_t   inpad;
     H5T_cset_t  cset;
@@ -5803,7 +5738,7 @@ test_encode(void)
     }
 
     H5E_BEGIN_TRY {
-    ret = H5Tclose(decoded_tid3);
+        ret = H5Tclose(decoded_tid3);
     } H5E_END_TRY;
     if(ret!=FAIL) {
         H5_FAILED();
@@ -6102,14 +6037,13 @@ static int
 test_int_float_except(void)
 {
 #if H5_SIZEOF_INT==4 && H5_SIZEOF_FLOAT==4
-    float buf[CONVERT_SIZE] = {(float)INT_MIN - 172.0f, (float)INT_MAX - 32.0f,
-            (float)INT_MAX - 68.0f, (float)4.5f};
-    int buf_int[CONVERT_SIZE] = {INT_MIN, INT_MAX, INT_MAX-127, 4};
+    float buf[CONVERT_SIZE] = {(float)INT_MIN - 172.0f, (float)INT_MAX - 32.0f, (float)INT_MAX - 68.0f, (float)4.5f};
+    int   buf_int[CONVERT_SIZE] = {INT_MIN, INT_MAX, INT_MAX-127, 4};
     float buf_float[CONVERT_SIZE] = {(float)INT_MIN, (float)INT_MAX + 1.0f, (float)INT_MAX - 127.0f, 4};
-    int *intp;          /* Pointer to buffer, as integers */
-    int buf2[CONVERT_SIZE] = {INT_MIN, INT_MAX, INT_MAX - 72, 0};
+    int  *intp;          /* Pointer to buffer, as integers */
+    int   buf2[CONVERT_SIZE] = {INT_MIN, INT_MAX, INT_MAX - 72, 0};
     float buf2_float[CONVERT_SIZE] = {(float)INT_MIN, (float)INT_MAX, (float)INT_MAX - 127.0f, (float)0.0f};
-    int buf2_int[CONVERT_SIZE] = {INT_MIN, INT_MAX, INT_MAX - 127, 0};
+    int   buf2_int[CONVERT_SIZE] = {INT_MIN, INT_MAX, INT_MAX - 127, 0};
     float *floatp;      /* Pointer to buffer #2, as floats */
     hid_t dxpl;         /* Dataset transfer property list */
     except_info_t e;    /* Exception information */
@@ -6165,8 +6099,8 @@ test_int_float_except(void)
 
     /* Convert second buffer */
     HDmemset(&e, 0, sizeof(except_info_t));
-    if(H5Tconvert(H5T_NATIVE_INT, H5T_NATIVE_FLOAT, (size_t)CONVERT_SIZE,
-            buf2, NULL, dxpl) < 0) TEST_ERROR
+    if(H5Tconvert(H5T_NATIVE_INT, H5T_NATIVE_FLOAT, (size_t)CONVERT_SIZE, buf2, NULL, dxpl) < 0)
+        TEST_ERROR
 
     /* Check the buffer after conversion, as floats */
     for(u = 0; u < CONVERT_SIZE; u++) {
@@ -6183,8 +6117,8 @@ test_int_float_except(void)
 
     /* Convert buffer */
     HDmemset(&e, 0, sizeof(except_info_t));
-    if(H5Tconvert(H5T_NATIVE_FLOAT, H5T_NATIVE_INT, (size_t)CONVERT_SIZE,
-            buf2, NULL, dxpl) < 0) TEST_ERROR
+    if(H5Tconvert(H5T_NATIVE_FLOAT, H5T_NATIVE_INT, (size_t)CONVERT_SIZE, buf2, NULL, dxpl) < 0)
+        TEST_ERROR
 
     /* Check the buffer after conversion, as integers */
     for(u = 0; u < CONVERT_SIZE; u++) {
@@ -6415,7 +6349,7 @@ test_set_order_compound(hid_t fapl)
     hid_t       cmpd = -1, memb_cmpd = -1, memb_array1 = -1, memb_array2 = -1, cmpd_array = -1;
     hid_t       vl_id = -1;
     hsize_t     dims[2] = {3, 4};   /* Array dimenstions */
-    char    filename[1024];
+    char        filename[1024];
     herr_t      ret;                /* Generic return value */
 
     TESTING("H5Tset/get_order for compound type");
@@ -6521,18 +6455,14 @@ test_set_order_compound(hid_t fapl)
 /*-------------------------------------------------------------------------
  * Function:    test_named_indirect_reopen
  *
- * Purpose:    Tests that open named datatypes can be reopened indirectly
+ * Purpose:     Tests that open named datatypes can be reopened indirectly
  *              through H5Dget_type without causing problems.
  *
- * Return:    Success:    0
- *
- *        Failure:    number of errors
+ * Return:      Success:    0
+ *              Failure:    number of errors
  *
- * Programmer:    Neil Fortner
+ * Programmer:  Neil Fortner
  *              Thursday, June 4, 2009
- *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 static int
@@ -6540,11 +6470,11 @@ test_named_indirect_reopen(hid_t fapl)
 {
     hid_t        file=-1, type=-1, reopened_type=-1, strtype=-1, dset=-1, space=-1;
     static hsize_t    dims[1] = {3};
-    size_t              dt_size;
-    int                 enum_value;
-    const char          *tag = "opaque_tag";
-    char                *tag_ret = NULL;
-    char        filename[1024];
+    size_t            dt_size;
+    int               enum_value;
+    const char       *tag = "opaque_tag";
+    char             *tag_ret = NULL;
+    char              filename[1024];
 
     TESTING("indirectly reopening committed datatypes");
 
@@ -6708,11 +6638,11 @@ test_named_indirect_reopen(hid_t fapl)
 
 error:
     H5E_BEGIN_TRY {
-    H5Tclose(type);
-    H5Tclose(strtype);
-    H5Tclose(reopened_type);
-    H5Sclose(space);
-    H5Dclose(dset);
+        H5Tclose(type);
+        H5Tclose(strtype);
+        H5Tclose(reopened_type);
+        H5Sclose(space);
+        H5Dclose(dset);
     H5Fclose(file);
     } H5E_END_TRY;
     if(tag_ret)
@@ -6912,12 +6842,12 @@ test_delete_obj_named(hid_t fapl)
 
 error:
     H5E_BEGIN_TRY {
-    H5Tclose(attr);
-    H5Dclose(dset);
-    H5Pclose(fapl2);
-    H5Fclose(filea1);
-    H5Fclose(filea2);
-    H5Fclose(fileb);
+        H5Tclose(attr);
+        H5Dclose(dset);
+        H5Pclose(fapl2);
+        H5Fclose(filea1);
+        H5Fclose(filea2);
+        H5Fclose(fileb);
     } H5E_END_TRY;
     return 1;
 } /* end test_delete_obj_named() */
@@ -7075,15 +7005,15 @@ test_delete_obj_named_fileid(hid_t fapl)
 
 error:
     H5E_BEGIN_TRY {
-    H5Aclose(attr);
-    H5Tclose(type);
-    H5Dclose(dset);
-    H5Pclose(fapl2);
-    H5Fclose(filea1);
-    H5Fclose(filea2);
-    H5Fclose(fileb);
-    H5Fclose(attr_fid);
-    H5Fclose(type_fid);
+        H5Aclose(attr);
+        H5Tclose(type);
+        H5Dclose(dset);
+        H5Pclose(fapl2);
+        H5Fclose(filea1);
+        H5Fclose(filea2);
+        H5Fclose(fileb);
+        H5Fclose(attr_fid);
+        H5Fclose(type_fid);
     } H5E_END_TRY;
     return 1;
 } /* end test_delete_obj_named_fileid() */
@@ -7092,12 +7022,12 @@ test_delete_obj_named_fileid(hid_t fapl)
 /*-------------------------------------------------------------------------
  * Function:    test_deprec
  *
- * Purpose:    Tests deprecated API routines for datatypes.
+ * Purpose:     Tests deprecated API routines for datatypes.
  *
- * Return:    Success:    0
- *        Failure:    number of errors
+ * Return:      Success:    0
+ *              Failure:    number of errors
  *
- * Programmer:    Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Thursday, September 27, 2007
  *
  *-------------------------------------------------------------------------
@@ -7167,31 +7097,31 @@ test_deprec(hid_t fapl)
 
     /* Predefined types cannot be committed */
     H5E_BEGIN_TRY {
-    status = H5Tcommit1(file, "test_named_1 (should not exist)", H5T_NATIVE_INT);
+        status = H5Tcommit1(file, "test_named_1 (should not exist)", H5T_NATIVE_INT);
     } H5E_END_TRY;
     if(status >= 0)
-    FAIL_PUTS_ERROR("    Predefined types should not be committable!")
+        FAIL_PUTS_ERROR("    Predefined types should not be committable!")
 
     /* Copy a predefined datatype and commit the copy */
     if((type = H5Tcopy(H5T_NATIVE_INT)) < 0) FAIL_STACK_ERROR
     if(H5Tcommit1(file, "native-int", type) < 0) FAIL_STACK_ERROR
     if((status = H5Tcommitted(type)) < 0) FAIL_STACK_ERROR
     if(0 == status)
-    FAIL_PUTS_ERROR("    H5Tcommitted() returned false!")
+        FAIL_PUTS_ERROR("    H5Tcommitted() returned false!")
 
     /* We should not be able to modify a type after it has been committed. */
     H5E_BEGIN_TRY {
-    status = H5Tset_precision(type, (size_t)256);
+        status = H5Tset_precision(type, (size_t)256);
     } H5E_END_TRY;
     if(status >= 0)
-    FAIL_PUTS_ERROR("    Committed type is not constant!")
+        FAIL_PUTS_ERROR("    Committed type is not constant!")
 
     /* We should not be able to re-commit a committed type */
     H5E_BEGIN_TRY {
-    status = H5Tcommit1(file, "test_named_2 (should not exist)", type);
+        status = H5Tcommit1(file, "test_named_2 (should not exist)", type);
     } H5E_END_TRY;
     if(status >= 0)
-    FAIL_PUTS_ERROR("    Committed types should not be recommitted!")
+        FAIL_PUTS_ERROR("    Committed types should not be recommitted!")
 
     /*
      * Close the committed type and reopen it.  It should return a named type.
@@ -7200,7 +7130,7 @@ test_deprec(hid_t fapl)
     if((type = H5Topen1(file, "native-int")) < 0) FAIL_STACK_ERROR
     if((status = H5Tcommitted(type)) < 0) FAIL_STACK_ERROR
     if(!status)
-    FAIL_PUTS_ERROR("    Opened named types should be named types!")
+        FAIL_PUTS_ERROR("    Opened named types should be named types!")
 
     /* Close */
     if(H5Tclose(type) < 0) FAIL_STACK_ERROR
@@ -7230,8 +7160,8 @@ test_deprec(hid_t fapl)
 
 error:
     H5E_BEGIN_TRY {
-    H5Tclose(type);
-    H5Fclose(file);
+        H5Tclose(type);
+        H5Fclose(file);
     } H5E_END_TRY;
     return 1;
 } /* end test_deprec() */
@@ -7241,13 +7171,13 @@ test_deprec(hid_t fapl)
 /*-------------------------------------------------------------------------
  * Function:    test_utf_ascii_conv
  *
- * Purpose:    Make sure the library doesn't conversion strings between
+ * Purpose:     Make sure the library doesn't conversion strings between
  *              ASCII and UTF8.
  *
- * Return:    Success:    0
- *        Failure:    number of errors
+ * Return:      Success:    0
+ *              Failure:    number of errors
  *
- * Programmer:    Raymond Lu
+ * Programmer:  Raymond Lu
  *              10 November 2011
  *-------------------------------------------------------------------------
  */
@@ -7437,13 +7367,13 @@ test_utf_ascii_conv(void)
 
 error:
     H5E_BEGIN_TRY {
-    H5Tclose(utf8_vtid);
-    H5Tclose(ascii_vtid);
-    H5Tclose(utf8_tid);
-    H5Tclose(ascii_tid);
-    H5Dclose(did);
-    H5Sclose(sid);
-    H5Fclose(fid);
+        H5Tclose(utf8_vtid);
+        H5Tclose(ascii_vtid);
+        H5Tclose(utf8_tid);
+        H5Tclose(ascii_tid);
+        H5Dclose(did);
+        H5Sclose(sid);
+        H5Fclose(fid);
     } H5E_END_TRY;
     return 1;
 }
@@ -7827,16 +7757,13 @@ test_versionbounds(void)
  *
  * Programmer:  Robb Matzke
  *              Tuesday, December  9, 1997
- *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 int
 main(void)
 {
     long    nerrors = 0;
-    hid_t    fapl = -1;
+    hid_t   fapl = H5I_INVALID_HID;
 
     /* Set the random # seed */
     HDsrandom((unsigned)HDtime(NULL));
@@ -7845,7 +7772,7 @@ main(void)
     fapl = h5_fileaccess();
 
     if(ALIGNMENT)
-    printf("Testing non-aligned conversions (ALIGNMENT=%d)....\n", ALIGNMENT);
+        HDprintf("Testing non-aligned conversions (ALIGNMENT=%d)....\n", ALIGNMENT);
 
     /* Do the tests */
     nerrors += test_classes();
@@ -7900,8 +7827,7 @@ main(void)
     nerrors += test_versionbounds();
 
     if(nerrors) {
-        HDprintf("***** %lu FAILURE%s! *****\n",
-               nerrors, 1==nerrors?"":"S");
+        HDprintf("***** %lu FAILURE%s! *****\n", nerrors, 1==nerrors?"":"S");
         HDexit(EXIT_FAILURE);
     }
 
diff --git a/test/gen_new_super.c b/test/gen_new_super.c
index ed43a39d122..d371f5fc422 100644
--- a/test/gen_new_super.c
+++ b/test/gen_new_super.c
@@ -23,26 +23,22 @@
  *      put into the 'test' directory in the 1.4+ branch of the library.
  */
 
-#include <assert.h>
-#include "testhdf5.h"
+#include "h5test.h"
 
 #define TESTFILE   "tsupern.h5"
 #define ISTORE_IK  64
 
 
 /*-------------------------------------------------------------------------
- * Function:	main
+ * Function:    main
  *
- * Purpose:	Create a file with a new version (>0) of the superblock
+ * Purpose:     Create a file with a new version (>0) of the superblock
  *
- * Return:	Success:
- *		Failure:
+ * Return:      EXIT_SUCCESS
  *
- * Programmer:	Quincey Koziol
+ * Programmer:  Quincey Koziol
  *              Tuesday, July 15, 2003
  *
- * Modifications:
- *
  *-------------------------------------------------------------------------
  */
 int
@@ -54,27 +50,27 @@ main(void)
 
     /* Create a file creation property list */
     fcpl = H5Pcreate(H5P_FILE_CREATE);
-    assert(fcpl>=0);
+    HDassert(fcpl >= 0);
 
-    ret=H5Pset_istore_k(fcpl,ISTORE_IK);
-    assert(ret>=0);
+    ret = H5Pset_istore_k(fcpl,ISTORE_IK);
+    HDassert(ret >= 0);
 
     /* Creating a file with the non-default file creation property list should
      * create a version 1 superblock
      */
 
     /* Create file with custom file creation property list */
-    file= H5Fcreate(TESTFILE, H5F_ACC_TRUNC , fcpl, H5P_DEFAULT);
-    assert(file>=0);
+    file = H5Fcreate(TESTFILE, H5F_ACC_TRUNC , fcpl, H5P_DEFAULT);
+    HDassert(file >= 0);
 
     /* Close FCPL */
-    ret=H5Pclose(fcpl);
-    assert(ret>=0);
+    ret = H5Pclose(fcpl);
+    HDassert(ret >= 0);
 
     /* Close file */
-    ret=H5Fclose(file);
-    assert(ret>=0);
+    ret = H5Fclose(file);
+    HDassert(ret >= 0);
 
-    return 0;
+    return EXIT_SUCCESS;
 }
 
diff --git a/test/gen_nullspace.c b/test/gen_nullspace.c
index e4e75ac5951..26df3f1b2a1 100644
--- a/test/gen_nullspace.c
+++ b/test/gen_nullspace.c
@@ -12,7 +12,7 @@
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 /*
- * Programmer:  Quincey Koziol <koziol@ncsa.uiuc.edu>
+ * Programmer:  Quincey Koziol
  *              Saturday, April 17, 2004
  *
  * Purpose:	Create a dataset with a null dataspace and an attribute
@@ -24,8 +24,7 @@
  *      put into the 'test' directory in the 1.6.x branch of the library.
  */
 
-#include <assert.h>
-#include "testhdf5.h"
+#include "h5test.h"
 
 #define NULLFILE   "tnullspace.h5"
 #define NULLDATASET  "null_dataset"
@@ -43,44 +42,44 @@ main(void)
 
     /* Create the file */
     fid = H5Fcreate(NULLFILE, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
-    assert(fid>0);
+    HDassert(fid > 0);
 
     sid = H5Screate(H5S_NULL);
-    assert(sid>0);
+    HDassert(sid > 0);
 
     /* Create dataset */
     did = H5Dcreate2(fid, NULLDATASET, H5T_NATIVE_UINT, sid, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
-    assert(did>0);
+    HDassert(did > 0);
 
     /* Close the dataset */
     ret = H5Dclose(did);
-    assert(ret>=0);
+    HDassert(ret >= 0);
 
     /* Open the root group */
     gid = H5Gopen2(fid, "/", H5P_DEFAULT);
-    assert(gid > 0);
+    HDassert(gid > 0);
 
     /* Create an attribute for the group */
     attr = H5Acreate2(gid, NULLATTR, H5T_NATIVE_INT, sid, H5P_DEFAULT, H5P_DEFAULT);
-    assert(attr > 0);
+    HDassert(attr > 0);
 
     /* Close attribute */
     ret = H5Aclose(attr);
-    assert(ret>=0);
+    HDassert(ret >= 0);
 
     /* Close the group */
     ret = H5Gclose(gid);
-    assert(ret>=0);
+    HDassert(ret >= 0);
 
     /* Close the dataspace */
     ret = H5Sclose(sid);
-    assert(ret>=0);
+    HDassert(ret >= 0);
 
     /* Close the file */
     ret = H5Fclose(fid);
-    assert(ret>=0);
+    HDassert(ret >= 0);
 
-    return 0;
+    return EXIT_SUCCESS;
 }
 
 
diff --git a/test/links.c b/test/links.c
index 60d3152cb52..cd9f05c365e 100644
--- a/test/links.c
+++ b/test/links.c
@@ -9037,15 +9037,15 @@ external_link_recursive(hid_t fapl, hbool_t new_format)
 static int
 external_link_query(hid_t fapl, hbool_t new_format)
 {
-    hid_t        fid = -1;                       /* File ID */
-    hid_t        gid = -1;                       /* Group IDs */
-    const char  *file_name;                      /* Name of the file the external link points to */
-    const char  *object_name;                    /* Name of the object the external link points to */
-    H5O_info2_t  oi;                            /* Object information */
-    H5L_info2_t  li;                             /* Link information */
-    char         filename1[NAME_BUF_SIZE],
-                 filename2[NAME_BUF_SIZE],       /* Names of files to externally link across */
-                 query_buf[NAME_BUF_SIZE];       /* Buffer to hold query result */
+    hid_t       fid = -1;                       /* File ID */
+    hid_t       gid = -1;                       /* Group IDs */
+    const char *file_name;                      /* Name of the file the external link points to */
+    const char *object_name;                    /* Name of the object the external link points to */
+    H5O_info2_t oi;                             /* Object information */
+    H5L_info2_t li;                             /* Link information */
+    char        filename1[NAME_BUF_SIZE],
+                filename2[NAME_BUF_SIZE],       /* Names of files to externally link across */
+                query_buf[NAME_BUF_SIZE];       /* Buffer to hold query result */
 
     if(new_format)
         TESTING("query aspects of external link (w/new group format)")
@@ -18286,7 +18286,6 @@ main(void)
             nerrors += test_deprec(my_fapl, new_format);
 #endif /* H5_NO_DEPRECATED_SYMBOLS */
 
-
             /* tests for external link */
             /* Test external file cache first, so it sees the default efc setting on the fapl
              */
diff --git a/test/th5o.c b/test/th5o.c
index ab4a8de604b..4bc2096b7f2 100644
--- a/test/th5o.c
+++ b/test/th5o.c
@@ -243,17 +243,17 @@ test_h5o_close(void)
 static void
 test_h5o_open_by_addr(void)
 {
-    hid_t        fid;                        /* HDF5 File ID      */
-    hid_t        grp, dset, dtype, dspace;   /* Object identifiers */
-    H5L_info2_t  li;                         /* Buffer for H5Lget_info */
-    haddr_t      grp_addr;                   /* Addresses for objects */
-    haddr_t      dset_addr;
-    haddr_t      dtype_addr;
-    hsize_t      dims[RANK];
-    H5I_type_t   id_type;                    /* Type of IDs returned from H5Oopen */
-    H5G_info_t   ginfo;                      /* Group info struct */
-    H5T_class_t  type_class;                 /* Class of the datatype */
-    herr_t       ret;                        /* Value returned from API calls */
+    hid_t       fid;                        /* HDF5 File ID      */
+    hid_t       grp, dset, dtype, dspace;   /* Object identifiers */
+    H5L_info2_t li;                         /* Buffer for H5Lget_info2 */
+    haddr_t     grp_addr;                   /* Addresses for objects */
+    haddr_t     dset_addr;
+    haddr_t     dtype_addr;
+    hsize_t     dims[RANK];
+    H5I_type_t  id_type;                    /* Type of IDs returned from H5Oopen */
+    H5G_info_t  ginfo;                      /* Group info struct */
+    H5T_class_t type_class;                 /* Class of the datatype */
+    herr_t      ret;                        /* Value returned from API calls */
 
     /* Create a new HDF5 file */
     fid = H5Fcreate(TEST_FILENAME, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
diff --git a/test/trefer.c b/test/trefer.c
index fd97239277c..68fef09bf28 100644
--- a/test/trefer.c
+++ b/test/trefer.c
@@ -87,12 +87,12 @@ test_reference_params(void)
     hid_t       aapl_id;    /* Attribute access property list   */
     hid_t       dapl_id;    /* Dataset access property list     */
     hsize_t     dims1[] = {SPACE1_DIM1};
-    H5R_ref_t     *wbuf,       /* buffer to write to disk          */
+    H5R_ref_t  *wbuf,       /* buffer to write to disk          */
                *rbuf,       /* buffer read from disk            */
                *tbuf;       /* temp. buffer read from disk      */
     unsigned *obuf;
     H5R_type_t  type;       /* Reference type                   */
-    unsigned int i;          /* Counters                         */
+    unsigned int i;         /* Counters                         */
     const char *write_comment = "Foo!"; /* Comments for group   */
     hid_t       ret_id;     /* Generic hid_t return value       */
     ssize_t     name_size;  /* Size of reference name           */
@@ -320,10 +320,10 @@ test_reference_obj(void)
     hid_t       tid1;       /* Datatype ID                      */
     hsize_t     dims1[] = {SPACE1_DIM1};
     hid_t       dapl_id;    /* Dataset access property list     */
-    H5R_ref_t     *wbuf,       /* buffer to write to disk          */
+    H5R_ref_t     *wbuf,    /* buffer to write to disk          */
                *rbuf;       /* buffer read from disk            */
     unsigned    *ibuf, *obuf;
-    unsigned         i, j;       /* Counters                         */
+    unsigned    i, j;       /* Counters                         */
     H5O_type_t  obj_type;   /* Object type                      */
     herr_t      ret;        /* Generic return value             */
 
diff --git a/test/vds_swmr.h b/test/vds_swmr.h
index edb01bc162b..0a194ffd0e2 100644
--- a/test/vds_swmr.h
+++ b/test/vds_swmr.h
@@ -95,7 +95,5 @@ H5TEST_DLLVAR char VDS_FILE_NAME[NAME_LEN];
 /* Dataset names */
 H5TEST_DLLVAR char SOURCE_DSET_PATH[NAME_LEN];
 H5TEST_DLLVAR char VDS_DSET_NAME[NAME_LEN];
-
-/* Fill values */
 #endif /* VDS_SWMR_H */
 
diff --git a/test/vfd.c b/test/vfd.c
index 038c9670690..bb04e973a2c 100644
--- a/test/vfd.c
+++ b/test/vfd.c
@@ -3286,8 +3286,7 @@ test_splitter(void)
  *
  * Purpose:     Tests the basic features of Virtual File Drivers
  *
- * Return:      Success:        0
- *              Failure:        1
+ * Return:      EXIT_SUCCESS/EXIT_FAILURE
  *
  *-------------------------------------------------------------------------
  */
@@ -3317,11 +3316,11 @@ main(void)
     if(nerrors) {
         HDprintf("***** %d Virtual File Driver TEST%s FAILED! *****\n",
             nerrors, nerrors > 1 ? "S" : "");
-        return 1;
+        return EXIT_FAILURE;
     } /* end if */
 
     HDprintf("All Virtual File Driver tests passed.\n");
 
-    return 0;
+    return EXIT_SUCCESS;
 } /* end main() */
 

From 64ffb37ff6e43966d570bc737b6fa7f96acded56 Mon Sep 17 00:00:00 2001
From: Dana Robinson <derobins@hdfgroup.org>
Date: Fri, 31 Jul 2020 12:23:57 -0700
Subject: [PATCH 53/55] Fixed bad parens in H5trace.c

---
 src/H5trace.c | 86 +++++++++++++++++++++++++--------------------------
 1 file changed, 43 insertions(+), 43 deletions(-)

diff --git a/src/H5trace.c b/src/H5trace.c
index 91019a4a316..db336738921 100644
--- a/src/H5trace.c
+++ b/src/H5trace.c
@@ -311,7 +311,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'a':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -764,7 +764,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                         break;
 
                     default:
-                       HDfprintf (out, "BADTYPE(D%c)", type[1]);
+                       HDfprintf(out, "BADTYPE(D%c)", type[1]);
                         goto error;
                 } /* end switch */
                 break;
@@ -1149,7 +1149,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 's':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -1226,7 +1226,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                         break;
 
                     default:
-                        HDfprintf (out, "BADTYPE(H%c)", type[1]);
+                        HDfprintf(out, "BADTYPE(H%c)", type[1]);
                         goto error;
                 } /* end switch */
                 break;
@@ -1414,7 +1414,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                                 break;
 
                             case H5I_NTYPES:
-                                HDfprintf (out, "%ld (ntypes - error)", (long)obj);
+                                HDfprintf(out, "%ld (ntypes - error)", (long)obj);
                                 break;
 
                             default:
@@ -1518,7 +1518,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                         else {
                             int is = HDva_arg(ap, int);
 
-                            HDfprintf (out, "%d", is);
+                            HDfprintf(out, "%d", is);
                             asize[argno] = is;
                         } /* end else */
                         break;
@@ -1638,7 +1638,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                         break;
 
                     default:
-                        HDfprintf (out, "BADTYPE(I%c)", type[1]);
+                        HDfprintf(out, "BADTYPE(I%c)", type[1]);
                         goto error;
                 } /* end switch */
                 break;
@@ -1664,7 +1664,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'l':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -1808,7 +1808,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                 else {
                     off_t offset = HDva_arg(ap, off_t);
 
-                    HDfprintf (out, "%ld", (long)offset);
+                    HDfprintf(out, "%ld", (long)offset);
                 } /* end else */
                 break;
 
@@ -2517,7 +2517,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                         break;
 
                     default:
-                        HDfprintf (out, "BADTYPE(T%c)", type[1]);
+                        HDfprintf(out, "BADTYPE(T%c)", type[1]);
                         goto error;
                 } /* end switch */
                 break;
@@ -2533,9 +2533,9 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     htri_t tri_var = HDva_arg (ap, htri_t);
 
                     if(tri_var>0)
-                        HDfprintf (out, "TRUE");
+                        HDfprintf(out, "TRUE");
                     else if(!tri_var)
-                        HDfprintf (out, "FALSE");
+                        HDfprintf(out, "FALSE");
                     else
                         HDfprintf(out, "FAIL(%d)", (int)tri_var);
                 } /* end else */
@@ -2592,7 +2592,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                         break;
 
                     default:
-                        HDfprintf (out, "BADTYPE(U%c)", type[1]);
+                        HDfprintf(out, "BADTYPE(U%c)", type[1]);
                         goto error;
                 } /* end switch */
                 break;
@@ -2602,7 +2602,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'a':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -2638,7 +2638,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'A':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -2656,7 +2656,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'b':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -2686,7 +2686,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'B':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -2716,7 +2716,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'C':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -2733,7 +2733,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'c':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -2769,7 +2769,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'd':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -2796,7 +2796,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'e':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -2820,7 +2820,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'f':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -2844,7 +2844,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'g':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -2886,7 +2886,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'h':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -2925,7 +2925,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'i':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -2949,7 +2949,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'j':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -2973,7 +2973,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'k':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -3000,7 +3000,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'l':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -3027,7 +3027,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'L':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -3051,7 +3051,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'm':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -3078,7 +3078,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'n':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -3108,7 +3108,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'o':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -3144,7 +3144,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'r':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -3171,7 +3171,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 's':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -3194,7 +3194,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'S':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -3251,7 +3251,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 't':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -3299,7 +3299,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'u':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -3317,7 +3317,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'v':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -3422,7 +3422,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'w':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -3448,7 +3448,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'x':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -3466,7 +3466,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'y':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -3502,7 +3502,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
                     case 'z':
                         if(ptr) {
                             if(vp)
-                                HDfprintf (out, "0x%p", vp);
+                                HDfprintf(out, "0x%p", vp);
                             else
                                 HDfprintf(out, "NULL");
                         } /* end if */
@@ -3712,7 +3712,7 @@ H5_trace(const double *returning, const char *func, const char *type, ...)
         HDfprintf(out, ";\n");
     else {
         last_call_depth = current_depth++;
-        HDfprintf (out, ")");
+        HDfprintf(out, ")");
     } /* end else */
     HDfflush(out);
 

From b9de162eae800a9459f0f1f07d2b043f73f8a907 Mon Sep 17 00:00:00 2001
From: Dana Robinson <derobins@hdfgroup.org>
Date: Sat, 1 Aug 2020 10:26:22 -0700
Subject: [PATCH 54/55] Minor normalizations with 1.12 branch

---
 bin/release                                   | 216 +++++++++---------
 src/H5AC.c                                    |   2 +-
 src/H5EAdbg.c                                 |   2 +-
 src/H5FD.c                                    |   2 +-
 src/H5I.c                                     | 120 +++++-----
 src/H5Ofsinfo.c                               |   2 +-
 src/H5Spoint.c                                |   2 +-
 src/H5Tdbg.c                                  |  12 +-
 src/H5Z.c                                     | 126 +++++-----
 src/H5public.h                                |  16 +-
 src/H5system.c                                |   8 +-
 test/H5srcdir.h                               |   4 +-
 test/gen_bogus.c                              |   2 +-
 test/gen_specmetaread.c                       |   3 +-
 tools/src/h5format_convert/h5format_convert.c |   6 +-
 tools/src/misc/h5mkgrp.c                      |   8 +-
 16 files changed, 265 insertions(+), 266 deletions(-)

diff --git a/bin/release b/bin/release
index a34191e9cc8..95f58ea21c8 100755
--- a/bin/release
+++ b/bin/release
@@ -39,7 +39,7 @@ USAGE()
 {
 cat << EOF
 Usage: $0 -d <dir> [--docver BRANCHNAME] [-h] [--nocheck] [--private] <methods> ...
-   -d DIR    The name of the directory where the releas(es) should be
+   -d DIR   The name of the directory where the releas(es) should be
                 placed.
    --docver BRANCHNAME  This is added for 1.8 and beyond to get the correct
                         version of documentation files from the hdf5docs
@@ -53,10 +53,10 @@ The other command-line options are the names of the programs to use
 for compressing the resulting tar archive (if none are given then
 "tar" is assumed):
 
-    tar        -- use tar and don't do any compressing.
-    gzip    -- use gzip with "-9" and append ".gz" to the output name.
+    tar         -- use tar and don't do any compressing.
+    gzip        -- use gzip with "-9" and append ".gz" to the output name.
     bzip2       -- use bzip2 with "-9" and append ".bz2" to the output name.
-    zip        -- convert all text files to DOS style and form a zip file for Windows use.
+    zip         -- convert all text files to DOS style and form a zip file for Windows use.
     cmake-tgz   -- create a tar file using the gzip default level with a build-unix.sh
                    command file and all other CMake files needed to build HDF5 source
                    using CMake on unix machines.
@@ -122,8 +122,8 @@ EOF
 tar2zip()
 {
     if [ $# -ne 3 ]; then
-    echo "usage: tar2zip <tarfilename> <zipfilename>"
-    return 1
+        echo "usage: tar2zip <tarfilename> <zipfilename>"
+        return 1
     fi
     ztmpdir=/tmp/ztmpdir$$
     mkdir -p $ztmpdir
@@ -135,10 +135,10 @@ tar2zip()
     (cd $ztmpdir; tar xf -) < $tarfile
     # sanity check
     if [ ! -d $ztmpdir/$version ]; then
-    echo "untar did not create $ztmpdir/$version source dir"
-    # cleanup
-    rm -rf $ztmpdir
-    return 1
+        echo "untar did not create $ztmpdir/$version source dir"
+        # cleanup
+        rm -rf $ztmpdir
+        return 1
     fi
     # step 2: convert text files
     # There maybe a simpler way to do this.
@@ -147,11 +147,11 @@ tar2zip()
     # -q   quiet mode
     # grep redirect output to /dev/null because -q or -s are not portable.
     find $ztmpdir/$version | \
-    while read inf; do \
-        if file $inf | grep "$inf\: .*text" > /dev/null 2>&1 ; then \
-        unix2dos -q -k $inf; \
-        fi\
-    done
+        while read inf; do \
+            if file $inf | grep "$inf\: .*text" > /dev/null 2>&1 ; then \
+                unix2dos -q -k $inf; \
+            fi\
+        done
     # step 3: make zipball
     # -9 maximum compression
     # -y Store symbolic links as such in the zip archive
@@ -202,8 +202,8 @@ tar2zip()
 tar2cmakezip()
 {
     if [ $# -ne 3 ]; then
-    echo "usage: tar2cmakezip <tarfilename> <zipfilename>"
-    return 1
+        echo "usage: tar2cmakezip <tarfilename> <zipfilename>"
+        return 1
     fi
     cmziptmpdir=/tmp/cmziptmpdir$$
     cmziptmpsubdir=$cmziptmpdir/CMake-$HDF5_VERS
@@ -216,10 +216,10 @@ tar2cmakezip()
     (cd $cmziptmpsubdir; tar xf -) < $tarfile
     # sanity check
     if [ ! -d $cmziptmpsubdir/$version ]; then
-    echo "untar did not create $cmziptmpsubdir/$version source dir"
-    # cleanup
-    rm -rf $cmziptmpdir
-    return 1
+        echo "untar did not create $cmziptmpsubdir/$version source dir"
+        # cleanup
+        rm -rf $cmziptmpdir
+        return 1
     fi
 
     # step 2: add batch file for building CMake on window
@@ -245,11 +245,11 @@ tar2cmakezip()
     # -q   quiet mode
     # grep redirect output to /dev/null because -q or -s are not portable.
     find $cmziptmpsubdir/$version | \
-    while read inf; do \
-        if file $inf | grep "$inf\: .*text" > /dev/null 2>&1 ; then \
-        unix2dos -q -k $inf; \
-        fi\
-    done
+        while read inf; do \
+            if file $inf | grep "$inf\: .*text" > /dev/null 2>&1 ; then \
+                unix2dos -q -k $inf; \
+            fi\
+        done
 
     # step 3: make zipball
     # -9 maximum compression
@@ -301,8 +301,8 @@ tar2cmakezip()
 tar2cmaketgz()
 {
     if [ $# -ne 3 ]; then
-    echo "usage: tar2cmaketgz <tarfilename> <tgzfilename>"
-    return 1
+        echo "usage: tar2cmaketgz <tarfilename> <tgzfilename>"
+        return 1
     fi
     cmgztmpdir=/tmp/cmgztmpdir$$
     cmgztmpsubdir=$cmgztmpdir/CMake-$HDF5_VERS
@@ -315,10 +315,10 @@ tar2cmaketgz()
     (cd $cmgztmpsubdir; tar xf -) < $tarfile
     # sanity check
     if [ ! -d $cmgztmpsubdir/$version ]; then
-    echo "untar did not create $cmgztmpsubdir/$version source dir"
-    # cleanup
-    rm -rf $cmgztmpdir
-    return 1
+        echo "untar did not create $cmgztmpsubdir/$version source dir"
+        # cleanup
+        rm -rf $cmgztmpdir
+        return 1
     fi
 
 
@@ -384,8 +384,8 @@ tar2cmaketgz()
 tar2hpccmaketgz()
 {
     if [ $# -ne 3 ]; then
-    echo "usage: tar2hpccmaketgz <tarfilename> <tgzfilename>"
-    return 1
+        echo "usage: tar2hpccmaketgz <tarfilename> <tgzfilename>"
+        return 1
     fi
     cmgztmpdir=/tmp/cmgztmpdir$$
     cmgztmpsubdir=$cmgztmpdir/HPC-CMake-$HDF5_VERS
@@ -398,10 +398,10 @@ tar2hpccmaketgz()
     (cd $cmgztmpsubdir; tar xf -) < $tarfile
     # sanity check
     if [ ! -d $cmgztmpsubdir/$version ]; then
-    echo "untar did not create $cmgztmpsubdir/$version source dir"
-    # cleanup
-    rm -rf $cmgztmpdir
-    return 1
+        echo "untar did not create $cmgztmpsubdir/$version source dir"
+        # cleanup
+        rm -rf $cmgztmpdir
+        return 1
     fi
 
 
@@ -442,7 +442,7 @@ check=yes
 release_date=`date +%F`
 today=`date +%Y%m%d`
 pmode='no'
-tmpdir="../#release_tmp.$$"    # tmp work directory
+tmpdir="../#release_tmp.$$"     # tmp work directory
 DOC_URL=https://git@bitbucket.hdfgroup.org/scm/hdffv/hdf5doc.git
 CPPLUS_RM_NAME=cpplus_RM
 MAINT_MODE_ENABLED=""
@@ -459,11 +459,11 @@ fi
 RESTORE_VERSION()
 {
     if [ X-${VERS_OLD} != X- ]; then
-    echo restoring version information back to $VERS_OLD
-    rm -f config/lt_vers.am
-    cp $tmpdir/lt_vers.am config/lt_vers.am
-    bin/h5vers -s $VERS_OLD
-    VERS_OLD=
+        echo restoring version information back to $VERS_OLD
+        rm -f config/lt_vers.am
+        cp $tmpdir/lt_vers.am config/lt_vers.am
+        bin/h5vers -s $VERS_OLD
+        VERS_OLD=
     fi
 }
 
@@ -473,32 +473,32 @@ while [ -n "$1" ]; do
     arg=$1
     shift
     case "$arg" in
-    -d)
-        DEST=$1
-        shift
-        ;;
-    --nocheck)
-        check=no
-        ;;
-    -h)
-        USAGE
-        exit 0
-        ;;
-    --private)
-        pmode=yes
-        ;;
+        -d)
+            DEST=$1
+            shift
+            ;;
+        --nocheck)
+            check=no
+            ;;
+        -h)
+            USAGE
+            exit 0
+            ;;
+        --private)
+            pmode=yes
+            ;;
         --docver)
             DOCVERSION=$1
             shift
             ;;
-    -*)
-        echo "Unknown switch: $arg" 1>&2
-        USAGE
-        exit 1
-        ;;
-    *)
-        methods="$methods $arg"
-        ;;
+        -*)
+            echo "Unknown switch: $arg" 1>&2
+            USAGE
+            exit 1
+            ;;
+        *)
+            methods="$methods $arg"
+            ;;
     esac
 done
 
@@ -553,7 +553,7 @@ if [ "X$fail" = "Xyes" ]; then
         echo "--nocheck argument to the bin/release command."
         exit 1
     else
-    echo "Continuing anyway..."
+        echo "Continuing anyway..."
     fi
 fi
 
@@ -595,61 +595,61 @@ MD5file=$HDF5_VERS.md5
 cp /dev/null $DEST/$MD5file
 for comp in $methods; do
     case $comp in
-    tar)
-        cp -p $tmpdir/$HDF5_VERS.tar $DEST/$HDF5_VERS.tar
-        (cd $DEST; md5sum $HDF5_VERS.tar >> $MD5file)
-        ;;
-    gzip)
-        test "$verbose" && echo "   Running gzip..." 1>&2
-        gzip -9 <$tmpdir/$HDF5_VERS.tar >$DEST/$HDF5_VERS.tar.gz
-        (cd $DEST; md5sum $HDF5_VERS.tar.gz >> $MD5file)
-        ;;
+        tar)
+            cp -p $tmpdir/$HDF5_VERS.tar $DEST/$HDF5_VERS.tar
+            (cd $DEST; md5sum $HDF5_VERS.tar >> $MD5file)
+            ;;
+        gzip)
+            test "$verbose" && echo "   Running gzip..." 1>&2
+            gzip -9 <$tmpdir/$HDF5_VERS.tar >$DEST/$HDF5_VERS.tar.gz
+            (cd $DEST; md5sum $HDF5_VERS.tar.gz >> $MD5file)
+            ;;
         cmake-tgz)
-        test "$verbose" && echo "   Creating CMake tar.gz file..." 1>&2
-        tar2cmaketgz $HDF5_VERS $tmpdir/$HDF5_VERS.tar $DEST/CMake-$HDF5_VERS.tar.gz 1>&2
-        (cd $DEST; md5sum CMake-$HDF5_VERS.tar.gz >> $MD5file)
+            test "$verbose" && echo "   Creating CMake tar.gz file..." 1>&2
+            tar2cmaketgz $HDF5_VERS $tmpdir/$HDF5_VERS.tar $DEST/CMake-$HDF5_VERS.tar.gz 1>&2
+            (cd $DEST; md5sum CMake-$HDF5_VERS.tar.gz >> $MD5file)
             ;;
         hpc-cmake-tgz)
-        test "$verbose" && echo "   Creating HPC-CMake tar.gz file..." 1>&2
-        tar2hpccmaketgz $HDF5_VERS $tmpdir/$HDF5_VERS.tar $DEST/HPC-CMake-$HDF5_VERS.tar.gz 1>&2
-        (cd $DEST; md5sum HPC-CMake-$HDF5_VERS.tar.gz >> $MD5file)
+            test "$verbose" && echo "   Creating HPC-CMake tar.gz file..." 1>&2
+            tar2hpccmaketgz $HDF5_VERS $tmpdir/$HDF5_VERS.tar $DEST/HPC-CMake-$HDF5_VERS.tar.gz 1>&2
+            (cd $DEST; md5sum HPC-CMake-$HDF5_VERS.tar.gz >> $MD5file)
+            ;;
+        bzip2)
+            test "$verbose" && echo "   Running bzip2..." 1>&2
+            bzip2 -9 <$tmpdir/$HDF5_VERS.tar >$DEST/$HDF5_VERS.tar.bz2
+            (cd $DEST; md5sum $HDF5_VERS.tar.bz2 >> $MD5file)
+            ;;
+        zip)
+            test "$verbose" && echo "   Creating zip ball..." 1>&2
+            tar2zip $HDF5_VERS $tmpdir/$HDF5_VERS.tar $DEST/$HDF5_VERS.zip 1>&2
+            (cd $DEST; md5sum $HDF5_VERS.zip >> $MD5file)
             ;;
-    bzip2)
-        test "$verbose" && echo "   Running bzip2..." 1>&2
-        bzip2 -9 <$tmpdir/$HDF5_VERS.tar >$DEST/$HDF5_VERS.tar.bz2
-        (cd $DEST; md5sum $HDF5_VERS.tar.bz2 >> $MD5file)
-        ;;
-    zip)
-        test "$verbose" && echo "   Creating zip ball..." 1>&2
-        tar2zip $HDF5_VERS $tmpdir/$HDF5_VERS.tar $DEST/$HDF5_VERS.zip 1>&2
-        (cd $DEST; md5sum $HDF5_VERS.zip >> $MD5file)
-        ;;
         cmake-zip)
             test "$verbose" && echo "   Creating CMake-zip ball..." 1>&2
             tar2cmakezip $HDF5_VERS $tmpdir/$HDF5_VERS.tar $DEST/CMake-$HDF5_VERS.zip 1>&2
             (cd $DEST; md5sum CMake-$HDF5_VERS.zip >> $MD5file)
             ;;
-    doc)
+        doc)
             if [ "${DOCVERSION}" = "" ]; then
                 DOCVERSION=master
             fi
-        test "$verbose" && echo "   Creating docs..." 1>&2
-        # Check out docs from git repo
-        (cd $tmpdir; git clone -q $DOC_URL ${DOCVERSION} > /dev/null) || exit 1
+            test "$verbose" && echo "   Creating docs..." 1>&2
+            # Check out docs from git repo
+            (cd $tmpdir; git clone -q $DOC_URL ${DOCVERSION} > /dev/null) || exit 1
             # Create doxygen C++ RM
-        (cd c++/src && doxygen cpp_doc_config > /dev/null ) || exit 1
-        # Replace version of C++ RM with just-created version
-        rm -rf $tmpdir/${DOCVERSION}/html/$CPPLUS_RM_NAME || exit 1
-        mv c++/src/$CPPLUS_RM_NAME $tmpdir/${DOCVERSION}/html/$CPPLUS_RM_NAME || exit 1
+            (cd c++/src && doxygen cpp_doc_config > /dev/null ) || exit 1
+            # Replace version of C++ RM with just-created version
+            rm -rf $tmpdir/${DOCVERSION}/html/$CPPLUS_RM_NAME || exit 1
+            mv c++/src/$CPPLUS_RM_NAME $tmpdir/${DOCVERSION}/html/$CPPLUS_RM_NAME || exit 1
             # Compress the docs and move them to the release area
-        mv $tmpdir/${DOCVERSION} $tmpdir/${HDF5_VERS}_docs || exit 1
-        (cd $tmpdir && tar cf ${HDF5_VERS}_docs.tar ${HDF5_VERS}_docs) || exit 1
-        mv $tmpdir/${HDF5_VERS}_docs.tar $DEST || exit 1
-        ;;
-    *)
-        echo "***Error*** Unknown method $comp"
-        exit 1
-        ;;
+            mv $tmpdir/${DOCVERSION} $tmpdir/${HDF5_VERS}_docs || exit 1
+            (cd $tmpdir && tar cf ${HDF5_VERS}_docs.tar ${HDF5_VERS}_docs) || exit 1
+            mv $tmpdir/${HDF5_VERS}_docs.tar $DEST || exit 1
+            ;;
+        *)
+            echo "***Error*** Unknown method $comp"
+            exit 1
+            ;;
     esac
 done
 
diff --git a/src/H5AC.c b/src/H5AC.c
index f8805b3ed87..6972a3140e9 100644
--- a/src/H5AC.c
+++ b/src/H5AC.c
@@ -138,7 +138,7 @@ static const H5AC_class_t *const H5AC_class_s[] = {
 /*-------------------------------------------------------------------------
  * Function:    H5AC_init
  *
- * Purpose:    Initialize the interface from some other layer.
+ * Purpose:     Initialize the interface from some other layer.
  *
  * Return:      Success:    non-negative
  *              Failure:    negative
diff --git a/src/H5EAdbg.c b/src/H5EAdbg.c
index 20c6a4dec39..e5b68be3715 100644
--- a/src/H5EAdbg.c
+++ b/src/H5EAdbg.c
@@ -295,7 +295,7 @@ CATCH
 
 END_FUNC(PKG)   /* end H5EA__iblock_debug() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5EA__sblock_debug
  *
diff --git a/src/H5FD.c b/src/H5FD.c
index 2e80c7f0b0c..2cd69df9662 100644
--- a/src/H5FD.c
+++ b/src/H5FD.c
@@ -1436,7 +1436,7 @@ H5FDread(H5FD_t *file, H5FD_mem_t type, hid_t dxpl_id, haddr_t addr, size_t size
  *              constant H5P_DEFAULT). The bytes to be written come from the
  *              buffer BUF.
  *
- * Return:      SNon-negative on success/Negative on failure
+ * Return:      Non-negative on success/Negative on failure
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5I.c b/src/H5I.c
index 11209d6f278..a739c4e378e 100644
--- a/src/H5I.c
+++ b/src/H5I.c
@@ -33,9 +33,9 @@
 #include "H5ACprivate.h"        /* Metadata cache                           */
 #include "H5CXprivate.h"        /* API Contexts                             */
 #include "H5Dprivate.h"         /* Datasets                                 */
-#include "H5Eprivate.h"        /* Error handling                           */
-#include "H5Fprivate.h"        /* File access                    */
-#include "H5FLprivate.h"    /* Free Lists                               */
+#include "H5Eprivate.h"         /* Error handling                           */
+#include "H5Fprivate.h"         /* File access                              */
+#include "H5FLprivate.h"        /* Free Lists                               */
 #include "H5Gprivate.h"         /* Groups                                   */
 #include "H5Ipkg.h"             /* IDs                                      */
 #include "H5MMprivate.h"        /* Memory management                        */
@@ -145,7 +145,7 @@ static int H5I__iterate_pub_cb(void *obj, hid_t id, void *udata);
 static int H5I__find_id_cb(void *_item, void *_key, void *_udata);
 static int H5I__id_dump_cb(void *_item, void *_key, void *_udata);
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_term_package
  *
@@ -197,7 +197,7 @@ H5I_term_package(void)
     FUNC_LEAVE_NOAPI(n)
 } /* end H5I_term_package() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iregister_type
  *
@@ -278,7 +278,7 @@ H5Iregister_type(size_t H5_ATTR_DEBUG_API_USED hash_size, unsigned reserved,
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iregister_type() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_register_type
  *
@@ -339,7 +339,7 @@ H5I_register_type(const H5I_class_t *cls)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_register_type() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Itype_exists
  *
@@ -371,7 +371,7 @@ H5Itype_exists(H5I_type_t type)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Itype_exists() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Inmembers
  *
@@ -421,7 +421,7 @@ H5Inmembers(H5I_type_t type, hsize_t *num_members)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Inmembers() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_nmembers
  *
@@ -458,7 +458,7 @@ H5I_nmembers(H5I_type_t type)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_nmembers() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__unwrap
  *
@@ -502,7 +502,7 @@ H5I__unwrap(void *obj_ptr, H5I_type_t type)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__unwrap() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iclear_type
  *
@@ -535,7 +535,7 @@ H5Iclear_type(H5I_type_t type, hbool_t force)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iclear_type() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_clear_type
  *
@@ -577,7 +577,7 @@ H5I_clear_type(H5I_type_t type, hbool_t force, hbool_t app_ref)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_clear_type() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__clear_type_cb
  *
@@ -643,7 +643,7 @@ H5I__clear_type_cb(void *_id, void H5_ATTR_UNUSED *key, void *_udata)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__clear_type_cb() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Idestroy_type
  *
@@ -677,7 +677,7 @@ H5Idestroy_type(H5I_type_t type)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Idestroy_type() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__destroy_type
  *
@@ -729,7 +729,7 @@ H5I__destroy_type(H5I_type_t type)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__destroy_type() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iregister
  *
@@ -757,7 +757,7 @@ H5Iregister(H5I_type_t type, const void *object)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iregister() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_register
  *
@@ -819,7 +819,7 @@ H5I_register(H5I_type_t type, const void *object, hbool_t app_ref)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_register() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_register_using_existing_id
  *
@@ -890,7 +890,7 @@ H5I_register_using_existing_id(H5I_type_t type, void *object, hbool_t app_ref, h
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_register_using_existing_id() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_subst
  *
@@ -927,7 +927,7 @@ H5I_subst(hid_t id, const void *new_object)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_subst() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_object
  *
@@ -957,7 +957,7 @@ H5I_object(hid_t id)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_object() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iobject_verify
  *
@@ -991,7 +991,7 @@ H5Iobject_verify(hid_t id, H5I_type_t id_type)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iobject_verify() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_object_verify
  *
@@ -1026,7 +1026,7 @@ H5I_object_verify(hid_t id, H5I_type_t id_type)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* H5I_object_verify() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_get_type
  *
@@ -1060,7 +1060,7 @@ H5I_get_type(hid_t id)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_get_type() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iget_type
  *
@@ -1087,13 +1087,13 @@ H5Iget_type(hid_t id)
     ret_value = H5I_get_type(id);
 
     if(ret_value <= H5I_BADID || (int)ret_value >= H5I_next_type || NULL == H5I_object(id))
-    HGOTO_DONE(H5I_BADID);
+        HGOTO_DONE(H5I_BADID);
 
 done:
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iget_type() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_is_file_object
  *
@@ -1144,7 +1144,7 @@ H5I_is_file_object(hid_t id)
     FUNC_LEAVE_NOAPI(ret_value);
 } /* H5I_is_file_object() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iremove_verify
  *
@@ -1180,7 +1180,7 @@ H5Iremove_verify(hid_t id, H5I_type_t id_type)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iremove_verify() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__remove_verify
  *
@@ -1213,7 +1213,7 @@ H5I__remove_verify(hid_t id, H5I_type_t id_type)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__remove_verify() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__remove_common
  *
@@ -1258,7 +1258,7 @@ H5I__remove_common(H5I_id_type_t *type_ptr, hid_t id)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__remove_common() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_remove
  *
@@ -1298,7 +1298,7 @@ H5I_remove(hid_t id)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_remove() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Idec_ref
  *
@@ -1334,7 +1334,7 @@ H5Idec_ref(hid_t id)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Idec_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_dec_ref
  *
@@ -1404,7 +1404,7 @@ H5I_dec_ref(hid_t id)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_dec_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_dec_app_ref
  *
@@ -1452,7 +1452,7 @@ H5I_dec_app_ref(hid_t id)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_dec_app_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_dec_app_ref_always_close
  *
@@ -1494,7 +1494,7 @@ H5I_dec_app_ref_always_close(hid_t id)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_dec_app_ref_always_close() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iinc_ref
  *
@@ -1525,7 +1525,7 @@ H5Iinc_ref(hid_t id)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iinc_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_inc_ref
  *
@@ -1563,7 +1563,7 @@ H5I_inc_ref(hid_t id, hbool_t app_ref)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_inc_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iget_ref
  *
@@ -1594,7 +1594,7 @@ H5Iget_ref(hid_t id)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iget_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_get_ref
  *
@@ -1627,7 +1627,7 @@ H5I_get_ref(hid_t id, hbool_t app_ref)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_get_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iinc_type_ref
  *
@@ -1660,7 +1660,7 @@ H5Iinc_type_ref(H5I_type_t type)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iinc_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__inc_type_ref
  *
@@ -1694,14 +1694,14 @@ H5I__inc_type_ref(H5I_type_t type)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__inc_type_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Idec_type_ref
  *
  * Purpose:     Decrements the reference count on an entire type of IDs.
  *              If the type reference count becomes zero then the type is
  *              destroyed along with all atoms in that type regardless of
- *              their reference counts.     Destroying IDs involves calling
+ *              their reference counts. Destroying IDs involves calling
  *              the free-func for each ID's object and then adding the ID
  *              struct to the ID free list.  Public interface to
  *              H5I_dec_type_ref.
@@ -1736,14 +1736,14 @@ H5Idec_type_ref(H5I_type_t type)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Idec_type_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_dec_type_ref
  *
  * Purpose:     Decrements the reference count on an entire type of IDs.
  *              If the type reference count becomes zero then the type is
  *              destroyed along with all atoms in that type regardless of
- *              their reference counts.     Destroying IDs involves calling
+ *              their reference counts. Destroying IDs involves calling
  *              the free-func for each ID's object and then adding the ID
  *              struct to the ID free list.
  *              Returns the number of references to the type on success; a
@@ -1789,7 +1789,7 @@ H5I_dec_type_ref(H5I_type_t type)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_dec_type_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iget_type_ref
  *
@@ -1822,7 +1822,7 @@ H5Iget_type_ref(H5I_type_t type)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iget_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__get_type_ref
  *
@@ -1857,7 +1857,7 @@ H5I__get_type_ref(H5I_type_t type)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__get_type_ref() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iis_valid
  *
@@ -1887,7 +1887,7 @@ H5Iis_valid(hid_t id)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iis_valid() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__search_cb
  *
@@ -1922,7 +1922,7 @@ H5I__search_cb(void *obj, hid_t id, void *_udata)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__search_cb() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Isearch
  *
@@ -1973,7 +1973,7 @@ H5Isearch(H5I_type_t type, H5I_search_func_t func, void *key)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Isearch() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__iterate_pub_cb
  *
@@ -2013,7 +2013,7 @@ H5I__iterate_pub_cb(void H5_ATTR_UNUSED *obj, hid_t id, void *_udata)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__iterate_pub_cb() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iiterate
  *
@@ -2060,7 +2060,7 @@ H5Iiterate(H5I_type_t type, H5I_iterate_func_t op, void *op_data)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iiterate() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__iterate_cb
  *
@@ -2108,7 +2108,7 @@ H5I__iterate_cb(void *_item, void H5_ATTR_UNUSED *_key, void *_udata)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__iterate_cb() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_iterate
  *
@@ -2167,7 +2167,7 @@ H5I_iterate(H5I_type_t type, H5I_search_func_t func, void *udata, hbool_t app_re
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_iterate() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__find_id
  *
@@ -2212,7 +2212,7 @@ H5I__find_id(hid_t id)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__find_id() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iget_name
  *
@@ -2263,7 +2263,7 @@ H5Iget_name(hid_t id, char *name/*out*/, size_t size)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iget_name() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5Iget_file_id
  *
@@ -2307,7 +2307,7 @@ H5Iget_file_id(hid_t obj_id)
     FUNC_LEAVE_API(ret_value)
 } /* end H5Iget_file_id() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__find_id_cb
  *
@@ -2345,7 +2345,7 @@ H5I__find_id_cb(void *_item, void H5_ATTR_UNUSED *_key, void *_udata)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I__find_id_cb() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_find_id
  *
@@ -2394,7 +2394,7 @@ H5I_find_id(const void *object, H5I_type_t type, hid_t *id)
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5I_find_id() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I__id_dump_cb
  *
@@ -2482,7 +2482,7 @@ H5I__id_dump_cb(void *_item, void H5_ATTR_UNUSED *_key, void *_udata)
     FUNC_LEAVE_NOAPI(H5_ITER_CONT)
 } /* end H5I__id_dump_cb() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5I_dump_ids_for_type
  *
diff --git a/src/H5Ofsinfo.c b/src/H5Ofsinfo.c
index 78e8e19a880..e2fa4e558b4 100644
--- a/src/H5Ofsinfo.c
+++ b/src/H5Ofsinfo.c
@@ -110,7 +110,7 @@ H5O_fsinfo_decode(H5F_t *f, H5O_t H5_ATTR_UNUSED *open_oh,
 
     /* Allocate space for message */
     if(NULL == (fsinfo = H5FL_CALLOC(H5O_fsinfo_t)))
-    HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, NULL, "memory allocation failed")
+        HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, NULL, "memory allocation failed")
 
     for(ptype = H5F_MEM_PAGE_SUPER; ptype < H5F_MEM_PAGE_NTYPES; ptype++)
         fsinfo->fs_addr[ptype - 1] = HADDR_UNDEF;
diff --git a/src/H5Spoint.c b/src/H5Spoint.c
index be9015fac9f..f53033b607a 100644
--- a/src/H5Spoint.c
+++ b/src/H5Spoint.c
@@ -12,7 +12,7 @@
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 /*
- * Programmer:  Quincey Koziol <koziol@ncsa.uiuc.edu>
+ * Programmer:  Quincey Koziol
  *              Tuesday, June 16, 1998
  *
  * Purpose:     Point selection dataspace I/O functions.
diff --git a/src/H5Tdbg.c b/src/H5Tdbg.c
index 7af736afe73..61881385afb 100644
--- a/src/H5Tdbg.c
+++ b/src/H5Tdbg.c
@@ -13,11 +13,11 @@
 
 /*-------------------------------------------------------------------------
  *
- * Created:        H5Tdbg.c
- *            Jul 19 2007
- *            Quincey Koziol <koziol@hdfgroup.org>
+ * Created:         H5Tdbg.c
+ *                  Jul 19 2007
+ *                  Quincey Koziol
  *
- * Purpose:        Dump debugging information about a datatype
+ * Purpose:         Dump debugging information about a datatype
  *
  *-------------------------------------------------------------------------
  */
@@ -72,7 +72,7 @@
 /*******************/
 
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5T__print_stats
  *
@@ -137,7 +137,7 @@ H5T__print_stats(H5T_path_t H5_ATTR_UNUSED * path, int H5_ATTR_UNUSED * nprint/*
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5T__print_stats() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    H5T_debug
  *
diff --git a/src/H5Z.c b/src/H5Z.c
index af5b888438d..3bd4bcbebad 100644
--- a/src/H5Z.c
+++ b/src/H5Z.c
@@ -35,10 +35,10 @@
 #ifdef H5Z_DEBUG
 typedef struct H5Z_stats_t {
     struct {
-	hsize_t	total;		/* total number of bytes processed */
-	hsize_t	errors;		/* bytes of total attributable to errors */
+        hsize_t     total;      /* total number of bytes processed */
+        hsize_t     errors;     /* bytes of total attributable to errors */
         H5_timevals_t times;    /* execution time including errors */
-    } stats[2];			/* 0 = output, 1 = input */
+    } stats[2];                 /* 0 = output, 1 = input */
 } H5Z_stats_t;
 #endif /* H5Z_DEBUG */
 
@@ -132,9 +132,9 @@ H5Z_term_package(void)
 
     if(H5_PKG_INIT_VAR) {
 #ifdef H5Z_DEBUG
-        char	comment[16], bandwidth[32];
-        int	dir, nprint = 0;
-        size_t	i;
+        char    comment[16], bandwidth[32];
+        int     dir, nprint = 0;
+        size_t  i;
 
         if(H5DEBUG(Z)) {
             for(i = 0; i < H5Z_table_used_g; i++) {
@@ -142,33 +142,34 @@ H5Z_term_package(void)
                     if(0 == H5Z_stat_table_g[i].stats[dir].total)
                         continue;
 
-		    if(0 == nprint++) {
-			/* Print column headers */
-			HDfprintf(H5DEBUG(Z), "H5Z: filter statistics "
-				   "accumulated over life of library:\n");
-			HDfprintf(H5DEBUG(Z),
-				   "   %-16s %10s %10s %8s %8s %8s %10s\n",
-				   "Filter", "Total", "Errors", "User",
-				   "System", "Elapsed", "Bandwidth");
-			HDfprintf(H5DEBUG(Z),
-				   "   %-16s %10s %10s %8s %8s %8s %10s\n",
-				   "------", "-----", "------", "----",
-				   "------", "-------", "---------");
-		    } /* end if */
-
-		    /* Truncate the comment to fit in the field */
-		    HDstrncpy(comment, H5Z_table_g[i].name, sizeof comment);
-		    comment[sizeof(comment) - 1] = '\0';
-
-		    /*
-		     * Format bandwidth to have four significant digits and
-		     * units of `B/s', `kB/s', `MB/s', `GB/s', or `TB/s' or
-		     * the word `Inf' if the elapsed time is zero.
-		     */
-                    H5_bandwidth(bandwidth, (double)(H5Z_stat_table_g[i].stats[dir].total),
+                    if(0 == nprint++) {
+                        /* Print column headers */
+                        HDfprintf(H5DEBUG(Z), "H5Z: filter statistics "
+                                "accumulated over life of library:\n");
+                        HDfprintf(H5DEBUG(Z),
+                                "   %-16s %10s %10s %8s %8s %8s %10s\n",
+                                "Filter", "Total", "Errors", "User",
+                                "System", "Elapsed", "Bandwidth");
+                        HDfprintf(H5DEBUG(Z),
+                                "   %-16s %10s %10s %8s %8s %8s %10s\n",
+                                "------", "-----", "------", "----",
+                                "------", "-------", "---------");
+                    } /* end if */
+
+                    /* Truncate the comment to fit in the field */
+                    HDstrncpy(comment, H5Z_table_g[i].name, sizeof comment);
+                    comment[sizeof(comment) - 1] = '\0';
+
+                    /*
+                    * Format bandwidth to have four significant digits and
+                    * units of `B/s', `kB/s', `MB/s', `GB/s', or `TB/s' or
+                    * the word `Inf' if the elapsed time is zero.
+                    */
+                    H5_bandwidth(bandwidth,
+                            (double)(H5Z_stat_table_g[i].stats[dir].total),
                             H5Z_stat_table_g[i].stats[dir].times.elapsed);
 
-		    /* Print the statistics */
+                    /* Print the statistics */
                     HDfprintf(H5DEBUG(Z), "   %s%-15s %10Hd %10Hd %8T %8T %8T %10s\n",
                             (dir ? "<" : ">"), comment,
                             H5Z_stat_table_g[i].stats[dir].total,
@@ -177,12 +178,12 @@ H5Z_term_package(void)
                             H5Z_stat_table_g[i].stats[dir].times.system,
                             H5Z_stat_table_g[i].stats[dir].times.elapsed,
                             bandwidth);
-		} /* end for */
-	    } /* end for */
-	} /* end if */
+                } /* end for */
+            } /* end for */
+        } /* end if */
 #endif /* H5Z_DEBUG */
 
-	/* Free the table of filters */
+        /* Free the table of filters */
         if(H5Z_table_g) {
             H5Z_table_g = (H5Z_class2_t *)H5MM_xfree(H5Z_table_g);
 
@@ -1256,7 +1257,7 @@ H5Z_pipeline(const H5O_pline_t *pline, unsigned flags,
     int             fclass_idx;     /* Index of filter class in global table */
     H5Z_class2_t   *fclass = NULL;  /* Filter class pointer */
 #ifdef H5Z_DEBUG
-    H5Z_stats_t	   *fstats = NULL;   /* Filter stats pointer */
+    H5Z_stats_t   *fstats = NULL;   /* Filter stats pointer */
     H5_timer_t      timer;           /* Timer for filter operations */
     H5_timevals_t   times;           /* Elapsed time for each operation */
 #endif
@@ -1278,12 +1279,12 @@ H5Z_pipeline(const H5O_pline_t *pline, unsigned flags,
     H5_timer_init(&timer);
 #endif
     if(pline && (flags & H5Z_FLAG_REVERSE)) { /* Read */
-	for(i = pline->nused; i > 0; --i) {
-	    idx = i - 1;
-	    if(*filter_mask & ((unsigned)1 << idx)) {
-		failed |= (unsigned)1 << idx;
-		continue;       /* filter excluded */
-	    } /* end if */
+        for(i = pline->nused; i > 0; --i) {
+            idx = i - 1;
+            if(*filter_mask & ((unsigned)1 << idx)) {
+                failed |= (unsigned)1 << idx;
+                continue;   /* filter excluded */
+            }
 
             /* If the filter isn't registered and the application doesn't
              * indicate no plugin through HDF5_PRELOAD_PLUG (using the symbol "::"),
@@ -1304,7 +1305,7 @@ H5Z_pipeline(const H5O_pline_t *pline, unsigned flags,
                     /* Search in the table of registered filters again to find the dynamic filter just loaded and registered */
                     if((fclass_idx = H5Z_find_idx(pline->filter[idx].id)) < 0)
                         issue_error = TRUE;
-                } /* end if */
+                }
                 else
                     issue_error = TRUE;
 
@@ -1353,24 +1354,25 @@ H5Z_pipeline(const H5O_pline_t *pline, unsigned flags,
                 *nbytes = *buf_size;
                 failed |= (unsigned)1 << idx;
                 H5E_clear_stack(NULL);
-            } /* end if */
+            }
             else
                 *nbytes = new_nbytes;
-	} /* end for */
-    } else if (pline) { /* Write */
-	for(idx = 0; idx < pline->nused; idx++) {
-	    if(*filter_mask & ((unsigned)1 << idx)) {
-		failed |= (unsigned)1 << idx;
-		continue;       /* filter excluded */
-	    } /* end if */
-	    if((fclass_idx = H5Z_find_idx(pline->filter[idx].id)) < 0) {
+        }
+    }
+    else if(pline) { /* Write */
+        for(idx = 0; idx < pline->nused; idx++) {
+            if(*filter_mask & ((unsigned)1 << idx)) {
+                failed |= (unsigned)1 << idx;
+                continue;       /* filter excluded */
+            }
+            if((fclass_idx = H5Z_find_idx(pline->filter[idx].id)) < 0) {
                 /* Check if filter is optional -- If it isn't, then error */
-		if((pline->filter[idx].flags & H5Z_FLAG_OPTIONAL) == 0)
-		    HGOTO_ERROR(H5E_PLINE, H5E_WRITEERROR, FAIL, "required filter is not registered")
-		failed |= (unsigned)1 << idx;
+                if((pline->filter[idx].flags & H5Z_FLAG_OPTIONAL) == 0)
+                    HGOTO_ERROR(H5E_PLINE, H5E_WRITEERROR, FAIL, "required filter is not registered")
+                failed |= (unsigned)1 << idx;
                 H5E_clear_stack(NULL);
-		continue;       /* filter excluded */
-	    } /* end if */
+                continue;       /* filter excluded */
+            } /* end if */
 
             fclass = &H5Z_table_g[fclass_idx];
 
@@ -1390,25 +1392,25 @@ H5Z_pipeline(const H5O_pline_t *pline, unsigned flags,
             fstats->stats[0].times.system  += times.system;
             fstats->stats[0].times.user    += times.user;
 
-	    fstats->stats[0].total += MAX(*nbytes, new_nbytes);
+            fstats->stats[0].total += MAX(*nbytes, new_nbytes);
             if(0 == new_nbytes)
                 fstats->stats[0].errors += *nbytes;
 #endif
 
             if(0 == new_nbytes) {
                 if(0 == (pline->filter[idx].flags & H5Z_FLAG_OPTIONAL)) {
-                    if((cb_struct.func && (H5Z_CB_FAIL==cb_struct.func(pline->filter[idx].id, *buf, *nbytes, cb_struct.op_data)))
+                    if((cb_struct.func && (H5Z_CB_FAIL == cb_struct.func(pline->filter[idx].id, *buf, *nbytes, cb_struct.op_data)))
                             || !cb_struct.func)
                         HGOTO_ERROR(H5E_PLINE, H5E_WRITEERROR, FAIL, "filter returned failure")
 
                     *nbytes = *buf_size;
-                } /* end if */
+                }
                 failed |= (unsigned)1 << idx;
                 H5E_clear_stack(NULL);
-            } /* end if */
+            }
             else
                 *nbytes = new_nbytes;
-	} /* end for */
+        } /* end for */
     }
 
     *filter_mask = failed;
diff --git a/src/H5public.h b/src/H5public.h
index 93cb2ea071e..d3edd23e52e 100644
--- a/src/H5public.h
+++ b/src/H5public.h
@@ -38,7 +38,7 @@
 #include <sys/types.h>
 #endif
 #ifdef H5_STDC_HEADERS
-#   include <limits.h>        /*for H5T_NATIVE_CHAR defn in H5Tpublic.h    */
+#   include <limits.h>      /*for H5T_NATIVE_CHAR defn in H5Tpublic.h    */
 #   include <stdarg.h>      /*for variadic functions in H5VLpublic.h     */
 #endif
 #ifndef __cplusplus
@@ -183,7 +183,7 @@ typedef long long ssize_t;
  */
 #if H5_SIZEOF_LONG_LONG >= 8
 H5_GCC_DIAG_OFF(long-long)
-typedef unsigned long long     hsize_t;
+typedef unsigned long long  hsize_t;
 typedef signed long long    hssize_t;
 H5_GCC_DIAG_ON(long-long)
 #       define H5_SIZEOF_HSIZE_T H5_SIZEOF_LONG_LONG
@@ -229,7 +229,7 @@ H5_GCC_DIAG_ON(long-long)
 #else
 #   error "nothing appropriate for H5_PRINTF_HADDR_FMT"
 #endif
-#define HADDR_MAX        (HADDR_UNDEF-1)
+#define HADDR_MAX       (HADDR_UNDEF-1)
 
 /* uint32_t type is used for creation order field for messages.  It may be
  * defined in Posix.1g, otherwise it is defined here.
@@ -297,7 +297,7 @@ typedef enum {
     H5_ITER_INC,                /* Increasing order */
     H5_ITER_DEC,                /* Decreasing order */
     H5_ITER_NATIVE,             /* No particular order, whatever is fastest */
-    H5_ITER_N                /* Number of iteration orders */
+    H5_ITER_N                   /* Number of iteration orders */
 } H5_iter_order_t;
 
 /* Iteration callback values */
@@ -314,10 +314,10 @@ typedef enum {
  * links in groups/attributes on objects.
  */
 typedef enum H5_index_t {
-    H5_INDEX_UNKNOWN = -1,    /* Unknown index type            */
-    H5_INDEX_NAME,        /* Index on names             */
-    H5_INDEX_CRT_ORDER,        /* Index on creation order         */
-    H5_INDEX_N            /* Number of indices defined         */
+    H5_INDEX_UNKNOWN = -1,      /* Unknown index type                   */
+    H5_INDEX_NAME,              /* Index on names                       */
+    H5_INDEX_CRT_ORDER,         /* Index on creation order              */
+    H5_INDEX_N                  /* Number of indices defined            */
 } H5_index_t;
 
 /*
diff --git a/src/H5system.c b/src/H5system.c
index b3db39c069a..24935fd36c9 100644
--- a/src/H5system.c
+++ b/src/H5system.c
@@ -13,11 +13,11 @@
 
 /*-------------------------------------------------------------------------
  *
- * Created:		H5system.c
- *			Aug 21 2006
- *			Quincey Koziol <koziol@hdfgroup.org>
+ * Created:     H5system.c
+ *              Aug 21 2006
+ *              Quincey Koziol
  *
- * Purpose:             System call wrapper implementations.
+ * Purpose:     System call wrapper implementations.
  *
  *-------------------------------------------------------------------------
  */
diff --git a/test/H5srcdir.h b/test/H5srcdir.h
index b02d432cac7..019cfda78d4 100644
--- a/test/H5srcdir.h
+++ b/test/H5srcdir.h
@@ -12,7 +12,7 @@
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 /*
- * Programmer:  Quincey Koziol <koziol@hdfgroup.org>
+ * Programmer:  Quincey Koziol
  *              Wednesday, March 17, 2010
  *
  * Purpose:     srcdir querying support.
@@ -20,8 +20,6 @@
 #ifndef _H5SRCDIR_H
 #define _H5SRCDIR_H
 
-/* Include the header file with the correct relative path for the srcdir string */
-
 #ifdef __cplusplus
 extern "C" {
 #endif
diff --git a/test/gen_bogus.c b/test/gen_bogus.c
index 1ab18a494d8..ab2620f473b 100644
--- a/test/gen_bogus.c
+++ b/test/gen_bogus.c
@@ -12,7 +12,7 @@
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 /*
- * Programmer:  Quincey Koziol <koziol@hdfgroup.org>
+ * Programmer:  Quincey Koziol
  *              Apr 17, 2007
  *
  * Purpose:     This program is run to generate an HDF5 data file with several
diff --git a/test/gen_specmetaread.c b/test/gen_specmetaread.c
index fd484d100b0..f2625a71912 100644
--- a/test/gen_specmetaread.c
+++ b/test/gen_specmetaread.c
@@ -23,9 +23,8 @@
  *      the library on the trunk as of when this file is checked in.
  */
 
-#include <assert.h>
 
-#include "testhdf5.h"
+#include "h5test.h"
 
 #define FILENAME        "specmetaread.h5"
 #define DIM             10
diff --git a/tools/src/h5format_convert/h5format_convert.c b/tools/src/h5format_convert/h5format_convert.c
index d63f36fd0ae..e60097bc7f0 100644
--- a/tools/src/h5format_convert/h5format_convert.c
+++ b/tools/src/h5format_convert/h5format_convert.c
@@ -64,7 +64,7 @@ static struct long_options l_opts[] = {
         { NULL, 0, '\0' }
 };
 
-
+
 /*-------------------------------------------------------------------------
  * Function: usage
  *
@@ -185,7 +185,7 @@ parse_command_line(int argc, const char **argv)
     return(-1); ;
 } /* parse_command_line() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function: leave
  *
@@ -387,7 +387,7 @@ convert_dsets_cb(const char *path, const H5O_info2_t *oi, const char *already_vi
     return -1;
 } /* end convert_dsets_cb() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function: main
  *
diff --git a/tools/src/misc/h5mkgrp.c b/tools/src/misc/h5mkgrp.c
index 4d2d2b85ff1..ad3b7b8baf6 100644
--- a/tools/src/misc/h5mkgrp.c
+++ b/tools/src/misc/h5mkgrp.c
@@ -49,7 +49,7 @@ typedef struct mkgrp_opt_t {
 
 mkgrp_opt_t params_g;           /* Command line parameter settings */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    leave
  *
@@ -81,7 +81,7 @@ leave(int ret)
     HDexit(ret);
 } /* end leave() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function: usage
  *
@@ -113,7 +113,7 @@ usage(const char *prog)
     PRINTVALSTREAM(rawoutstream, "\n");
 } /* end usage() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function:    parse_command_line
  *
@@ -248,7 +248,7 @@ parse_command_line(int argc, const char *argv[], mkgrp_opt_t *options)
     return 0;
 } /* parse_command_line() */
 
-
+
 /*-------------------------------------------------------------------------
  * Function: main
  *

From be02566f49f953bc80c5b5018871138e201ea633 Mon Sep 17 00:00:00 2001
From: Dana Robinson <derobins@hdfgroup.org>
Date: Tue, 4 Aug 2020 09:14:36 -0700
Subject: [PATCH 55/55] Fixes indenting in tools test scripts

---
 tools/test/h5copy/testh5copy.sh.in      |  10 +-
 tools/test/h5diff/h5diff_plugin.sh.in   | 117 ++++----
 tools/test/h5diff/testh5diff.sh.in      |  43 +--
 tools/test/h5dump/h5dump_plugin.sh.in   |  28 +-
 tools/test/h5dump/testh5dump.sh.in      | 381 ++++++++++++------------
 tools/test/h5dump/testh5dumppbits.sh.in | 158 +++++-----
 tools/test/h5dump/testh5dumpvds.sh.in   | 172 ++++++-----
 tools/test/h5dump/testh5dumpxml.sh.in   |  31 +-
 tools/test/h5ls/h5ls_plugin.sh.in       |   6 +-
 tools/test/misc/testh5mkgrp.sh.in       |  91 +++---
 10 files changed, 529 insertions(+), 508 deletions(-)

diff --git a/tools/test/h5copy/testh5copy.sh.in b/tools/test/h5copy/testh5copy.sh.in
index 2440ca42814..84e3b65caf4 100644
--- a/tools/test/h5copy/testh5copy.sh.in
+++ b/tools/test/h5copy/testh5copy.sh.in
@@ -200,6 +200,7 @@ TOOLTEST()
         fi
         runh5diff=no
     fi
+
     if [ "$3" = -o ]; then
         outputfile=$4
     else
@@ -219,6 +220,7 @@ TOOLTEST()
         $RUNSERIAL $H5COPY_BIN $@
     ) > $actualout 2> $actualerr
     RET=$?
+
     if [ $RET != 0 ]; then
         echo "*FAILED*"
         echo "failed result is:"
@@ -268,6 +270,7 @@ TOOLTEST_PREFILL()
         $RUNSERIAL $H5COPY_BIN  -i $inputfile -o $outputfile -v -s $grp_name -d $grp_name2
     ) > $actualout 2> $actualerr
     RET=$?
+
     if [ $RET != 0 ]; then
         echo "*FAILED*"
         echo "failed result is:"
@@ -282,6 +285,7 @@ TOOLTEST_PREFILL()
             $RUNSERIAL $H5COPY_BIN  -i $inputfile -o $outputfile -v -s $obj_name -d $obj_name2
         ) > $actualout 2> $actualerr
         RET=$?
+
         if [ $RET != 0 ]; then
             echo "*FAILED*"
             echo "failed result is:"
@@ -313,6 +317,7 @@ TOOLTEST_SAME()
     else
         runh5diff=no
     fi
+
     if [ "$3" = -o ]; then
         outputfile=$4
     else
@@ -330,6 +335,7 @@ TOOLTEST_SAME()
         $RUNSERIAL $H5COPY_BIN  -i $inputfile -o $outputfile -v -s $grp_name -d $grp_name
     ) > $actualout 2> $actualerr
     RET=$?
+
     if [ $RET != 0 ]; then
         echo "*FAILED*"
         echo "failed result is:"
@@ -344,6 +350,7 @@ TOOLTEST_SAME()
             $RUNSERIAL $H5COPY_BIN  -i $outputfile -o $outputfile -v -s $grp_name -d $grp_name2
         ) > $actualout 2> $actualerr
         RET=$?
+
         if [ $RET != 0 ]; then
             echo "*FAILED*"
             echo "failed result is:"
@@ -406,6 +413,7 @@ TOOLTEST_FAIL()
     if [ "$1" = -i ]; then
         inputfile=$2
     fi
+
     if [ "$3" = -o ]; then
         outputfile=$4
     fi
@@ -417,8 +425,8 @@ TOOLTEST_FAIL()
         #echo "#############################"
         $RUNSERIAL $H5COPY_BIN $@
     ) > $actualout 2> $actualerr
-
     RET=$?
+
     # save actualout and actualerr in case they are needed later.
     cp $actualout $actualout_sav
     STDOUT_FILTER $actualout
diff --git a/tools/test/h5diff/h5diff_plugin.sh.in b/tools/test/h5diff/h5diff_plugin.sh.in
index 341cba57c92..ffc43dad652 100644
--- a/tools/test/h5diff/h5diff_plugin.sh.in
+++ b/tools/test/h5diff/h5diff_plugin.sh.in
@@ -135,24 +135,24 @@ CLEAN_TESTFILES_AND_TESTDIR()
 #   -h   print help page
 while [ $# -gt 0 ]; do
     case "$1" in
-    -p)    # reset the tool name and bin to run ph5diff tests
-    TESTNAME=ph5diff
-    H5DIFF=../../src/h5diff/ph5diff  # The tool name
-    H5DIFF_BIN=`pwd`/$H5DIFF    # The path of the tool binary
-    pmode=yes
-    shift
-    ;;
+    -p) # reset the tool name and bin to run ph5diff tests
+        TESTNAME=ph5diff
+        H5DIFF=../../src/h5diff/ph5diff  # The tool name
+        H5DIFF_BIN=`pwd`/$H5DIFF    # The path of the tool binary
+        pmode=yes
+        shift
+        ;;
     -h) # print help page
-    echo "$0 [-p] [-h]"
-    echo "    -p   run ph5diff tests"
-    echo "    -h   print help page"
-    shift
-    exit 0
-    ;;
+        echo "$0 [-p] [-h]"
+        echo "    -p   run ph5diff tests"
+        echo "    -h   print help page"
+        shift
+        exit 0
+        ;;
     *)  # unknown option
         echo "$0: Unknown option ($1)"
-    exit 1
-    ;;
+        exit 1
+        ;;
     esac
 done
 
@@ -218,19 +218,21 @@ TOOLTEST() {
     # Run test.
     TESTING $H5DIFF $@
     (
-    #echo "#############################"
-    #echo "Expected output for '$H5DIFF $@'"
-    #echo "#############################"
-    cd $TESTDIR
-    eval $ENVCMD $RUNCMD $H5DIFF_BIN "$@"
+        #echo "#############################"
+        #echo "Expected output for '$H5DIFF $@'"
+        #echo "#############################"
+        cd $TESTDIR
+        eval $ENVCMD $RUNCMD $H5DIFF_BIN "$@"
     ) >$actual 2>$actual_err
     EXIT_CODE=$?
+
     # save actual and actual_err in case they are needed later.
     cp $actual $actual_sav
     STDOUT_FILTER $actual
     cp $actual_err $actual_err_sav
     STDERR_FILTER $actual_err
     cat $actual_err >> $actual
+
     # don't add exit code check in pmode, as it causes failure. (exit code
     # is from mpirun not tool)
     # if any problem occurs relate to an exit code, it will be caught in
@@ -260,27 +262,29 @@ TOOLTEST() {
         actual_sorted=actual_sorted
         sort $expect -o $expect_sorted
         sort $actual -o $actual_sorted
+
         # remove "EXIT CODE:" line from expect file. test for exit code
         # is done by serial mode.
         grep -v "EXIT CODE:" $expect_sorted > $expect_sorted.noexit
         mv $expect_sorted.noexit $expect_sorted
-    if $CMP $expect_sorted $actual_sorted; then
-        echo " PASSED"
-    else
-        echo "*FAILED*"
-        nerrors="`expr $nerrors + 1`"
-        if test yes = "$verbose"; then
-        echo "====Expected result ($expect_sorted) differs from actual result ($actual_sorted)"
-        $DIFF $expect_sorted $actual_sorted |sed 's/^/    /'
-        echo "====The actual output ($actual_sav)"
-        sed 's/^/    /' < $actual_sav
-        echo "====The actual stderr ($actual_err_sav)"
-        sed 's/^/    /' < $actual_err_sav
-        echo "====End of actual stderr ($actual_err_sav)"
-        echo ""
+
+        if $CMP $expect_sorted $actual_sorted; then
+            echo " PASSED"
+        else
+            echo "*FAILED*"
+            nerrors="`expr $nerrors + 1`"
+            if test yes = "$verbose"; then
+                echo "====Expected result ($expect_sorted) differs from actual result ($actual_sorted)"
+                $DIFF $expect_sorted $actual_sorted |sed 's/^/    /'
+                echo "====The actual output ($actual_sav)"
+                sed 's/^/    /' < $actual_sav
+                echo "====The actual stderr ($actual_err_sav)"
+                sed 's/^/    /' < $actual_err_sav
+                echo "====End of actual stderr ($actual_err_sav)"
+                echo ""
+            fi
         fi
     fi
-    fi
 
     # Clean up output file
     if test -z "$HDF5_NOCLEANUP"; then
@@ -306,18 +310,20 @@ TOOLTEST_ERR() {
     # Run test.
     TESTING $H5DIFF $@
     (
-    #echo "#############################"
-    #echo "Expected output for '$H5DIFF $@'"
-    #echo "#############################"
-    cd $TESTDIR
-    eval $ENVCMD $RUNCMD $H5DIFF_BIN "$@"
+        #echo "#############################"
+        #echo "Expected output for '$H5DIFF $@'"
+        #echo "#############################"
+        cd $TESTDIR
+        eval $ENVCMD $RUNCMD $H5DIFF_BIN "$@"
     ) >$actual 2>$actual_err
     EXIT_CODE=$?
+
     # save actual and actual_err in case they are needed later.
     cp $actual $actual_sav
     STDOUT_FILTER $actual
     cp $actual_err $actual_err_sav
     STDERR_FILTER $actual_err
+
     # don't add exit code check in pmode, as it causes failure. (exit code
     # is from mpirun not tool)
     # if any problem occurs relate to an exit code, it will be caught in
@@ -348,23 +354,24 @@ TOOLTEST_ERR() {
         sort $expect_err -o $expect_sorted
         sort $actual_err -o $actual_sorted
         mv $expect_sorted.noexit $expect_sorted
-    if $CMP $expect_sorted $actual_sorted; then
-        echo " PASSED"
-    else
-        echo "*FAILED*"
-        nerrors="`expr $nerrors + 1`"
-        if test yes = "$verbose"; then
-        echo "====Expected result ($expect_sorted) differs from actual result ($actual_sorted)"
-        $DIFF $expect_sorted $actual_sorted |sed 's/^/    /'
-        echo "====The actual output ($actual_sav)"
-        sed 's/^/    /' < $actual_sav
-        echo "====The actual stderr ($actual_err_sav)"
-        sed 's/^/    /' < $actual_err_sav
-        echo "====End of actual stderr ($actual_err_sav)"
-        echo ""
+
+        if $CMP $expect_sorted $actual_sorted; then
+            echo " PASSED"
+        else
+            echo "*FAILED*"
+            nerrors="`expr $nerrors + 1`"
+            if test yes = "$verbose"; then
+                echo "====Expected result ($expect_sorted) differs from actual result ($actual_sorted)"
+                $DIFF $expect_sorted $actual_sorted |sed 's/^/    /'
+                echo "====The actual output ($actual_sav)"
+                sed 's/^/    /' < $actual_sav
+                echo "====The actual stderr ($actual_err_sav)"
+                sed 's/^/    /' < $actual_err_sav
+                echo "====End of actual stderr ($actual_err_sav)"
+                echo ""
+            fi
         fi
     fi
-    fi
 
     # Clean up output file
     if test -z "$HDF5_NOCLEANUP"; then
diff --git a/tools/test/h5diff/testh5diff.sh.in b/tools/test/h5diff/testh5diff.sh.in
index 4e622ee9a76..9f88ee1d7aa 100644
--- a/tools/test/h5diff/testh5diff.sh.in
+++ b/tools/test/h5diff/testh5diff.sh.in
@@ -500,18 +500,20 @@ TOOLTEST() {
     # Run test.
     TESTING $H5DIFF $@
     (
-    #echo "#############################"
-    #echo "Expected output for '$H5DIFF $@'"
-    #echo "#############################"
-    cd $TESTDIR
-    eval $RUNCMD $H5DIFF_BIN "$@"
+        #echo "#############################"
+        #echo "Expected output for '$H5DIFF $@'"
+        #echo "#############################"
+        cd $TESTDIR
+        eval $RUNCMD $H5DIFF_BIN "$@"
     ) >$actual 2>$actual_err
     EXIT_CODE=$?
+
     # save actual and actual_err in case they are needed later.
     cp $actual $actual_sav
     STDOUT_FILTER $actual
     cp $actual_err $actual_err_sav
     STDERR_FILTER $actual_err
+
     # don't add exit code check in pmode, as it causes failure. (exit code
     # is from mpirun not tool)
     # if any problem occurs relate to an exit code, it will be caught in
@@ -545,23 +547,24 @@ TOOLTEST() {
         # is done by serial mode.
         grep -v "EXIT CODE:" $expect_sorted > $expect_sorted.noexit
         mv $expect_sorted.noexit $expect_sorted
-    if $CMP $expect_sorted $actual_sorted; then
-        echo " PASSED"
-    else
-        echo "*FAILED*"
-        nerrors="`expr $nerrors + 1`"
-        if test yes = "$verbose"; then
-        echo "====Expected result ($expect_sorted) differs from actual result ($actual_sorted)"
-        $DIFF $expect_sorted $actual_sorted |sed 's/^/    /'
-        echo "====The actual output ($actual_sav)"
-        sed 's/^/    /' < $actual_sav
-        echo "====The actual stderr ($actual_err_sav)"
-        sed 's/^/    /' < $actual_err_sav
-        echo "====End of actual stderr ($actual_err_sav)"
-        echo ""
+
+        if $CMP $expect_sorted $actual_sorted; then
+            echo " PASSED"
+        else
+            echo "*FAILED*"
+            nerrors="`expr $nerrors + 1`"
+            if test yes = "$verbose"; then
+            echo "====Expected result ($expect_sorted) differs from actual result ($actual_sorted)"
+            $DIFF $expect_sorted $actual_sorted |sed 's/^/    /'
+            echo "====The actual output ($actual_sav)"
+            sed 's/^/    /' < $actual_sav
+            echo "====The actual stderr ($actual_err_sav)"
+            sed 's/^/    /' < $actual_err_sav
+            echo "====End of actual stderr ($actual_err_sav)"
+            echo ""
+            fi
         fi
     fi
-    fi
 
     # Clean up output file
     if test -z "$HDF5_NOCLEANUP"; then
diff --git a/tools/test/h5dump/h5dump_plugin.sh.in b/tools/test/h5dump/h5dump_plugin.sh.in
index 6a00a162ea5..d940ab34eb2 100644
--- a/tools/test/h5dump/h5dump_plugin.sh.in
+++ b/tools/test/h5dump/h5dump_plugin.sh.in
@@ -181,8 +181,8 @@ TOOLTEST() {
     # Run test.
     TESTING $H5DUMP $@
     (
-    cd $TESTDIR
-      $ENVCMD $RUNSERIAL $H5DUMP_BIN "$@"
+        cd $TESTDIR
+        $ENVCMD $RUNSERIAL $H5DUMP_BIN "$@"
     ) >$actual 2>$actual_err
 
     # save actual and actual_err in case they are needed later.
@@ -192,24 +192,24 @@ TOOLTEST() {
     STDERR_FILTER $actual_err
     cat $actual_err >> $actual
 
-  if [ ! -f $expect ]; then
-    # Create the expect file if it doesn't yet exist.
-     echo " CREATED"
-     cp $actual $expect
-     echo "    Expected result (*.ddl) missing"
-     nerrors="`expr $nerrors + 1`"
+    if [ ! -f $expect ]; then
+        # Create the expect file if it doesn't yet exist.
+        echo " CREATED"
+        cp $actual $expect
+        echo "    Expected result (*.ddl) missing"
+        nerrors="`expr $nerrors + 1`"
     elif $CMP $expect $actual > /dev/null 2>&1 ; then
-     echo " PASSED"
+        echo " PASSED"
     else
-     echo "*FAILED*"
-     echo "    Expected result (*.ddl) differs from actual result (*.out)"
-     nerrors="`expr $nerrors + 1`"
-     test yes = "$verbose" && $DIFF $caseless $expect $actual |sed 's/^/    /'
+        echo "*FAILED*"
+        echo "    Expected result (*.ddl) differs from actual result (*.out)"
+        nerrors="`expr $nerrors + 1`"
+        test yes = "$verbose" && $DIFF $caseless $expect $actual |sed 's/^/    /'
     fi
 
     # Clean up output file
     if test -z "$HDF5_NOCLEANUP"; then
-     rm -f $actual $actual_err $actual_sav $actual_err_sav $actual_ext
+        rm -f $actual $actual_err $actual_sav $actual_err_sav $actual_ext
     fi
 
 }
diff --git a/tools/test/h5dump/testh5dump.sh.in b/tools/test/h5dump/testh5dump.sh.in
index 53c89275118..b69346eebc2 100644
--- a/tools/test/h5dump/testh5dump.sh.in
+++ b/tools/test/h5dump/testh5dump.sh.in
@@ -465,14 +465,14 @@ TESTING() {
 TOOLTEST() {
     # check if caseless compare and diff requested
     if [ "$1" = ignorecase ]; then
-    caseless="-i"
-    # replace cmp with diff which runs much longer.
-    xCMP="$DIFF -i"
-    shift
+        caseless="-i"
+        # replace cmp with diff which runs much longer.
+        xCMP="$DIFF -i"
+        shift
     else
-    caseless=""
-    # stick with faster cmp if ignorecase is not requested.
-    xCMP="$CMP"
+        caseless=""
+        # stick with faster cmp if ignorecase is not requested.
+        xCMP="$CMP"
     fi
 
     expect="$TESTDIR/$1"
@@ -485,8 +485,8 @@ TOOLTEST() {
     # Run test.
     TESTING $DUMPER $@
     (
-    cd $TESTDIR
-      $RUNSERIAL $DUMPER_BIN "$@"
+        cd $TESTDIR
+        $RUNSERIAL $DUMPER_BIN "$@"
     ) >$actual 2>$actual_err
 
     # save actual and actual_err in case they are needed later.
@@ -495,24 +495,24 @@ TOOLTEST() {
     cp $actual_err $actual_err_sav
     STDERR_FILTER $actual_err
 
-  if [ ! -f $expect ]; then
-    # Create the expect file if it doesn't yet exist.
-     echo " CREATED"
-     cp $actual $expect
-     echo "    Expected result (*.ddl) missing"
-     nerrors="`expr $nerrors + 1`"
+    if [ ! -f $expect ]; then
+        # Create the expect file if it doesn't yet exist.
+        echo " CREATED"
+        cp $actual $expect
+        echo "    Expected result (*.ddl) missing"
+        nerrors="`expr $nerrors + 1`"
     elif $xCMP $expect $actual > /dev/null 2>&1 ; then
-     echo " PASSED"
+        echo " PASSED"
     else
-     echo "*FAILED*"
-     echo "    Expected result (*.ddl) differs from actual result (*.out)"
-     nerrors="`expr $nerrors + 1`"
-     test yes = "$verbose" && $DIFF $caseless $expect $actual |sed 's/^/    /'
+        echo "*FAILED*"
+        echo "    Expected result (*.ddl) differs from actual result (*.out)"
+        nerrors="`expr $nerrors + 1`"
+        test yes = "$verbose" && $DIFF $caseless $expect $actual |sed 's/^/    /'
     fi
 
     # Clean up output file
     if test -z "$HDF5_NOCLEANUP"; then
-     rm -f $actual $actual_err $actual_sav $actual_err_sav $actual_ext
+        rm -f $actual $actual_err $actual_sav $actual_err_sav $actual_ext
     fi
 
 }
@@ -534,41 +534,41 @@ TOOLTEST2() {
     # Run test.
     TESTING $DUMPER $@
     (
-      cd $TESTDIR
-      $RUNSERIAL $DUMPER_BIN "$@"
+        cd $TESTDIR
+        $RUNSERIAL $DUMPER_BIN "$@"
     ) >$actual 2>$actual_err
 
     if [ ! -f $expect ]; then
-    # Create the expect file if it doesn't yet exist.
-     echo " CREATED"
-     cp $actual $expect
-     echo "    Expected result (*.ddl) missing"
-     nerrors="`expr $nerrors + 1`"
-    elif $CMP $expect $actual; then
-      if [ ! -f $expectdata ]; then
-      # Create the expect data file if it doesn't yet exist.
+        # Create the expect file if it doesn't yet exist.
         echo " CREATED"
-        cp $actualdata $expectdata
-        echo "    Expected data (*.exp) missing"
+        cp $actual $expect
+        echo "    Expected result (*.ddl) missing"
         nerrors="`expr $nerrors + 1`"
-      elif $CMP $expectdata $actualdata; then
-        echo " PASSED"
-      else
+    elif $CMP $expect $actual; then
+        if [ ! -f $expectdata ]; then
+            # Create the expect data file if it doesn't yet exist.
+            echo " CREATED"
+            cp $actualdata $expectdata
+            echo "    Expected data (*.exp) missing"
+            nerrors="`expr $nerrors + 1`"
+        elif $CMP $expectdata $actualdata; then
+            echo " PASSED"
+        else
+            echo "*FAILED*"
+            echo "    Expected datafile (*.exp) differs from actual datafile (*.txt)"
+            nerrors="`expr $nerrors + 1`"
+            test yes = "$verbose" && $DIFF $expectdata $actualdata |sed 's/^/    /'
+        fi
+    else
         echo "*FAILED*"
-        echo "    Expected datafile (*.exp) differs from actual datafile (*.txt)"
+        echo "    Expected result (*.ddl) differs from actual result (*.out)"
         nerrors="`expr $nerrors + 1`"
-        test yes = "$verbose" && $DIFF $expectdata $actualdata |sed 's/^/    /'
-      fi
-    else
-     echo "*FAILED*"
-     echo "    Expected result (*.ddl) differs from actual result (*.out)"
-     nerrors="`expr $nerrors + 1`"
-     test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
+        test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
     fi
 
     # Clean up output file
     if test -z "$HDF5_NOCLEANUP"; then
-     rm -f $actual $actualdata $actual_err
+        rm -f $actual $actualdata $actual_err
     fi
 
 }
@@ -592,56 +592,55 @@ TOOLTEST2A() {
     # Run test.
     TESTING $DUMPER $@
     (
-      cd $TESTDIR
-      $RUNSERIAL $DUMPER_BIN "$@"
+        cd $TESTDIR
+        $RUNSERIAL $DUMPER_BIN "$@"
     ) >$actual 2>$actual_err
 
     if [ ! -f $expect ]; then
-    # Create the expect file if it doesn't yet exist.
-     echo " CREATED"
-     cp $actual $expect
-     echo "    Expected result (*.ddl) missing"
-     nerrors="`expr $nerrors + 1`"
-    elif $CMP $expect $actual; then
-      if [ ! -f $expectdata ]; then
-      # Create the expect data file if it doesn't yet exist.
+        # Create the expect file if it doesn't yet exist.
         echo " CREATED"
-        cp $actualdata $expectdata
-        echo "    Expected data (*.exp) missing"
+        cp $actual $expect
+        echo "    Expected result (*.ddl) missing"
         nerrors="`expr $nerrors + 1`"
-      elif $DIFF $expectdata $actualdata; then
-        if [ ! -f $expectmeta ]; then
-        # Create the expect meta file if it doesn't yet exist.
-          echo " CREATED"
-          cp $actualmeta $expectmeta
-          echo "    Expected metafile (*.ddl) missing"
-          nerrors="`expr $nerrors + 1`"
-        elif $CMP $expectmeta $actualmeta; then
-          echo " PASSED"
+    elif $CMP $expect $actual; then
+        if [ ! -f $expectdata ]; then
+            # Create the expect data file if it doesn't yet exist.
+            echo " CREATED"
+            cp $actualdata $expectdata
+            echo "    Expected data (*.exp) missing"
+            nerrors="`expr $nerrors + 1`"
+        elif $DIFF $expectdata $actualdata; then
+            if [ ! -f $expectmeta ]; then
+                # Create the expect meta file if it doesn't yet exist.
+                echo " CREATED"
+                cp $actualmeta $expectmeta
+                echo "    Expected metafile (*.ddl) missing"
+                nerrors="`expr $nerrors + 1`"
+            elif $CMP $expectmeta $actualmeta; then
+                echo " PASSED"
+            else
+                echo "*FAILED*"
+                echo "    Expected metafile (*.ddl) differs from actual metafile (*.txt)"
+                nerrors="`expr $nerrors + 1`"
+                test yes = "$verbose" && $DIFF $expectmeta $actualmeta |sed 's/^/    /'
+            fi
         else
-          echo "*FAILED*"
-          echo "    Expected metafile (*.ddl) differs from actual metafile (*.txt)"
-          nerrors="`expr $nerrors + 1`"
-          test yes = "$verbose" && $DIFF $expectmeta $actualmeta |sed 's/^/    /'
+            echo "*FAILED*"
+            echo "    Expected datafile (*.exp) differs from actual datafile (*.txt)"
+            nerrors="`expr $nerrors + 1`"
+            test yes = "$verbose" && $DIFF $expectdata $actualdata |sed 's/^/    /'
         fi
-      else
+    else
         echo "*FAILED*"
-        echo "    Expected datafile (*.exp) differs from actual datafile (*.txt)"
+        echo "    Expected result (*.ddl) differs from actual result (*.out)"
         nerrors="`expr $nerrors + 1`"
-        test yes = "$verbose" && $DIFF $expectdata $actualdata |sed 's/^/    /'
-      fi
-    else
-     echo "*FAILED*"
-     echo "    Expected result (*.ddl) differs from actual result (*.out)"
-     nerrors="`expr $nerrors + 1`"
-     test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
+        test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
     fi
 
     # Clean up output file
     if test -z "$HDF5_NOCLEANUP"; then
-     rm -f $actual $actualdata $actual_err $actualmeta
+        rm -f $actual $actualdata $actual_err $actualmeta
     fi
-
 }
 
 # same as TOOLTEST2 but only compares the generated data file to the expected data file
@@ -658,28 +657,28 @@ TOOLTEST2B() {
     # Run test.
     TESTING $DUMPER $@
     (
-      cd $TESTDIR
-      $RUNSERIAL $DUMPER_BIN "$@"
+        cd $TESTDIR
+        $RUNSERIAL $DUMPER_BIN "$@"
     ) >$actual 2>$actual_err
 
     if [ ! -f $expectdata ]; then
-    # Create the expect data file if it doesn't yet exist.
-      echo " CREATED"
-      cp $actualdata $expectdata
-      echo "    Expected data (*.exp) missing"
-      nerrors="`expr $nerrors + 1`"
+        # Create the expect data file if it doesn't yet exist.
+        echo " CREATED"
+        cp $actualdata $expectdata
+        echo "    Expected data (*.exp) missing"
+        nerrors="`expr $nerrors + 1`"
     elif $CMP $expectdata $actualdata; then
-      echo " PASSED"
+        echo " PASSED"
     else
-      echo "*FAILED*"
-      echo "    Expected datafile (*.exp) differs from actual datafile (*.txt)"
-      nerrors="`expr $nerrors + 1`"
-      test yes = "$verbose" && $DIFF $expectdata $actualdata |sed 's/^/    /'
+        echo "*FAILED*"
+        echo "    Expected datafile (*.exp) differs from actual datafile (*.txt)"
+        nerrors="`expr $nerrors + 1`"
+        test yes = "$verbose" && $DIFF $expectdata $actualdata |sed 's/^/    /'
     fi
 
     # Clean up output file
     if test -z "$HDF5_NOCLEANUP"; then
-     rm -f $actual $actualdata $actual_err
+        rm -f $actual $actualdata $actual_err
     fi
 
 }
@@ -699,8 +698,8 @@ TOOLTEST3() {
     # Run test.
     TESTING $DUMPER $@
     (
-      cd $TESTDIR
-      $RUNSERIAL $DUMPER_BIN "$@"
+        cd $TESTDIR
+        $RUNSERIAL $DUMPER_BIN "$@"
     ) >$actual 2>$actual_err
 
     # save actual and actual_err in case they are needed later.
@@ -719,23 +718,23 @@ TOOLTEST3() {
      $actual_err > $actual_ext
 
     if [ ! -f $expect ]; then
-    # Create the expect file if it doesn't yet exist.
-     echo " CREATED"
-     cp $actual $expect
-     echo "    Expected result (*.ddl) missing"
-     nerrors="`expr $nerrors + 1`"
+        # Create the expect file if it doesn't yet exist.
+        echo " CREATED"
+        cp $actual $expect
+        echo "    Expected result (*.ddl) missing"
+        nerrors="`expr $nerrors + 1`"
     elif $CMP $expect $actual; then
-     echo " PASSED"
+        echo " PASSED"
     else
-     echo "*FAILED*"
-     echo "    Expected result (*.ddl) differs from actual result (*.out)"
-     nerrors="`expr $nerrors + 1`"
-     test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
+        echo "*FAILED*"
+        echo "    Expected result (*.ddl) differs from actual result (*.out)"
+        nerrors="`expr $nerrors + 1`"
+        test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
     fi
 
     # Clean up output file
     if test -z "$HDF5_NOCLEANUP"; then
-   rm -f $actual $actual_err $actual_sav $actual_err_sav
+        rm -f $actual $actual_err $actual_sav $actual_err_sav
     fi
 
 }
@@ -757,8 +756,8 @@ TOOLTEST4() {
     # Run test.
     TESTING $DUMPER $@
     (
-      cd $TESTDIR
-      $ENVCMD $RUNSERIAL $DUMPER_BIN "$@"
+        cd $TESTDIR
+        $ENVCMD $RUNSERIAL $DUMPER_BIN "$@"
     ) >$actual 2>$actual_err
 
     # save actual and actual_err in case they are needed later.
@@ -777,30 +776,30 @@ TOOLTEST4() {
      $actual_err > $actual_ext
 
     if [ ! -f $expect ]; then
-    # Create the expect file if it doesn't yet exist.
-     echo " CREATED"
-     cp $actual $expect
-     echo "    Expected result (*.ddl) missing"
-     nerrors="`expr $nerrors + 1`"
+        # Create the expect file if it doesn't yet exist.
+        echo " CREATED"
+        cp $actual $expect
+        echo "    Expected result (*.ddl) missing"
+        nerrors="`expr $nerrors + 1`"
     elif $CMP $expect $actual; then
-     if $CMP $expect_err $actual_ext; then
-      echo " PASSED"
-     else
-      echo "*FAILED*"
-      echo "    Expected result (*.err) differs from actual result (*.oerr)"
-      nerrors="`expr $nerrors + 1`"
-      test yes = "$verbose" && $DIFF $expect_err $actual_ext |sed 's/^/    /'
-     fi
+        if $CMP $expect_err $actual_ext; then
+            echo " PASSED"
+        else
+            echo "*FAILED*"
+            echo "    Expected result (*.err) differs from actual result (*.oerr)"
+            nerrors="`expr $nerrors + 1`"
+            test yes = "$verbose" && $DIFF $expect_err $actual_ext |sed 's/^/    /'
+        fi
     else
-     echo "*FAILED*"
-     echo "    Expected result (*.ddl) differs from actual result (*.out)"
-     nerrors="`expr $nerrors + 1`"
-     test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
+        echo "*FAILED*"
+        echo "    Expected result (*.ddl) differs from actual result (*.out)"
+        nerrors="`expr $nerrors + 1`"
+        test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
     fi
 
     # Clean up output file
     if test -z "$HDF5_NOCLEANUP"; then
-   rm -f $actual $actual_err $actual_sav $actual_err_sav
+        rm -f $actual $actual_err $actual_sav $actual_err_sav
     fi
 
 }
@@ -822,8 +821,8 @@ TOOLTEST5() {
     # Run test.
     TESTING $DUMPER $@
     (
-      cd $TESTDIR
-      $ENVCMD $RUNSERIAL $DUMPER_BIN "$@"
+        cd $TESTDIR
+        $ENVCMD $RUNSERIAL $DUMPER_BIN "$@"
     ) >$actual 2>$actual_err
 
     # save actual and actual_err in case they are needed later.
@@ -842,33 +841,33 @@ TOOLTEST5() {
      $actual_err > $actual_ext
 
     if [ ! -f $expect ]; then
-    # Create the expect file if it doesn't yet exist.
-     echo " CREATED"
-     cp $actual $expect
-     echo "    Expected result (*.ddl) missing"
-     nerrors="`expr $nerrors + 1`"
+        # Create the expect file if it doesn't yet exist.
+        echo " CREATED"
+        cp $actual $expect
+        echo "    Expected result (*.ddl) missing"
+        nerrors="`expr $nerrors + 1`"
     elif $CMP $expect $actual; then
-     if $CMP $expect_err $actual_ext; then
-      echo " PASSED"
-     else
-      echo "*FAILED*"
-      echo "    Expected result (*.err) differs from actual result (*.oerr)"
-      nerrors="`expr $nerrors + 1`"
-      test yes = "$verbose" && $DIFF $expect_err $actual_ext |sed 's/^/    /'
-     fi
+        if $CMP $expect_err $actual_ext; then
+            echo " PASSED"
+        else
+            echo "*FAILED*"
+            echo "    Expected result (*.err) differs from actual result (*.oerr)"
+            nerrors="`expr $nerrors + 1`"
+            test yes = "$verbose" && $DIFF $expect_err $actual_ext |sed 's/^/    /'
+        fi
     else
-     echo "*FAILED*"
-     echo "    Expected result (*.ddl) differs from actual result (*.out)"
-     nerrors="`expr $nerrors + 1`"
-     test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
+        echo "*FAILED*"
+        echo "    Expected result (*.ddl) differs from actual result (*.out)"
+        nerrors="`expr $nerrors + 1`"
+        test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
     fi
 
     # Clean up output file
     if test -z "$HDF5_NOCLEANUP"; then
-   rm -f $actual $actual_err $actual_sav $actual_err_sav
+        rm -f $actual $actual_err $actual_sav $actual_err_sav
     fi
-
 }
+
 # ADD_HELP_TEST
 TOOLTEST_HELP() {
 
@@ -880,27 +879,27 @@ TOOLTEST_HELP() {
     # Run test.
     TESTING $DUMPER $@
     (
-      cd $TESTDIR
-      $RUNSERIAL $DUMPER_BIN "$@"
+        cd $TESTDIR
+        $RUNSERIAL $DUMPER_BIN "$@"
     ) >$actual 2>$actual_err
 
     if [ ! -f $expectdata ]; then
-    # Create the expect data file if it doesn't yet exist.
-      echo " CREATED"
-      cp $actual $expect-CREATED
-      echo "    Expected output (*.txt) missing"
-      nerrors="`expr $nerrors + 1`"
+        # Create the expect data file if it doesn't yet exist.
+        echo " CREATED"
+        cp $actual $expect-CREATED
+        echo "    Expected output (*.txt) missing"
+        nerrors="`expr $nerrors + 1`"
     elif $CMP $expect $actual; then
-      echo " PASSED"
+        echo " PASSED"
     else
-      echo "*FAILED*"
-      echo "    Expected output (*.txt) differs from actual output (*.out)"
-      nerrors="`expr $nerrors + 1`"
+        echo "*FAILED*"
+        echo "    Expected output (*.txt) differs from actual output (*.out)"
+        nerrors="`expr $nerrors + 1`"
     fi
 
     # Clean up output file
     if test -z "$HDF5_NOCLEANUP"; then
-     rm -f $actual $actual_err
+        rm -f $actual $actual_err
     fi
 
 }
@@ -920,14 +919,16 @@ GREPTEST()
     # Run test.
     TESTING $DUMPER -p $@
     (
-      cd $TESTDIR
-      $ENVCMD $RUNSERIAL $DUMPER_BIN -p "$@"
+        cd $TESTDIR
+        $ENVCMD $RUNSERIAL $DUMPER_BIN -p "$@"
     ) >$actual 2>$actual_err
+
     if [ "$txttype" = "ERRTXT" ]; then
         $GREP "$expectdata" $actual_err > /dev/null
     else
         $GREP "$expectdata" $actual > /dev/null
     fi
+
     if [ $? -eq 0 ]; then
         echo " PASSED"
     else
@@ -937,7 +938,7 @@ GREPTEST()
 
     # Clean up output file
     if test -z "$HDF5_NOCLEANUP"; then
-     rm -f $actual $actual_err
+        rm -f $actual $actual_err
     fi
 }
 
@@ -956,14 +957,16 @@ GREPTEST2()
     # Run test.
     TESTING $DUMPER -p $@
     (
-      cd $TESTDIR
-      $ENVCMD $RUNSERIAL $DUMPER_BIN -p "$@"
+        cd $TESTDIR
+        $ENVCMD $RUNSERIAL $DUMPER_BIN -p "$@"
     ) >$actual 2>$actual_err
+
     if [ "$txttype" = "ERRTXT" ]; then
         $GREP "$expectdata" $actual_err > /dev/null
     else
         $GREP "$expectdata" $actual > /dev/null
     fi
+
     if [ $? -eq 0 ]; then
         echo " PASSED"
     else
@@ -973,21 +976,21 @@ GREPTEST2()
 
     # Clean up output file
     if test -z "$HDF5_NOCLEANUP"; then
-     rm -f $actual $actual_err
+        rm -f $actual $actual_err
     fi
 }
 
 # Print a "SKIP" message
 SKIP() {
-   TESTING $DUMPER $@
+    TESTING $DUMPER $@
     echo  " -SKIP-"
 }
 
 # Print a line-line message left justified in a field of 70 characters
 #
 PRINT_H5DIFF() {
- SPACES="                                                               "
- echo " Running h5diff $* $SPACES" | cut -c1-70 | tr -d '\012'
+    SPACES="                                                               "
+    echo " Running h5diff $* $SPACES" | cut -c1-70 | tr -d '\012'
 }
 
 
@@ -997,10 +1000,11 @@ DIFFTEST()
 {
     PRINT_H5DIFF  $@
     (
-  cd $TESTDIR
-  $RUNSERIAL $H5DIFF_BIN "$@" -q
+        cd $TESTDIR
+        $RUNSERIAL $H5DIFF_BIN "$@" -q
     )
     RET=$?
+
     if [ $RET != 0 ] ; then
          echo "*FAILED*"
          nerrors="`expr $nerrors + 1`"
@@ -1014,8 +1018,8 @@ DIFFTEST()
 # beginning with the word "Verifying".
 #
 PRINT_H5IMPORT() {
- SPACES="                                                               "
- echo " Running h5import $* $SPACES" | cut -c1-70 | tr -d '\012'
+    SPACES="                                                               "
+    echo " Running h5import $* $SPACES" | cut -c1-70 | tr -d '\012'
 }
 
 # Call the h5import tool
@@ -1025,15 +1029,16 @@ IMPORTTEST()
     # remove the output hdf5 file if it exists
     hdf5_file="$TESTDIR/$5"
     if [ -f $hdf5_file ]; then
-     rm -f $hdf5_file
+        rm -f $hdf5_file
     fi
 
     PRINT_H5IMPORT  $@
     (
-  cd $TESTDIR
-  $RUNSERIAL $H5IMPORT_BIN "$@"
+        cd $TESTDIR
+        $RUNSERIAL $H5IMPORT_BIN "$@"
     )
     RET=$?
+
     if [ $RET != 0 ] ; then
          echo "*FAILED*"
          nerrors="`expr $nerrors + 1`"
@@ -1138,9 +1143,9 @@ TOOLTEST tcomp-4.ddl --enable-error-stack tcompound_complex.h5
 TOOLTEST tcompound_complex2.ddl --enable-error-stack tcompound_complex2.h5
 # tests for bitfields and opaque data types
 if test $WORDS_BIGENDIAN != "yes"; then
-TOOLTEST tbitnopaque_le.ddl --enable-error-stack tbitnopaque.h5
+    TOOLTEST tbitnopaque_le.ddl --enable-error-stack tbitnopaque.h5
 else
-TOOLTEST tbitnopaque_be.ddl --enable-error-stack tbitnopaque.h5
+    TOOLTEST tbitnopaque_be.ddl --enable-error-stack tbitnopaque.h5
 fi
 
 #test for the nested compound type
@@ -1318,12 +1323,12 @@ TOOLTEST tallfilters.ddl --enable-error-stack -H -p -d all  tfilters.h5
 TOOLTEST tuserfilter.ddl --enable-error-stack -H  -p -d myfilter  tfilters.h5
 
 if test $USE_FILTER_DEFLATE = "yes" ; then
-  # data read internal filters
-  TOOLTEST treadintfilter.ddl --enable-error-stack -d deflate -d shuffle -d fletcher32 -d nbit -d scaleoffset tfilters.h5
-  if test $USE_FILTER_SZIP = "yes"; then
-    # data read
-    TOOLTEST treadfilter.ddl --enable-error-stack -d all -d szip tfilters.h5
-  fi
+    # data read internal filters
+    TOOLTEST treadintfilter.ddl --enable-error-stack -d deflate -d shuffle -d fletcher32 -d nbit -d scaleoffset tfilters.h5
+    if test $USE_FILTER_SZIP = "yes"; then
+        # data read
+        TOOLTEST treadfilter.ddl --enable-error-stack -d all -d szip tfilters.h5
+    fi
 fi
 
 # test for displaying objects with very long names
@@ -1380,9 +1385,9 @@ TOOLTEST   tbin4.ddl --enable-error-stack -d double  -b FILE -o out4.bin    tbin
 
 # Clean up binary output files
 if test -z "$HDF5_NOCLEANUP"; then
- rm -f out[1-4].bin
- rm -f out1.h5
- rm -f out3.h5
+    rm -f out[1-4].bin
+    rm -f out1.h5
+    rm -f out3.h5
 fi
 
 # test for dataset region references
@@ -1394,7 +1399,7 @@ TOOLTEST2 tbinregR.exp --enable-error-stack -d /Dataset1 -s 0 -R -y -o tbinregR.
 
 # Clean up text output files
 if test -z "$HDF5_NOCLEANUP"; then
- rm -f tbinregR.txt
+    rm -f tbinregR.txt
 fi
 
 # tests for group creation order
diff --git a/tools/test/h5dump/testh5dumppbits.sh.in b/tools/test/h5dump/testh5dumppbits.sh.in
index febce2cabb7..ff0659a6292 100644
--- a/tools/test/h5dump/testh5dumppbits.sh.in
+++ b/tools/test/h5dump/testh5dumppbits.sh.in
@@ -236,26 +236,25 @@ TOOLTEST() {
     cp $actual_err $actual_err_sav
     STDERR_FILTER $actual_err
 
-  if [ ! -f $expect ]; then
-    # Create the expect file if it doesn't yet exist.
-     echo " CREATED"
-     cp $actual $expect
-     echo "    Expected result (*.ddl) missing"
-     nerrors="`expr $nerrors + 1`"
+    if [ ! -f $expect ]; then
+        # Create the expect file if it doesn't yet exist.
+        echo " CREATED"
+        cp $actual $expect
+        echo "    Expected result (*.ddl) missing"
+        nerrors="`expr $nerrors + 1`"
     elif $CMP $expect $actual; then
-     echo " PASSED"
+        echo " PASSED"
     else
-     echo "*FAILED*"
-     echo "    Expected result (*.ddl) differs from actual result (*.out)"
-   nerrors="`expr $nerrors + 1`"
-   test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
+        echo "*FAILED*"
+        echo "    Expected result (*.ddl) differs from actual result (*.out)"
+        nerrors="`expr $nerrors + 1`"
+        test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
     fi
 
     # Clean up output file
     if test -z "$HDF5_NOCLEANUP"; then
-   rm -f $actual $actual_err $actual_sav $actual_err_sav $actual_ext
+        rm -f $actual $actual_err $actual_sav $actual_err_sav $actual_ext
     fi
-
 }
 
 
@@ -274,36 +273,36 @@ TOOLTEST2() {
     # Run test.
     TESTING $DUMPER $@
     (
-      cd $TESTDIR
-      $RUNSERIAL $DUMPER_BIN "$@"
+        cd $TESTDIR
+        $RUNSERIAL $DUMPER_BIN "$@"
     ) >$actual 2>$actual_err
 
     if [ ! -f $expect ]; then
-    # Create the expect file if it doesn't yet exist.
-     echo " CREATED"
-     cp $actual $expect
-     echo "    Expected result (*.ddl) missing"
-     nerrors="`expr $nerrors + 1`"
-    elif $CMP $expect $actual; then
-      if [ ! -f $expectdata ]; then
-      # Create the expect data file if it doesn't yet exist.
+        # Create the expect file if it doesn't yet exist.
         echo " CREATED"
-        cp $actualdata $expectdata
-        echo "    Expected data (*.exp) missing"
+        cp $actual $expect
+        echo "    Expected result (*.ddl) missing"
         nerrors="`expr $nerrors + 1`"
-      elif $CMP $expectdata $actualdata; then
-        echo " PASSED"
-      else
+    elif $CMP $expect $actual; then
+        if [ ! -f $expectdata ]; then
+            # Create the expect data file if it doesn't yet exist.
+            echo " CREATED"
+            cp $actualdata $expectdata
+            echo "    Expected data (*.exp) missing"
+            nerrors="`expr $nerrors + 1`"
+        elif $CMP $expectdata $actualdata; then
+            echo " PASSED"
+        else
+            echo "*FAILED*"
+            echo "    Expected datafile (*.exp) differs from actual datafile (*.txt)"
+            nerrors="`expr $nerrors + 1`"
+            test yes = "$verbose" && $DIFF $expectdata $actualdata |sed 's/^/    /'
+        fi
+    else
         echo "*FAILED*"
-        echo "    Expected datafile (*.exp) differs from actual datafile (*.txt)"
+        echo "    Expected result (*.ddl) differs from actual result (*.out)"
         nerrors="`expr $nerrors + 1`"
-        test yes = "$verbose" && $DIFF $expectdata $actualdata |sed 's/^/    /'
-      fi
-    else
-     echo "*FAILED*"
-     echo "    Expected result (*.ddl) differs from actual result (*.out)"
-     nerrors="`expr $nerrors + 1`"
-     test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
+        test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
     fi
 
     # Clean up output file
@@ -328,8 +327,8 @@ TOOLTEST3() {
     # Run test.
     TESTING $DUMPER $@
     (
-      cd $TESTDIR
-      $RUNSERIAL $DUMPER_BIN "$@"
+        cd $TESTDIR
+        $RUNSERIAL $DUMPER_BIN "$@"
     ) >$actual 2>$actual_err
 
     # save actual and actual_err in case they are needed later.
@@ -348,23 +347,23 @@ TOOLTEST3() {
      $actual_err > $actual_ext
 
     if [ ! -f $expect ]; then
-    # Create the expect file if it doesn't yet exist.
-     echo " CREATED"
-     cp $actual $expect
-     echo "    Expected result (*.ddl) missing"
-     nerrors="`expr $nerrors + 1`"
+        # Create the expect file if it doesn't yet exist.
+        echo " CREATED"
+        cp $actual $expect
+        echo "    Expected result (*.ddl) missing"
+        nerrors="`expr $nerrors + 1`"
     elif $CMP $expect $actual; then
-     echo " PASSED"
+        echo " PASSED"
     else
-     echo "*FAILED*"
-     echo "    Expected result (*.ddl) differs from actual result (*.out)"
-     nerrors="`expr $nerrors + 1`"
-     test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
+        echo "*FAILED*"
+        echo "    Expected result (*.ddl) differs from actual result (*.out)"
+        nerrors="`expr $nerrors + 1`"
+        test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
     fi
 
     # Clean up output file
     if test -z "$HDF5_NOCLEANUP"; then
-   rm -f $actual $actual_err $actual_sav $actual_err_sav
+        rm -f $actual $actual_err $actual_sav $actual_err_sav
     fi
 
 }
@@ -385,8 +384,8 @@ TOOLTEST4() {
     # Run test.
     TESTING $DUMPER $@
     (
-      cd $TESTDIR
-      $RUNSERIAL $DUMPER_BIN "$@"
+        cd $TESTDIR
+        $RUNSERIAL $DUMPER_BIN "$@"
     ) >$actual 2>$actual_err
 
     # save actual and actual_err in case they are needed later.
@@ -405,30 +404,30 @@ TOOLTEST4() {
      $actual_err > $actual_ext
 
     if [ ! -f $expect ]; then
-    # Create the expect file if it doesn't yet exist.
-     echo " CREATED"
-     cp $actual $expect
-     echo "    Expected result (*.ddl) missing"
-     nerrors="`expr $nerrors + 1`"
+        # Create the expect file if it doesn't yet exist.
+        echo " CREATED"
+        cp $actual $expect
+        echo "    Expected result (*.ddl) missing"
+        nerrors="`expr $nerrors + 1`"
     elif $CMP $expect $actual; then
-     if $CMP $expect_err $actual_ext; then
-      echo " PASSED"
-     else
-      echo "*FAILED*"
-      echo "    Expected result (*.err) differs from actual result (*.oerr)"
-      nerrors="`expr $nerrors + 1`"
-      test yes = "$verbose" && $DIFF $expect_err $actual_ext |sed 's/^/    /'
-     fi
+        if $CMP $expect_err $actual_ext; then
+            echo " PASSED"
+        else
+            echo "*FAILED*"
+            echo "    Expected result (*.err) differs from actual result (*.oerr)"
+            nerrors="`expr $nerrors + 1`"
+            test yes = "$verbose" && $DIFF $expect_err $actual_ext |sed 's/^/    /'
+        fi
     else
-     echo "*FAILED*"
-     echo "    Expected result (*.ddl) differs from actual result (*.out)"
-     nerrors="`expr $nerrors + 1`"
-     test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
+        echo "*FAILED*"
+        echo "    Expected result (*.ddl) differs from actual result (*.out)"
+        nerrors="`expr $nerrors + 1`"
+        test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
     fi
 
     # Clean up output file
     if test -z "$HDF5_NOCLEANUP"; then
-   rm -f $actual $actual_err $actual_sav $actual_err_sav
+        rm -f $actual $actual_err $actual_sav $actual_err_sav
     fi
 
 }
@@ -442,8 +441,8 @@ SKIP() {
 # Print a line-line message left justified in a field of 70 characters
 #
 PRINT_H5DIFF() {
- SPACES="                                                               "
- echo " Running h5diff $* $SPACES" | cut -c1-70 | tr -d '\012'
+    SPACES="                                                               "
+    echo " Running h5diff $* $SPACES" | cut -c1-70 | tr -d '\012'
 }
 
 
@@ -453,10 +452,11 @@ DIFFTEST()
 {
     PRINT_H5DIFF  $@
     (
-  cd $TESTDIR
-  $RUNSERIAL $H5DIFF_BIN "$@" -q
+        cd $TESTDIR
+        $RUNSERIAL $H5DIFF_BIN "$@" -q
     )
     RET=$?
+
     if [ $RET != 0 ] ; then
          echo "*FAILED*"
          nerrors="`expr $nerrors + 1`"
@@ -470,8 +470,8 @@ DIFFTEST()
 # beginning with the word "Verifying".
 #
 PRINT_H5IMPORT() {
- SPACES="                                                               "
- echo " Running h5import $* $SPACES" | cut -c1-70 | tr -d '\012'
+    SPACES="                                                               "
+    echo " Running h5import $* $SPACES" | cut -c1-70 | tr -d '\012'
 }
 
 # Call the h5import tool
@@ -481,22 +481,22 @@ IMPORTTEST()
     # remove the output hdf5 file if it exists
     hdf5_file="$TESTDIR/$5"
     if [ -f $hdf5_file ]; then
-     rm -f $hdf5_file
+        rm -f $hdf5_file
     fi
 
     PRINT_H5IMPORT  $@
     (
-  cd $TESTDIR
-  $RUNSERIAL $H5IMPORT_BIN "$@"
+        cd $TESTDIR
+        $RUNSERIAL $H5IMPORT_BIN "$@"
     )
     RET=$?
+
     if [ $RET != 0 ] ; then
          echo "*FAILED*"
          nerrors="`expr $nerrors + 1`"
     else
          echo " PASSED"
     fi
-
 }
 
 
diff --git a/tools/test/h5dump/testh5dumpvds.sh.in b/tools/test/h5dump/testh5dumpvds.sh.in
index f89234ec735..29ff23875cf 100644
--- a/tools/test/h5dump/testh5dumpvds.sh.in
+++ b/tools/test/h5dump/testh5dumpvds.sh.in
@@ -205,8 +205,8 @@ TOOLTEST() {
     # Run test.
     TESTING $DUMPER $@
     (
-    cd $TESTDIR
-      $RUNSERIAL $DUMPER_BIN "$@"
+        cd $TESTDIR
+        $RUNSERIAL $DUMPER_BIN "$@"
     ) >$actual 2>$actual_err
 
     # save actual and actual_err in case they are needed later.
@@ -216,26 +216,25 @@ TOOLTEST() {
     STDERR_FILTER $actual_err
     cat $actual_err >> $actual
 
-  if [ ! -f $expect ]; then
-    # Create the expect file if it doesn't yet exist.
-     echo " CREATED"
-     cp $actual $expect
-     echo "    Expected result (*.ddl) missing"
-     nerrors="`expr $nerrors + 1`"
+    if [ ! -f $expect ]; then
+        # Create the expect file if it doesn't yet exist.
+        echo " CREATED"
+        cp $actual $expect
+        echo "    Expected result (*.ddl) missing"
+        nerrors="`expr $nerrors + 1`"
     elif $CMP $expect $actual; then
-     echo " PASSED"
+        echo " PASSED"
     else
-     echo "*FAILED*"
-     echo "    Expected result (*.ddl) differs from actual result (*.out)"
-   nerrors="`expr $nerrors + 1`"
-   test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
+        echo "*FAILED*"
+        echo "    Expected result (*.ddl) differs from actual result (*.out)"
+        nerrors="`expr $nerrors + 1`"
+        test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
     fi
 
     # Clean up output file
     if test -z "$HDF5_NOCLEANUP"; then
-   rm -f $actual $actual_err $actual_sav $actual_err_sav $actual_ext
+        rm -f $actual $actual_err $actual_sav $actual_err_sav $actual_ext
     fi
-
 }
 
 
@@ -254,42 +253,42 @@ TOOLTEST2() {
     # Run test.
     TESTING $DUMPER $@
     (
-      cd $TESTDIR
-      $RUNSERIAL $DUMPER_BIN "$@"
+        cd $TESTDIR
+        $RUNSERIAL $DUMPER_BIN "$@"
     ) >$actual 2>$actual_err
     cat $actual_err >> $actual
 
     if [ ! -f $expect ]; then
-    # Create the expect file if it doesn't yet exist.
-     echo " CREATED"
-     cp $actual $expect
-     echo "    Expected result (*.ddl) missing"
-     nerrors="`expr $nerrors + 1`"
-    elif $CMP $expect $actual; then
-      if [ ! -f $expectdata ]; then
-      # Create the expect data file if it doesn't yet exist.
+        # Create the expect file if it doesn't yet exist.
         echo " CREATED"
-        cp $actualdata $expectdata
-        echo "    Expected data (*.exp) missing"
+        cp $actual $expect
+        echo "    Expected result (*.ddl) missing"
         nerrors="`expr $nerrors + 1`"
-      elif $CMP $expectdata $actualdata; then
-        echo " PASSED"
-      else
+    elif $CMP $expect $actual; then
+        if [ ! -f $expectdata ]; then
+            # Create the expect data file if it doesn't yet exist.
+            echo " CREATED"
+            cp $actualdata $expectdata
+            echo "    Expected data (*.exp) missing"
+            nerrors="`expr $nerrors + 1`"
+        elif $CMP $expectdata $actualdata; then
+            echo " PASSED"
+        else
+            echo "*FAILED*"
+            echo "    Expected datafile (*.exp) differs from actual datafile (*.txt)"
+            nerrors="`expr $nerrors + 1`"
+            test yes = "$verbose" && $DIFF $expectdata $actualdata |sed 's/^/    /'
+        fi
+    else
         echo "*FAILED*"
-        echo "    Expected datafile (*.exp) differs from actual datafile (*.txt)"
+        echo "    Expected result (*.ddl) differs from actual result (*.out)"
         nerrors="`expr $nerrors + 1`"
-        test yes = "$verbose" && $DIFF $expectdata $actualdata |sed 's/^/    /'
-      fi
-    else
-     echo "*FAILED*"
-     echo "    Expected result (*.ddl) differs from actual result (*.out)"
-     nerrors="`expr $nerrors + 1`"
-     test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
+        test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
     fi
 
     # Clean up output file
     if test -z "$HDF5_NOCLEANUP"; then
-     rm -f $actual $actualdata $actual_err
+        rm -f $actual $actualdata $actual_err
     fi
 
 }
@@ -309,8 +308,8 @@ TOOLTEST3() {
     # Run test.
     TESTING $DUMPER $@
     (
-      cd $TESTDIR
-      $RUNSERIAL $DUMPER_BIN "$@"
+        cd $TESTDIR
+        $RUNSERIAL $DUMPER_BIN "$@"
     ) >$actual 2>$actual_err
 
     # save actual and actual_err in case they are needed later.
@@ -326,27 +325,27 @@ TOOLTEST3() {
         -e 's/[1-9]*\.[0-9]*\.[0-9]*[^)]*/version (number)/' \
         -e 's/H5Eget_auto[1-2]*/H5Eget_auto(1 or 2)/' \
         -e 's/H5Eset_auto[1-2]*/H5Eset_auto(1 or 2)/' \
-     $actual_err > $actual_ext
+        $actual_err > $actual_ext
     cat $actual_ext >> $actual
 
     if [ ! -f $expect ]; then
-    # Create the expect file if it doesn't yet exist.
-     echo " CREATED"
-     cp $actual $expect
-     echo "    Expected result (*.ddl) missing"
-     nerrors="`expr $nerrors + 1`"
+        # Create the expect file if it doesn't yet exist.
+        echo " CREATED"
+        cp $actual $expect
+        echo "    Expected result (*.ddl) missing"
+        nerrors="`expr $nerrors + 1`"
     elif $CMP $expect $actual; then
-     echo " PASSED"
+        echo " PASSED"
     else
-     echo "*FAILED*"
-     echo "    Expected result (*.ddl) differs from actual result (*.out)"
-     nerrors="`expr $nerrors + 1`"
-     test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
+        echo "*FAILED*"
+        echo "    Expected result (*.ddl) differs from actual result (*.out)"
+        nerrors="`expr $nerrors + 1`"
+        test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
     fi
 
     # Clean up output file
     if test -z "$HDF5_NOCLEANUP"; then
-   rm -f $actual $actual_err $actual_sav $actual_err_sav
+        rm -f $actual $actual_err $actual_sav $actual_err_sav
     fi
 
 }
@@ -367,8 +366,8 @@ TOOLTEST4() {
     # Run test.
     TESTING $DUMPER $@
     (
-      cd $TESTDIR
-      $RUNSERIAL $DUMPER_BIN "$@"
+        cd $TESTDIR
+        $RUNSERIAL $DUMPER_BIN "$@"
     ) >$actual 2>$actual_err
 
     # save actual and actual_err in case they are needed later.
@@ -384,47 +383,46 @@ TOOLTEST4() {
         -e 's/[1-9]*\.[0-9]*\.[0-9]*[^)]*/version (number)/' \
         -e 's/H5Eget_auto[1-2]*/H5Eget_auto(1 or 2)/' \
         -e 's/H5Eset_auto[1-2]*/H5Eset_auto(1 or 2)/' \
-     $actual_err > $actual_ext
+        $actual_err > $actual_ext
     #cat $actual_ext >> $actual
 
     if [ ! -f $expect ]; then
-    # Create the expect file if it doesn't yet exist.
-     echo " CREATED"
-     cp $actual $expect
+        # Create the expect file if it doesn't yet exist.
+        echo " CREATED"
+        cp $actual $expect
     elif $CMP $expect $actual; then
-     if $CMP $expect_err $actual_ext; then
-      echo " PASSED"
-    else
-     echo "*FAILED*"
-     echo "    Expected result (*.err) differs from actual result (*.oerr)"
-     nerrors="`expr $nerrors + 1`"
-     test yes = "$verbose" && $DIFF $expect_err $actual_ext |sed 's/^/    /'
-    fi
+        if $CMP $expect_err $actual_ext; then
+            echo " PASSED"
+        else
+            echo "*FAILED*"
+            echo "    Expected result (*.err) differs from actual result (*.oerr)"
+            nerrors="`expr $nerrors + 1`"
+            test yes = "$verbose" && $DIFF $expect_err $actual_ext |sed 's/^/    /'
+        fi
     else
-     echo "*FAILED*"
-     echo "    Expected result (*.ddl) differs from actual result (*.out)"
-     nerrors="`expr $nerrors + 1`"
-     test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
+        echo "*FAILED*"
+        echo "    Expected result (*.ddl) differs from actual result (*.out)"
+        nerrors="`expr $nerrors + 1`"
+        test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
     fi
 
     # Clean up output file
     if test -z "$HDF5_NOCLEANUP"; then
-   rm -f $actual $actual_err $actual_sav $actual_err_sav
+        rm -f $actual $actual_err $actual_sav $actual_err_sav
     fi
-
 }
 
 # Print a "SKIP" message
 SKIP() {
-   TESTING $DUMPER $@
+    TESTING $DUMPER $@
     echo  " -SKIP-"
 }
 
 # Print a line-line message left justified in a field of 70 characters
 #
 PRINT_H5DIFF() {
- SPACES="                                                               "
- echo " Running h5diff $* $SPACES" | cut -c1-70 | tr -d '\012'
+    SPACES="                                                               "
+    echo " Running h5diff $* $SPACES" | cut -c1-70 | tr -d '\012'
 }
 
 
@@ -434,25 +432,25 @@ DIFFTEST()
 {
     PRINT_H5DIFF  $@
     (
-  cd $TESTDIR
-  $RUNSERIAL $H5DIFF_BIN "$@" -q
+        cd $TESTDIR
+        $RUNSERIAL $H5DIFF_BIN "$@" -q
     )
     RET=$?
+
     if [ $RET != 0 ] ; then
          echo "*FAILED*"
          nerrors="`expr $nerrors + 1`"
     else
          echo " PASSED"
     fi
-
 }
 
 # Print a line-line message left justified in a field of 70 characters
 # beginning with the word "Verifying".
 #
 PRINT_H5IMPORT() {
- SPACES="                                                               "
- echo " Running h5import $* $SPACES" | cut -c1-70 | tr -d '\012'
+    SPACES="                                                               "
+    echo " Running h5import $* $SPACES" | cut -c1-70 | tr -d '\012'
 }
 
 # Call the h5import tool
@@ -462,22 +460,22 @@ IMPORTTEST()
     # remove the output hdf5 file if it exists
     hdf5_file="$TESTDIR/$5"
     if [ -f $hdf5_file ]; then
-     rm -f $hdf5_file
+        rm -f $hdf5_file
     fi
 
     PRINT_H5IMPORT  $@
     (
-  cd $TESTDIR
-  $RUNSERIAL $H5IMPORT_BIN "$@"
+        cd $TESTDIR
+        $RUNSERIAL $H5IMPORT_BIN "$@"
     )
     RET=$?
+
     if [ $RET != 0 ] ; then
          echo "*FAILED*"
          nerrors="`expr $nerrors + 1`"
     else
          echo " PASSED"
     fi
-
 }
 
 
@@ -491,7 +489,7 @@ COPY_TESTFILES_TO_TESTDIR
 
 ####### test for dataset vds ######
 
-  # Data read
+# Data read
 if test $USE_FILTER_DEFLATE = "yes" ; then
     TOOLTEST tvds-1.ddl --enable-error-stack 1_vds.h5
     TOOLTEST tvds-2.ddl --enable-error-stack 2_vds.h5
@@ -504,7 +502,7 @@ if test $USE_FILTER_DEFLATE = "yes" ; then
     TOOLTEST vds-gap2.ddl --vds-gap-size=2 --enable-error-stack vds-eiger.h5
 fi
 
-  # Layout read
+# Layout read
 if test $USE_FILTER_DEFLATE = "yes" ; then
     TOOLTEST tvds_layout-1.ddl -p --enable-error-stack 1_vds.h5
     TOOLTEST tvds_layout-2.ddl -p --enable-error-stack 2_vds.h5
diff --git a/tools/test/h5dump/testh5dumpxml.sh.in b/tools/test/h5dump/testh5dumpxml.sh.in
index f7af3006e58..52a13c2a28f 100644
--- a/tools/test/h5dump/testh5dumpxml.sh.in
+++ b/tools/test/h5dump/testh5dumpxml.sh.in
@@ -262,36 +262,35 @@ TOOLTEST() {
     # Run test.
     TESTING $DUMPER $@
     (
-    cd $TESTDIR
-      $RUNSERIAL $DUMPER_BIN "$@"
+        cd $TESTDIR
+        $RUNSERIAL $DUMPER_BIN "$@"
     ) >$actual 2>$actual_err
 
-
    if [ ! -f $expect ]; then
-    # Create the expect file if it doesn't yet exist.
-    echo " CREATED"
-     cp $actual $expect
-     echo "    Expected result (*.xml) missing"
-     nerrors="`expr $nerrors + 1`"
+        # Create the expect file if it doesn't yet exist.
+        echo " CREATED"
+        cp $actual $expect
+        echo "    Expected result (*.xml) missing"
+        nerrors="`expr $nerrors + 1`"
    elif  $CMP $expect $actual; then
-      echo " PASSED"
+        echo " PASSED"
    else
-      echo "*FAILED*"
-      echo "    Expected result (*.xml) differs from actual result (*.out)"
-      nerrors="`expr $nerrors + 1`"
-      test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
+        echo "*FAILED*"
+        echo "    Expected result (*.xml) differs from actual result (*.out)"
+        nerrors="`expr $nerrors + 1`"
+        test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
    fi
 
    # Clean up output file
    if test -z "$HDF5_NOCLEANUP"; then
-      rm -f $actual $actual_err
+        rm -f $actual $actual_err
    fi
 }
 
 # Print a "SKIP" message
 SKIP() {
-         TESTING $DUMPER $@
-          echo  " -SKIP-"
+    TESTING $DUMPER $@
+    echo  " -SKIP-"
 }
 
 
diff --git a/tools/test/h5ls/h5ls_plugin.sh.in b/tools/test/h5ls/h5ls_plugin.sh.in
index c89269d10c1..28370e6f69f 100644
--- a/tools/test/h5ls/h5ls_plugin.sh.in
+++ b/tools/test/h5ls/h5ls_plugin.sh.in
@@ -139,8 +139,8 @@ CLEAN_TESTFILES_AND_TESTDIR()
 # Print a $* message left justified in a field of 70 characters
 #
 MESSAGE() {
-   SPACES="                                                               "
-   echo "$* $SPACES" | cut -c1-70 | tr -d '\012'
+    SPACES="                                                               "
+    echo "$* $SPACES" | cut -c1-70 | tr -d '\012'
 }
 
 # Print a line-line message left justified in a field of 70 characters
@@ -206,7 +206,7 @@ TOOLTEST() {
             echo ""
         fi
     elif [ ! -f $expect ]; then
-    # Create the expect file if it doesn't yet exist.
+        # Create the expect file if it doesn't yet exist.
         echo " CREATED"
         cp $actual $expect
         echo "    Expected result (*.ls) missing"
diff --git a/tools/test/misc/testh5mkgrp.sh.in b/tools/test/misc/testh5mkgrp.sh.in
index 3ad1f71eb60..b08cce1b9dc 100644
--- a/tools/test/misc/testh5mkgrp.sh.in
+++ b/tools/test/misc/testh5mkgrp.sh.in
@@ -150,10 +150,11 @@ TOOLTEST()
 {
     TESTING $H5MKGRP $@
     (
-    cd $TESTDIR
-    $RUNSERIAL $H5MKGRP_BIN $@
+        cd $TESTDIR
+        $RUNSERIAL $H5MKGRP_BIN $@
     ) > output.out
     RET=$?
+
     if [ $RET != 0 ]; then
         echo "*FAILED*"
         echo "failed result is:"
@@ -164,7 +165,7 @@ TOOLTEST()
 
         # Clean up output file
         if test -z "$HDF5_NOCLEANUP"; then
-           rm -f output.out
+            rm -f output.out
         fi
     fi
 }
@@ -181,8 +182,8 @@ H5LSTEST()
     # any unexpected output from that stream too.
     VERIFY_H5LS  $@
     (
-      cd $TESTDIR
-      $RUNSERIAL $H5LS_BIN $H5LS_ARGS $@
+        cd $TESTDIR
+        $RUNSERIAL $H5LS_BIN $H5LS_ARGS $@
     ) 2>&1 |sed 's/Modified:.*/Modified:  XXXX-XX-XX XX:XX:XX XXX/' >$actual
 
     # save actual in case it is needed later.
@@ -190,25 +191,25 @@ H5LSTEST()
     STDOUT_FILTER $actual
     STDERR_FILTER $actual
 
-   if [ ! -f $expect ]; then
-      # Create the expect file if it doesn't yet exist.
-      echo " CREATED"
-      cp $actual $expect
-      echo "    Expected result (*.ls) missing"
-      nerrors="`expr $nerrors + 1`"
-   elif $CMP $expect $actual; then
-      echo " PASSED"
-   else
-      echo "*FAILED*"
-      echo "    Expected result (*.ls) differs from actual result (*.out)"
-      nerrors="`expr $nerrors + 1`"
-      test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
-   fi
-
-   # Clean up output file
-   if test -z "$HDF5_NOCLEANUP"; then
-      rm -f $actual $actual_sav
-   fi
+    if [ ! -f $expect ]; then
+        # Create the expect file if it doesn't yet exist.
+        echo " CREATED"
+        cp $actual $expect
+        echo "    Expected result (*.ls) missing"
+        nerrors="`expr $nerrors + 1`"
+    elif $CMP $expect $actual; then
+        echo " PASSED"
+    else
+        echo "*FAILED*"
+        echo "    Expected result (*.ls) differs from actual result (*.out)"
+        nerrors="`expr $nerrors + 1`"
+        test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
+    fi
+
+    # Clean up output file
+    if test -z "$HDF5_NOCLEANUP"; then
+        rm -f $actual $actual_sav
+    fi
 }
 
 # Single run of tool
@@ -258,30 +259,30 @@ CMPTEST()
     # any unexpected output from that stream too.
     TESTING $H5MKGRP $@
     (
-    cd $TESTDIR
-    $RUNSERIAL $H5MKGRP_BIN $@
+        cd $TESTDIR
+        $RUNSERIAL $H5MKGRP_BIN $@
     ) >$actual 2>$actual_err
     cat $actual_err >> $actual
 
-   if [ ! -f $expect ]; then
-    # Create the expect file if it doesn't yet exist.
-      echo " CREATED"
-      cp $actual $expect
-      echo "    Expected result (*.txt) missing"
-      nerrors="`expr $nerrors + 1`"
-   elif $CMP $expect $actual; then
-      echo " PASSED"
-   else
-      echo "*FAILED*"
-      echo "    Expected result (*.txt) differs from actual result (*.out)"
-      nerrors="`expr $nerrors + 1`"
-      test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
-   fi
-
-   # Clean up output file
-   if test -z "$HDF5_NOCLEANUP"; then
-      rm -f $actual $actual_err
-   fi
+    if [ ! -f $expect ]; then
+        # Create the expect file if it doesn't yet exist.
+        echo " CREATED"
+        cp $actual $expect
+        echo "    Expected result (*.txt) missing"
+        nerrors="`expr $nerrors + 1`"
+    elif $CMP $expect $actual; then
+        echo " PASSED"
+    else
+        echo "*FAILED*"
+        echo "    Expected result (*.txt) differs from actual result (*.out)"
+        nerrors="`expr $nerrors + 1`"
+        test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
+    fi
+
+    # Clean up output file
+    if test -z "$HDF5_NOCLEANUP"; then
+        rm -f $actual $actual_err
+    fi
 }
 
 ##############################################################################
