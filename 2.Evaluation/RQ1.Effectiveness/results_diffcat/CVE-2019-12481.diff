diff --git a/applications/mp4box/filedump.c b/applications/mp4box/filedump.c
index ca0524baba..8973fbe4ff 100644
--- a/applications/mp4box/filedump.c
+++ b/applications/mp4box/filedump.c
@@ -2371,8 +2371,9 @@ void DumpTrackInfo(GF_ISOFile *file, u32 trackID, Bool full_dump)
 	        || (msub_type==GF_ISOM_SUBTYPE_HVT1)
 	   )  {
 		esd = gf_isom_get_esd(file, trackNum, 1);
-		if (!esd) {
+		if (!esd || !esd->decoderConfig) {
 			fprintf(stderr, "WARNING: Broken MPEG-4 Track\n");
+			if (esd) gf_odf_desc_del((GF_Descriptor *)esd);
 		} else {
 			const char *st = gf_odf_stream_type_name(esd->decoderConfig->streamType);
 			if (st) {
@@ -2796,7 +2797,7 @@ void DumpTrackInfo(GF_ISOFile *file, u32 trackID, Bool full_dump)
 		u32 w, h, i, count;
 		gf_isom_get_visual_info(file, trackNum, 1, &w, &h);
 		fprintf(stderr, "\tAOM AV1 stream - Resolution %d x %d\n", w, h);
-		
+
 		av1c = gf_isom_av1_config_get(file, trackNum, 1);
 		fprintf(stderr, "\tversion=%u, profile=%u, level_idx0=%u, tier=%u\n", (u32)av1c->version, (u32)av1c->seq_profile, (u32)av1c->seq_level_idx_0, (u32)av1c->seq_tier_0);
 		fprintf(stderr, "\thigh_bitdepth=%u, twelve_bit=%u, monochrome=%u\n", (u32)av1c->high_bitdepth, (u32)av1c->twelve_bit, (u32)av1c->monochrome);
diff --git a/src/isomedia/box_code_base.c b/src/isomedia/box_code_base.c
index 8407ba7abd..b2909ef01d 100644
--- a/src/isomedia/box_code_base.c
+++ b/src/isomedia/box_code_base.c
@@ -4035,9 +4035,10 @@ GF_Err audio_sample_entry_Read(GF_Box *s, GF_BitStream *bs)
 	data = (char*)gf_malloc(sizeof(char) * size);
 	gf_bs_read_data(bs, data, size);
 	for (i=0; i<size-8; i++) {
-		if (GF_4CC(data[i+4], data[i+5], data[i+6], data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {
+		if (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {
 			GF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);
 			e = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);
+			if (!e) gf_isom_box_add_for_dump_mode((GF_Box*)ptr, (GF_Box*)ptr->esd);
 			gf_bs_del(mybs);
 			break;
 		}
diff --git a/src/isomedia/box_code_drm.c b/src/isomedia/box_code_drm.c
index 3ce1ef72be..90f8e9b6ab 100644
--- a/src/isomedia/box_code_drm.c
+++ b/src/isomedia/box_code_drm.c
@@ -488,7 +488,7 @@ GF_Err iSLT_Write(GF_Box *s, GF_BitStream *bs)
 	if (!s) return GF_BAD_PARAM;
 	e = gf_isom_full_box_write(s, bs);
 	if (e) return e;
-	
+
 	gf_bs_write_u64(bs, ptr->salt);
 	return GF_OK;
 }
@@ -1363,6 +1363,10 @@ GF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, void *traf, GF_SampleEncr
 				sai->subsample_count = gf_bs_read_u16(bs);
 				sai->subsamples = (GF_CENCSubSampleEntry *)gf_malloc(sai->subsample_count*sizeof(GF_CENCSubSampleEntry));
 				for (j = 0; j < sai->subsample_count; j++) {
+					if (gf_bs_get_size(bs) - gf_bs_get_position(bs) < 6) {
+						gf_isom_cenc_samp_aux_info_del(sai);
+						return GF_ISOM_INVALID_FILE;
+					}
 					sai->subsamples[j].bytes_clear_data = gf_bs_read_u16(bs);
 					sai->subsamples[j].bytes_encrypted_data = gf_bs_read_u32(bs);
 				}
diff --git a/src/isomedia/drm_sample.c b/src/isomedia/drm_sample.c
index bd9d87621d..c58e8245ab 100644
--- a/src/isomedia/drm_sample.c
+++ b/src/isomedia/drm_sample.c
@@ -560,7 +560,7 @@ GF_Err gf_isom_get_original_format_type(GF_ISOFile *the_file, u32 trackNumber, u
 	if (!sea) return GF_BAD_PARAM;
 
 	sinf = (GF_ProtectionSchemeInfoBox*)gf_list_get(sea->protections, 0);
-	if (outOriginalFormat && sinf->original_format) {
+	if (outOriginalFormat && sinf && sinf->original_format) {
 		*outOriginalFormat = sinf->original_format->data_format;
 	}
 	return GF_OK;
diff --git a/src/media_tools/dash_segmenter.c b/src/media_tools/dash_segmenter.c
index 324ab04427..b7389aaf04 100644
--- a/src/media_tools/dash_segmenter.c
+++ b/src/media_tools/dash_segmenter.c
@@ -476,7 +476,7 @@ GF_Err gf_media_get_rfc_6381_codec_name(GF_ISOFile *movie, u32 track, char *szCo
 	switch (subtype) {
 	case GF_ISOM_SUBTYPE_MPEG4:
 		esd = gf_isom_get_esd(movie, track, 1);
-		if (esd) {
+		if (esd && esd->decoderConfig) {
 			switch (esd->decoderConfig->streamType) {
 			case GF_STREAM_AUDIO:
 				if (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {
@@ -528,6 +528,7 @@ GF_Err gf_media_get_rfc_6381_codec_name(GF_ISOFile *movie, u32 track, char *szCo
 			return GF_OK;
 		} else {
 			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[RFC6381] Cannot find ESD. Aborting.\n"));
+			if (esd) gf_odf_desc_del((GF_Descriptor *)esd);
 			return GF_ISOM_INVALID_FILE;
 		}
 	case GF_ISOM_SUBTYPE_AVC_H264:
@@ -685,7 +686,7 @@ GF_Err gf_media_get_rfc_6381_codec_name(GF_ISOFile *movie, u32 track, char *szCo
 		snprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, "%s.%01u.%02u%c.%02u", gf_4cc_to_str(subtype),
 			av1_state.config->seq_profile, av1_state.config->seq_level_idx_0, av1_state.config->seq_tier_0 ? 'H' : 'M',
 			av1_state.bit_depth);
-		
+
 		/* "All the other fields [...] are optional, mutually inclusive (all or none) fields." https://aomediacodec.github.io/av1-isobmff/ */
 		if (av1_state.color_description_present_flag) {
 			char tmp[RFC6381_CODEC_NAME_SIZE_MAX];
@@ -1698,7 +1699,7 @@ static GF_Err isom_segment_file(GF_ISOFile *input, const char *output_file, GF_D
 
 	if (force_timescale)
 		gf_isom_set_timescale(output, force_timescale);
-		
+
 	//flush movie
 	e = gf_isom_finalize_for_fragment(output, 1);
 	if (e) goto err_exit;
diff --git a/src/odf/ipmpx_code.c b/src/odf/ipmpx_code.c
index d829707d23..551935eae7 100644
--- a/src/odf/ipmpx_code.c
+++ b/src/odf/ipmpx_code.c
@@ -1096,8 +1096,14 @@ static void DelGF_IPMPX_RemoveToolNotificationListener(GF_IPMPX_Data *_p)
 static GF_Err ReadGF_IPMPX_RemoveToolNotificationListener(GF_BitStream *bs, GF_IPMPX_Data *_p, u32 size)
 {
 	u32 i;
+	u8 count;
 	GF_IPMPX_RemoveToolNotificationListener*p = (GF_IPMPX_RemoveToolNotificationListener*)_p;
-	p->eventTypeCount = gf_bs_read_int(bs, 8);
+	p->eventTypeCount = 0;
+	count = gf_bs_read_int(bs, 8);
+	if (count > ARRAY_LENGTH(p->eventType))
+		return GF_CORRUPTED_DATA;
+
+	p->eventTypeCount = count;
 	for (i=0; i<p->eventTypeCount; i++) p->eventType[i] = gf_bs_read_int(bs, 8);
 	return GF_OK;
 }
