diff --git a/src/bits.c b/src/bits.c
index e1877575..02cd1c43 100644
--- a/src/bits.c
+++ b/src/bits.c
@@ -1602,6 +1602,45 @@ bit_embed_TU_size (BITCODE_TU restrict wstr, const int len)
   return str;
 }
 
+/* len of wide string (unix-only) */
+int
+bit_wcs2nlen (BITCODE_TU restrict wstr, const size_t maxlen)
+{
+  size_t len;
+
+  if (!wstr)
+    return 0;
+  len = 0;
+#  ifdef HAVE_ALIGNED_ACCESS_REQUIRED
+  // for strict alignment CPU's like sparc only. also for UBSAN.
+  if ((uintptr_t)wstr % SIZEOF_SIZE_T)
+    {
+      unsigned char *b = (unsigned char *)wstr;
+      uint16_t c = (b[0] << 8) + b[1];
+      while (c)
+        {
+          len++;
+          if (len > maxlen)
+            return 0;
+          b += 2;
+          c = (b[0] << 8) + b[1];
+        }
+      return (int)len;
+    }
+  else
+#  endif
+  {
+    BITCODE_TU c = wstr;
+    while (*c++)
+      {
+        len++;
+        if (len > maxlen)
+          return 0;
+      }
+    return (int)len;
+  }
+}
+
 #ifndef HAVE_NATIVE_WCHAR2
 
 /* len of wide string (unix-only) */
diff --git a/src/bits.h b/src/bits.h
index 9f029938..5d3448f9 100644
--- a/src/bits.h
+++ b/src/bits.h
@@ -260,6 +260,9 @@ int bit_wcs2len (BITCODE_TU restrict wstr);
 BITCODE_TU bit_wcs2cpy (BITCODE_TU restrict dest, const BITCODE_TU restrict src);
 int bit_wcs2cmp (BITCODE_TU restrict s1, const BITCODE_TU restrict s2);
 #endif
+/* bounded length of UCS-2 string. stops scanning at maxlen.
+   Beware: might overflow to negative lengths */
+int bit_wcs2nlen (BITCODE_TU restrict wstr, const size_t maxlen);
 
 /* Converts UCS-2 to UTF-8, returning a copy. */
 EXPORT char *bit_convert_TU (BITCODE_TU restrict wstr) ATTRIBUTE_MALLOC;
diff --git a/src/dwg.spec b/src/dwg.spec
index ee4ffc21..5bf6c078 100644
--- a/src/dwg.spec
+++ b/src/dwg.spec
@@ -3014,8 +3014,10 @@ DWG_OBJECT (LTYPE)
             if (_obj->dashes[rcount1].shape_flag & 2)
               {
                 static int dash_i = 0;
+                if (dash_i >= 512)
+                  break;
                 _obj->dashes[rcount1].text = (char*)&_obj->strings_area[dash_i];
-                dash_i += bit_wcs2len ((BITCODE_TU)_obj->dashes[rcount1].text) + 2;
+                dash_i += bit_wcs2nlen ((BITCODE_TU)_obj->dashes[rcount1].text, 512 - dash_i) + 2;
               }
           }
       }
diff --git a/configure.ac b/configure.ac
index 3d6c66be..00c1c3d6 100644
--- a/configure.ac
+++ b/configure.ac
@@ -249,7 +249,7 @@ AC_CHECK_FUNCS([scandir],[],
 AC_CHECK_FUNCS([floor sqrt])
 AC_CHECK_LIB([m],[floor])
 AC_CHECK_LIB([m],[sqrt])
-AC_CHECK_FUNCS([memchr memmove strcasecmp strchr strrchr strtol strtoul strtoull])
+AC_CHECK_FUNCS([memchr memmove strcasecmp strchr strrchr strtol strtoul strtoull strnlen])
 AC_CHECK_FUNCS([memmem],[],
   AC_MSG_WARN([memmem not found. Using a slower workaround.]))
 AC_CHECK_FUNCS([wcslen wcsnlen wcscpy wcscmp])
diff --git a/src/bits.c b/src/bits.c
index 382e7956..b8ec4904 100644
--- a/src/bits.c
+++ b/src/bits.c
@@ -1622,7 +1622,7 @@ bit_wcs2nlen (const BITCODE_TU restrict wstr, const size_t maxlen)
       while (c)
         {
           len++;
-          if (len > maxlen)
+          if (len >= maxlen)
             return 0;
           b += 2;
           c = (b[0] << 8) + b[1];
@@ -1633,11 +1633,12 @@ bit_wcs2nlen (const BITCODE_TU restrict wstr, const size_t maxlen)
 #  endif
   {
     BITCODE_TU c = wstr;
-    while (*c++)
+    while (*c)
       {
         len++;
-        if (len > maxlen)
+        if (len >= maxlen)
           return 0;
+        c++;
       }
     return len;
   }
@@ -1750,6 +1751,28 @@ bit_wcs2cmp (BITCODE_TU restrict dest, const BITCODE_TU restrict src)
 
 #endif /* HAVE_NATIVE_WCHAR2 */
 
+#ifndef HAVE_STRNLEN
+/* bounds-checked len of string */
+size_t
+bit_strnlen (const char *restrict str, const size_t maxlen)
+{
+  size_t len;
+  char *c = str;
+
+  if (!str)
+    return 0;
+  len = 0;
+  while (*c)
+    {
+      len++;
+      if (len >= maxlen)
+        return 0;
+      c++;
+    }
+  return len;
+}
+#endif
+
 /* converts TU to ASCII with embedded \U+XXXX */
 char *
 bit_embed_TU (BITCODE_TU restrict wstr)
diff --git a/src/bits.h b/src/bits.h
index f622cdd8..b798c319 100644
--- a/src/bits.h
+++ b/src/bits.h
@@ -270,6 +270,11 @@ BITCODE_TU bit_wcs2cpy (BITCODE_TU restrict dest,
 int bit_wcs2cmp (BITCODE_TU restrict s1, const BITCODE_TU restrict s2);
 #endif
 
+#ifndef HAVE_STRNLEN
+size_t bit_strnlen (const char *restrict str, const size_t maxlen);
+#define strnlen (str, maxlen) bit_strnlen(str, maxlen)
+#endif
+
 /* Converts UCS-2 to UTF-8, returning a copy. */
 EXPORT char *bit_convert_TU (BITCODE_TU restrict wstr) ATTRIBUTE_MALLOC;
 
diff --git a/src/config.h.in b/src/config.h.in
index ad93c5ba..d29a097e 100644
--- a/src/config.h.in
+++ b/src/config.h.in
@@ -156,6 +156,9 @@
 /* Define to 1 if you have the <string.h> header file. */
 #undef HAVE_STRING_H
 
+/* Define to 1 if you have the `strnlen' function. */
+#undef HAVE_STRNLEN
+
 /* Define to 1 if you have the `strrchr' function. */
 #undef HAVE_STRRCHR
 
diff --git a/src/dwg.spec b/src/dwg.spec
index 07182460..4e8ad166 100644
--- a/src/dwg.spec
+++ b/src/dwg.spec
@@ -2997,9 +2997,15 @@ DWG_OBJECT (LTYPE)
           {
             if (_obj->dashes[rcount1].shape_flag & 2)
               {
-                static int dash_i = 0;
+                static unsigned int dash_i = 0;
+                if (dash_i >= 256)
+                  {
+                    LOG_ERROR ("dashes[%u] overflow @%u", rcount1, dash_i)
+                    break;
+                  }
                 _obj->dashes[rcount1].text = (char*)&_obj->strings_area[dash_i];
-                dash_i += strlen (_obj->dashes[rcount1].text) + 1;
+                LOG_TRACE ("dashes[%u] @%u\n", rcount1, dash_i)
+                dash_i += strnlen (_obj->dashes[rcount1].text, 256 - dash_i) + 1;
               }
           }
       }
@@ -3015,9 +3021,13 @@ DWG_OBJECT (LTYPE)
               {
                 static unsigned int dash_i = 0;
                 if (dash_i >= 512)
-                  break;
+                  {
+                    LOG_ERROR ("dashes[%u] overflow @%u", rcount1, dash_i)
+                    break;
+                  }
                 _obj->dashes[rcount1].text = (char*)&_obj->strings_area[dash_i];
-                dash_i += bit_wcs2nlen ((BITCODE_TU)_obj->dashes[rcount1].text, 512 - dash_i) + 2;
+                LOG_TRACE ("dashes[%u] @%u\n", rcount1, dash_i)
+                dash_i += (2 * bit_wcs2nlen ((BITCODE_TU)_obj->dashes[rcount1].text, 256 - (dash_i / 2))) + 2;
               }
           }
       }
