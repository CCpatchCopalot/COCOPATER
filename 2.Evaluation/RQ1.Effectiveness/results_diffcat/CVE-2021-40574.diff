diff --git a/src/filters/load_text.c b/src/filters/load_text.c
index 4f41d2d3b..b82d2991b 100644
--- a/src/filters/load_text.c
+++ b/src/filters/load_text.c
@@ -255,7 +255,7 @@ char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicod
 {
 	u32 i, j, len;
 	char *sOK;
-	char szLineConv[1024];
+	char szLineConv[2048];
 	unsigned short *sptr;
 
 	memset(szLine, 0, sizeof(char)*lineSize);
@@ -328,7 +328,7 @@ char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicod
 		}
 	}
 	sptr = (u16 *)szLine;
-	i = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr);
+	i = (u32) gf_utf8_wcstombs(szLineConv, 2048, (const unsigned short **) &sptr);
 	szLineConv[i] = 0;
 	strcpy(szLine, szLineConv);
 	/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \0 after a \n*/
@@ -2338,6 +2338,8 @@ static GF_Err gf_text_process_sub(GF_Filter *filter, GF_TXTIn *ctx)
 		while (szLine[i+1] && szLine[i+1]!='}') {
 			szTime[i] = szLine[i+1];
 			i++;
+			if (i>=19)
+				break;
 		}
 		szTime[i] = 0;
 		ctx->start = atoi(szTime);
diff --git a/applications/mp4box/filedump.c b/applications/mp4box/filedump.c
index 6e773f42e..eaa8af451 100644
--- a/applications/mp4box/filedump.c
+++ b/applications/mp4box/filedump.c
@@ -3782,10 +3782,10 @@ void DumpMovieInfo(GF_ISOFile *file, Bool full_dump)
 			fprintf(stderr, "unknown type %d\n", type);
 		} else {
 			u16 *src_str = (u16 *) data;
-			u32 len = (u32) ( UTF8_MAX_BYTES_PER_CHAR * gf_utf8_wcslen(src_str) );
+			u32 len = UTF8_MAX_BYTES_PER_CHAR * gf_utf8_wcslen(src_str);
 			char *utf8str = (char *)gf_malloc(len + 1);
-			u32 res_len = (u32) gf_utf8_wcstombs(utf8str, len, (const unsigned short **) &src_str);
-			if (res_len != (u32) -1) {
+			u32 res_len = gf_utf8_wcstombs(utf8str, len, (const unsigned short **) &src_str);
+			if (res_len != GF_UTF8_FAIL) {
 				utf8str[res_len] = 0;
 				fprintf(stderr, "%s\n", utf8str);
 			}
diff --git a/include/gpac/main.h b/include/gpac/main.h
index 741cede11..e85afe88e 100644
--- a/include/gpac/main.h
+++ b/include/gpac/main.h
@@ -57,8 +57,8 @@ int wmain( int argc, wchar_t** wargv )\
 {\
 	int i;\
 	int res;\
-	size_t len;\
-	size_t res_len;\
+	u32 len;\
+	u32 res_len;\
 	char **argv;\
 	argv = (char **)malloc(argc*sizeof(wchar_t *));\
 	for (i = 0; i < argc; i++) {\
@@ -66,7 +66,8 @@ int wmain( int argc, wchar_t** wargv )\
 		len = UTF8_MAX_BYTES_PER_CHAR*gf_utf8_wcslen(wargv[i]);\
 		argv[i] = (char *)malloc(len + 1);\
 		res_len = gf_utf8_wcstombs(argv[i], len, (const unsigned short **) &src_str);\
-		argv[i][res_len] = 0;\
+		if (res_len != GF_UTF8_FAIL)\
+			argv[i][res_len] = 0;\
 		if (res_len > len) {\
 			fprintf(stderr, "Length allocated for conversion of wide char to UTF-8 not sufficient\n");\
 			return -1;\
diff --git a/include/gpac/utf.h b/include/gpac/utf.h
index 245273d95..399fbd95e 100644
--- a/include/gpac/utf.h
+++ b/include/gpac/utf.h
@@ -49,6 +49,7 @@ The wide characters in GPAC are unsignad shorts, in other words GPAC only suppor
 
 #include <gpac/tools.h>
 
+#define GF_UTF8_FAIL	0xFFFFFFFF
 /*!
 \brief wide-char to multibyte conversion
 
@@ -56,9 +57,9 @@ Converts a wide-char string to a multibyte string
 \param dst multibyte destination buffer
 \param dst_len multibyte destination buffer size
 \param srcp address of the wide-char string. This will be set to the next char to be converted in the input buffer if not enough space in the destination, or NULL if conversion was completed.
-\return length (in byte) of the multibyte string or -1 if error.
+\return length (in byte) of the multibyte string or GF_UTF8_FAIL if error.
  */
-size_t gf_utf8_wcstombs(char* dst, size_t dst_len, const unsigned short** srcp);
+u32 gf_utf8_wcstombs(char* dst, size_t dst_len, const unsigned short** srcp);
 
 /*!
 \brief multibyte to wide-char conversion
@@ -67,9 +68,9 @@ Converts a multibyte string to a wide-char string
 \param dst wide-char destination buffer
 \param dst_len wide-char destination buffer size
 \param srcp address of the multibyte character buffer. This will be set to the next char to be converted in the input buffer if not enough space in the destination, or NULL if conversion was completed.
-\return length (in unsigned short) of the wide-char string or -1 if error.
+\return length (in unsigned short) of the wide-char string or GF_UTF8_FAIL if error.
  */
-size_t gf_utf8_mbstowcs(unsigned short* dst, size_t dst_len, const char** srcp);
+u32 gf_utf8_mbstowcs(unsigned short* dst, size_t dst_len, const char** srcp);
 
 /*!
 \brief wide-char string length
@@ -78,7 +79,7 @@ Gets the length in character of a wide-char string
 \param s the wide-char string
 \return the wide-char string length
  */
-size_t gf_utf8_wcslen(const unsigned short *s);
+u32 gf_utf8_wcslen(const unsigned short *s);
 
 /*!
 \brief returns a UTF8 string from a string started with BOM
diff --git a/modules/ft_font/ft_font.c b/modules/ft_font/ft_font.c
index 97267e870..8df9b35ee 100644
--- a/modules/ft_font/ft_font.c
+++ b/modules/ft_font/ft_font.c
@@ -593,7 +593,6 @@ static GF_Err ft_get_font_info(GF_FontReader *dr, char **font_name, u32 *em_size
 
 static GF_Err ft_get_glyphs(GF_FontReader *dr, const char *utf_string, u32 *glyph_buffer, u32 *io_glyph_buffer_size, const char *xml_lang, Bool *is_rtl)
 {
-	size_t _len;
 	u32 len;
 	u32 i;
 	u16 *conv;
@@ -613,9 +612,8 @@ static GF_Err ft_get_glyphs(GF_FontReader *dr, const char *utf_string, u32 *glyp
 		*io_glyph_buffer_size = len+1;
 		return GF_BUFFER_TOO_SMALL;
 	}
-	_len = gf_utf8_mbstowcs((u16*) glyph_buffer, *io_glyph_buffer_size, (const char **) &utf8);
-	if (_len==(size_t)-1) return GF_IO_ERR;
-	len = (u32) _len;
+	len = gf_utf8_mbstowcs((u16*) glyph_buffer, *io_glyph_buffer_size, (const char **) &utf8);
+	if (len == GF_UTF8_FAIL) return GF_IO_ERR;
 	if (utf8) return GF_IO_ERR;
 
 	/*perform bidi relayout*/
diff --git a/src/compositor/compositor.c b/src/compositor/compositor.c
index 1f4b6c03e..08936cf74 100644
--- a/src/compositor/compositor.c
+++ b/src/compositor/compositor.c
@@ -3799,7 +3799,7 @@ GF_EXPORT
 const char *gf_sc_get_selected_text(GF_Compositor *compositor)
 {
 	const u16 *srcp;
-	size_t len;
+	u32 len;
 	if (compositor->store_text_state != GF_SC_TSEL_FROZEN) return NULL;
 
 	gf_sc_lock(compositor, GF_TRUE);
@@ -3819,7 +3819,7 @@ const char *gf_sc_get_selected_text(GF_Compositor *compositor)
 	if (compositor->selected_text) gf_free(compositor->selected_text);
 	compositor->selected_text = gf_malloc(sizeof(char)*2*compositor->sel_buffer_len);
 	len = gf_utf8_wcstombs((char *) compositor->selected_text, 2*compositor->sel_buffer_len, &srcp);
-	if ((s32)len<0) len = 0;
+	if (len == GF_UTF8_FAIL) len = 0;
 	compositor->selected_text[len] = 0;
 	gf_sc_lock(compositor, GF_FALSE);
 
diff --git a/src/compositor/events.c b/src/compositor/events.c
index bfff1e7ed..03c91d0fb 100644
--- a/src/compositor/events.c
+++ b/src/compositor/events.c
@@ -86,12 +86,12 @@ static void flush_text_node_edit(GF_Compositor *compositor, Bool final_flush)
 	}
 	if (compositor->sel_buffer_len) {
 		char *txt;
-		size_t len;
+		u32 len;
 		const u16 *lptr;
 		txt = (char*)gf_malloc(sizeof(char)*2*compositor->sel_buffer_len);
 		lptr = compositor->sel_buffer;
 		len = gf_utf8_wcstombs(txt, 2*compositor->sel_buffer_len, &lptr);
-		if ((s32)len<0) len = 0;
+		if (len == GF_UTF8_FAIL) len = 0;
 		txt[len] = 0;
 		*compositor->edited_text = gf_strdup(txt);
 		gf_free(txt);
@@ -135,18 +135,19 @@ static void flush_text_node_edit(GF_Compositor *compositor, Bool final_flush)
 GF_Err gf_sc_paste_text(GF_Compositor *compositor, const char *text)
 {
 	u16 *conv_buf;
-	size_t len;
+	u32 len;
 	if (!compositor->sel_buffer || !compositor->edited_text) return GF_BAD_PARAM;
 	if (!text) return GF_OK;
-	len = strlen(text);
+	len = (u32) strlen(text);
 	if (!len) return GF_OK;
 
 	gf_sc_lock(compositor, GF_TRUE);
 
 	conv_buf = (u16*)gf_malloc(sizeof(u16)*(len+1));
 	len = gf_utf8_mbstowcs(conv_buf, len, &text);
+	if (len == GF_UTF8_FAIL) return GF_IO_ERR;
 
-	compositor->sel_buffer_alloc += (u32) len;
+	compositor->sel_buffer_alloc += len;
 	if (compositor->sel_buffer_len == compositor->sel_buffer_alloc)
 		compositor->sel_buffer_alloc++;
 
@@ -154,8 +155,8 @@ GF_Err gf_sc_paste_text(GF_Compositor *compositor, const char *text)
 	memmove(&compositor->sel_buffer[compositor->caret_pos+len], &compositor->sel_buffer[compositor->caret_pos], sizeof(u16)*(compositor->sel_buffer_len-compositor->caret_pos));
 	memcpy(&compositor->sel_buffer[compositor->caret_pos], conv_buf, sizeof(u16)*len);
 	gf_free(conv_buf);
-	compositor->sel_buffer_len += (u32) len;
-	compositor->caret_pos += (u32) len;
+	compositor->sel_buffer_len += len;
+	compositor->caret_pos += len;
 	compositor->sel_buffer[compositor->sel_buffer_len]=0;
 	flush_text_node_edit(compositor, GF_FALSE);
 	gf_sc_lock(compositor, GF_FALSE);
@@ -281,7 +282,7 @@ static Bool load_text_node(GF_Compositor *compositor, u32 cmd_type)
 							gf_node_list_insert_child(&children, t, pos);
 							res = &((GF_DOMText *)child->node)->textContent;
 						} else {
-							size_t len;
+							u32 len;
 							GF_DOMText *cur;
 
 							gf_node_list_insert_child(&children, t, pos+1);
@@ -299,7 +300,7 @@ static Bool load_text_node(GF_Compositor *compositor, u32 cmd_type)
 							cur->textContent = (char*)gf_malloc(sizeof(char)*(len+1));
 							srcp = compositor->sel_buffer;
 							len = gf_utf8_wcstombs(cur->textContent, len, &srcp);
-							if ((s32)len<0) len = 0;
+							if (len == GF_UTF8_FAIL) len = 0;
 							cur->textContent[len] = 0;
 							compositor->sel_buffer[compositor->caret_pos] = end;
 
@@ -308,7 +309,7 @@ static Bool load_text_node(GF_Compositor *compositor, u32 cmd_type)
 								ntext->textContent = (char*)gf_malloc(sizeof(char)*(len+1));
 								srcp = compositor->sel_buffer + compositor->caret_pos + 1;
 								len = gf_utf8_wcstombs(ntext->textContent, len, &srcp);
-								if ((s32)len<0) len = 0;
+								if (len == GF_UTF8_FAIL) len = 0;
 								ntext->textContent[len] = 0;
 							} else {
 								ntext->textContent = gf_strdup("");
@@ -372,15 +373,17 @@ static Bool load_text_node(GF_Compositor *compositor, u32 cmd_type)
 		compositor->sel_buffer = (u16*)gf_realloc(compositor->sel_buffer, sizeof(u16)*compositor->sel_buffer_alloc);
 
 		if (caret_pos>=0) {
-			size_t l = gf_utf8_mbstowcs(compositor->sel_buffer, compositor->sel_buffer_alloc, &src);
-			compositor->sel_buffer_len = (u32) l;
+			u32 l = gf_utf8_mbstowcs(compositor->sel_buffer, compositor->sel_buffer_alloc, &src);
+			if (l == GF_UTF8_FAIL) return GF_FALSE;
+			compositor->sel_buffer_len = l;
 			memmove(&compositor->sel_buffer[caret_pos+1], &compositor->sel_buffer[caret_pos], sizeof(u16)*(compositor->sel_buffer_len-caret_pos));
 			compositor->sel_buffer[caret_pos] = GF_CARET_CHAR;
 			compositor->caret_pos = caret_pos;
 
 		} else {
-			size_t l = gf_utf8_mbstowcs(compositor->sel_buffer, compositor->sel_buffer_alloc, &src);
-			compositor->sel_buffer_len = (u32) l;
+			u32 l = gf_utf8_mbstowcs(compositor->sel_buffer, compositor->sel_buffer_alloc, &src);
+			if (l == GF_UTF8_FAIL) return GF_FALSE;
+			compositor->sel_buffer_len = l;
 			compositor->sel_buffer[compositor->sel_buffer_len] = GF_CARET_CHAR;
 			compositor->caret_pos = compositor->sel_buffer_len;
 		}
diff --git a/src/compositor/mpeg4_inputsensor.c b/src/compositor/mpeg4_inputsensor.c
index 04a24f167..d74f68388 100644
--- a/src/compositor/mpeg4_inputsensor.c
+++ b/src/compositor/mpeg4_inputsensor.c
@@ -356,14 +356,14 @@ static GF_Err IS_ProcessData(GF_InputSensorCtx *is_ctx, const char *inBuffer, u3
 		field1->eventType = field2->eventType = 0;
 		is_ctx->enteredText[is_ctx->text_len] = (short) '\0';
 
-		len = (u32) gf_utf8_wcslen(is_ctx->enteredText);
+		len = gf_utf8_wcslen(is_ctx->enteredText);
 		if (len && (is_ctx->enteredText[len-1] == is_ctx->termChar)) {
 			ptr = is_ctx->enteredText;
-			len = (u32) gf_utf8_wcstombs(tmp_utf8, 5000, &ptr);
-			if ((s32)len<0) len = 1;
+			len = gf_utf8_wcstombs(tmp_utf8, 5000, &ptr);
+			if (len == GF_UTF8_FAIL) len = 1;
 			if (outText->buffer) gf_free(outText->buffer);
 			outText->buffer = (char*)gf_malloc(sizeof(char) * (len));
-			memcpy(outText->buffer, tmp_utf8, sizeof(char) * len-1);
+			memcpy(outText->buffer, tmp_utf8, sizeof(char) * (len-1) );
 			outText->buffer[len-1] = 0;
 			if (inText->buffer) gf_free(inText->buffer);
 			inText->buffer = NULL;
@@ -382,8 +382,8 @@ static GF_Err IS_ProcessData(GF_InputSensorCtx *is_ctx, const char *inBuffer, u3
 			}
 			is_ctx->text_len = len;
 			ptr = is_ctx->enteredText;
-			len = (u32) gf_utf8_wcstombs(tmp_utf8, 5000, &ptr);
-			if ((s32)len<0) len = 0;
+			len = gf_utf8_wcstombs(tmp_utf8, 5000, &ptr);
+			if (len == GF_UTF8_FAIL) len = 0;
 			if (inText->buffer) gf_free(inText->buffer);
 			inText->buffer = (char*)gf_malloc(sizeof(char) * (len+1));
 			memcpy(inText->buffer, tmp_utf8, sizeof(char) * len);
@@ -795,8 +795,8 @@ Bool gf_sc_input_sensor_keyboard_input(GF_Compositor *compositor, u32 key_code,
 			tc[0] = keyPressed;
 			tc[1] = 0;
 			ptr = tc;
-			len = (u32) gf_utf8_wcstombs(szStr, 10, &ptr);
-			if ((s32)len<0) len = 0;
+			len = gf_utf8_wcstombs(szStr, 10, &ptr);
+			if (len == GF_UTF8_FAIL) len = 0;
 			n->keyPress.buffer = (char*)gf_malloc(sizeof(char) * (len+1));
 			memcpy(n->keyPress.buffer, szStr, sizeof(char) * len);
 			n->keyPress.buffer[len] = 0;
@@ -807,8 +807,8 @@ Bool gf_sc_input_sensor_keyboard_input(GF_Compositor *compositor, u32 key_code,
 			tc[0] = keyReleased;
 			tc[1] = 0;
 			ptr = tc;
-			len = (u32) gf_utf8_wcstombs(szStr, 10, &ptr);
-			if ((s32)len<0) len = 0;
+			len = gf_utf8_wcstombs(szStr, 10, &ptr);
+			if (len == GF_UTF8_FAIL) len = 0;
 			n->keyRelease.buffer = (char*)gf_malloc(sizeof(char) * (len+1));
 			memcpy(n->keyRelease.buffer, szStr, sizeof(char) * len);
 			n->keyRelease.buffer[len] = 0;
@@ -904,8 +904,8 @@ void gf_sc_input_sensor_string_input(GF_Compositor *compositor, u32 character)
 				st->text_len -= 1;
 				st->enteredText[st->text_len] = 0;
 				ptr = st->enteredText;
-				len = (u32) gf_utf8_wcstombs(szStr, 10, &ptr);
-				if ((s32)len<0) len = 0;
+				len = gf_utf8_wcstombs(szStr, 10, &ptr);
+				if (len == GF_UTF8_FAIL) len = 0;
 				if (n->enteredText.buffer) gf_free(n->enteredText.buffer);
 				szStr[len] = 0;
 				n->enteredText.buffer = gf_strdup(szStr);
@@ -923,8 +923,8 @@ void gf_sc_input_sensor_string_input(GF_Compositor *compositor, u32 character)
 			st->text_len += 1;
 			st->enteredText[st->text_len] = 0;
 			ptr = st->enteredText;
-			len = (u32) gf_utf8_wcstombs(szStr, 10, &ptr);
-			if ((s32)len<0) len = 0;
+			len = gf_utf8_wcstombs(szStr, 10, &ptr);
+			if (len == GF_UTF8_FAIL) len = 0;
 			if (n->enteredText.buffer) gf_free(n->enteredText.buffer);
 			szStr[len] = 0;
 			n->enteredText.buffer = gf_strdup(szStr);
diff --git a/src/compositor/svg_font.c b/src/compositor/svg_font.c
index 2e423e187..9d4965898 100644
--- a/src/compositor/svg_font.c
+++ b/src/compositor/svg_font.c
@@ -44,7 +44,7 @@ typedef struct
 static GF_Err svg_font_get_glyphs(void *udta, const char *utf_string, u32 *glyph_buffer, u32 *io_glyph_buffer_size, const char *lang, Bool *is_rtl)
 {
 	u32 prev_c;
-	size_t len;
+	u32 len;
 	u32 i, gl_idx;
 	u16 *utf_res;
 	GF_Node *node = (GF_Node *)udta;
@@ -64,16 +64,16 @@ static GF_Err svg_font_get_glyphs(void *udta, const char *utf_string, u32 *glyph
 	}
 
 	len = gf_utf8_mbstowcs((u16*) glyph_buffer, *io_glyph_buffer_size, (const char**)&utf8);
-	if (len == (size_t) -1) return GF_IO_ERR;
+	if (len == GF_UTF8_FAIL) return GF_IO_ERR;
 	/*should not happen*/
 	if (utf8) return GF_IO_ERR;
 
 	/*perform bidi relayout*/
 	utf_res = (u16 *) glyph_buffer;
-	*is_rtl = gf_utf8_reorder_bidi(utf_res, (u32) len);
+	*is_rtl = gf_utf8_reorder_bidi(utf_res, len);
 
 	/*move 16bit buffer to 32bit*/
-	for (i=(u32)len; i>0; i--) {
+	for (i=len; i>0; i--) {
 		glyph_buffer[i-1] = utf_res[i-1];
 	}
 
@@ -349,7 +349,7 @@ void compositor_init_svg_glyph(GF_Compositor *compositor, GF_Node *node)
 {
 	u16 utf_name[20];
 	u8 *utf8;
-	size_t len;
+	u32 len;
 	GF_Rect rc;
 	GF_Glyph *glyph;
 	GF_Font *font;
@@ -377,6 +377,7 @@ void compositor_init_svg_glyph(GF_Compositor *compositor, GF_Node *node)
 	if (!st) return;
 	utf8 = (u8 *) *atts.unicode;
 	len = gf_utf8_mbstowcs(utf_name, 200, (const char **) &utf8);
+	if (len == GF_UTF8_FAIL) return;
 	/*this is a single glyph*/
 	if (len==1) {
 		st->glyph.utf_name = utf_name[0];
diff --git a/src/filters/dasher.c b/src/filters/dasher.c
index 89fa2f814..867ed5882 100644
--- a/src/filters/dasher.c
+++ b/src/filters/dasher.c
@@ -2607,7 +2607,7 @@ static void dasher_setup_set_defaults(GF_DasherCtx *ctx, GF_MPD_AdaptationSet *s
 			for (j=0; j<role_count; j++) {
 				char *role = ds->p_role->value.string_list.vals[j];
 				GF_MPD_Descriptor *desc=NULL;
-				char *uri;
+				char *uri=NULL;
 				//all roles defined by dash 5th edition
 				if (!strcmp(role, "caption") || !strcmp(role, "subtitle") || !strcmp(role, "main")
 			        || !strcmp(role, "alternate") || !strcmp(role, "supplementary") || !strcmp(role, "commentary")
diff --git a/src/filters/dec_ttxt.c b/src/filters/dec_ttxt.c
index 4879f980d..11c4dacf0 100644
--- a/src/filters/dec_ttxt.c
+++ b/src/filters/dec_ttxt.c
@@ -656,8 +656,8 @@ static void ttd_new_text_chunk(GF_TTXTDec *ctx, GF_TextSampleDescriptor *tsd, M_
 				memcpy(wsChunk, &utf16_txt[start_char], sizeof(s16)*(i-start_char));
 				wsChunk[i-start_char] = 0;
 				sp = &wsChunk[0];
-				len = (u32) gf_utf8_wcstombs(szLine, 5000, (const unsigned short **) &sp);
-				if ((s32)len<0) len = 0;
+				len = gf_utf8_wcstombs(szLine, 5000, (const unsigned short **) &sp);
+				if (len == GF_UTF8_FAIL) len = 0;
 				szLine[len] = 0;
 
 				gf_sg_vrml_mf_append(&text->string, GF_SG_VRML_MFSTRING, (void **) &st);
@@ -919,7 +919,8 @@ static void ttd_apply_sample(GF_TTXTDec *ctx, GF_TextSample *txt, u32 sample_des
 		char_count = txt->len / 2;
 	} else {
 		char *p = txt->text;
-		char_count = (u32) gf_utf8_mbstowcs(utf16_text, 2500, (const char **) &p);
+		char_count = gf_utf8_mbstowcs(utf16_text, 2500, (const char **) &p);
+		if (char_count == GF_UTF8_FAIL) char_count = 0;
 	}
 
 	chunks = gf_list_new();
diff --git a/src/filters/load_text.c b/src/filters/load_text.c
index 6a4cd9175..abfe75f59 100644
--- a/src/filters/load_text.c
+++ b/src/filters/load_text.c
@@ -328,8 +328,8 @@ char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicod
 		}
 	}
 	sptr = (u16 *)szLine;
-	i = (u32) gf_utf8_wcstombs(szLineConv, 2048, (const unsigned short **) &sptr);
-	if ((s32)i<0) i = 0;
+	i = gf_utf8_wcstombs(szLineConv, 2048, (const unsigned short **) &sptr);
+	if (i == GF_UTF8_FAIL) i = 0;
 	szLineConv[i] = 0;
 	strcpy(szLine, szLineConv);
 	/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \0 after a \n*/
@@ -745,12 +745,12 @@ force_line:
 
 			ptr = (char *) szLine;
 			{
-				size_t _len = gf_utf8_mbstowcs(uniLine, 5000, (const char **) &ptr);
-				if (_len == (size_t) -1) {
+				len = gf_utf8_mbstowcs(uniLine, 5000, (const char **) &ptr);
+				if (len == GF_UTF8_FAIL) {
 					GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[TXTIn] Invalid UTF data (line %d)\n", ctx->curLine));
 					ctx->state = 0;
+					len = 0;
 				}
-				len = (u32) _len;
 			}
 			i=j=0;
 			rem_styles = 0;
@@ -770,8 +770,8 @@ force_line:
 				}
 				else if (uniLine[i]=='<')  {
 					const unsigned short* src = uniLine + i;
-					size_t alen = gf_utf8_wcstombs(szLine, 2048, (const unsigned short**) & src);
-					if (alen<0) alen = 0;
+					u32 alen = gf_utf8_wcstombs(szLine, 2048, (const unsigned short**) & src);
+					if (alen == GF_UTF8_FAIL) alen = 0;
 					szLine[alen] = 0;
 					strlwr(szLine);
 					if (!strncmp(szLine, "<font ", 6) ) {
@@ -943,8 +943,8 @@ force_line:
 			uniText[j] = 0;
 
 			sptr = (u16 *) uniText;
-			len = (u32) gf_utf8_wcstombs(szText, 5000, (const u16 **) &sptr);
-			if ((s32)len<0) len = 0;
+			len = gf_utf8_wcstombs(szText, 5000, (const u16 **) &sptr);
+			if (len == GF_UTF8_FAIL) len = 0;
 
 			gf_isom_text_add_text(ctx->samp, szText, len);
 			char_len += char_line;
diff --git a/src/filters/reframe_mp3.c b/src/filters/reframe_mp3.c
index da0af6d4e..d90c1ecf5 100644
--- a/src/filters/reframe_mp3.c
+++ b/src/filters/reframe_mp3.c
@@ -196,10 +196,10 @@ static void id3dmx_set_string(GF_FilterPid *apid, char *name, u8 *buf, Bool is_d
 {
 	if ((buf[0]==0xFF) || (buf[0]==0xFE)) {
 		const u16 *sptr = (u16 *) (buf+2);
-		s32 len = (s32) ( UTF8_MAX_BYTES_PER_CHAR * gf_utf8_wcslen(sptr) );
+		u32 len = UTF8_MAX_BYTES_PER_CHAR * gf_utf8_wcslen(sptr);
 		char *tmp = gf_malloc(len+1);
-		len = (s32) gf_utf8_wcstombs(tmp, len, &sptr);
-		if (len>=0) {
+		len = gf_utf8_wcstombs(tmp, len, &sptr);
+		if (len != GF_UTF8_FAIL) {
 			tmp[len] = 0;
 			if (is_dyn) {
 				gf_filter_pid_set_property_dyn(apid, name, &PROP_STRING(tmp) );
diff --git a/src/isomedia/box_dump.c b/src/isomedia/box_dump.c
index adc638401..0bc734a30 100644
--- a/src/isomedia/box_dump.c
+++ b/src/isomedia/box_dump.c
@@ -2968,7 +2968,7 @@ static GF_Err gf_isom_dump_ttxt_track(GF_ISOFile *the_file, u32 track, FILE *dum
 {
 	u32 i, j, count, di, nb_descs, shift_offset[20], so_count;
 	u64 last_DTS;
-	size_t len;
+	u32 len;
 	GF_Box *a;
 	Bool has_scroll;
 	char szDur[100];
@@ -3184,7 +3184,7 @@ static GF_Err gf_isom_dump_ttxt_track(GF_ISOFile *the_file, u32 track, FILE *dum
 				str = s_txt->text;
 				len = gf_utf8_mbstowcs((u16*)utf16Line, 10000, (const char **) &str);
 			}
-			if (len != (size_t) -1) {
+			if (len != GF_UTF8_FAIL) {
 				utf16Line[len] = 0;
 				for (j=0; j<len; j++) {
 					if ((utf16Line[j]=='\n') || (utf16Line[j]=='\r') || (utf16Line[j]==0x85) || (utf16Line[j]==0x2028) || (utf16Line[j]==0x2029) ) {
@@ -3449,9 +3449,8 @@ static GF_Err gf_isom_dump_srt_track(GF_ISOFile *the_file, u32 track, FILE *dump
 				len = txt->len;
 			} else {
 				u8 *str = (u8 *) (txt->text);
-				size_t res = gf_utf8_mbstowcs(utf16Line, 10000, (const char **) &str);
-				if (res==(size_t)-1) return GF_NON_COMPLIANT_BITSTREAM;
-				len = (u32) res;
+				len = gf_utf8_mbstowcs(utf16Line, 10000, (const char **) &str);
+				if (len == GF_UTF8_FAIL) return GF_NON_COMPLIANT_BITSTREAM;
 				utf16Line[len] = 0;
 			}
 			char_num = 0;
@@ -3507,15 +3506,15 @@ static GF_Err gf_isom_dump_srt_track(GF_ISOFile *the_file, u32 track, FILE *dump
 				}
 
 				if (!is_new_line) {
-					size_t sl;
+					u32 sl;
 					char szChar[30];
 					s16 swT[2], *swz;
 					swT[0] = utf16Line[j];
 					swT[1] = 0;
 					swz= (s16 *)swT;
 					sl = gf_utf8_wcstombs(szChar, 30, (const unsigned short **) &swz);
-					if (sl == (size_t)-1) sl=0;
-					szChar[(u32) sl]=0;
+					if (sl == GF_UTF8_FAIL) sl=0;
+					szChar[sl]=0;
 					gf_fprintf(dump, "%s", szChar);
 				}
 				char_num++;
@@ -6271,10 +6270,10 @@ GF_Err xtra_box_dump(GF_Box *a, FILE * trace)
 		gf_fprintf(trace, "<WMATag name=\"%s\" version=\"%d\" type=\"%d\"", tag->name, tag->flags, tag->prop_type);
 		if (!tag->prop_type) {
 			u16 *src_str = (u16 *) tag->prop_value;
-			u32 len = (u32) ( UTF8_MAX_BYTES_PER_CHAR * gf_utf8_wcslen(src_str) );
+			u32 len = UTF8_MAX_BYTES_PER_CHAR * gf_utf8_wcslen(src_str);
 			char *utf8str = (char *)gf_malloc(len + 1);
-			u32 res_len = (u32) gf_utf8_wcstombs(utf8str, len, (const unsigned short **) &src_str);
-			if (res_len != (u32) -1) {
+			u32 res_len = gf_utf8_wcstombs(utf8str, len, (const unsigned short **) &src_str);
+			if (res_len != GF_UTF8_FAIL) {
 				utf8str[res_len] = 0;
 
 				gf_fprintf(trace, " value=\"%s\">\n", utf8str);
diff --git a/src/isomedia/isom_write.c b/src/isomedia/isom_write.c
index d3b1cd0f0..1bdb5b71b 100644
--- a/src/isomedia/isom_write.c
+++ b/src/isomedia/isom_write.c
@@ -6135,11 +6135,10 @@ GF_Err gf_isom_wma_set_tag(GF_ISOFile *mov, char *name, char *value)
 	tag->prop_value = gf_malloc(sizeof(u16) * (len+1) );
 	memset(tag->prop_value, 0, sizeof(u16) * (len+1) );
 	if (len) {
-		u32 _len = (u32) gf_utf8_mbstowcs((u16 *) tag->prop_value, len, (const char **) &value);
-		if (_len != (u32) -1) {
-			tag->prop_value[2 * _len] = 0;
-			tag->prop_value[2 * _len + 1] = 0;
-		}
+		u32 _len = gf_utf8_mbstowcs((u16 *) tag->prop_value, len, (const char **) &value);
+		if (_len == GF_UTF8_FAIL) _len = 0;
+		tag->prop_value[2 * _len] = 0;
+		tag->prop_value[2 * _len + 1] = 0;
 		tag->prop_size = 2 * _len + 2;
 	} else {
 		tag->prop_size = 2;
diff --git a/src/odf/odf_code.c b/src/odf/odf_code.c
index de835ef5f..e71e48d37 100644
--- a/src/odf/odf_code.c
+++ b/src/odf/odf_code.c
@@ -47,7 +47,7 @@ static GFINLINE GF_Err OD_ReadUTF8String(GF_BitStream *bs, char **string, Bool i
 static GFINLINE u32 OD_SizeUTF8String(char *string, Bool isUTF8)
 {
 	if (isUTF8) return 1 + (u32) strlen(string);
-	return 1 + 2 * (u32) gf_utf8_wcslen((const unsigned short *)string);
+	return 1 + 2 * gf_utf8_wcslen((const unsigned short *)string);
 }
 
 static GFINLINE void OD_WriteUTF8String(GF_BitStream *bs, char *string, Bool isUTF8)
@@ -58,7 +58,7 @@ static GFINLINE void OD_WriteUTF8String(GF_BitStream *bs, char *string, Bool isU
 		gf_bs_write_int(bs, len, 8);
 		gf_bs_write_data(bs, string, len);
 	} else {
-		len = (u32) gf_utf8_wcslen((const unsigned short *)string);
+		len = gf_utf8_wcslen((const unsigned short *)string);
 		gf_bs_write_int(bs, len, 8);
 		gf_bs_write_data(bs, string, len*2);
 	}
@@ -2217,7 +2217,7 @@ GF_Err gf_odf_size_exp_text(GF_ExpandedTextual *etd, u32 *outSize)
 		if (etd->isUTF8) {
 			nonLen = (u32) strlen((const char*)etd->NonItemText);
 		} else {
-			nonLen = (u32) gf_utf8_wcslen((const unsigned short*)etd->NonItemText);
+			nonLen = gf_utf8_wcslen((const unsigned short*)etd->NonItemText);
 		}
 	} else {
 		nonLen = 0;
@@ -2267,7 +2267,7 @@ GF_Err gf_odf_write_exp_text(GF_BitStream *bs, GF_ExpandedTextual *etd)
 		if (etd->isUTF8) {
 			nonLen = (u32) strlen((const char*)etd->NonItemText);
 		} else {
-			nonLen = (u32) gf_utf8_wcslen((const unsigned short*)etd->NonItemText);
+			nonLen = gf_utf8_wcslen((const unsigned short*)etd->NonItemText);
 		}
 	} else {
 		nonLen = 0;
diff --git a/src/scene_manager/scene_dump.c b/src/scene_manager/scene_dump.c
index 03132e8f3..073a1ff6c 100644
--- a/src/scene_manager/scene_dump.c
+++ b/src/scene_manager/scene_dump.c
@@ -422,16 +422,14 @@ static void EndList(GF_SceneDumper *sdump, const char *name)
 
 static void scene_dump_utf_string(GF_SceneDumper *sdump, Bool escape_xml, char *str)
 {
-	size_t _len;
 	u32 len, i;
 	u16 *uniLine;
 	if (!str) return;
 	len = (u32) strlen(str);
 	if (!len) return;
 	uniLine = (u16*)gf_malloc(sizeof(u16) * len*4);
-	_len = gf_utf8_mbstowcs(uniLine, len, (const char **) &str);
-	if (_len != (size_t) (-1)) {
-		len = (u32) _len;
+	len = gf_utf8_mbstowcs(uniLine, len, (const char **) &str);
+	if (len != GF_UTF8_FAIL) {
 		for (i=0; i<len; i++) {
 			//if (uniLine[i] == (u16) '\"') gf_fprintf(sdump->trace, "\\");
 			switch (uniLine[i]) {
@@ -597,15 +595,12 @@ static void gf_dump_vrml_sffield(GF_SceneDumper *sdump, u32 type, void *ptr, Boo
 			gf_fprintf(sdump->trace, "\"%s\"", str);
 		}
 		else {
-			size_t _len;
 			u16 *uniLine;
 
 			uniLine = (u16*)gf_malloc(sizeof(short) * (len + 1));
-			_len = gf_utf8_mbstowcs(uniLine, len, (const char **)&str);
-
-			if (_len != (size_t)-1) {
-				len = (u32)_len;
+			len = gf_utf8_mbstowcs(uniLine, len, (const char **)&str);
 
+			if (len != GF_UTF8_FAIL) {
 				for (i = 0; i<len; i++) {
 
 					switch (uniLine[i]) {
@@ -702,7 +697,7 @@ static void gf_dump_vrml_sffield(GF_SceneDumper *sdump, u32 type, void *ptr, Boo
 			short uniLine[5000];
 			str = ((SFURL *)ptr)->url;
 			len = gf_utf8_mbstowcs(uniLine, 5000, (const char **) &str);
-			if (len != (size_t) -1) {
+			if (len != GF_UTF8_FAIL) {
 				gf_fprintf(sdump->trace, sdump->XMLDump ? (sdump->X3DDump ?  "'" : "&quot;") : "\"");
 				fwprintf(sdump->trace, (unsigned short *) uniLine);
 				gf_fprintf(sdump->trace, sdump->XMLDump ? (sdump->X3DDump ?  "'" : "&quot;") : "\"");
diff --git a/src/scene_manager/swf_bifs.c b/src/scene_manager/swf_bifs.c
index 7a9e4a551..cc0579201 100644
--- a/src/scene_manager/swf_bifs.c
+++ b/src/scene_manager/swf_bifs.c
@@ -848,7 +848,7 @@ static GF_Err swf_bifs_define_text(SWFReader *read, SWFText *text)
 		gf_node_register((GF_Node *) par, (GF_Node *)tr);
 
 		if (use_text) {
-			size_t _len;
+			u32 _len;
 			u16 *str_w, *widestr;
 			char *str;
 			void *ptr;
@@ -882,8 +882,8 @@ static GF_Err swf_bifs_define_text(SWFReader *read, SWFText *text)
 			str = (char*)gf_malloc(sizeof(char) * (gr->nbGlyphs+2));
 			widestr = str_w;
 			_len = gf_utf8_wcstombs(str, sizeof(u8) * (gr->nbGlyphs+1), (const unsigned short **) &widestr);
-			if (_len != (size_t) -1) {
-				j=(u32) _len;
+			if (_len != GF_UTF8_FAIL) {
+				j = _len;
 				str[j] = 0;
 				gf_sg_vrml_mf_reset(&t->string, GF_SG_VRML_MFSTRING);
 				gf_sg_vrml_mf_append(&t->string, GF_SG_VRML_MFSTRING, &ptr);
diff --git a/src/scene_manager/swf_svg.c b/src/scene_manager/swf_svg.c
index 7c4036e6f..656ec47e1 100644
--- a/src/scene_manager/swf_svg.c
+++ b/src/scene_manager/swf_svg.c
@@ -292,7 +292,7 @@ static GF_Err swf_svg_define_text(SWFReader *read, SWFText *text)
 			swf_svg_print(read, ">");
 			/*convert to UTF-8*/
 			{
-				size_t _len;
+				u32 _len;
 				u16     *str_w;
 				u16     *widestr;
 				char    *str;
@@ -306,8 +306,8 @@ static GF_Err swf_svg_define_text(SWFReader *read, SWFText *text)
 				str = (char*)gf_malloc(sizeof(char) * (gr->nbGlyphs+2));
 				widestr = str_w;
 				_len = gf_utf8_wcstombs(str, sizeof(u8) * (gr->nbGlyphs+1), (const unsigned short **) &widestr);
-				if (_len != (size_t) -1) {
-					str[(u32) _len] = 0;
+				if (_len != GF_UTF8_FAIL) {
+					str[_len] = 0;
 					swf_svg_print(read, "%s", str);
 				}
 			}
diff --git a/src/scenegraph/dom_js.c b/src/scenegraph/dom_js.c
index daa8b9ab2..27f09e6d9 100644
--- a/src/scenegraph/dom_js.c
+++ b/src/scenegraph/dom_js.c
@@ -2377,8 +2377,8 @@ static JSValue event_getProperty(JSContext *c, JSValueConst obj, int magic)
 		txt[0] = evt->detail;
 		txt[1] = 0;
 		srcp = (const u16 *) txt;
-		len = (u32) gf_utf8_wcstombs(szData, 5, &srcp);
-		if ((s32)len<0) len = 0;
+		len = gf_utf8_wcstombs(szData, 5, &srcp);
+		if (len == GF_UTF8_FAIL) len = 0;
 		szData[len] = 0;
 		return JS_NewString(c, szData);
 	}
diff --git a/src/utils/os_file.c b/src/utils/os_file.c
index 58ae8cf41..16e648a7d 100644
--- a/src/utils/os_file.c
+++ b/src/utils/os_file.c
@@ -723,12 +723,12 @@ GF_Err gf_enum_directory(const char *dir, Bool enum_directory, gf_enum_dir_item
 	}
 
 	tmpdir = _path;
-	if (gf_utf8_mbstowcs(path, GF_MAX_PATH, &tmpdir) == (size_t)-1) {
+	if (gf_utf8_mbstowcs(path, GF_MAX_PATH, &tmpdir) == GF_UTF8_FAIL) {
 		GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, ("[Core] Cannot convert %s to UTF16: broken string\n", dir));
 		return GF_BAD_PARAM;
 	}
 	tmpdir  = filter;
-	if (gf_utf8_mbstowcs(w_filter, sizeof(w_filter), &tmpdir) == (size_t)-1) {
+	if (gf_utf8_mbstowcs(w_filter, sizeof(w_filter), &tmpdir) == GF_UTF8_FAIL) {
 		GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, ("[Core] Cannot convert %s to UTF16: broken string\n", filter));
 		return GF_BAD_PARAM;
 	}
diff --git a/src/utils/utf.c b/src/utils/utf.c
index 00bb501e8..79090ae24 100644
--- a/src/utils/utf.c
+++ b/src/utils/utf.c
@@ -435,16 +435,16 @@ Bool gf_utf8_is_legal(const u8 *data, u32 length)
 }
 
 GF_EXPORT
-size_t gf_utf8_wcslen (const unsigned short *s)
+u32 gf_utf8_wcslen (const unsigned short *s)
 {
 	const unsigned short* ptr;
 	for (ptr = s; *ptr != (unsigned short)'\0'; ptr++) {
 	}
-	return ptr - s;
+	return (u32) ( ptr - s );
 }
 
 GF_EXPORT
-size_t gf_utf8_wcstombs(char* dest, size_t len, const unsigned short** srcp)
+u32 gf_utf8_wcstombs(char* dest, size_t len, const unsigned short** srcp)
 {
 	if (!srcp || !*srcp)
 		return 0;
@@ -456,15 +456,15 @@ size_t gf_utf8_wcstombs(char* dest, size_t len, const unsigned short** srcp)
 		ConversionFlags flags = strictConversion;
 
 		ConversionResult res = ConvertUTF16toUTF8(sourceStart, sourceEnd, &targetStart, targetEnd, flags);
-		if (res != conversionOK) return (size_t)-1;
+		if (res != conversionOK) return GF_UTF8_FAIL;
 		*targetStart = 0;
 		*srcp=NULL;
-		return strlen(dest);
+		return (u32) strlen(dest);
 	}
 }
 
 GF_EXPORT
-size_t gf_utf8_mbstowcs(unsigned short* dest, size_t len, const char** srcp)
+u32 gf_utf8_mbstowcs(unsigned short* dest, size_t len, const char** srcp)
 {
 	if (!srcp || !*srcp)
 		return 0;
@@ -475,7 +475,7 @@ size_t gf_utf8_mbstowcs(unsigned short* dest, size_t len, const char** srcp)
 		UTF16* targetEnd = (UTF16* ) (dest + len);
 		ConversionFlags flags = strictConversion;
 		ConversionResult res = ConvertUTF8toUTF16(sourceStart, sourceEnd, &targetStart, targetEnd, flags);
-		if (res != conversionOK) return (size_t)-1;
+		if (res != conversionOK) return GF_UTF8_FAIL;
 		*targetStart = 0;
 		*srcp=NULL;
 		return gf_utf8_wcslen(dest);
@@ -486,16 +486,16 @@ size_t gf_utf8_mbstowcs(unsigned short* dest, size_t len, const char** srcp)
 #else
 
 GF_EXPORT
-size_t gf_utf8_wcslen (const unsigned short *s)
+u32 gf_utf8_wcslen (const unsigned short *s)
 {
 	const unsigned short* ptr;
 	for (ptr = s; *ptr != (unsigned short)'\0'; ptr++) {
 	}
-	return ptr - s;
+	return (u32) (ptr - s);
 }
 
 GF_EXPORT
-size_t gf_utf8_wcstombs(char* dest, size_t len, const unsigned short** srcp)
+u32 gf_utf8_wcstombs(char* dest, size_t len, const unsigned short** srcp)
 {
 	/*
 	* Original code from the GNU UTF-8 Library
@@ -538,7 +538,7 @@ size_t gf_utf8_wcstombs(char* dest, size_t len, const unsigned short** srcp)
 					*destptr++ = (unsigned char)(((wc >> (6 * --count)) & 0x3F) | 0x80);
 				} while (count > 0);
 		}
-		return destptr - dest;
+		return (u32) (destptr - dest);
 	} else {
 		/* Ignore dest and len. */
 		size_t totalcount = 0;
@@ -558,7 +558,7 @@ size_t gf_utf8_wcstombs(char* dest, size_t len, const unsigned short** srcp)
 			}
 			totalcount += count;
 		}
-		return totalcount;
+		return (u32) totalcount;
 	}
 }
 
@@ -576,7 +576,7 @@ typedef struct
 static gf_utf8_mbstate_t internal;
 
 GF_EXPORT
-size_t gf_utf8_mbstowcs(unsigned short* dest, size_t len, const char** srcp)
+u32 gf_utf8_mbstowcs(unsigned short* dest, size_t len, const char** srcp)
 {
 	gf_utf8_mbstate_t* ps = &internal;
 	const char *src = *srcp;
@@ -636,11 +636,11 @@ bad_input_backup:
 		goto bad_input;
 	}
 	*srcp = src;
-	return destptr-dest;
+	return (u32) (destptr - dest);
 
 bad_input:
 	*srcp = src;
-	return (size_t)(-1);
+	return GF_UTF8_FAIL;
 }
 
 
@@ -723,7 +723,7 @@ wchar_t* gf_utf8_to_wcs(const char* str)
 	result = gf_calloc(source_len + 1, sizeof(wchar_t));
 	if (!result)
 		return 0;
-	if (gf_utf8_mbstowcs(result, source_len, &str) == (size_t)-1) {
+	if (gf_utf8_mbstowcs(result, source_len, &str) == GF_UTF8_FAIL) {
 		gf_free(result);
 		return 0;
 	}
@@ -740,7 +740,7 @@ char* gf_wcs_to_utf8(const wchar_t* str)
 	result = gf_calloc(source_len + 1, UTF8_MAX_BYTES_PER_CHAR);
 	if (!result)
 		return 0;
-	if (gf_utf8_wcstombs(result, source_len * UTF8_MAX_BYTES_PER_CHAR, &str) < 0) {
+	if (gf_utf8_wcstombs(result, source_len * UTF8_MAX_BYTES_PER_CHAR, &str) == GF_UTF8_FAIL) {
 		gf_free(result);
 		return 0;
 	}
diff --git a/src/utils/xml_parser.c b/src/utils/xml_parser.c
index 8fc4ce87b..afa416f6d 100644
--- a/src/utils/xml_parser.c
+++ b/src/utils/xml_parser.c
@@ -63,7 +63,7 @@ static char *xml_translate_xml_string(char *str)
 			if (str[i+1]=='#') {
 				char szChar[20], *end;
 				u16 wchar[2];
-				u32 val;
+				u32 val, _len;
 				const unsigned short *srcp;
 				strncpy(szChar, str+i, 10);
 				szChar[10] = 0;
@@ -78,7 +78,9 @@ static char *xml_translate_xml_string(char *str)
 					sscanf(szChar, "&#%u;", &val);
 				wchar[0] = val;
 				srcp = wchar;
-				j += (u32) gf_utf8_wcstombs(&value[j], 20, &srcp);
+				_len = gf_utf8_wcstombs(&value[j], 20, &srcp);
+				if (_len == GF_UTF8_FAIL) _len = 0;
+				j += _len;
 			}
 			else if (!strnicmp(&str[i], "&amp;", sizeof(char)*5)) {
 				value[j] = '&';
@@ -1074,10 +1076,10 @@ GF_Err gf_xml_sax_parse(GF_SAXParser *parser, const void *string)
 
 	if (parser->unicode_type>1) {
 		const u16 *sptr = (const u16 *)string;
-		u32 len = 2 * (u32) gf_utf8_wcslen(sptr);
+		u32 len = 2 * gf_utf8_wcslen(sptr);
 		utf_conv = (char *)gf_malloc(sizeof(char)*(len+1));
-		len = (u32) gf_utf8_wcstombs(utf_conv, len, &sptr);
-		if (len==(u32) -1) {
+		len = gf_utf8_wcstombs(utf_conv, len, &sptr);
+		if (len == GF_UTF8_FAIL) {
 			parser->sax_state = SAX_STATE_SYNTAX_ERROR;
 			gf_free(utf_conv);
 			return GF_CORRUPTED_DATA;
