diff --git a/README b/README
index 3cff2da..bb854d4 100644
--- a/README
+++ b/README
@@ -465,12 +465,50 @@ hierarchical process and fails if they differ across levels.
 
 --------------------------------------------------------------------------
 
+Release 1.65:
+
+The components requested through DisplayRectangle() are always codestream
+component (i.e. Y, U, V) and not RGB components in the target image.
+This led to some confusion and lack of initialization of bitmap descriptors
+if less components were requested than present in the image.
+The large-range scan did not properly check whether the DCT precision exceeds
+the range decodable by the Huffman encoder. It now aborts faithfully if such
+coefficients are detected.
+The code did not check if the number of components present in a JPEG LS-2
+transformation are identical to the number of components indicated in the
+frame header. The code now aborts with an error if such a condition is
+detected.
+
+--------------------------------------------------------------------------
+
+Release 1.66:
+
+Previous releases had no means to signal an error from within the BitMapHook.
+Now the return code of the BitMapHook call back function, if non-zero, is
+used as an error, and such an error is then reported upstream to the caller.
+
+Note that the supplied bitmap hook in the "cmd" directory is only an example
+and does not validate inputs. The encoder, in particular, operates on a
+"garbadge-in garbadge-out" basis. If the samples in the bitmap hook exceed
+the range indicated to the library, bad things will happen. That is, if the
+encoder is supposed to operate within an unknown environment with unknown
+input data, input validation is required within the bitmap hook.
+
+THE SAMPLE CODE DOES NOT ATTEMPT TO VALIDATE INPUT
+
+Similar restrictions applies to the "PNM" helper code (or any code) in the
+cmd directory. It does not attempt to validate input. At least some
+minimal attempts to ensure that input files are valid is now in place, but
+real life deployment of the code should contain more checks.
+
+--------------------------------------------------------------------------
+
 For license conditions, please check the file README.license in this
 directory.
 
 Finally, I want to thank Accusoft and the Computing Center of the University of
 Stuttgart and Fraunhofer IIS for sponsoring this project.
 
-Thomas Richter, February 2022
+Thomas Richter, July 2023
 
--------------------------------------------------------------------------------------
+---------------------------------------------------------------------------
diff --git a/README.history b/README.history
index 1166d43..6449941 100644
--- a/README.history
+++ b/README.history
@@ -584,3 +584,26 @@ transformation are identical to the number of components indicated in the
 frame header. The code now aborts with an error if such a condition is
 detected.
 
+--------------------------------------------------------------------------
+
+Release 1.66:
+
+Previous releases had no means to signal an error from within the BitMapHook.
+Now the return code of the BitMapHook call back function, if non-zero, is
+used as an error, and such an error is then reported upstream to the caller.
+
+Note that the supplied bitmap hook in the "cmd" directory is only an example
+and does not validate inputs. The encoder, in particular, operates on a
+"garbadge-in garbadge-out" basis. If the samples in the bitmap hook exceed
+the range indicated to the library, bad things will happen. That is, if the
+encoder is supposed to operate within an unknown environment with unknown
+input data, input validation is required within the bitmap hook.
+
+THE SAMPLE CODE DOES NOT ATTEMPT TO VALIDATE INPUT
+
+Similar restrictions applies to the "PNM" helper code (or any code) in the
+cmd directory. It does not attempt to validate input. At least some
+minimal attempts to ensure that input files are valid is now in place, but
+real life deployment of the code should contain more checks.
+
+
diff --git a/cmd/bitmaphook.cpp b/cmd/bitmaphook.cpp
index cee7229..9f41dbe 100644
--- a/cmd/bitmaphook.cpp
+++ b/cmd/bitmaphook.cpp
@@ -42,7 +42,7 @@
 ** This header provides the interface for the bitmap hook that 
 ** delivers the bitmap data to the core library.
 **
-** $Id: bitmaphook.cpp,v 1.16 2022/02/28 11:11:32 thor Exp $
+** $Id: bitmaphook.cpp,v 1.17 2023/07/07 12:19:11 thor Exp $
 **
 */
 
@@ -160,8 +160,10 @@ JPG_LONG BitmapHook(struct JPG_Hook *hook, struct JPG_TagItem *tags)
           if (bmm->bmm_pLDRSource && bmm->bmm_pLDRMemPtr) {
             // A designated LDR source is available. Read from here rather than using
             // our primitive tone mapper.
-            fread(bmm->bmm_pLDRMemPtr,sizeof(UBYTE),width * height * bmm->bmm_usDepth,
-                  bmm->bmm_pLDRSource);
+            ssize_t cnt = fread(bmm->bmm_pLDRMemPtr,sizeof(UBYTE),width * height * bmm->bmm_usDepth,
+                                bmm->bmm_pLDRSource);
+            if (cnt != width * height * bmm->bmm_usDepth)
+              return JPGERR_UNEXPECTED_EOF;
           }
           //
           if (bmm->bmm_pSource) {
@@ -203,8 +205,10 @@ JPG_LONG BitmapHook(struct JPG_Hook *hook, struct JPG_TagItem *tags)
                 } while(--count);
               }
             } else {
-              fread(bmm->bmm_pMemPtr,bmm->bmm_ucPixelType & CTYP_SIZE_MASK,
-                    width * height * bmm->bmm_usDepth,bmm->bmm_pSource);
+              ssize_t cnt = fread(bmm->bmm_pMemPtr,bmm->bmm_ucPixelType & CTYP_SIZE_MASK,
+                                  width * height * bmm->bmm_usDepth,bmm->bmm_pSource);
+              if (cnt != width * height * bmm->bmm_usDepth)
+                return JPGERR_UNEXPECTED_EOF;
 #ifdef JPG_LIL_ENDIAN
               // On those bloddy little endian machines, an endian swap is necessary
               // as PNM is big-endian.
@@ -440,8 +444,10 @@ JPG_LONG AlphaHook(struct JPG_Hook *hook, struct JPG_TagItem *tags)
                 } while(--count);
               }
             } else {
-              fread(bmm->bmm_pAlphaPtr,bmm->bmm_ucAlphaType & CTYP_SIZE_MASK,
-                    bmm->bmm_ulWidth * height,bmm->bmm_pAlphaSource);
+              ssize_t cnt = fread(bmm->bmm_pAlphaPtr,bmm->bmm_ucAlphaType & CTYP_SIZE_MASK,
+                                  bmm->bmm_ulWidth * height,bmm->bmm_pAlphaSource);
+              if (cnt != bmm->bmm_ulWidth * height)
+                return JPGERR_UNEXPECTED_EOF;
 #ifdef JPG_LIL_ENDIAN
               // On those bloddy little endian machines, an endian swap is necessary
               // as PNM is big-endian.
diff --git a/cmd/iohelpers.cpp b/cmd/iohelpers.cpp
index b4212c4..8319db7 100644
--- a/cmd/iohelpers.cpp
+++ b/cmd/iohelpers.cpp
@@ -41,7 +41,7 @@
 /*
 ** Several helper functions that are related to native IO of pixel values
 **
-** $Id: iohelpers.cpp,v 1.10 2021/11/15 08:59:59 thor Exp $
+** $Id: iohelpers.cpp,v 1.11 2023/07/07 12:19:11 thor Exp $
 **
 */
 
@@ -210,8 +210,8 @@ FILE *OpenPNMFile(const char *file,int &width,int &height,int &depth,int &precis
               precision++;
           }
         }
-        
-        if (parms == 3) {
+
+        if (width > 0 && height > 0 && parms == 3) {
           return in;
         }
         fprintf(stderr,"unsupported or invalid PNM format\n");
diff --git a/interface/bitmaphook.cpp b/interface/bitmaphook.cpp
index c32ebf8..b128164 100644
--- a/interface/bitmaphook.cpp
+++ b/interface/bitmaphook.cpp
@@ -41,7 +41,7 @@
 /*
  * Member functions of the bitmap hook class
  * 
- * $Id: bitmaphook.cpp,v 1.10 2015/03/16 08:55:33 thor Exp $
+ * $Id: bitmaphook.cpp,v 1.11 2023/07/07 12:19:54 thor Exp $
  *
  */
 
@@ -192,8 +192,11 @@ void BitMapHook::Request(struct JPG_Hook *hook,struct JPG_TagItem *tags,UBYTE pi
   tags[22].ti_Data.ti_lData = 0;
   //
   // Now call the hook if it exists
-  if (hook)
-    hook->CallLong(tags);
+  if (hook) {
+    LONG result = hook->CallLong(tags);
+    if (result < 0)
+      comp->EnvironOf()->Throw(result,"BitmapHook::Request",__LINE__,__FILE__,"BitMapHook signalled an error");
+  }
 
   // and now, finally, scan what we got back
   ibm->ibm_pData           = tags[1].ti_Data.ti_pPtr;
@@ -235,8 +238,12 @@ void BitMapHook::Release(struct JPG_Hook *hook,struct JPG_TagItem *tags,UBYTE pi
     tags[20].ti_Data.ti_lData = (rect.ra_MaxY + comp->SubYOf() + 1 - 1) / comp->SubYOf() - 1;
     tags[21].ti_Data.ti_lData = 0;
     tags[22].ti_Data.ti_lData = 0;
-    
-    hook->CallLong(tags);
+
+    if (hook) {
+      LONG result = hook->CallLong(tags);
+      if (result < 0)
+        comp->EnvironOf()->Throw(result,"BitmapHook::Release",__LINE__,__FILE__,"BitMapHook signalled an error");
+    }
   }
 }
 ///
