{
    "0": "-    uint32_t enc_len = 0;\n\n+    uint64_t enc_len = 0;\n\n",
    "1": "-    uint64_t enc_len = 0;\n\n+    uint32_t enc_len = 0;\n\n-    *enc_len = strlen(skey_str) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n-    status = AES_decrypt(encryptedPrivateKey, *enc_len, skey_str, ECDSA_SKEY_LEN);\n\n+    status = AES_decrypt(encryptedPrivateKey, *enc_len, skey_str, BUF_LEN);\n\n-void trustedGetPublicEcdsaKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint32_t enc_len, char *pub_key_x, char *pub_key_y) {\n\n+void trustedGetPublicEcdsaKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint64_t enc_len, char *pub_key_x, char *pub_key_y) {\n\n-    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);\n\n+    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);\n\n-void trustedEcdsaSignAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint32_t enc_len, const char *hash, char *sigR, char *sigS, uint8_t *sig_v, int base) {\n\n+void trustedEcdsaSignAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint64_t enc_len, const char *hash, char *sigR, char *sigS, uint8_t *sig_v, int base) {\n\n-    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);\n\n+    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);\n\n-void trustedDecryptKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint32_t enc_len, char *key) {\n\n+void trustedDecryptKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint64_t enc_len, char *key) {\n\n-    int status = AES_decrypt_DH(encryptedPrivateKey, enc_len, key, 3072);\n\n+    int status = AES_decrypt(encryptedPrivateKey, enc_len, key, 3072);\n\n-void trustedEncryptKeyAES(int *errStatus, char *errString, const char *key, uint8_t *encryptedPrivateKey, uint32_t *enc_len) {\n\n+void trustedEncryptKeyAES(int *errStatus, char *errString, const char *key, uint8_t *encryptedPrivateKey, uint64_t *enc_len) {\n\n-    int status = AES_encrypt_DH((char *)key, encryptedPrivateKey, BUF_LEN);\n\n+    int status = AES_encrypt((char *)key, encryptedPrivateKey, BUF_LEN, DKG, DECRYPTABLE, enc_len);\n\n-    status = AES_decrypt_DH(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);\n\n+    status = AES_decrypt(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);\n\n-void trustedDecryptDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t enc_len, uint8_t *decrypted_dkg_secret) {\n\n+void trustedDecryptDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint64_t enc_len, uint8_t *decrypted_dkg_secret) {\n\n-void trustedSetEncryptedDkgPolyAES(int *errStatus, char *errString, uint8_t *encrypted_poly, uint32_t enc_len) {\n\n+void trustedSetEncryptedDkgPolyAES(int *errStatus, char *errString, uint8_t *encrypted_poly, uint64_t enc_len) {\n\n-void trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t *encrypted_skey, uint32_t *dec_len, char *result_str, char *s_shareG2, char *pub_keyB, uint8_t _t, uint8_t _n,\n\n+void trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t *encrypted_skey, uint64_t *dec_len, char *result_str, char *s_shareG2, char *pub_keyB, uint8_t _t, uint8_t _n,\n\n-    status = AES_decrypt(encrypted_skey, enc_len, skey, ECDSA_SKEY_LEN);\n\n+    status = AES_decrypt(encrypted_skey, enc_len, skey, BUF_LEN);\n\n-void trustedGetPublicSharesAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t enc_len, char *public_shares, unsigned _t, unsigned _n) {\n\n+void trustedGetPublicSharesAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint64_t enc_len, char *public_shares, unsigned _t, unsigned _n) {\n\n-    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);\n\n+    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);\n\n-void trustedCreateBlsKeyAES(int *errStatus, char *errString, const char *s_shares, uint8_t *encryptedPrivateKey, uint64_t key_len, uint8_t *encr_bls_key, uint32_t *enc_bls_key_len) {\n\n+void trustedCreateBlsKeyAES(int *errStatus, char *errString, const char *s_shares, uint8_t *encryptedPrivateKey, uint64_t key_len, uint8_t *encr_bls_key, uint64_t *enc_bls_key_len) {\n\n-    int status = AES_decrypt(encryptedPrivateKey, key_len, skey, ECDSA_SKEY_LEN);\n\n+    int status = AES_decrypt(encryptedPrivateKey, key_len, skey, BUF_LEN);\n\n-    SAFE_CHAR_BUF(skey_hex, ECDSA_SKEY_LEN);\n-    int status = AES_decrypt(encryptedPrivateKey, key_len, skey_hex, ECDSA_SKEY_LEN);\n\n+    SAFE_CHAR_BUF(skey_hex, BUF_LEN);\n+    int status = AES_decrypt(encryptedPrivateKey, key_len, skey_hex, BUF_LEN);\n\n-void sealHexSEK(int *errStatus, char *errString, uint8_t *encrypted_sek, uint64_t *enc_len, char *sek_hex) {\n\n+void sealHexSEK(int *errStatus, char *errString, uint8_t *encrypted_sek, uint32_t *enc_len, char *sek_hex) {\n\n-void trustedSetSEK_backup(int *errStatus, char *errString, uint8_t *encrypted_sek, uint64_t *enc_len, const char *sek_hex) {\n\n+void trustedSetSEK_backup(int *errStatus, char *errString, uint8_t *encrypted_sek, uint32_t *enc_len, const char *sek_hex) {\n\n-void trustedGenerateEcdsaKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint64_t *enc_len, char *pub_key_x, char *pub_key_y) {\n\n+void trustedGenerateEcdsaKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint32_t *enc_len, char *pub_key_x, char *pub_key_y) {\n\n-    int status = AES_encrypt((char *) skey_str, encryptedPrivateKey, BUF_LEN, ECDSA, NON_DECRYPTABLE, enc_len);\n\n+    int status = AES_encrypt((char *) skey_str, encryptedPrivateKey, BUF_LEN);\n\n-    status = AES_decrypt(encryptedPrivateKey, *enc_len, skey_str, BUF_LEN);\n\n+    *enc_len = strlen(skey_str) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n+    status = AES_decrypt(encryptedPrivateKey, *enc_len, skey_str, ECDSA_SKEY_LEN);\n\n-void trustedGetPublicEcdsaKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint64_t enc_len, char *pub_key_x, char *pub_key_y) {\n\n+void trustedGetPublicEcdsaKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint32_t enc_len, char *pub_key_x, char *pub_key_y) {\n\n-    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);\n\n+    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);\n\n-void trustedEcdsaSignAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint64_t enc_len, const char *hash, char *sigR, char *sigS, uint8_t *sig_v, int base) {\n\n+void trustedEcdsaSignAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint32_t enc_len, const char *hash, char *sigR, char *sigS, uint8_t *sig_v, int base) {\n\n-    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);\n\n+    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);\n\n-void trustedDecryptKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint64_t enc_len, char *key) {\n\n+void trustedDecryptKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint32_t enc_len, char *key) {\n\n-    int status = AES_decrypt(encryptedPrivateKey, enc_len, key, 3072);\n\n+    int status = AES_decrypt_DH(encryptedPrivateKey, enc_len, key, 3072);\n\n-void trustedEncryptKeyAES(int *errStatus, char *errString, const char *key, uint8_t *encryptedPrivateKey, uint64_t *enc_len) {\n\n+void trustedEncryptKeyAES(int *errStatus, char *errString, const char *key, uint8_t *encryptedPrivateKey, uint32_t *enc_len) {\n\n-    int status = AES_encrypt((char *)key, encryptedPrivateKey, BUF_LEN, DKG, DECRYPTABLE, enc_len);\n\n+    int status = AES_encrypt_DH((char *)key, encryptedPrivateKey, BUF_LEN);\n\n-    status = AES_decrypt(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);\n\n+    status = AES_decrypt_DH(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);\n\n-void trustedBlsSignMessageAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint64_t enc_len, char *_hashX, char *_hashY, char *signature) {\n\n+void trustedBlsSignMessageAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint32_t enc_len, char *_hashX, char *_hashY, char *signature) {\n\n-void trustedGenDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint64_t *enc_len, size_t _t) {\n\n+void trustedGenDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t *enc_len, size_t _t) {\n\n+    *enc_len = strlen(dkg_secret) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n\n-void trustedDecryptDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint64_t enc_len, uint8_t *decrypted_dkg_secret) {\n\n+void trustedDecryptDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t enc_len, uint8_t *decrypted_dkg_secret) {\n\n-void trustedSetEncryptedDkgPolyAES(int *errStatus, char *errString, uint8_t *encrypted_poly, uint64_t enc_len) {\n\n+void trustedSetEncryptedDkgPolyAES(int *errStatus, char *errString, uint8_t *encrypted_poly, uint32_t enc_len) {\n\n-void trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t *encrypted_skey, uint64_t *dec_len, char *result_str, char *s_shareG2, char *pub_keyB, uint8_t _t, uint8_t _n,\n\n+void trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t *encrypted_skey, uint32_t *dec_len, char *result_str, char *s_shareG2, char *pub_keyB, uint8_t _t, uint8_t _n,\n\n-    status = AES_decrypt(encrypted_skey, enc_len, skey, BUF_LEN);\n\n+    status = AES_decrypt(encrypted_skey, enc_len, skey, ECDSA_SKEY_LEN);\n\n-void trustedGetPublicSharesAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint64_t enc_len, char *public_shares, unsigned _t, unsigned _n) {\n\n+void trustedGetPublicSharesAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t enc_len, char *public_shares, unsigned _t, unsigned _n) {\n\n-    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);\n\n+    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);\n\n-void trustedCreateBlsKeyAES(int *errStatus, char *errString, const char *s_shares, uint8_t *encryptedPrivateKey, uint64_t key_len, uint8_t *encr_bls_key, uint64_t *enc_bls_key_len) {\n\n+void trustedCreateBlsKeyAES(int *errStatus, char *errString, const char *s_shares, uint8_t *encryptedPrivateKey, uint64_t key_len, uint8_t *encr_bls_key, uint32_t *enc_bls_key_len) {\n\n-    int status = AES_decrypt(encryptedPrivateKey, key_len, skey, BUF_LEN);\n\n+    int status = AES_decrypt(encryptedPrivateKey, key_len, skey, ECDSA_SKEY_LEN);\n\n+    *enc_bls_key_len = strlen(key_share) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n\n-    SAFE_CHAR_BUF(skey_hex, BUF_LEN);\n-    int status = AES_decrypt(encryptedPrivateKey, key_len, skey_hex, BUF_LEN);\n\n+    SAFE_CHAR_BUF(skey_hex, ECDSA_SKEY_LEN);\n+    int status = AES_decrypt(encryptedPrivateKey, key_len, skey_hex, ECDSA_SKEY_LEN);\n\n-    for (int i = 2; i < strlen(message) + 1; i++) {\n-        message[i - 2 ] = message[i];\n\n+    return status;\n+}\n+int AES_encrypt_DH(char *message, uint8_t *encr_message, uint64_t encrLen) {\n+    if (!message) {\n+        LOG_ERROR(\"Null message in AES_encrypt_DH\");\n+        return -1;\n+    }\n+    if (!encr_message) {\n+        LOG_ERROR(\"Null encr message in AES_encrypt_DH\");\n+        return -2;\n+    }\n+    uint64_t len = strlen(message) + 1;\n+    if (len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrLen ) {\n+        LOG_ERROR(\"Output buffer too small\");\n+        return -3;\n+    }\n+    sgx_read_rand(encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE);\n+    sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_DH_key, (uint8_t*)message, strlen(message), encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE, encr_message + SGX_AESGCM_MAC_SIZE,\n+                          SGX_AESGCM_IV_SIZE, NULL, 0, (sgx_aes_gcm_128bit_tag_t *) encr_message);\n+    return status;\n\n+int AES_decrypt_DH(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) {\n+    if (!message) {\n+        LOG_ERROR(\"Null message in AES_encrypt_DH\");\n+        return -1;\n+    }\n+    if (!encr_message) {\n+        LOG_ERROR(\"Null encr message in AES_encrypt_DH\");\n+        return -2;\n+    }\n+    if (length < SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE) {\n+        LOG_ERROR(\"length < SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE\");\n+        return -1;\n+    }\n+    uint64_t len = length - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE;\n+    if (msgLen < len) {\n+        LOG_ERROR(\"Output buffer not large enough\");\n+        return -2;\n+    }\n+    sgx_status_t status = sgx_rijndael128GCM_decrypt(&AES_DH_key, encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE, len, (unsigned char*) message, encr_message + SGX_AESGCM_MAC_SIZE,\n+                          SGX_AESGCM_IV_SIZE, NULL, 0, (sgx_aes_gcm_128bit_tag_t *)encr_message);\n\n-    uint64_t enc_bls_len = 0;\n\n+    uint32_t enc_bls_len = 0;\n\n-        uint64_t decLen;\n\n+        uint32_t decLen;\n\n-    uint64_t enc_len = 0;\n\n+    uint32_t enc_len = 0;\n\n-int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrLen) {\n\n+#define SAFE_CHAR_BUF(__X__, __Y__)  ;char __X__ [ __Y__ ]; memset(__X__, 0, __Y__);\n+int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrBufLen, unsigned char type, unsigned char decryptable, uint64_t* resultLen) {\n+    if (!type) {\n+        LOG_ERROR(\"Null type in AES_encrypt\");\n+        return -1;\n+    }\n\n-    if (len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrLen ) {\n\n+    if (2 + len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrBufLen ) {\n\n-    sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_key, (uint8_t*)message, strlen(message), encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE, encr_message + SGX_AESGCM_MAC_SIZE,\n-                          SGX_AESGCM_IV_SIZE, NULL, 0, (sgx_aes_gcm_128bit_tag_t *) encr_message);\n\n+    sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_key, (uint8_t*)message, len, encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE, encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,\n+                          NULL, 0, (sgx_aes_gcm_128bit_tag_t *) encr_message);\n+    *resultLen = len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n\n-    if (2 + len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrBufLen ) {\n\n+    if (len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrLen ) {\n\n-    SAFE_CHAR_BUF(fullMessage, len + 2);\n-    fullMessage[0] = type;\n-    fullMessage[1] = decryptable;\n-    strncpy(fullMessage + 2, message, len );\n-    len = len + 2;\n-    message = fullMessage;\n\n-    sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_key, (uint8_t*)message, len, encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE, encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,\n-                          NULL, 0, (sgx_aes_gcm_128bit_tag_t *) encr_message);\n-    *resultLen = len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n\n+    sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_key, (uint8_t*)message, strlen(message), encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE, encr_message + SGX_AESGCM_MAC_SIZE,\n+                          SGX_AESGCM_IV_SIZE, NULL, 0, (sgx_aes_gcm_128bit_tag_t *) encr_message);\n\n",
    "2": "-void sealHexSEK(int *errStatus, char *errString, uint8_t *encrypted_sek, uint32_t *enc_len, char *sek_hex) {\n\n+void sealHexSEK(int *errStatus, char *errString, uint8_t *encrypted_sek, uint64_t *enc_len, char *sek_hex) {\n\n",
    "3": "-    uint32_t encrypt_text_length = sgx_get_encrypt_txt_len((const sgx_sealed_data_t *)encrypted_sek);\n\n+    uint64_t encrypt_text_length = sgx_get_encrypt_txt_len((const sgx_sealed_data_t *)encrypted_sek);\n\n",
    "4": "-    uint32_t add_text_length = sgx_get_add_mac_txt_len((const sgx_sealed_data_t *)encrypted_sek);\n\n+    uint64_t add_text_length = sgx_get_add_mac_txt_len((const sgx_sealed_data_t *)encrypted_sek);\n\n",
    "5": "-void trustedGenerateSEK(int *errStatus, char *errString, uint8_t *encrypted_sek, uint32_t *enc_len, char *sek_hex) {\n\n+void trustedGenerateSEK(int *errStatus, char *errString, uint8_t *encrypted_sek, uint64_t *enc_len, char *sek_hex) {\n\n",
    "6": "-void trustedSetSEK_backup(int *errStatus, char *errString, uint8_t *encrypted_sek, uint32_t *enc_len, const char *sek_hex) {\n\n+void trustedSetSEK_backup(int *errStatus, char *errString, uint8_t *encrypted_sek, uint64_t *enc_len, const char *sek_hex) {\n\n",
    "7": "-void trustedGenerateEcdsaKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint32_t *enc_len, char *pub_key_x, char *pub_key_y) {\n\n+void trustedGenerateEcdsaKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint64_t *enc_len, char *pub_key_x, char *pub_key_y) {\n\n",
    "8": "-    SAFE_CHAR_BUF(skey_str, ECDSA_SKEY_LEN); SAFE_CHAR_BUF(arr_skey_str, mpz_sizeinbase(skey, ECDSA_SKEY_BASE) + 2);\n\n+    SAFE_CHAR_BUF(skey_str, BUF_LEN);\n+    SAFE_CHAR_BUF(arr_skey_str, mpz_sizeinbase(skey, ECDSA_SKEY_BASE) + 2);\n\n-    SAFE_CHAR_BUF(skey_str, BUF_LEN);\n-    SAFE_CHAR_BUF(arr_skey_str, mpz_sizeinbase(skey, ECDSA_SKEY_BASE) + 2);\n\n+    SAFE_CHAR_BUF(skey_str, ECDSA_SKEY_LEN); SAFE_CHAR_BUF(arr_skey_str, mpz_sizeinbase(skey, ECDSA_SKEY_BASE) + 2);\n\n",
    "9": "-    skey_str[ECDSA_SKEY_LEN - 1] = 0;\n\n",
    "10": "-    int status = AES_encrypt((char *) skey_str, encryptedPrivateKey, BUF_LEN);\n\n+    int status = AES_encrypt((char *) skey_str, encryptedPrivateKey, BUF_LEN, ECDSA, NON_DECRYPTABLE, enc_len);\n\n",
    "11": "-    IT_ERROR_STATE SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n\n+    IT_ERROR_STATE SAFE_CHAR_BUF(skey, BUF_LEN);\n\n-    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n\n+    SAFE_CHAR_BUF(skey, BUF_LEN);\n\n-    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n\n+    SAFE_CHAR_BUF(skey, BUF_LEN);\n\n-    SAFE_CHAR_BUF(common_key, ECDSA_SKEY_LEN);\n\n+    SAFE_CHAR_BUF(common_key, BUF_LEN);\n\n-    SAFE_CHAR_BUF(s_share, ECDSA_SKEY_LEN);\n\n+    SAFE_CHAR_BUF(s_share, BUF_LEN);\n\n-    SAFE_CHAR_BUF(cypher, ECDSA_SKEY_LEN);\n\n+    SAFE_CHAR_BUF(cypher, BUF_LEN);\n\n-    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n\n+    SAFE_CHAR_BUF(skey,BUF_LEN);\n\n-    SAFE_CHAR_BUF(encr_sshare, ECDSA_SKEY_LEN);\n\n+    SAFE_CHAR_BUF(encr_sshare, BUF_LEN);\n\n-    SAFE_CHAR_BUF(common_key, ECDSA_SKEY_LEN);\n\n+    SAFE_CHAR_BUF(common_key, BUF_LEN);\n\n-    SAFE_CHAR_BUF(decr_sshare, ECDSA_SKEY_LEN);\n\n+    SAFE_CHAR_BUF(decr_sshare, BUF_LEN);\n\n-    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n\n+    SAFE_CHAR_BUF(skey, BUF_LEN);\n\n-    IT_ERROR_STATE SAFE_CHAR_BUF(skey, BUF_LEN);\n\n+    IT_ERROR_STATE SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n\n-    SAFE_CHAR_BUF(skey, BUF_LEN);\n\n+    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n\n-    SAFE_CHAR_BUF(skey, BUF_LEN);\n\n+    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n\n-    SAFE_CHAR_BUF(common_key, BUF_LEN);\n\n+    SAFE_CHAR_BUF(common_key, ECDSA_SKEY_LEN);\n\n-    SAFE_CHAR_BUF(s_share, BUF_LEN);\n\n+    SAFE_CHAR_BUF(s_share, ECDSA_SKEY_LEN);\n\n-    SAFE_CHAR_BUF(cypher, BUF_LEN);\n\n+    SAFE_CHAR_BUF(cypher, ECDSA_SKEY_LEN);\n\n-    SAFE_CHAR_BUF(skey,BUF_LEN);\n\n+    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n\n-    SAFE_CHAR_BUF(encr_sshare, BUF_LEN);\n\n+    SAFE_CHAR_BUF(encr_sshare, ECDSA_SKEY_LEN);\n\n-    SAFE_CHAR_BUF(common_key, BUF_LEN);\n\n+    SAFE_CHAR_BUF(common_key, ECDSA_SKEY_LEN);\n\n-    SAFE_CHAR_BUF(decr_sshare, BUF_LEN);\n\n+    SAFE_CHAR_BUF(decr_sshare, ECDSA_SKEY_LEN);\n\n-    SAFE_CHAR_BUF(skey, BUF_LEN);\n\n+    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n\n",
    "12": "-    *enc_len = strlen(key) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n\n",
    "13": "+        LOG_ERROR(key);\n+        LOG_ERROR(decryptedKey);\n\n",
    "14": "-void trustedBlsSignMessageAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint32_t enc_len, char *_hashX, char *_hashY, char *signature) {\n\n+void trustedBlsSignMessageAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint64_t enc_len, char *_hashX, char *_hashY, char *signature) {\n\n",
    "15": "-void trustedGenDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t *enc_len, size_t _t) {\n\n+void trustedGenDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint64_t *enc_len, size_t _t) {\n\n",
    "16": "-    status = AES_encrypt(dkg_secret, encrypted_dkg_secret, 3 * BUF_LEN);\n\n+    status = AES_encrypt(dkg_secret, encrypted_dkg_secret, 3 * BUF_LEN, DKG, DECRYPTABLE, enc_len);\n\n",
    "17": "-    *enc_len = strlen(dkg_secret) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n\n",
    "18": "-    IT_ERROR_STATE uint32_t enc_len;\n\n+    IT_ERROR_STATE uint64_t enc_len;\n\n-    IT_ERROR_STATE uint64_t enc_len;\n\n+    IT_ERROR_STATE uint32_t enc_len;\n\n",
    "19": "-    status = AES_encrypt(key_share, encr_bls_key, BUF_LEN);\n\n+    status = AES_encrypt(key_share, encr_bls_key, BUF_LEN, BLS, NON_DECRYPTABLE, enc_bls_key_len);\n\n-    status = AES_encrypt(key_share, encr_bls_key, BUF_LEN, BLS, NON_DECRYPTABLE, enc_bls_key_len);\n\n+    status = AES_encrypt(key_share, encr_bls_key, BUF_LEN);\n\n",
    "20": "-    *enc_bls_key_len = strlen(key_share) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n\n",
    "21": "-    uint64_t encrypt_text_length = sgx_get_encrypt_txt_len((const sgx_sealed_data_t *)encrypted_sek);\n\n+    uint32_t encrypt_text_length = sgx_get_encrypt_txt_len((const sgx_sealed_data_t *)encrypted_sek);\n\n-    uint64_t add_text_length = sgx_get_add_mac_txt_len((const sgx_sealed_data_t *)encrypted_sek);\n\n+    uint32_t add_text_length = sgx_get_add_mac_txt_len((const sgx_sealed_data_t *)encrypted_sek);\n\n",
    "22": "-void trustedGenerateSEK(int *errStatus, char *errString, uint8_t *encrypted_sek, uint64_t *enc_len, char *sek_hex) {\n\n+void trustedGenerateSEK(int *errStatus, char *errString, uint8_t *encrypted_sek, uint32_t *enc_len, char *sek_hex) {\n\n",
    "23": "+    skey_str[ECDSA_SKEY_LEN - 1] = 0;\n\n",
    "24": "+    *enc_len = strlen(key) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n\n",
    "25": "-        LOG_ERROR(key);\n-        LOG_ERROR(decryptedKey);\n\n",
    "26": "-    status = AES_encrypt(dkg_secret, encrypted_dkg_secret, 3 * BUF_LEN, DKG, DECRYPTABLE, enc_len);\n\n+    status = AES_encrypt(dkg_secret, encrypted_dkg_secret, 3 * BUF_LEN);\n\n",
    "27": "-    for (int j = 0; j < _len; j++) {\n\n+    for (uint64_t j = 0; j < _len; j++) {\n\n",
    "28": "-    for (uint64_t j = 0; j < _len; j++) {\n\n+    for (int j = 0; j < _len; j++) {\n\n",
    "29": "-    uint32_t enc_bls_len = 0;\n\n+    uint64_t enc_bls_len = 0;\n\n",
    "30": "-    uint32_t enc_len;\n\n+    uint64_t enc_len;\n\n",
    "31": "-    uint64_t enc_len;\n\n+    uint32_t enc_len;\n\n",
    "32": "-    unsigned int encryptedLen = 0;\n\n+    uint64_t encryptedLen = 0;\n\n",
    "33": "-    uint64_t encryptedLen = 0;\n\n+    unsigned int encryptedLen = 0;\n\n",
    "34": "-    int len = strnlen(_hex, 2 * _max_length + 1);\n\n+    uint64_t len = strnlen(_hex, 2 * _max_length + 1);\n\n",
    "35": "-    for (int i = 0; i < len / 2; i++) {\n\n+    for (uint64_t i = 0; i < len / 2; i++) {\n\n",
    "36": "-    uint64_t len = strnlen(_hex, 2 * _max_length + 1);\n\n+    int len = strnlen(_hex, 2 * _max_length + 1);\n\n-    for (uint64_t i = 0; i < len / 2; i++) {\n\n+    for (int i = 0; i < len / 2; i++) {\n\n",
    "37": "-        uint32_t decLen;\n\n+        uint64_t decLen;\n\n",
    "38": "-    uint32_t enc_len = 0;\n\n+    uint64_t enc_len = 0;\n\n",
    "39": "+    SAFE_CHAR_BUF(fullMessage, len + 2);\n+    fullMessage[0] = type;\n+    fullMessage[1] = decryptable;\n+    strncpy(fullMessage + 2, message, len );\n+    len = len + 2;\n+    message = fullMessage;\n\n"
}