{
    "0": "+    struct cachefiles_vol_xattr *buf;\n\n",
    "1": "+    len += sizeof(*buf);\n+    buf = kmalloc(len, GFP_KERNEL);\n+    if (!buf) {\n+        return false;\n+    }\n+    buf->reserved = cpu_to_be32(0);\n+    memcpy(buf->data, p, len);\n\n",
    "2": "-        ret = vfs_setxattr(&init_user_ns, dentry, cachefiles_xattr_cache, p, len, 0);\n\n+        ret = vfs_setxattr(&init_user_ns, dentry, cachefiles_xattr_cache, buf, len, 0);\n\n-    struct cachefiles_vol_xattr *buf;\n\n-    len += sizeof(*buf);\n-    buf = kmalloc(len, GFP_KERNEL);\n-    if (!buf) {\n-        return false;\n-    }\n-    buf->reserved = cpu_to_be32(0);\n-    memcpy(buf->data, p, len);\n\n-        ret = vfs_setxattr(&init_user_ns, dentry, cachefiles_xattr_cache, buf, len, 0);\n\n+        ret = vfs_setxattr(&init_user_ns, dentry, cachefiles_xattr_cache, p, len, 0);\n\n-    kfree(buf);\n\n-    struct cachefiles_xattr *buf;\n\n+    struct cachefiles_vol_xattr *buf;\n\n-    } else if (memcmp(buf->data, p, len) != 0) {\n\n+    } else if (buf->reserved != cpu_to_be32(0)) {\n+        why = cachefiles_coherency_vol_check_resv;\n+    } else if (memcmp(buf->data, p, len - sizeof(*buf)) != 0) {\n\n-    struct cachefiles_vol_xattr *buf;\n\n+    struct cachefiles_xattr *buf;\n\n-    } else if (buf->reserved != cpu_to_be32(0)) {\n-        why = cachefiles_coherency_vol_check_resv;\n-    } else if (memcmp(buf->data, p, len - sizeof(*buf)) != 0) {\n\n+    } else if (memcmp(buf->data, p, len) != 0) {\n\n",
    "3": "+    kfree(buf);\n\n",
    "4": "-    unsigned int bmsize;\n\n",
    "5": "-    ret = pipe_resize_ring(pipe, nr_notes);\n\n+    nr_notes = nr_pages * WATCH_QUEUE_NOTES_PER_PAGE;\n+    ret = pipe_resize_ring(pipe, roundup_pow_of_two(nr_notes));\n\n-    bmsize = (nr_notes + BITS_PER_LONG - 1) / BITS_PER_LONG;\n-    bmsize *= sizeof(unsigned long);\n-    bitmap = kmalloc(bmsize, GFP_KERNEL);\n\n+    bitmap = bitmap_alloc(nr_notes, GFP_KERNEL);\n\n-    memset(bitmap, 0xff, bmsize);\n\n+    bitmap_fill(bitmap, nr_notes);\n\n-    wqueue->nr_notes = nr_pages * WATCH_QUEUE_NOTES_PER_PAGE;\n\n+    wqueue->nr_notes = nr_notes;\n\n-    nr_notes = nr_pages * WATCH_QUEUE_NOTES_PER_PAGE;\n-    ret = pipe_resize_ring(pipe, roundup_pow_of_two(nr_notes));\n\n+    ret = pipe_resize_ring(pipe, nr_notes);\n\n-    bitmap = bitmap_alloc(nr_notes, GFP_KERNEL);\n\n+    bmsize = (nr_notes + BITS_PER_LONG - 1) / BITS_PER_LONG;\n+    bmsize *= sizeof(unsigned long);\n+    bitmap = kmalloc(bmsize, GFP_KERNEL);\n\n-    bitmap_fill(bitmap, nr_notes);\n\n+    memset(bitmap, 0xff, bmsize);\n\n-    wqueue->nr_notes = nr_notes;\n\n+    wqueue->nr_notes = nr_pages * WATCH_QUEUE_NOTES_PER_PAGE;\n\n",
    "6": "+    unsigned int bmsize;\n\n",
    "7": "+    bitmap_free(wqueue->notes_bitmap);\n\n",
    "8": "-    bitmap_free(wqueue->notes_bitmap);\n\n",
    "9": "-        unsigned int head = pipe->head;\n\n+        unsigned int head = smp_load_acquire(&pipe->head);\n\n",
    "10": "-        unsigned int head = smp_load_acquire(&pipe->head);\n\n+        unsigned int head = pipe->head;\n\n",
    "11": "+    len += sizeof(*buf);\n\n",
    "12": "-    len += sizeof(*buf);\n\n",
    "13": "+    generic_pipe_buf_release(pipe, buf);\n\n",
    "14": "-    generic_pipe_buf_release(pipe, buf);\n\n",
    "15": "-        if (tf[i].type >= sizeof(wfilter->type_filter) * 8) {\n\n+        if (tf[i].type >= WATCH_TYPE__NR) {\n\n-        if (tf[i].type >= sizeof(wfilter->type_filter) * BITS_PER_LONG) {\n\n+        if (tf[i].type >= WATCH_TYPE__NR) {\n\n-        if (tf[i].type >= WATCH_TYPE__NR) {\n\n+        if (tf[i].type >= sizeof(wfilter->type_filter) * 8) {\n\n-        if (tf[i].type >= WATCH_TYPE__NR) {\n\n+        if (tf[i].type >= sizeof(wfilter->type_filter) * BITS_PER_LONG) {\n\n",
    "16": "-    int n;\n\n+    int n, skips = 0;\n\n",
    "17": "+            } else {\n+                start += folio_size(folio);\n\n",
    "18": "+            if (wbc->sync_mode == WB_SYNC_NONE) {\n+                if (skips >= 5 || need_resched()) {\n+                    break;\n+                }\n+                skips++;\n+            }\n\n",
    "19": "-    int n, skips = 0;\n\n+    int n;\n\n-            if (wbc->sync_mode == WB_SYNC_NONE) {\n-                if (skips >= 5 || need_resched()) {\n-                    break;\n-                }\n-                skips++;\n-            }\n\n",
    "20": "-            } else {\n-                start += folio_size(folio);\n\n",
    "21": "-    pipe->head = head + 1;\n\n+    smp_store_release(&pipe->head, head + 1);\n\n-    smp_store_release(&pipe->head, head + 1);\n\n+    pipe->head = head + 1;\n\n",
    "22": "-        put_watch_queue(pipe->watch_queue);\n\n",
    "23": "+#ifdef CONFIG_WATCH_QUEUE\n+    if (pipe->watch_queue) {\n+        put_watch_queue(pipe->watch_queue);\n+    }\n+#endif\n\n",
    "24": "+        put_watch_queue(pipe->watch_queue);\n\n-#ifdef CONFIG_WATCH_QUEUE\n-    if (pipe->watch_queue) {\n-        put_watch_queue(pipe->watch_queue);\n-    }\n-#endif\n\n"
}