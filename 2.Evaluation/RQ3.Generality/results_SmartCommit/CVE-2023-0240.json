{
    "0": "+    io_init_identity(&req->identity);\n\n",
    "1": "-    io_init_identity(&req->identity);\n\n",
    "2": "-    const struct cred *creds = get_current_cred();\n-    int id;\n-    id = idr_alloc_cyclic(&ctx->personality_idr, (void *) creds, 1, USHRT_MAX, GFP_KERNEL);\n-    if (id < 0) {\n-        put_cred(creds);\n\n+    struct io_identity *id;\n+    int ret;\n+    id = kmalloc(sizeof(*id), GFP_KERNEL);\n+    if (unlikely(!id)) {\n+        return -ENOMEM;\n\n-    return id;\n\n+    io_init_identity(id);\n+    id->creds = get_current_cred();\n+    ret = idr_alloc_cyclic(&ctx->personality_idr, id, 1, USHRT_MAX, GFP_KERNEL);\n+    if (ret < 0) {\n+        put_cred(id->creds);\n+        kfree(id);\n+    }\n+    return ret;\n\n-    struct io_identity *id;\n-    int ret;\n-    id = kmalloc(sizeof(*id), GFP_KERNEL);\n-    if (unlikely(!id)) {\n-        return -ENOMEM;\n\n+    const struct cred *creds = get_current_cred();\n+    int id;\n+    id = idr_alloc_cyclic(&ctx->personality_idr, (void *) creds, 1, USHRT_MAX, GFP_KERNEL);\n+    if (id < 0) {\n+        put_cred(creds);\n\n-    io_init_identity(id);\n-    id->creds = get_current_cred();\n-    ret = idr_alloc_cyclic(&ctx->personality_idr, id, 1, USHRT_MAX, GFP_KERNEL);\n-    if (ret < 0) {\n-        put_cred(id->creds);\n-        kfree(id);\n-    }\n-    return ret;\n\n+    return id;\n\n",
    "3": "-    struct io_uring_task *tctx;\n-    struct io_ring_ctx *ctx;\n\n+    struct io_uring_task *tctx = req->task->io_uring;\n+    struct io_ring_ctx *ctx = req->ctx;\n\n-    struct io_uring_task *tctx = req->task->io_uring;\n-    struct io_ring_ctx *ctx = req->ctx;\n\n+    struct io_uring_task *tctx;\n+    struct io_ring_ctx *ctx;\n\n",
    "4": "-    tctx = req->task->io_uring;\n-    ctx = req->ctx;\n\n",
    "5": "+    tctx = req->task->io_uring;\n+    ctx = req->ctx;\n\n",
    "6": "-    const struct cred *cred;\n-    cred = idr_remove(&ctx->personality_idr, id);\n-    if (cred) {\n-        put_cred(cred);\n\n+    struct io_identity *iod;\n+    iod = idr_remove(&ctx->personality_idr, id);\n+    if (iod) {\n+        put_cred(iod->creds);\n+        if (refcount_dec_and_test(&iod->count)) {\n+            kfree(iod);\n+        }\n\n-    struct io_identity *iod;\n-    iod = idr_remove(&ctx->personality_idr, id);\n-    if (iod) {\n-        put_cred(iod->creds);\n-        if (refcount_dec_and_test(&iod->count)) {\n-            kfree(iod);\n-        }\n\n+    const struct cred *cred;\n+    cred = idr_remove(&ctx->personality_idr, id);\n+    if (cred) {\n+        put_cred(cred);\n\n-    const struct cred *old_creds;\n-    old_creds = idr_remove(&ctx->personality_idr, id);\n-    if (old_creds) {\n-        put_cred(old_creds);\n\n+    struct io_identity *iod;\n+    iod = idr_remove(&ctx->personality_idr, id);\n+    if (iod) {\n+        put_cred(iod->creds);\n+        if (refcount_dec_and_test(&iod->count)) {\n+            kfree(iod);\n+        }\n\n-    struct io_identity *iod;\n-    iod = idr_remove(&ctx->personality_idr, id);\n-    if (iod) {\n-        put_cred(iod->creds);\n-        if (refcount_dec_and_test(&iod->count)) {\n-            kfree(iod);\n-        }\n\n+    const struct cred *old_creds;\n+    old_creds = idr_remove(&ctx->personality_idr, id);\n+    if (old_creds) {\n+        put_cred(old_creds);\n\n",
    "7": "+        struct io_identity *iod;\n\n",
    "8": "-        req->work.identity->creds = idr_find(&ctx->personality_idr, id);\n-        if (unlikely(!req->work.identity->creds)) {\n\n+        iod = idr_find(&ctx->personality_idr, id);\n+        if (unlikely(!iod)) {\n\n-        iod = idr_find(&ctx->personality_idr, id);\n-        if (unlikely(!iod)) {\n\n+        req->work.identity->creds = idr_find(&ctx->personality_idr, id);\n+        if (unlikely(!req->work.identity->creds)) {\n\n",
    "9": "-        get_cred(req->work.identity->creds);\n\n+        refcount_inc(&iod->count);\n+        io_put_identity(req);\n+        get_cred(iod->creds);\n+        req->work.identity = iod;\n\n-        refcount_inc(&iod->count);\n-        io_put_identity(req);\n-        get_cred(iod->creds);\n-        req->work.identity = iod;\n\n+        get_cred(req->work.identity->creds);\n\n",
    "10": "-        struct io_identity *iod;\n\n+    struct io_identity *id = &req->identity;\n\n",
    "11": "+    io_put_identity(req);\n\n",
    "12": "-static void io_prep_async_work(struct io_kiocb *req) {\n\n+static bool io_identity_cow(struct io_kiocb *req) {\n+    const struct cred *creds = NULL;\n+    struct io_identity *id;\n+    if (req->work.flags & IO_WQ_WORK_CREDS) {\n+        creds = req->work.identity->creds;\n+    }\n+    id = kmemdup(req->work.identity, sizeof(*id), GFP_KERNEL);\n+    if (unlikely(!id)) {\n+        req->work.flags |= IO_WQ_WORK_CANCEL;\n+        return false;\n+    }\n+    io_init_identity(id);\n+    if (creds) {\n+        req->work.identity->creds = creds;\n+    }\n+    refcount_inc(&id->count);\n+    if (req->work.identity != &req->identity && refcount_sub_and_test(2, &req->work.identity->count)) {\n+        kfree(req->work.identity);\n+    }\n+    req->work.identity = id;\n+    return true;\n+}\n+static bool io_grab_identity(struct io_kiocb *req) {\n\n-    io_req_init_async(req);\n-    if (req->flags & REQ_F_ISREG) {\n-        if (def->hash_reg_file || (ctx->flags & IORG_SETUP_IOPOLL)) {\n-            io_wq_hash_work(&req->work, file_inode(req->file));\n-        }\n-    } else {\n-        if (def->unbound_nonreg_file) {\n-            req->work.flags |= IO_WQ_WORK_UNBOUND;\n\n+    if (def->needs_fsize && id->fsize != rlimit(RLIMIT_FSIZE)) {\n+        return false;\n\n+    if (!(req->work.flags & IO_WQ_WORK_FILES) && (def->work_flags & IO_WQ_WORK_FILES) && !(req->flags & REQ_F_NO_FILE_TABLE)) {\n+        if (id->files != current->files || id->nsproxy != current->nsproxy) {\n+            return false;\n\n-    if (!(req->work.flags & IO_WQ_WORK_FILES) && (io_op_defs[req->opcode].work_flags & IO_WQ_WORK_FILES) && !(req->flags & REQ_F_NO_FILE_TABLE)) {\n-        req->work.identity->files = get_files_struct(current);\n-        get_nsproxy(current->nsproxy);\n-        req->work.identity->nsproxy = current->nsproxy;\n\n+        atomic_inc(&id->files->count);\n+        get_nsproxy(id->nsproxy);\n\n-    if (!(req->work.flags & IO_WQ_WORK_MM) && (def->work_flags & IO_WQ_WORK_MM)) {\n-        mmgrab(current->mm);\n-        req->work.identity->mm = current->mm;\n-        req->work.flags |= IO_WQ_WORK_MM;\n-    }\n\n-        spin_lock(&current->fs->lock);\n-        if (!current->fs->in_exec) {\n-            req->work.identity->fs = current->fs;\n-            req->work.identity->fs->users++;\n\n+        if (current->fs != id->fs) {\n+            return false;\n+        }\n+        spin_lock(&id->fs->lock);\n+        if (!id->fs->in_exec) {\n+            id->fs->users++;\n\n-    if (def->needs_fsize) {\n-        req->work.identity->fsize = rlimit(RLIMIT_FSIZE);\n\n+    return true;\n+}\n+static void io_prep_async_work(struct io_kiocb *req) {\n+    const struct io_op_def *def = &io_op_defs[req->opcode];\n+    struct io_identity *id = &req->identity;\n+    struct io_ring_ctx *ctx = req->ctx;\n+    io_req_init_async(req);\n+    if (req->flags & REQ_F_ISREG) {\n+        if (def->hash_reg_file || (ctx->flags & IORG_SETUP_IOPOLL)) {\n+            io_wq_hash_work(&req->work, file_inode(req->file));\n+        }\n\n-        req->work.identity->fsize = RLIM_FITY;\n\n+        if (def->unbound_nonreg_file) {\n+            req->work.flags |= IO_WQ_WORK_UNBOUND;\n+        }\n+    }\n+    if (!(req->work.flags & IO_WQ_WORK_MM) && (def->work_flags & IO_WQ_WORK_MM)) {\n+        mmgrab(id->mm);\n+        req->work.flags |= IO_WQ_WORK_MM;\n+    }\n+    if (io_grab_identity(req)) {\n+        return;\n+    }\n+    if (!io_identity_cow(req)) {\n+        return;\n+    }\n+    if (!io_grab_identity(req)) {\n+        WARN_ON(1);\n\n-        if (def->unbound_nonreg_file) {\n-            req->work.flags |= IO_WQ_WORK_UNBOUND;\n-        }\n-    }\n-    if (!(req->work.flags & IO_WQ_WORK_MM) && (def->work_flags & IO_WQ_WORK_MM)) {\n-        mmgrab(id->mm);\n-        req->work.flags |= IO_WQ_WORK_MM;\n-    }\n-    if (io_grab_identity(req)) {\n-        return;\n-    }\n-    if (!io_identity_cow(req)) {\n-        return;\n-    }\n-    if (!io_grab_identity(req)) {\n-        WARN_ON(1);\n\n+        req->work.identity->fsize = RLIM_FITY;\n\n",
    "13": "-        req->work.identity->blkcg_css = blkcg_css();\n-        if (css_tryget_online(req->work.identity->blkcg_css)) {\n\n+        if (id->blkcg_css != blkcg_css()) {\n+            rcu_read_unlock();\n+            return false;\n+        }\n+        if (css_tryget_online(id->blkcg_css)) {\n\n",
    "14": "-        req->work.identity->creds = get_current_cred();\n\n+        if (id->creds != current_cred()) {\n+            return false;\n+        }\n+        get_cred(id->creds);\n\n"
}