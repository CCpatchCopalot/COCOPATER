{
    "0": "+        if(!data->set.allow_auth_to_other_hosts && (type != FOLLOW_FAKE)) {\n+            char *portnum;\n+            int port;\n+            bool clear = FALSE;\n+            if(data->set.use_port && data->state.allow_port) {\n+                port = (int)data->set.use_port;\n+            } else {\n+                uc = curl_url_get(data->state.uh, CURLUPART_PORT, &portnum, CURLU_DEFAULT_PORT);\n+                if(uc) {\n+                    free(newurl);\n+                    return Curl_uc_to_curlcode(uc);\n+                }\n+                port = atoi(portnum);\n+                free(portnum);\n+            }\n+            if(port != data->info.conn_remote_port) {\n+                infof(data, \"Clear auth, redirects to port from %u to %u\", data->info.conn_remote_port, port);\n+                clear = TRUE;\n+            } else {\n+                char *scheme;\n+                const struct Curl_handler *p;\n+                uc = curl_url_get(data->state.uh, CURLUPART_SCHEME, &scheme, 0);\n+                if(uc) {\n+                    free(newurl);\n+                    return Curl_uc_to_curlcode(uc);\n+                }\n+                p = Curl_builtin_scheme(scheme);\n+                if(p && (p->protocol != data->info.conn_protocol)) {\n+                    infof(data, \"Clear auth, redirects scheme from %s to %s\", data->info.conn_scheme, scheme);\n+                    clear = TRUE;\n+                }\n+                free(scheme);\n+            }\n+            if(clear) {\n+                Curl_safefree(data->state.aptr.user);\n+                Curl_safefree(data->state.aptr.passwd);\n+            }\n+        }\n\n",
    "1": "-        if(!data->set.allow_auth_to_other_hosts && (type != FOLLOW_FAKE)) {\n-            char *portnum;\n-            int port;\n-            bool clear = FALSE;\n-            if(data->set.use_port && data->state.allow_port) {\n-                port = (int)data->set.use_port;\n-            } else {\n-                uc = curl_url_get(data->state.uh, CURLUPART_PORT, &portnum, CURLU_DEFAULT_PORT);\n-                if(uc) {\n-                    free(newurl);\n-                    return Curl_uc_to_curlcode(uc);\n-                }\n-                port = atoi(portnum);\n-                free(portnum);\n-            }\n-            if(port != data->info.conn_remote_port) {\n-                infof(data, \"Clear auth, redirects to port from %u to %u\", data->info.conn_remote_port, port);\n-                clear = TRUE;\n-            } else {\n-                char *scheme;\n-                const struct Curl_handler *p;\n-                uc = curl_url_get(data->state.uh, CURLUPART_SCHEME, &scheme, 0);\n-                if(uc) {\n-                    free(newurl);\n-                    return Curl_uc_to_curlcode(uc);\n-                }\n-                p = Curl_builtin_scheme(scheme);\n-                if(p && (p->protocol != data->info.conn_protocol)) {\n-                    infof(data, \"Clear auth, redirects scheme from %s to %s\", data->info.conn_scheme, scheme);\n-                    clear = TRUE;\n-                }\n-                free(scheme);\n-            }\n-            if(clear) {\n-                Curl_safefree(data->state.aptr.user);\n-                Curl_safefree(data->state.aptr.passwd);\n-            }\n-        }\n\n"
}